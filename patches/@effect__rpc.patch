diff --git a/README.md b/README.md
index 36e3b19ad1094131f3f4362d217e4ecd33e4f794..5eb8b89155c636500cef921e46177081dd2eb01b 100644
--- a/README.md
+++ b/README.md
@@ -6,32 +6,15 @@ The `@effect/rpc` library facilitates the development of remote procedure call (
 
 ## Declaring Requests
 
-The `TaggedRequest` API in the `effect/Schema` module is designed to facilitate the creation of structured requests that can serialize function signatures involving input arguments, successful outcomes, and potential failures. Essentially, it's a tool for defining a serializable function that can be reliably transported across different systems or network layers.
+The `RpcGroup` and `Rpc` modules can be used alongside the `Schema` module to
+define requests and responses.
 
-Hereâ€™s a simplified explanation:
-
-1. **Function Modeling**: `TaggedRequest` allows you to model a function signature as a class, which includes the input arguments, the type of the success response, and the type of the failure response.
-
-2. **Serialization Schema**: For each component (input, success, failure), you specify a corresponding schema. This setup helps ensure that the data associated with each request can be properly serialized (converted to a format suitable for storage or transmission) and deserialized (converted back to usable format).
-
-3. **Usage Scenario**: This API is particularly useful when you need to handle remote procedure calls (RPCs) where functions and their arguments need to be sent over a network, processed, and then responded to asynchronously.
-
-4. **Streamlined Code**: By leveraging `Schema.TaggedRequest`, developers can reduce the amount of boilerplate code typically required for handling complex data serialization and deserialization tasks in distributed systems.
-
-In practice, when you create an instance of `TaggedRequest`, you define the function's behavior along with its serialization rules, which streamlines the process of encoding input data, sending it across a network, and decoding responses.
-
-```mermaid
-sequenceDiagram
-    Sender->>SenderBound: encodes A to I
-    SenderBound-->>ReceiverBound: send I
-    ReceiverBound->>Receiver: decodes I to A
-    Receiver->>ReceiverBound: encodes Exit<Success, Failure><br/>to Exit<SuccessEncoded, FailureEncoded>
-    ReceiverBound-->>SenderBound: send back<br/>Exit<SuccessEncoded, FailureEncoded>
-    SenderBound->>Sender: decodes Exit<SuccessEncoded, FailureEncoded><br/>to Exit<Success, Failure>
-```
+Here we are defining a request to retrieve a list of users, a request to
+retrieve a user by ID, and a request to create a new user.
 
 ```ts filename="request.ts"
 // request.ts
+import { Rpc, RpcGroup } from "@effect/rpc"
 import { Schema } from "effect"
 
 // Define a user with an ID and name
@@ -40,90 +23,99 @@ export class User extends Schema.Class<User>("User")({
   name: Schema.String // User's name as a string
 }) {}
 
-// Request to retrieve a list of users
-export class UserList extends Schema.TaggedRequest<UserList>()("UserList", {
-  failure: Schema.Never, // Indicates that no errors are expected
-  success: Schema.Array(User), // Specifies that the response is an array of Users
-  payload: {}
-}) {}
-
-// Request to retrieve a user by ID
-export class UserById extends Schema.TaggedRequest<UserById>()("UserById", {
-  failure: Schema.String, // Indicates that errors, if any, will be returned as strings
-  success: User, // Specifies that the response is a User
-  payload: {
-    id: Schema.String
-  }
-}) {}
-
-// Request to create a new user
-export class UserCreate extends Schema.TaggedRequest<UserCreate>()(
-  "UserCreate",
-  {
-    failure: Schema.Never, // Indicates that no errors are expected
-    success: User, // Specifies that the response is a User
+// Define a group of RPCs for user management.
+// You can use the `RpcGroup.make` function to create a group of RPCs.
+export class UserRpcs extends RpcGroup.make(
+  // Request to retrieve a list of users
+  Rpc.make("UserList", {
+    success: User, // Succeed with a stream of users
+    stream: true
+  }),
+  Rpc.make("UserById", {
+    success: User,
+    error: Schema.String, // Indicates that errors, if any, will be returned as strings
+    payload: {
+      id: Schema.String
+    }
+  }),
+  Rpc.make("UserCreate", {
+    success: User,
     payload: {
       name: Schema.String
     }
-  }
+  })
 ) {}
 ```
 
-## Defining a Router
+## Implementing the handlers
 
-This section introduces how to configure a router using an imaginary database setup to manage user data.
+This section introduces how to implement the rpc handlers, using an imaginary database setup to manage user data.
 
 ```ts filename="router.ts"
-// router.ts
-import { RpcRouter, Rpc } from "@effect/rpc"
-import { Effect, Ref } from "effect"
-import { User, UserById, UserCreate, UserList } from "./request.js"
+// handlers.ts
+import type { Rpc } from "@effect/rpc"
+import { Effect, Layer, Ref, Stream } from "effect"
+import { User, UserRpcs } from "./request.js"
 
 // ---------------------------------------------
 // Imaginary Database
 // ---------------------------------------------
 
-const ref = Ref.unsafeMake<Array<User>>([
-  new User({ id: "1", name: "Alice" }),
-  new User({ id: "2", name: "Bob" })
-])
-
-const db = {
-  user: {
-    findMany: () => ref.get,
-    findById: (id: string) =>
-      Ref.get(ref).pipe(
-        Effect.andThen((users) => {
-          const user = users.find((user) => user.id === id)
-          return user
-            ? Effect.succeed(user)
-            : Effect.fail(`User not found: ${id}`)
-        })
-      ),
-    create: (name: string) =>
-      Ref.updateAndGet(ref, (users) => [
-        ...users,
-        new User({ id: String(users.length + 1), name })
-      ]).pipe(Effect.andThen((users) => users[users.length - 1]))
+class UserRepository extends Effect.Service<UserRepository>()(
+  "UserRepository",
+  {
+    effect: Effect.gen(function* () {
+      const ref = yield* Ref.make<Array<User>>([
+        new User({ id: "1", name: "Alice" }),
+        new User({ id: "2", name: "Bob" })
+      ])
+
+      return {
+        findMany: ref.get,
+        findById: (id: string) =>
+          Ref.get(ref).pipe(
+            Effect.andThen((users) => {
+              const user = users.find((user) => user.id === id)
+              return user
+                ? Effect.succeed(user)
+                : Effect.fail(`User not found: ${id}`)
+            })
+          ),
+        create: (name: string) =>
+          Ref.updateAndGet(ref, (users) => [
+            ...users,
+            new User({ id: String(users.length + 1), name })
+          ]).pipe(Effect.andThen((users) => users[users.length - 1]))
+      }
+    })
   }
-}
+) {}
 
 // ---------------------------------------------
-// Router
+// RPC handlers
 // ---------------------------------------------
 
-export const appRouter = RpcRouter.make(
-  Rpc.effect(UserList, () => db.user.findMany()),
-  Rpc.effect(UserById, ({ id }) => db.user.findById(id)),
-  Rpc.effect(UserCreate, ({ name }) => db.user.create(name))
-)
+export const UsersLive: Layer.Layer<
+  Rpc.Handler<"UserList"> | Rpc.Handler<"UserById"> | Rpc.Handler<"UserCreate">
+> = UserRpcs.toLayer(
+  Effect.gen(function* () {
+    const db = yield* UserRepository
 
-export type AppRouter = typeof appRouter
+    return {
+      UserList: () => Stream.fromIterableEffect(db.findMany),
+      UserById: ({ id }) => db.findById(id),
+      UserCreate: ({ name }) => db.create(name)
+    }
+  })
+).pipe(
+  // Provide the UserRepository layer
+  Layer.provide(UserRepository.Default)
+)
 ```
 
 ## Serving the API
 
-This part explains how to serve the API using the defined router.
+This part explains how to serve the API using the handlers we defined earlier.
 
 ```ts filename="server.ts"
 // server.ts
@@ -151,15 +143,7 @@ Use this `curl` command to test if the API is operational:
 ```bash
 curl -X POST http://localhost:3000/rpc \
      -H "Content-Type: application/json" \
-     -d '[
-           {
-             "request": { "_tag": "UserList" },
-             "traceId": "traceId",
-             "spanId": "spanId",
-             "sampled": true,
-             "headers": {}
-           }
-         ]'
+     -d $'{"_tag": "Request", "id": "123", "tag": "UserList", "payload": {}, "traceId": "traceId", "spanId": "spanId", "sampled": true, "headers": {} }\n'
 ```
 
 ## Using your new backend on the client
@@ -168,58 +152,136 @@ Let's now move to the client-side code and embrace the power of end-to-end types
 
 ```ts
 // client.ts
-import { HttpClient, HttpClientRequest } from "@effect/platform"
-import { RpcResolver } from "@effect/rpc"
-import { HttpRpcResolver } from "@effect/rpc-http"
-import { Effect } from "effect"
-import { UserCreate, UserList } from "./request.js"
-import type { AppRouter } from "./router.js"
-
-// Define an effect which creates the client
-const makeClient = Effect.gen(function*() {
-  const baseClient = yield* HttpClient.HttpClient
-  const client = baseClient.pipe(
-    HttpClient.filterStatusOk,
-    HttpClient.mapRequest(HttpClientRequest.prependUrl("http://localhost:3000/rpc"))
-  )
-  return RpcResolver.toClient(HttpRpcResolver.make<AppRouter>(client))
-})
+import { FetchHttpClient } from "@effect/platform"
+import { RpcClient, RpcSerialization } from "@effect/rpc"
+import { Chunk, Effect, Layer, Stream } from "effect"
+import { UserRpcs } from "./request.js"
+
+// Choose which protocol to use
+const ProtocolLive = RpcClient.layerProtocolHttp({
+  url: "http://localhost:3000/rpc"
+}).pipe(
+  Layer.provide([
+    // use fetch for http requests
+    FetchHttpClient.layer,
+    // use ndjson for serialization
+    RpcSerialization.layerNdjson
+  ])
+)
 
 // Use the client
 const program = Effect.gen(function* () {
-  const client = yield* makeClient
-  let users = yield* client(new UserList())
-  if (!users.find((user) => user.id === "3")) {
+  const client = yield* RpcClient.make(UserRpcs)
+  let users = yield* Stream.runCollect(client.UserList({}))
+  if (!Chunk.findFirst(users, (user) => user.id === "3")) {
     console.log(`Creating user "Charlie"`)
-    yield* client(new UserCreate({ name: "Charlie" }))
-    users = yield* client(new UserList())
+    yield* client.UserCreate({ name: "Charlie" })
+    users = yield* Stream.runCollect(client.UserList({}))
   } else {
     console.log(`User "Charlie" already exists`)
   }
   return users
-})
+}).pipe(Effect.scoped)
 
-program.pipe(
-  Effect.provide(FetchHttpClient.layer),
-  Effect.runPromise
-).then(console.log)
+program.pipe(Effect.provide(ProtocolLive), Effect.runPromise).then(console.log)
 ```
 
-# Stream
+## Defining middleware
 
-## Setting Up the Stream Request
+To add middleware to the RPC server (& optionally the client), you can use the
+`RpcMiddleware` module.
 
-```ts filename="request.ts"
-// request.ts
-import * as Rpc from "@effect/rpc/Rpc"
-import { Schema } from "effect"
+The first step is to define the middleware context tag, which is used to both
+implement and access the middleware.
+
+```ts filename="middleware.ts"
+// middleware.ts
+import { RpcMiddleware } from "@effect/rpc"
+import { Context } from "effect"
+import type { User } from "./request.js"
+
+// A context tag which represents the current user
+export class CurrentUser extends Context.Tag("CurrentUser")<
+  CurrentUser,
+  User
+>() {}
+
+// The context tag for the authentication middleware
+export class AuthMiddleware extends RpcMiddleware.Tag<AuthMiddleware>()(
+  "AuthMiddleware",
+  {
+    // This middleware will provide the current user context
+    provides: CurrentUser,
+    // This middleware requires a client implementation too
+    requiredForClient: true
+  }
+) {}
+```
+
+## Implementing middleware
+
+Once the middleware context tag is defined, you can then use it in a `RpcGroup`
+to apply it to various RPCs.
+
+When it has been applied, you can then implement the middleware logic and add it
+to your server and client.
+
+```ts
+import { Headers } from "@effect/platform"
+import { Rpc, RpcClient, RpcGroup, RpcMiddleware, RpcServer } from "@effect/rpc"
+import { Effect, Layer, Schema } from "effect"
+import { AuthMiddleware } from "./middleware.js"
+import { User } from "./request.js"
+
+export class UserRpcs extends RpcGroup.make(
+  Rpc.make("UserById", {
+    success: User,
+    payload: {
+      id: Schema.String
+    }
+  })
+    // apply the middleware to a single RPC
+    .middleware(AuthMiddleware)
+)
+  // or apply the middleware to the entire group
+  .middleware(AuthMiddleware) {}
+
+// Implement the middleware for a server
+export const AuthLive: Layer.Layer<AuthMiddleware> = Layer.succeed(
+  AuthMiddleware,
+  // A middleware that provides the current user.
+  //
+  // You can access the headers, payload, and the RPC definition when
+  // implementing the middleware.
+  AuthMiddleware.of(({ headers, payload, rpc }) =>
+    Effect.succeed(new User({ id: "123", name: "Logged in user" }))
+  )
+)
+
+// apply the middleware to a rpc server
+RpcServer.layer(UserRpcs).pipe(Layer.provide(AuthLive))
+
+// Implement the middleware for a client
+//
+// The client middleware can access the request and the RPC definition, and
+// returns a modified request.
+export const AuthClientLive: Layer.Layer<
+  RpcMiddleware.ForClient<AuthMiddleware>
+> = RpcMiddleware.layerClient(AuthMiddleware, ({ request, rpc }) =>
+  Effect.succeed({
+    ...request,
+    headers: Headers.set(request.headers, "authorization", "Bearer token")
+  })
+)
 
-export class Counts extends Rpc.StreamRequest<Counts>()("Counts", {
-  failure: Schema.Never, // Indicates that no errors are expected
-  success: Schema.Number, // Specifies that the response is a number
-  payload: {}
+// apply the middleware to a rpc client
+export class UsersClient extends Effect.Service<UsersClient>()("UsersClient", {
+  scoped: RpcClient.make(UserRpcs),
+  // add the middleware layer to the dependencies
+  dependencies: [AuthClientLive]
 }) {}
 ```
+<<<<<<< HEAD
 
 ## Defining the Router
 
@@ -306,3 +368,5 @@ timestamp=...:55.445Z level=INFO fiber=#1 message=4
 timestamp=...:55.447Z level=INFO fiber=#1 message=5
 */
 ```
+=======
+>>>>>>> 6e55d9ed4 (@effect/rpc 3rd revision)
diff --git a/RpcClient/package.json b/RpcClient/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..198a1fec4560480e9d78d0c1410a36b55190cf5f
--- /dev/null
+++ b/RpcClient/package.json
@@ -0,0 +1,6 @@
+{
+  "main": "../dist/cjs/RpcClient.js",
+  "module": "../dist/esm/RpcClient.js",
+  "types": "../dist/dts/RpcClient.d.ts",
+  "sideEffects": []
+}
diff --git a/RpcGroup/package.json b/RpcGroup/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..036736a8f4dcd2834c3663bc06c3dc3bab51232a
--- /dev/null
+++ b/RpcGroup/package.json
@@ -0,0 +1,6 @@
+{
+  "main": "../dist/cjs/RpcGroup.js",
+  "module": "../dist/esm/RpcGroup.js",
+  "types": "../dist/dts/RpcGroup.d.ts",
+  "sideEffects": []
+}
diff --git a/RpcMessage/package.json b/RpcMessage/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..3761d219d9b54e034e6835a4df2e528d2f1386ec
--- /dev/null
+++ b/RpcMessage/package.json
@@ -0,0 +1,6 @@
+{
+  "main": "../dist/cjs/RpcMessage.js",
+  "module": "../dist/esm/RpcMessage.js",
+  "types": "../dist/dts/RpcMessage.d.ts",
+  "sideEffects": []
+}
diff --git a/RpcMiddleware/package.json b/RpcMiddleware/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..a775119e2013ee5691ae6b565187194796f32c60
--- /dev/null
+++ b/RpcMiddleware/package.json
@@ -0,0 +1,6 @@
+{
+  "main": "../dist/cjs/RpcMiddleware.js",
+  "module": "../dist/esm/RpcMiddleware.js",
+  "types": "../dist/dts/RpcMiddleware.d.ts",
+  "sideEffects": []
+}
diff --git a/RpcSchema/package.json b/RpcSchema/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..a49b50d8728b47d7651670b3c606a445c2299dee
--- /dev/null
+++ b/RpcSchema/package.json
@@ -0,0 +1,6 @@
+{
+  "main": "../dist/cjs/RpcSchema.js",
+  "module": "../dist/esm/RpcSchema.js",
+  "types": "../dist/dts/RpcSchema.d.ts",
+  "sideEffects": []
+}
diff --git a/RpcSerialization/package.json b/RpcSerialization/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..58160260e984e72d4ce92ae7a075b9483e78b7b7
--- /dev/null
+++ b/RpcSerialization/package.json
@@ -0,0 +1,6 @@
+{
+  "main": "../dist/cjs/RpcSerialization.js",
+  "module": "../dist/esm/RpcSerialization.js",
+  "types": "../dist/dts/RpcSerialization.d.ts",
+  "sideEffects": []
+}
diff --git a/RpcServer/package.json b/RpcServer/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..53da2915daa632da51a63b0c5de6376efe8d6b93
--- /dev/null
+++ b/RpcServer/package.json
@@ -0,0 +1,6 @@
+{
+  "main": "../dist/cjs/RpcServer.js",
+  "module": "../dist/esm/RpcServer.js",
+  "types": "../dist/dts/RpcServer.d.ts",
+  "sideEffects": []
+}
diff --git a/RpcTest/package.json b/RpcTest/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..a54592880ab8fa471152c629bab034b2eab4a0fc
--- /dev/null
+++ b/RpcTest/package.json
@@ -0,0 +1,6 @@
+{
+  "main": "../dist/cjs/RpcTest.js",
+  "module": "../dist/esm/RpcTest.js",
+  "types": "../dist/dts/RpcTest.d.ts",
+  "sideEffects": []
+}
diff --git a/RpcWorker/package.json b/RpcWorker/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..a4a42f2e3fdffb5050e3a53f71690a768a05bf03
--- /dev/null
+++ b/RpcWorker/package.json
@@ -0,0 +1,6 @@
+{
+  "main": "../dist/cjs/RpcWorker.js",
+  "module": "../dist/esm/RpcWorker.js",
+  "types": "../dist/dts/RpcWorker.d.ts",
+  "sideEffects": []
+}
diff --git a/dist/cjs/Rpc.js b/dist/cjs/Rpc.js
index 4013a8aa2d32fe6ac8ba89cca147c43fe056f48d..0cc4eb50d62b60df05925cfcb4f13707381ab686 100644
--- a/dist/cjs/Rpc.js
+++ b/dist/cjs/Rpc.js
@@ -3,23 +3,16 @@
 Object.defineProperty(exports, "__esModule", {
   value: true
 });
-exports.stream = exports.schemaHeaders = exports.request = exports.provideServiceEffect = exports.provideService = exports.isRpc = exports.effect = exports.currentHeaders = exports.call = exports.annotateHeaders = exports.TypeId = exports.StreamRequestTypeId = exports.StreamRequest = exports.RequestSchema = void 0;
-var Headers = _interopRequireWildcard(require("@effect/platform/Headers"));
-var Effect = _interopRequireWildcard(require("effect/Effect"));
-var FiberRef = _interopRequireWildcard(require("effect/FiberRef"));
-var _Function = require("effect/Function");
+exports.make = exports.isRpc = exports.isFork = exports.fromTaggedRequest = exports.fork = exports.exitSchema = exports.TypeId = exports.ForkTypeId = void 0;
+var Context_ = _interopRequireWildcard(require("effect/Context"));
 var _GlobalValue = require("effect/GlobalValue");
+var Option = _interopRequireWildcard(require("effect/Option"));
 var _Pipeable = require("effect/Pipeable");
 var Predicate = _interopRequireWildcard(require("effect/Predicate"));
 var Schema = _interopRequireWildcard(require("effect/Schema"));
-var Stream = _interopRequireWildcard(require("effect/Stream"));
-var Internal = _interopRequireWildcard(require("./internal/rpc.js"));
+var RpcSchema = _interopRequireWildcard(require("./RpcSchema.js"));
 function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
 function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
-/**
- * @since 1.0.0
- */
-
 /**
  * @since 1.0.0
  * @category type ids
@@ -27,129 +20,133 @@ function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e;
 const TypeId = exports.TypeId = /*#__PURE__*/Symbol.for("@effect/rpc/Rpc");
 /**
  * @since 1.0.0
- * @category refinements
+ * @category guards
  */
 const isRpc = u => Predicate.hasProperty(u, TypeId);
-/**
- * @since 1.0.0
- * @category constructors
- */
 exports.isRpc = isRpc;
-const effect = (schema, handler) => ({
+const Proto = {
   [TypeId]: TypeId,
-  _tag: "Effect",
-  schema,
-  handler,
   pipe() {
     return (0, _Pipeable.pipeArguments)(this, arguments);
+  },
+  setSuccess(successSchema) {
+    return makeProto({
+      ...this,
+      successSchema
+    });
+  },
+  setError(errorSchema) {
+    return makeProto({
+      ...this,
+      errorSchema
+    });
+  },
+  setPayload(payloadSchema) {
+    return makeProto({
+      ...this,
+      payloadSchema: Schema.isSchema(payloadSchema) ? payloadSchema : Schema.Struct(payloadSchema)
+    });
+  },
+  middleware(middleware) {
+    return makeProto({
+      ...this,
+      middlewares: new Set([...this.middlewares, middleware])
+    });
+  },
+  annotate(tag, value) {
+    return makeProto({
+      ...this,
+      annotations: Context_.add(this.annotations, tag, value)
+    });
+  },
+  annotateContext(context) {
+    return makeProto({
+      ...this,
+      annotations: Context_.merge(this.annotations, context)
+    });
   }
-});
-/**
- * @since 1.0.0
- * @category type ids
- */
-exports.effect = effect;
-const StreamRequestTypeId = exports.StreamRequestTypeId = Internal.StreamRequestTypeId;
-/**
- * @since 1.0.0
- * @category schemas
- */
-const StreamRequest = () => (tag, options) => {
-  return class extends Schema.TaggedRequest()(tag, options) {
-    constructor(props, disableValidation) {
-      super(props, disableValidation);
-      this[Internal.StreamRequestTypeId] = Internal.StreamRequestTypeId;
-    }
-  };
 };
+const makeProto = options => {
+  const self = Object.assign(Object.create(Proto), options);
+  self.key = `@effect/rpc/Rpc/${options._tag}`;
+  return self;
+};
+const constEmptyStruct = /*#__PURE__*/Schema.Struct({});
 /**
  * @since 1.0.0
  * @category constructors
  */
-exports.StreamRequest = StreamRequest;
-const stream = (schema, handler) => ({
-  [TypeId]: TypeId,
-  _tag: "Stream",
-  schema: schema,
-  handler,
-  pipe() {
-    return (0, _Pipeable.pipeArguments)(this, arguments);
-  }
-});
-/**
- * @since 1.0.0
- * @category schemas
- */
-exports.stream = stream;
-const RequestSchema = schema => Schema.Struct({
-  request: schema,
-  traceId: Schema.String,
-  spanId: Schema.String,
-  sampled: Schema.Boolean,
-  headers: Schema.Record({
-    key: Schema.String,
-    value: Schema.String
-  })
-});
-/**
- * @since 1.0.0
- * @category headers
- */
-exports.RequestSchema = RequestSchema;
-const currentHeaders = exports.currentHeaders = /*#__PURE__*/(0, _GlobalValue.globalValue)("@effect/rpc/Rpc/currentHeaders", () => FiberRef.unsafeMake(Headers.empty));
+const make = (tag, options) => {
+  const successSchema = options?.success ?? Schema.Void;
+  const errorSchema = options?.error ?? Schema.Never;
+  return makeProto({
+    _tag: tag,
+    payloadSchema: Schema.isSchema(options?.payload) ? options?.payload : options?.payload ? Schema.Struct(options?.payload) : constEmptyStruct,
+    successSchema: options?.stream ? RpcSchema.Stream({
+      success: successSchema,
+      failure: errorSchema
+    }) : successSchema,
+    errorSchema: options?.stream ? Schema.Never : errorSchema,
+    annotations: Context_.empty(),
+    middlewares: new Set()
+  });
+};
 /**
  * @since 1.0.0
- * @category headers
+ * @category constructors
  */
-const annotateHeaders = exports.annotateHeaders = /*#__PURE__*/(0, _Function.dual)(2, (self, headers) => {
-  const resolved = Headers.fromInput(headers);
-  return Effect.locallyWith(self, currentHeaders, prev => ({
-    ...prev,
-    ...resolved
-  }));
+exports.make = make;
+const fromTaggedRequest = schema => makeProto({
+  _tag: schema._tag,
+  payloadSchema: schema,
+  successSchema: schema.success,
+  errorSchema: schema.failure,
+  annotations: Context_.empty(),
+  middlewares: new Set()
 });
+exports.fromTaggedRequest = fromTaggedRequest;
+const exitSchemaCache = /*#__PURE__*/(0, _GlobalValue.globalValue)("@effect/rpc/Rpc/exitSchemaCache", () => new WeakMap());
 /**
  * @since 1.0.0
- * @category headers
+ * @category constructors
  */
-const schemaHeaders = schema => {
-  const decode = Schema.decodeUnknown(schema);
-  return Effect.flatMap(FiberRef.get(currentHeaders), decode);
+const exitSchema = self => {
+  if (exitSchemaCache.has(self)) {
+    return exitSchemaCache.get(self);
+  }
+  const rpc = self;
+  const streamSchemas = RpcSchema.getStreamSchemas(rpc.successSchema.ast);
+  const schema = Schema.Exit({
+    success: Option.isSome(streamSchemas) ? Schema.Void : rpc.successSchema,
+    failure: Option.isSome(streamSchemas) ? Schema.Union(streamSchemas.value.failure, rpc.errorSchema) : rpc.errorSchema,
+    defect: Schema.Defect
+  });
+  exitSchemaCache.set(self, schema);
+  return schema;
 };
 /**
  * @since 1.0.0
- * @category requests
+ * @category Fork
  */
-exports.schemaHeaders = schemaHeaders;
-const request = (request, options) => (0, _Function.pipe)(Effect.makeSpanScoped(`${options?.spanPrefix ?? "Rpc.request "}${request._tag}`, {
-  kind: "client",
-  captureStackTrace: false
-}), Effect.zip(FiberRef.get(currentHeaders)), Effect.map(([span, headers]) => Internal.makeRequest({
-  request,
-  traceId: span.traceId,
-  spanId: span.spanId,
-  sampled: span.sampled,
-  headers
-})));
+exports.exitSchema = exitSchema;
+const ForkTypeId = exports.ForkTypeId = /*#__PURE__*/Symbol.for("@effect/rpc/Rpc/Fork");
 /**
+ * You can use `fork` to wrap a response Effect or Stream, to ensure that the
+ * response is executed concurrently regardless of the RpcServer concurrency
+ * setting.
+ *
  * @since 1.0.0
- * @category requests
+ * @category Fork
  */
-exports.request = request;
-const call = (req, resolver, options) => {
-  const isStream = Internal.StreamRequestTypeId in req;
-  const res = (0, _Function.pipe)(request(req, options), Effect.flatMap(_ => Effect.request(_, resolver)));
-  return isStream ? Stream.unwrapScoped(res) : Effect.scoped(res);
-};
-/**
- * @since 1.0.0
- * @category context
- */
-exports.call = call;
-const provideServiceEffect = exports.provideServiceEffect = /*#__PURE__*/(0, _Function.dual)(3, (self, tag, make) => self._tag === "Effect" ? effect(self.schema, req => Effect.provideServiceEffect(self.handler(req), tag, Effect.orDie(make))) : stream(self.schema, req => Stream.provideServiceEffect(self.handler(req), tag, Effect.orDie(make))));
+const fork = value => ({
+  [ForkTypeId]: ForkTypeId,
+  value
+});
 /**
  * @since 1.0.0
- * @category context
+ * @category Fork
  */
-const provideService = exports.provideService = /*#__PURE__*/(0, _Function.dual)(3, (self, tag, service) => self._tag === "Effect" ? effect(self.schema, req => Effect.provideService(self.handler(req), tag, service)) : stream(self.schema, req => Stream.provideService(self.handler(req), tag, service)));
+exports.fork = fork;
+const isFork = u => ForkTypeId in u;
+exports.isFork = isFork;
 //# sourceMappingURL=Rpc.js.map
\ No newline at end of file
diff --git a/dist/cjs/Rpc.js.map b/dist/cjs/Rpc.js.map
index ee4df6c993ac18c82b0e031bd1d790b14b821bb5..71f0e566c47c30fffe51c4e00a516e464a11b96c 100644
--- a/dist/cjs/Rpc.js.map
+++ b/dist/cjs/Rpc.js.map
@@ -1 +1 @@
-{"version":3,"file":"Rpc.js","names":["Headers","_interopRequireWildcard","require","Effect","FiberRef","_Function","_GlobalValue","_Pipeable","Predicate","Schema","Stream","Internal","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","TypeId","exports","Symbol","for","isRpc","hasProperty","effect","schema","handler","_tag","pipe","pipeArguments","arguments","StreamRequestTypeId","StreamRequest","tag","options","TaggedRequest","constructor","props","disableValidation","stream","RequestSchema","Struct","request","traceId","String","spanId","sampled","Boolean","headers","Record","key","value","currentHeaders","globalValue","unsafeMake","empty","annotateHeaders","dual","self","resolved","fromInput","locallyWith","prev","schemaHeaders","decode","decodeUnknown","flatMap","makeSpanScoped","spanPrefix","kind","captureStackTrace","zip","map","span","makeRequest","req","resolver","isStream","res","_","unwrapScoped","scoped","provideServiceEffect","make","orDie","provideService","service"],"sources":["../../src/Rpc.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
+{"version":3,"file":"Rpc.js","names":["Context_","_interopRequireWildcard","require","_GlobalValue","Option","_Pipeable","Predicate","Schema","RpcSchema","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","TypeId","exports","Symbol","for","isRpc","hasProperty","Proto","pipe","pipeArguments","arguments","setSuccess","successSchema","makeProto","setError","errorSchema","setPayload","payloadSchema","isSchema","Struct","middleware","middlewares","Set","annotate","tag","value","annotations","add","annotateContext","context","merge","options","self","assign","create","key","_tag","constEmptyStruct","make","success","Void","error","Never","payload","stream","Stream","failure","empty","fromTaggedRequest","schema","exitSchemaCache","globalValue","exitSchema","rpc","streamSchemas","getStreamSchemas","ast","Exit","isSome","Union","defect","Defect","ForkTypeId","fork","isFork"],"sources":["../../src/Rpc.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/cjs/RpcClient.js b/dist/cjs/RpcClient.js
new file mode 100644
index 0000000000000000000000000000000000000000..ab1b4fad74091c80bbc6a0517a91bf88e04ee93d
--- /dev/null
+++ b/dist/cjs/RpcClient.js
@@ -0,0 +1,656 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.withHeadersEffect = exports.withHeaders = exports.makeProtocolWorker = exports.makeProtocolSocket = exports.makeProtocolHttp = exports.makeNoSerialization = exports.make = exports.layerProtocolWorker = exports.layerProtocolSocket = exports.layerProtocolHttp = exports.currentHeaders = exports.Protocol = void 0;
+var Headers = _interopRequireWildcard(require("@effect/platform/Headers"));
+var HttpBody = _interopRequireWildcard(require("@effect/platform/HttpBody"));
+var HttpClient = _interopRequireWildcard(require("@effect/platform/HttpClient"));
+var HttpClientRequest = _interopRequireWildcard(require("@effect/platform/HttpClientRequest"));
+var Socket = _interopRequireWildcard(require("@effect/platform/Socket"));
+var Transferable = _interopRequireWildcard(require("@effect/platform/Transferable"));
+var Worker = _interopRequireWildcard(require("@effect/platform/Worker"));
+var Cause = _interopRequireWildcard(require("effect/Cause"));
+var Chunk = _interopRequireWildcard(require("effect/Chunk"));
+var Context = _interopRequireWildcard(require("effect/Context"));
+var Effect = _interopRequireWildcard(require("effect/Effect"));
+var Exit = _interopRequireWildcard(require("effect/Exit"));
+var Fiber = _interopRequireWildcard(require("effect/Fiber"));
+var FiberId = _interopRequireWildcard(require("effect/FiberId"));
+var FiberRef = _interopRequireWildcard(require("effect/FiberRef"));
+var _Function = require("effect/Function");
+var _GlobalValue = require("effect/GlobalValue");
+var Layer = _interopRequireWildcard(require("effect/Layer"));
+var Mailbox = _interopRequireWildcard(require("effect/Mailbox"));
+var Option = _interopRequireWildcard(require("effect/Option"));
+var Pool = _interopRequireWildcard(require("effect/Pool"));
+var Runtime = _interopRequireWildcard(require("effect/Runtime"));
+var Schedule = _interopRequireWildcard(require("effect/Schedule"));
+var Schema = _interopRequireWildcard(require("effect/Schema"));
+var Scope = _interopRequireWildcard(require("effect/Scope"));
+var Stream = _interopRequireWildcard(require("effect/Stream"));
+var _utils = require("./internal/utils.js");
+var Rpc = _interopRequireWildcard(require("./Rpc.js"));
+var _RpcMessage = require("./RpcMessage.js");
+var RpcSchema = _interopRequireWildcard(require("./RpcSchema.js"));
+var RpcSerialization = _interopRequireWildcard(require("./RpcSerialization.js"));
+var RpcWorker = _interopRequireWildcard(require("./RpcWorker.js"));
+function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
+function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
+/**
+ * @since 1.0.0
+ */
+
+let requestIdCounter = /*#__PURE__*/BigInt(0);
+/**
+ * @since 1.0.0
+ * @category client
+ */
+const makeNoSerialization = exports.makeNoSerialization = /*#__PURE__*/Effect.fnUntraced(function* (group, options) {
+  const spanPrefix = options?.spanPrefix ?? "RpcClient";
+  const supportsAck = options?.supportsAck ?? true;
+  const disableTracing = options?.disableTracing ?? false;
+  const generateRequestId = options?.generateRequestId ?? (() => requestIdCounter++);
+  const context = yield* Effect.context();
+  const scope = Context.get(context, Scope.Scope);
+  const entries = new Map();
+  let isShutdown = false;
+  yield* Scope.addFinalizer(scope, Effect.fiberIdWith(fiberId => {
+    isShutdown = true;
+    return clearEntries(Exit.interrupt(fiberId));
+  }));
+  const clearEntries = Effect.fnUntraced(function* (exit) {
+    for (const [id, entry] of entries) {
+      entries.delete(id);
+      if (entry._tag === "Mailbox") {
+        yield* entry.mailbox.done(exit);
+      } else {
+        entry.resume(exit);
+      }
+    }
+  });
+  const onRequest = rpc => {
+    const isStream = RpcSchema.isStreamSchema(rpc.successSchema);
+    const middleware = getRpcClientMiddleware(rpc);
+    return (payload, options) => {
+      const headers = options?.headers ? Headers.fromInput(options.headers) : Headers.empty;
+      if (!isStream) {
+        const effect = Effect.useSpan(`${spanPrefix}.${rpc._tag}`, {
+          captureStackTrace: false
+        }, span => onEffectRequest(rpc, middleware, span, payload ? rpc.payloadSchema.make(payload) : {}, headers, options?.context ?? Context.empty(), options?.discard ?? false));
+        return disableTracing ? Effect.withTracerEnabled(effect, false) : effect;
+      }
+      const mailbox = Effect.suspend(() => onStreamRequest(rpc, middleware, payload ? rpc.payloadSchema.make(payload) : {}, headers, options?.streamBufferSize ?? 16, options?.context ?? Context.empty()));
+      if (options?.asMailbox) return mailbox;
+      return Stream.unwrapScoped(Effect.map(mailbox, Mailbox.toStream));
+    };
+  };
+  const onEffectRequest = (rpc, middleware, span, payload, headers, context, discard) => Effect.withFiberRuntime(parentFiber => {
+    if (isShutdown) {
+      return Effect.interrupt;
+    }
+    const id = generateRequestId();
+    const send = middleware({
+      _tag: "Request",
+      id,
+      tag: rpc._tag,
+      payload,
+      traceId: span.traceId,
+      spanId: span.spanId,
+      sampled: span.sampled,
+      headers: Headers.merge(parentFiber.getFiberRef(currentHeaders), headers)
+    });
+    if (discard) {
+      return Effect.flatMap(send, message => options.onFromClient({
+        message,
+        context,
+        discard
+      }));
+    }
+    const runtime = Runtime.make({
+      context: parentFiber.currentContext,
+      fiberRefs: parentFiber.getFiberRefs(),
+      runtimeFlags: Runtime.defaultRuntime.runtimeFlags
+    });
+    let fiber;
+    return Effect.onInterrupt(Effect.async(resume => {
+      const entry = {
+        _tag: "Effect",
+        rpc,
+        context,
+        resume(exit) {
+          resume(exit);
+          if (!fiber.unsafePoll()) {
+            parentFiber.currentScheduler.scheduleTask(() => {
+              fiber.unsafeInterruptAsFork(parentFiber.id());
+            }, 0);
+          }
+        }
+      };
+      entries.set(id, entry);
+      fiber = send.pipe(Effect.flatMap(request => options.onFromClient({
+        message: request,
+        context,
+        discard
+      })), Effect.withParentSpan(span), Runtime.runFork(runtime));
+      fiber.addObserver(exit => {
+        if (exit._tag === "Failure") {
+          return resume(exit);
+        }
+      });
+    }), interruptors => {
+      entries.delete(id);
+      const ids = Array.from(interruptors).flatMap(id => Array.from(FiberId.toSet(id)));
+      return Effect.zipRight(Fiber.interrupt(fiber), sendInterrupt(id, ids, context));
+    });
+  });
+  const onStreamRequest = Effect.fnUntraced(function* (rpc, middleware, payload, headers, streamBufferSize, context) {
+    if (isShutdown) {
+      return yield* Effect.interrupt;
+    }
+    const span = yield* Effect.makeSpanScoped(`${spanPrefix}.${rpc._tag}`, {
+      captureStackTrace: false
+    }).pipe(disableTracing ? Effect.withTracerEnabled(false) : _Function.identity);
+    const fiber = Option.getOrThrow(Fiber.getCurrentFiber());
+    const id = generateRequestId();
+    const scope = Context.unsafeGet(fiber.currentContext, Scope.Scope);
+    yield* Scope.addFinalizerExit(scope, exit => {
+      if (!entries.has(id)) return Effect.void;
+      entries.delete(id);
+      return sendInterrupt(id, Exit.isFailure(exit) ? Array.from(Cause.interruptors(exit.cause)).flatMap(id => Array.from(FiberId.toSet(id))) : [], context);
+    });
+    const mailbox = yield* Mailbox.make(streamBufferSize);
+    entries.set(id, {
+      _tag: "Mailbox",
+      rpc,
+      mailbox,
+      scope,
+      context
+    });
+    yield* middleware({
+      _tag: "Request",
+      id,
+      tag: rpc._tag,
+      traceId: span.traceId,
+      payload,
+      spanId: span.spanId,
+      sampled: span.sampled,
+      headers: Headers.merge(fiber.getFiberRef(currentHeaders), headers)
+    }).pipe(Effect.flatMap(request => options.onFromClient({
+      message: request,
+      context,
+      discard: false
+    })), Effect.withParentSpan(span), Effect.catchAllCause(error => mailbox.failCause(error)), Effect.interruptible, Effect.forkIn(scope));
+    return mailbox;
+  });
+  const getRpcClientMiddleware = rpc => {
+    const middlewares = [];
+    for (const tag of rpc.middlewares.values()) {
+      const middleware = context.unsafeMap.get(`${tag.key}/Client`);
+      if (!middleware) continue;
+      middlewares.push(middleware);
+    }
+    return middlewares.length === 0 ? Effect.succeed : function (request) {
+      let i = 0;
+      return Effect.map(Effect.whileLoop({
+        while: () => i < middlewares.length,
+        body: () => middlewares[i]({
+          rpc,
+          request
+        }),
+        step(nextRequest) {
+          request = nextRequest;
+          i++;
+        }
+      }), () => request);
+    };
+  };
+  const sendInterrupt = (requestId, interruptors, context) => Effect.async(resume => {
+    const parentFiber = Option.getOrThrow(Fiber.getCurrentFiber());
+    const runtime = Runtime.make({
+      context: parentFiber.currentContext,
+      fiberRefs: parentFiber.getFiberRefs(),
+      runtimeFlags: Runtime.defaultRuntime.runtimeFlags
+    });
+    const fiber = options.onFromClient({
+      message: {
+        _tag: "Interrupt",
+        requestId,
+        interruptors
+      },
+      context,
+      discard: false
+    }).pipe(Effect.timeout(1000), Runtime.runFork(runtime));
+    fiber.addObserver(() => {
+      resume(Effect.void);
+    });
+  });
+  const write = message => {
+    switch (message._tag) {
+      case "Chunk":
+        {
+          const requestId = parseRequestId(message.requestId);
+          const entry = entries.get(requestId);
+          if (!entry || entry._tag !== "Mailbox") return Effect.void;
+          return entry.mailbox.offerAll(message.values).pipe(supportsAck ? Effect.zipRight(options.onFromClient({
+            message: {
+              _tag: "Ack",
+              requestId: message.requestId
+            },
+            context: entry.context,
+            discard: false
+          })) : _Function.identity, Effect.onError(cause => entry.mailbox.done(Exit.failCause(cause))), Effect.forkIn(entry.scope));
+        }
+      case "Exit":
+        {
+          const requestId = parseRequestId(message.requestId);
+          const entry = entries.get(requestId);
+          if (!entry) return Effect.void;
+          entries.delete(requestId);
+          if (entry._tag === "Effect") {
+            entry.resume(message.exit);
+            return Effect.void;
+          }
+          return entry.mailbox.done(Exit.asVoid(message.exit));
+        }
+      case "Defect":
+        {
+          return clearEntries(Exit.die(message.defect));
+        }
+      case "ClientEnd":
+        {
+          return Effect.void;
+        }
+    }
+  };
+  const client = {};
+  for (const rpc of group.requests.values()) {
+    ;
+    client[rpc._tag] = onRequest(rpc);
+  }
+  return {
+    client: client,
+    write
+  };
+});
+/**
+ * @since 1.0.0
+ * @category client
+ */
+const make = exports.make = /*#__PURE__*/Effect.fnUntraced(function* (group, options) {
+  const {
+    run,
+    send,
+    supportsAck,
+    supportsTransferables
+  } = yield* Protocol;
+  const entries = new Map();
+  const {
+    client,
+    write
+  } = yield* makeNoSerialization(group, {
+    ...options,
+    supportsAck,
+    onFromClient({
+      message
+    }) {
+      switch (message._tag) {
+        case "Request":
+          {
+            const rpc = group.requests.get(message.tag);
+            const schemas = RpcSchema.getStreamSchemas(rpc.successSchema.ast);
+            const collector = supportsTransferables ? Transferable.unsafeMakeCollector() : undefined;
+            const fiber = Option.getOrThrow(Fiber.getCurrentFiber());
+            const entry = {
+              rpc,
+              context: collector ? Context.add(fiber.currentContext, Transferable.Collector, collector) : fiber.currentContext,
+              decodeChunk: Option.isSome(schemas) ? Schema.decodeUnknown(Schema.NonEmptyArray(schemas.value.success)) : undefined
+            };
+            entries.set(message.id, entry);
+            return Schema.encode(rpc.payloadSchema)(message.payload).pipe(Effect.locally(FiberRef.currentContext, entry.context), Effect.orDie, Effect.flatMap(payload => send({
+              ...message,
+              payload,
+              headers: Object.entries(message.headers)
+            }, collector && collector.unsafeClear())));
+          }
+        case "Ack":
+          {
+            const entry = entries.get(message.requestId);
+            if (!entry) return Effect.void;
+            return send(message);
+          }
+        case "Interrupt":
+          {
+            const entry = entries.get(message.requestId);
+            if (!entry) return Effect.void;
+            entries.delete(message.requestId);
+            return send({
+              _tag: "Interrupt",
+              requestId: message.requestId
+            });
+          }
+        case "Eof":
+          {
+            return Effect.void;
+          }
+      }
+    }
+  });
+  yield* run(message => {
+    switch (message._tag) {
+      case "Chunk":
+        {
+          const requestId = parseRequestId(message.requestId);
+          const entry = entries.get(requestId);
+          if (!entry || !entry.decodeChunk) return Effect.void;
+          return entry.decodeChunk(message.values).pipe(Effect.locally(FiberRef.currentContext, entry.context), Effect.orDie, Effect.flatMap(chunk => write({
+            _tag: "Chunk",
+            clientId: 0,
+            requestId: parseRequestId(message.requestId),
+            values: chunk
+          })), Effect.onError(cause => write({
+            _tag: "Exit",
+            clientId: 0,
+            requestId: parseRequestId(message.requestId),
+            exit: Exit.failCause(cause)
+          })));
+        }
+      case "Exit":
+        {
+          const requestId = parseRequestId(message.requestId);
+          const entry = entries.get(requestId);
+          if (!entry) return Effect.void;
+          entries.delete(requestId);
+          return Schema.decode(Rpc.exitSchema(entry.rpc))(message.exit).pipe(Effect.locally(FiberRef.currentContext, entry.context), Effect.orDie, Effect.matchCauseEffect({
+            onSuccess: exit => write({
+              _tag: "Exit",
+              clientId: 0,
+              requestId,
+              exit
+            }),
+            onFailure: cause => write({
+              _tag: "Exit",
+              clientId: 0,
+              requestId,
+              exit: Exit.failCause(cause)
+            })
+          }));
+        }
+      case "Defect":
+        {
+          return write({
+            _tag: "Defect",
+            clientId: 0,
+            defect: decodeDefect(message.defect)
+          });
+        }
+      default:
+        {
+          return Effect.void;
+        }
+    }
+  }).pipe(Effect.catchAllCause(Effect.logError), Effect.interruptible, Effect.forkScoped);
+  return client;
+});
+const parseRequestId = input => typeof input === "string" ? BigInt(input) : input;
+/**
+ * @since 1.0.0
+ * @category headers
+ */
+const currentHeaders = exports.currentHeaders = /*#__PURE__*/(0, _GlobalValue.globalValue)("@effect/rpc/RpcClient/currentHeaders", () => FiberRef.unsafeMake(Headers.empty));
+/**
+ * @since 1.0.0
+ * @category headers
+ */
+const withHeaders = exports.withHeaders = /*#__PURE__*/(0, _Function.dual)(2, (effect, headers) => Effect.locallyWith(effect, currentHeaders, Headers.merge(Headers.fromInput(headers))));
+/**
+ * @since 1.0.0
+ * @category headers
+ */
+const withHeadersEffect = exports.withHeadersEffect = /*#__PURE__*/(0, _Function.dual)(2, (effect, headers) => Effect.flatMap(headers, headers => withHeaders(effect, headers)));
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+class Protocol extends /*#__PURE__*/Context.Tag("@effect/rpc/RpcClient/Protocol")() {
+  /**
+   * @since 1.0.0
+   */
+  static make = /*#__PURE__*/(0, _utils.withRun)();
+}
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+exports.Protocol = Protocol;
+const makeProtocolHttp = client => Protocol.make(Effect.fnUntraced(function* (writeResponse) {
+  const serialization = yield* RpcSerialization.RpcSerialization;
+  const isJson = serialization.contentType === "application/json";
+  const send = request => {
+    if (request._tag !== "Request") {
+      return Effect.void;
+    }
+    const parser = serialization.unsafeMake();
+    if (!serialization.supportsBigInt) transformBigInt(request);
+    const encoded = parser.encode(request);
+    const body = typeof encoded === "string" ? HttpBody.text(encoded, serialization.contentType) : HttpBody.uint8Array(encoded, serialization.contentType);
+    if (isJson) {
+      return client.post("/", {
+        body
+      }).pipe(Effect.flatMap(r => r.json), Effect.scoped, Effect.flatMap(u => {
+        if (!Array.isArray(u)) {
+          return Effect.dieMessage(`Expected an array of responses, but got: ${u}`);
+        }
+        let i = 0;
+        return Effect.whileLoop({
+          while: () => i < u.length,
+          body: () => writeResponse(u[i++]),
+          step: _Function.constVoid
+        });
+      }), Effect.orDie);
+    }
+    return client.post("/", {
+      body
+    }).pipe(Effect.flatMap(r => Stream.runForEachChunk(r.stream, chunk => {
+      const responses = Chunk.toReadonlyArray(chunk).flatMap(parser.decode);
+      if (responses.length === 0) return Effect.void;
+      let i = 0;
+      return Effect.whileLoop({
+        while: () => i < responses.length,
+        body: () => writeResponse(responses[i++]),
+        step: _Function.constVoid
+      });
+    })), Effect.orDie);
+  };
+  return {
+    send,
+    supportsAck: false,
+    supportsTransferables: false
+  };
+}));
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+exports.makeProtocolHttp = makeProtocolHttp;
+const layerProtocolHttp = options => Layer.scoped(Protocol, Effect.flatMap(HttpClient.HttpClient, client => {
+  client = HttpClient.mapRequest(client, HttpClientRequest.prependUrl(options.url));
+  return makeProtocolHttp(options.transformClient ? options.transformClient(client) : client);
+}));
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+exports.layerProtocolHttp = layerProtocolHttp;
+const makeProtocolSocket = exports.makeProtocolSocket = /*#__PURE__*/Protocol.make( /*#__PURE__*/Effect.fnUntraced(function* (writeResponse) {
+  const socket = yield* Socket.Socket;
+  const serialization = yield* RpcSerialization.RpcSerialization;
+  const write = yield* socket.writer;
+  let parser = serialization.unsafeMake();
+  yield* Effect.suspend(() => {
+    parser = serialization.unsafeMake();
+    return socket.runRaw(message => {
+      try {
+        const responses = parser.decode(message);
+        if (responses.length === 0) return;
+        let i = 0;
+        return Effect.whileLoop({
+          while: () => i < responses.length,
+          body: () => writeResponse(responses[i++]),
+          step: _Function.constVoid
+        });
+      } catch (defect) {
+        return writeResponse({
+          _tag: "Defect",
+          defect
+        });
+      }
+    });
+  }).pipe(Effect.zipRight(Effect.fail(new Socket.SocketCloseError({
+    reason: "Close",
+    code: 1000
+  }))), Effect.tapErrorCause(cause => writeResponse({
+    _tag: "Defect",
+    defect: Cause.squash(cause)
+  })), Effect.retry(Schedule.spaced(1000)), Effect.annotateLogs({
+    module: "RpcClient",
+    method: "makeProtocolSocket"
+  }), Effect.interruptible, Effect.forkScoped);
+  yield* Effect.suspend(() => write(parser.encode(_RpcMessage.constPing))).pipe(Effect.delay("30 seconds"), Effect.ignore, Effect.forever, Effect.interruptible, Effect.forkScoped);
+  return {
+    send(request) {
+      if (!serialization.supportsBigInt) transformBigInt(request);
+      return Effect.orDie(write(parser.encode(request)));
+    },
+    supportsAck: true,
+    supportsTransferables: false
+  };
+}));
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+const makeProtocolWorker = options => Protocol.make(Effect.fnUntraced(function* (writeResponse) {
+  const worker = yield* Worker.PlatformWorker;
+  const scope = yield* Effect.scope;
+  let workerId = 0;
+  const initialMessage = yield* Effect.serviceOption(RpcWorker.InitialMessage);
+  const entries = new Map();
+  yield* Scope.addFinalizerExit(scope, exit => Effect.forEach(entries, ([_, entry]) => Scope.close(entry.scope, exit), {
+    discard: true,
+    concurrency: "unbounded"
+  }));
+  const acquire = Effect.gen(function* () {
+    const id = workerId++;
+    const backing = yield* worker.spawn(id);
+    const readyLatch = yield* Effect.makeLatch();
+    yield* backing.run(message => {
+      if (message[0] === 0) {
+        return readyLatch.open;
+      }
+      const response = message[1];
+      if (response._tag === "Exit") {
+        const entry = entries.get(response.requestId);
+        if (entry) {
+          entries.delete(response.requestId);
+          return Effect.ensuring(writeResponse(response), Scope.close(entry.scope, Exit.void));
+        }
+      } else if (response._tag === "Defect") {
+        return Effect.zipRight(Effect.forEach(entries, ([requestId, entry]) => {
+          entries.delete(requestId);
+          return Scope.close(entry.scope, Exit.die(response.defect));
+        }, {
+          discard: true
+        }), writeResponse(response));
+      }
+      return writeResponse(response);
+    }).pipe(Effect.tapErrorCause(cause => writeResponse({
+      _tag: "Defect",
+      defect: Cause.squash(cause)
+    })), Effect.retry(Schedule.spaced(1000)), Effect.annotateLogs({
+      module: "RpcClient",
+      method: "makeProtocolWorker"
+    }), Effect.interruptible, Effect.forkScoped);
+    yield* readyLatch.await;
+    if (Option.isSome(initialMessage)) {
+      const [value, transfers] = yield* initialMessage.value;
+      yield* backing.send({
+        _tag: "InitialMessage",
+        value
+      }, transfers);
+    }
+    return backing;
+  });
+  const pool = "minSize" in options ? yield* Pool.makeWithTTL({
+    acquire,
+    min: options.minSize,
+    max: options.maxSize,
+    concurrency: options.concurrency,
+    targetUtilization: options.targetUtilization,
+    timeToLive: options.timeToLive
+  }) : yield* Pool.make({
+    acquire,
+    size: options.size,
+    concurrency: options.concurrency,
+    targetUtilization: options.targetUtilization
+  });
+  const send = (request, transferables) => {
+    switch (request._tag) {
+      case "Request":
+        {
+          return Scope.make().pipe(Effect.flatMap(scope => Effect.flatMap(Scope.extend(pool.get, scope), worker => {
+            entries.set(request.id, {
+              worker,
+              scope
+            });
+            return Effect.orDie(worker.send(request, transferables));
+          })), Effect.orDie);
+        }
+      case "Interrupt":
+        {
+          const entry = entries.get(request.requestId);
+          if (!entry) return Effect.void;
+          entries.delete(request.requestId);
+          return Effect.ensuring(Effect.orDie(entry.worker.send(request)), Scope.close(entry.scope, Exit.void));
+        }
+      case "Ack":
+        {
+          const entry = entries.get(request.requestId);
+          if (!entry) return Effect.void;
+          return Effect.orDie(entry.worker.send(request));
+        }
+    }
+    return Effect.void;
+  };
+  yield* Effect.scoped(pool.get);
+  return {
+    send,
+    supportsAck: true,
+    supportsTransferables: true
+  };
+}));
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+exports.makeProtocolWorker = makeProtocolWorker;
+const layerProtocolWorker = options => Layer.scoped(Protocol, makeProtocolWorker(options));
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+exports.layerProtocolWorker = layerProtocolWorker;
+const layerProtocolSocket = exports.layerProtocolSocket = /*#__PURE__*/Layer.scoped(Protocol, makeProtocolSocket);
+// internal
+const decodeDefect = /*#__PURE__*/Schema.decodeSync(Schema.Defect);
+const transformBigInt = request => {
+  if (request._tag === "Request") {
+    ;
+    request.id = request.id.toString();
+  } else if ("requestId" in request) {
+    ;
+    request.requestId = request.requestId.toString();
+  }
+};
+//# sourceMappingURL=RpcClient.js.map
\ No newline at end of file
diff --git a/dist/cjs/RpcClient.js.map b/dist/cjs/RpcClient.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..f71a53859716dbca3a0b3ed2893c1a53abf7caee
--- /dev/null
+++ b/dist/cjs/RpcClient.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"RpcClient.js","names":["Headers","_interopRequireWildcard","require","HttpBody","HttpClient","HttpClientRequest","Socket","Transferable","Worker","Cause","Chunk","Context","Effect","Exit","Fiber","FiberId","FiberRef","_Function","_GlobalValue","Layer","Mailbox","Option","Pool","Runtime","Schedule","Schema","Scope","Stream","_utils","Rpc","_RpcMessage","RpcSchema","RpcSerialization","RpcWorker","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","requestIdCounter","BigInt","makeNoSerialization","exports","fnUntraced","group","options","spanPrefix","supportsAck","disableTracing","generateRequestId","context","scope","entries","Map","isShutdown","addFinalizer","fiberIdWith","fiberId","clearEntries","interrupt","exit","id","entry","delete","_tag","mailbox","done","resume","onRequest","rpc","isStream","isStreamSchema","successSchema","middleware","getRpcClientMiddleware","payload","headers","fromInput","empty","effect","useSpan","captureStackTrace","span","onEffectRequest","payloadSchema","make","discard","withTracerEnabled","suspend","onStreamRequest","streamBufferSize","asMailbox","unwrapScoped","map","toStream","withFiberRuntime","parentFiber","send","tag","traceId","spanId","sampled","merge","getFiberRef","currentHeaders","flatMap","message","onFromClient","runtime","currentContext","fiberRefs","getFiberRefs","runtimeFlags","defaultRuntime","fiber","onInterrupt","async","unsafePoll","currentScheduler","scheduleTask","unsafeInterruptAsFork","pipe","request","withParentSpan","runFork","addObserver","interruptors","ids","Array","from","toSet","zipRight","sendInterrupt","makeSpanScoped","identity","getOrThrow","getCurrentFiber","unsafeGet","addFinalizerExit","void","isFailure","cause","catchAllCause","error","failCause","interruptible","forkIn","middlewares","values","unsafeMap","key","push","length","succeed","whileLoop","while","body","step","nextRequest","requestId","timeout","write","parseRequestId","offerAll","onError","asVoid","die","defect","client","requests","run","supportsTransferables","Protocol","schemas","getStreamSchemas","ast","collector","unsafeMakeCollector","undefined","add","Collector","decodeChunk","isSome","decodeUnknown","NonEmptyArray","value","success","encode","locally","orDie","unsafeClear","chunk","clientId","decode","exitSchema","matchCauseEffect","onSuccess","onFailure","decodeDefect","logError","forkScoped","input","globalValue","unsafeMake","withHeaders","dual","locallyWith","withHeadersEffect","Tag","withRun","makeProtocolHttp","writeResponse","serialization","isJson","contentType","parser","supportsBigInt","transformBigInt","encoded","text","uint8Array","post","json","scoped","isArray","dieMessage","constVoid","runForEachChunk","stream","responses","toReadonlyArray","layerProtocolHttp","mapRequest","prependUrl","url","transformClient","makeProtocolSocket","socket","writer","runRaw","fail","SocketCloseError","reason","code","tapErrorCause","squash","retry","spaced","annotateLogs","module","method","constPing","delay","ignore","forever","makeProtocolWorker","worker","PlatformWorker","workerId","initialMessage","serviceOption","InitialMessage","forEach","_","close","concurrency","acquire","gen","backing","spawn","readyLatch","makeLatch","open","response","ensuring","await","transfers","pool","makeWithTTL","min","minSize","max","maxSize","targetUtilization","timeToLive","size","transferables","extend","layerProtocolWorker","layerProtocolSocket","decodeSync","Defect","toString"],"sources":["../../src/RpcClient.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/cjs/RpcGroup.js b/dist/cjs/RpcGroup.js
new file mode 100644
index 0000000000000000000000000000000000000000..d31464d9ee866000e5a9cb86ad4847460696421f
--- /dev/null
+++ b/dist/cjs/RpcGroup.js
@@ -0,0 +1,110 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.make = exports.TypeId = void 0;
+var Context = _interopRequireWildcard(require("effect/Context"));
+var Effect = _interopRequireWildcard(require("effect/Effect"));
+var Layer = _interopRequireWildcard(require("effect/Layer"));
+var Schema = _interopRequireWildcard(require("effect/Schema"));
+var Rpc = _interopRequireWildcard(require("./Rpc.js"));
+function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
+function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
+/**
+ * @since 1.0.0
+ * @category type ids
+ */
+const TypeId = exports.TypeId = /*#__PURE__*/Symbol.for("@effect/rpc/RpcGroup");
+const RpcGroupProto = {
+  add(...rpcs) {
+    return makeProto({
+      requests: resolveInput(...this.requests.values(), ...rpcs),
+      annotations: this.annotations
+    });
+  },
+  merge(that) {
+    const requests = new Map(this.requests);
+    for (const rpc of that.requests.values()) {
+      requests.set(rpc._tag, rpc);
+    }
+    return makeProto({
+      requests,
+      annotations: Context.merge(this.annotations, that.annotations)
+    });
+  },
+  middleware(middleware) {
+    const requests = new Map();
+    for (const [tag, rpc] of this.requests) {
+      requests.set(tag, rpc.middleware(middleware));
+    }
+    return makeProto({
+      requests,
+      annotations: this.annotations
+    });
+  },
+  toHandlersContext(build) {
+    return Effect.gen(this, function* () {
+      const context = yield* Effect.context();
+      const handlers = Effect.isEffect(build) ? yield* build : build;
+      const contextMap = new Map();
+      for (const [tag, handler] of Object.entries(handlers)) {
+        const rpc = this.requests.get(tag);
+        contextMap.set(rpc.key, {
+          handler,
+          context
+        });
+      }
+      return Context.unsafeMake(contextMap);
+    });
+  },
+  toLayer(build) {
+    return Layer.scopedContext(this.toHandlersContext(build));
+  },
+  annotate(tag, value) {
+    return makeProto({
+      requests: this.requests,
+      annotations: Context.add(this.annotations, tag, value)
+    });
+  },
+  annotateRpcs(tag, value) {
+    return this.annotateRpcsContext(Context.make(tag, value));
+  },
+  annotateContext(context) {
+    return makeProto({
+      requests: this.requests,
+      annotations: Context.merge(this.annotations, context)
+    });
+  },
+  annotateRpcsContext(context) {
+    const requests = new Map();
+    for (const [tag, rpc] of this.requests) {
+      requests.set(tag, rpc.annotateContext(Context.merge(context, rpc.annotations)));
+    }
+    return makeProto({
+      requests,
+      annotations: this.annotations
+    });
+  }
+};
+const makeProto = options => Object.assign(function () {}, RpcGroupProto, {
+  requests: options.requests,
+  annotations: options.annotations
+});
+const resolveInput = (...rpcs) => {
+  const requests = new Map();
+  for (const rpc of rpcs) {
+    requests.set(rpc._tag, Schema.isSchema(rpc) ? Rpc.fromTaggedRequest(rpc) : rpc);
+  }
+  return requests;
+};
+/**
+ * @since 1.0.0
+ * @category groups
+ */
+const make = (...rpcs) => makeProto({
+  requests: resolveInput(...rpcs),
+  annotations: Context.empty()
+});
+exports.make = make;
+//# sourceMappingURL=RpcGroup.js.map
\ No newline at end of file
diff --git a/dist/cjs/RpcGroup.js.map b/dist/cjs/RpcGroup.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..865d5c836ecc8ac0cf3feee22f3bf2d8caa6a9c5
--- /dev/null
+++ b/dist/cjs/RpcGroup.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"RpcGroup.js","names":["Context","_interopRequireWildcard","require","Effect","Layer","Schema","Rpc","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","TypeId","exports","Symbol","for","RpcGroupProto","add","rpcs","makeProto","requests","resolveInput","values","annotations","merge","that","Map","rpc","_tag","middleware","tag","toHandlersContext","build","gen","context","handlers","isEffect","contextMap","handler","entries","key","unsafeMake","toLayer","scopedContext","annotate","value","annotateRpcs","annotateRpcsContext","make","annotateContext","options","assign","isSchema","fromTaggedRequest","empty"],"sources":["../../src/RpcGroup.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/cjs/RpcMessage.js b/dist/cjs/RpcMessage.js
new file mode 100644
index 0000000000000000000000000000000000000000..d9c98938d0b38033c0ba6aa50d1d53d738dec7fd
--- /dev/null
+++ b/dist/cjs/RpcMessage.js
@@ -0,0 +1,57 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.constPong = exports.constPing = exports.constEof = exports.ResponseIdTypeId = exports.ResponseDefectEncoded = exports.RequestIdTypeId = exports.RequestId = void 0;
+var Schema = _interopRequireWildcard(require("effect/Schema"));
+function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
+function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
+/**
+ * @since 1.0.0
+ * @category request
+ */
+const RequestIdTypeId = exports.RequestIdTypeId = /*#__PURE__*/Symbol.for("@effect/rpc/RpcServer/RequestId");
+/**
+ * @since 1.0.0
+ * @category request
+ */
+const RequestId = id => typeof id === "bigint" ? id : BigInt(id);
+/**
+ * @since 1.0.0
+ * @category request
+ */
+exports.RequestId = RequestId;
+const constEof = exports.constEof = {
+  _tag: "Eof"
+};
+/**
+ * @since 1.0.0
+ * @category request
+ */
+const constPing = exports.constPing = {
+  _tag: "Ping"
+};
+/**
+ * @since 1.0.0
+ * @category response
+ */
+const ResponseIdTypeId = exports.ResponseIdTypeId = /*#__PURE__*/Symbol.for("@effect/rpc/RpcServer/ResponseId");
+const encodeDefect = /*#__PURE__*/Schema.encodeSync(Schema.Defect);
+/**
+ * @since 1.0.0
+ * @category response
+ */
+const ResponseDefectEncoded = input => ({
+  _tag: "Defect",
+  defect: encodeDefect(input)
+});
+/**
+ * @since 1.0.0
+ * @category response
+ */
+exports.ResponseDefectEncoded = ResponseDefectEncoded;
+const constPong = exports.constPong = {
+  _tag: "Pong"
+};
+//# sourceMappingURL=RpcMessage.js.map
\ No newline at end of file
diff --git a/dist/cjs/RpcMessage.js.map b/dist/cjs/RpcMessage.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..e0e0daf2db05cfbb17455b6dfbd07029e35e9b22
--- /dev/null
+++ b/dist/cjs/RpcMessage.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"RpcMessage.js","names":["Schema","_interopRequireWildcard","require","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","RequestIdTypeId","exports","Symbol","for","RequestId","id","BigInt","constEof","_tag","constPing","ResponseIdTypeId","encodeDefect","encodeSync","Defect","ResponseDefectEncoded","input","defect","constPong"],"sources":["../../src/RpcMessage.ts"],"sourcesContent":[null],"mappings":";;;;;;AAOA,IAAAA,MAAA,GAAAC,uBAAA,CAAAC,OAAA;AAAuC,SAAAC,yBAAAC,CAAA,6BAAAC,OAAA,mBAAAC,CAAA,OAAAD,OAAA,IAAAE,CAAA,OAAAF,OAAA,YAAAF,wBAAA,YAAAA,CAAAC,CAAA,WAAAA,CAAA,GAAAG,CAAA,GAAAD,CAAA,KAAAF,CAAA;AAAA,SAAAH,wBAAAG,CAAA,EAAAE,CAAA,SAAAA,CAAA,IAAAF,CAAA,IAAAA,CAAA,CAAAI,UAAA,SAAAJ,CAAA,eAAAA,CAAA,uBAAAA,CAAA,yBAAAA,CAAA,WAAAK,OAAA,EAAAL,CAAA,QAAAG,CAAA,GAAAJ,wBAAA,CAAAG,CAAA,OAAAC,CAAA,IAAAA,CAAA,CAAAG,GAAA,CAAAN,CAAA,UAAAG,CAAA,CAAAI,GAAA,CAAAP,CAAA,OAAAQ,CAAA,KAAAC,SAAA,UAAAC,CAAA,GAAAC,MAAA,CAAAC,cAAA,IAAAD,MAAA,CAAAE,wBAAA,WAAAC,CAAA,IAAAd,CAAA,oBAAAc,CAAA,OAAAC,cAAA,CAAAC,IAAA,CAAAhB,CAAA,EAAAc,CAAA,SAAAG,CAAA,GAAAP,CAAA,GAAAC,MAAA,CAAAE,wBAAA,CAAAb,CAAA,EAAAc,CAAA,UAAAG,CAAA,KAAAA,CAAA,CAAAV,GAAA,IAAAU,CAAA,CAAAC,GAAA,IAAAP,MAAA,CAAAC,cAAA,CAAAJ,CAAA,EAAAM,CAAA,EAAAG,CAAA,IAAAT,CAAA,CAAAM,CAAA,IAAAd,CAAA,CAAAc,CAAA,YAAAN,CAAA,CAAAH,OAAA,GAAAL,CAAA,EAAAG,CAAA,IAAAA,CAAA,CAAAe,GAAA,CAAAlB,CAAA,EAAAQ,CAAA,GAAAA,CAAA;AAevC;;;;AAIO,MAAMW,eAAe,GAAAC,OAAA,CAAAD,eAAA,gBAAkBE,MAAM,CAACC,GAAG,CAAC,iCAAiC,CAAC;AAc3F;;;;AAIO,MAAMC,SAAS,GAAIC,EAAmB,IAC3C,OAAOA,EAAE,KAAK,QAAQ,GAAGA,EAAe,GAAGC,MAAM,CAACD,EAAE,CAAc;AA4EpE;;;;AAAAJ,OAAA,CAAAG,SAAA,GAAAA,SAAA;AAIO,MAAMG,QAAQ,GAAAN,OAAA,CAAAM,QAAA,GAAQ;EAAEC,IAAI,EAAE;AAAK,CAAE;AAE5C;;;;AAIO,MAAMC,SAAS,GAAAR,OAAA,CAAAQ,SAAA,GAAS;EAAED,IAAI,EAAE;AAAM,CAAE;AAkB/C;;;;AAIO,MAAME,gBAAgB,GAAAT,OAAA,CAAAS,gBAAA,gBAAkBR,MAAM,CAACC,GAAG,CAAC,kCAAkC,CAAC;AAiE7F,MAAMQ,YAAY,gBAAGlC,MAAM,CAACmC,UAAU,CAACnC,MAAM,CAACoC,MAAM,CAAC;AAErD;;;;AAIO,MAAMC,qBAAqB,GAAIC,KAAc,KAA6B;EAC/EP,IAAI,EAAE,QAAQ;EACdQ,MAAM,EAAEL,YAAY,CAACI,KAAK;CAC3B,CAAC;AA6BF;;;;AAAAd,OAAA,CAAAa,qBAAA,GAAAA,qBAAA;AAIO,MAAMG,SAAS,GAAAhB,OAAA,CAAAgB,SAAA,GAAS;EAAET,IAAI,EAAE;AAAM,CAAE","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/cjs/RpcMiddleware.js b/dist/cjs/RpcMiddleware.js
new file mode 100644
index 0000000000000000000000000000000000000000..9f3389fb4d331e702cd620ec46e6d8b77c872206
--- /dev/null
+++ b/dist/cjs/RpcMiddleware.js
@@ -0,0 +1,58 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.layerClient = exports.TypeId = exports.Tag = void 0;
+var Context = _interopRequireWildcard(require("effect/Context"));
+var Effect = _interopRequireWildcard(require("effect/Effect"));
+var Layer = _interopRequireWildcard(require("effect/Layer"));
+var Schema = _interopRequireWildcard(require("effect/Schema"));
+var _Scope = require("effect/Scope");
+function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
+function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
+/**
+ * @since 1.0.0
+ * @category type ids
+ */
+const TypeId = exports.TypeId = /*#__PURE__*/Symbol.for("@effect/rpc/RpcMiddleware");
+/**
+ * @since 1.0.0
+ * @category tags
+ */
+const Tag = () => (id, options) => {
+  const Err = globalThis.Error;
+  const limit = Err.stackTraceLimit;
+  Err.stackTraceLimit = 2;
+  const creationError = new Err();
+  Err.stackTraceLimit = limit;
+  function TagClass() {}
+  const TagClass_ = TagClass;
+  Object.setPrototypeOf(TagClass, Object.getPrototypeOf(Context.GenericTag(id)));
+  TagClass.key = id;
+  Object.defineProperty(TagClass, "stack", {
+    get() {
+      return creationError.stack;
+    }
+  });
+  TagClass_[TypeId] = TypeId;
+  TagClass_.failure = options?.optional === true || options?.failure === undefined ? Schema.Never : options.failure;
+  if (options?.provides) {
+    TagClass_.provides = options.provides;
+  }
+  TagClass_.optional = options?.optional ?? false;
+  TagClass_.requiredForClient = options?.requiredForClient ?? false;
+  return TagClass;
+};
+/**
+ * @since 1.0.0
+ * @category client
+ */
+exports.Tag = Tag;
+const layerClient = (tag, service) => Layer.scopedContext(Effect.gen(function* () {
+  const context = (yield* Effect.context()).pipe(Context.omit(_Scope.Scope));
+  const middleware = Effect.isEffect(service) ? yield* service : service;
+  return Context.unsafeMake(new Map([[`${tag.key}/Client`, options => Effect.mapInputContext(middleware(options), requestContext => Context.merge(context, requestContext))]]));
+}));
+exports.layerClient = layerClient;
+//# sourceMappingURL=RpcMiddleware.js.map
\ No newline at end of file
diff --git a/dist/cjs/RpcMiddleware.js.map b/dist/cjs/RpcMiddleware.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..25e0fe23c09fcebca549940b5a95b5c8b5a29f8f
--- /dev/null
+++ b/dist/cjs/RpcMiddleware.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"RpcMiddleware.js","names":["Context","_interopRequireWildcard","require","Effect","Layer","Schema","_Scope","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","TypeId","exports","Symbol","for","Tag","id","options","Err","globalThis","Error","limit","stackTraceLimit","creationError","TagClass","TagClass_","setPrototypeOf","getPrototypeOf","GenericTag","key","stack","failure","optional","undefined","Never","provides","requiredForClient","layerClient","tag","service","scopedContext","gen","context","pipe","omit","Scope","middleware","isEffect","unsafeMake","Map","mapInputContext","requestContext","merge"],"sources":["../../src/RpcMiddleware.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/cjs/RpcSchema.js b/dist/cjs/RpcSchema.js
new file mode 100644
index 0000000000000000000000000000000000000000..9801cf4e14cbcb19aaceab10fe3bee969cd4501b
--- /dev/null
+++ b/dist/cjs/RpcSchema.js
@@ -0,0 +1,71 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.isStreamSerializable = exports.isStreamSchema = exports.getStreamSchemas = exports.StreamSchemaId = exports.Stream = void 0;
+var Effect = _interopRequireWildcard(require("effect/Effect"));
+var Option = _interopRequireWildcard(require("effect/Option"));
+var ParseResult = _interopRequireWildcard(require("effect/ParseResult"));
+var _Predicate = require("effect/Predicate");
+var Schema = _interopRequireWildcard(require("effect/Schema"));
+var AST = _interopRequireWildcard(require("effect/SchemaAST"));
+var Stream_ = _interopRequireWildcard(require("effect/Stream"));
+function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
+function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
+/**
+ * @since 1.0.0
+ * @category Stream
+ */
+const StreamSchemaId = exports.StreamSchemaId = /*#__PURE__*/Symbol.for("@effect/rpc/RpcSchema/Stream");
+/**
+ * @since 1.0.0
+ * @category Stream
+ */
+const isStreamSchema = schema => schema.ast.annotations[AST.SchemaIdAnnotationId] === StreamSchemaId;
+/**
+ * @since 1.0.0
+ * @category Stream
+ */
+exports.isStreamSchema = isStreamSchema;
+const isStreamSerializable = schema => isStreamSchema(Schema.successSchema(schema));
+/**
+ * @since 1.0.0
+ * @category Stream
+ */
+exports.isStreamSerializable = isStreamSerializable;
+const getStreamSchemas = ast => ast.annotations[StreamSchemaId] ? Option.some(ast.annotations[StreamSchemaId]) : Option.none();
+/**
+ * @since 1.0.0
+ * @category Stream
+ */
+exports.getStreamSchemas = getStreamSchemas;
+const Stream = ({
+  failure,
+  success
+}) => Object.assign(Schema.declare([success, failure], {
+  decode: (success, failure) => parseStream(ParseResult.decodeUnknown(Schema.ChunkFromSelf(success)), ParseResult.decodeUnknown(failure)),
+  encode: (success, failure) => parseStream(ParseResult.encodeUnknown(Schema.ChunkFromSelf(success)), ParseResult.encodeUnknown(failure))
+}, {
+  schemaId: StreamSchemaId,
+  [StreamSchemaId]: {
+    success,
+    failure
+  }
+}), {
+  success,
+  failure
+});
+exports.Stream = Stream;
+const isStream = u => (0, _Predicate.hasProperty)(u, Stream_.StreamTypeId);
+const parseStream = (decodeSuccess, decodeFailure) => (u, options, ast) => Effect.flatMap(Effect.context(), context => {
+  if (!isStream(u)) return Effect.fail(new ParseResult.Type(ast, u));
+  return Effect.succeed(u.pipe(Stream_.mapChunksEffect(value => decodeSuccess(value, options)), Stream_.catchAll(error => {
+    if (ParseResult.isParseError(error)) return Stream_.die(error);
+    return Effect.matchEffect(decodeFailure(error, options), {
+      onFailure: Effect.die,
+      onSuccess: Effect.fail
+    });
+  }), Stream_.provideContext(context)));
+});
+//# sourceMappingURL=RpcSchema.js.map
\ No newline at end of file
diff --git a/dist/cjs/RpcSchema.js.map b/dist/cjs/RpcSchema.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..10bdbfa50588859b8f8857d31456113671c6dbad
--- /dev/null
+++ b/dist/cjs/RpcSchema.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"RpcSchema.js","names":["Effect","_interopRequireWildcard","require","Option","ParseResult","_Predicate","Schema","AST","Stream_","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","StreamSchemaId","exports","Symbol","for","isStreamSchema","schema","ast","annotations","SchemaIdAnnotationId","isStreamSerializable","successSchema","getStreamSchemas","some","none","Stream","failure","success","assign","declare","decode","parseStream","decodeUnknown","ChunkFromSelf","encode","encodeUnknown","schemaId","isStream","hasProperty","StreamTypeId","decodeSuccess","decodeFailure","options","flatMap","context","fail","Type","succeed","pipe","mapChunksEffect","value","catchAll","error","isParseError","die","matchEffect","onFailure","onSuccess","provideContext"],"sources":["../../src/RpcSchema.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/cjs/RpcSerialization.js b/dist/cjs/RpcSerialization.js
new file mode 100644
index 0000000000000000000000000000000000000000..6ae0602b92d7246a4ed4073230aa01598ce86a35
--- /dev/null
+++ b/dist/cjs/RpcSerialization.js
@@ -0,0 +1,116 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.ndjson = exports.msgPack = exports.layerNdjson = exports.layerMsgPack = exports.layerJson = exports.json = exports.RpcSerialization = void 0;
+var _MsgPack = require("@effect/platform/MsgPack");
+var Context = _interopRequireWildcard(require("effect/Context"));
+var Effect = _interopRequireWildcard(require("effect/Effect"));
+var Layer = _interopRequireWildcard(require("effect/Layer"));
+function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
+function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
+/**
+ * @since 1.0.0
+ */
+
+/**
+ * @since 1.0.0
+ * @category serialization
+ */
+class RpcSerialization extends /*#__PURE__*/Context.Tag("@effect/rpc/RpcSerialization")() {}
+/**
+ * @since 1.0.0
+ * @category serialization
+ */
+exports.RpcSerialization = RpcSerialization;
+const json = exports.json = /*#__PURE__*/Effect.sync(() => {
+  const decoder = new TextDecoder();
+  return RpcSerialization.of({
+    contentType: "application/json",
+    supportsBigInt: false,
+    unsafeMake: () => ({
+      decode: bytes => [JSON.parse(typeof bytes === "string" ? bytes : decoder.decode(bytes))],
+      encode: response => JSON.stringify(response)
+    })
+  });
+});
+/**
+ * @since 1.0.0
+ * @category serialization
+ */
+const ndjson = exports.ndjson = /*#__PURE__*/Effect.sync(() => {
+  const decoder = new TextDecoder();
+  return RpcSerialization.of({
+    contentType: "application/ndjson",
+    supportsBigInt: false,
+    unsafeMake: () => {
+      let buffer = "";
+      return {
+        decode: bytes => {
+          buffer += typeof bytes === "string" ? bytes : decoder.decode(bytes);
+          let position = 0;
+          let nlIndex = buffer.indexOf("\n", position);
+          const items = [];
+          while (nlIndex !== -1) {
+            const item = JSON.parse(buffer.slice(position, nlIndex));
+            items.push(item);
+            position = nlIndex + 1;
+            nlIndex = buffer.indexOf("\n", position);
+          }
+          buffer = buffer.slice(position);
+          return items;
+        },
+        encode: response => JSON.stringify(response) + "\n"
+      };
+    }
+  });
+});
+/**
+ * @since 1.0.0
+ * @category serialization
+ */
+const msgPack = exports.msgPack = /*#__PURE__*/RpcSerialization.of({
+  contentType: "application/msgpack",
+  supportsBigInt: true,
+  unsafeMake: () => {
+    const unpackr = new _MsgPack.Msgpackr.Unpackr();
+    const packr = new _MsgPack.Msgpackr.Packr();
+    const encoder = new TextEncoder();
+    return {
+      decode: bytes => unpackr.unpackMultiple(typeof bytes === "string" ? encoder.encode(bytes) : bytes),
+      encode: response => packr.pack(response)
+    };
+  }
+});
+/**
+ * A rpc serialization layer that uses JSON for serialization.
+ *
+ * Use this if your protocol supports framing for messages, otherwise use
+ * `layerSerializationNdjson`.
+ *
+ * @since 1.0.0
+ * @category serialization
+ */
+const layerJson = exports.layerJson = /*#__PURE__*/Layer.effect(RpcSerialization, json);
+/**
+ * A rpc serialization layer that uses NDJSON for serialization.
+ *
+ * Use this if your protocol does not support framing for messages, otherwise
+ * use `layerSerializationJson`.
+ *
+ * @since 1.0.0
+ * @category serialization
+ */
+const layerNdjson = exports.layerNdjson = /*#__PURE__*/Layer.effect(RpcSerialization, ndjson);
+/**
+ * A rpc serialization layer that uses MessagePack for serialization.
+ *
+ * MessagePack has a more compact binary format compared to JSON and NDJSON. It
+ * also has better support for binary data.
+ *
+ * @since 1.0.0
+ * @category serialization
+ */
+const layerMsgPack = exports.layerMsgPack = /*#__PURE__*/Layer.succeed(RpcSerialization, msgPack);
+//# sourceMappingURL=RpcSerialization.js.map
\ No newline at end of file
diff --git a/dist/cjs/RpcSerialization.js.map b/dist/cjs/RpcSerialization.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..1edffd6eccaedd44e261dbb1af5797ffae0e486f
--- /dev/null
+++ b/dist/cjs/RpcSerialization.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"RpcSerialization.js","names":["_MsgPack","require","Context","_interopRequireWildcard","Effect","Layer","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","RpcSerialization","Tag","exports","json","sync","decoder","TextDecoder","of","contentType","supportsBigInt","unsafeMake","decode","bytes","JSON","parse","encode","response","stringify","ndjson","buffer","position","nlIndex","indexOf","items","item","slice","push","msgPack","unpackr","Msgpackr","Unpackr","packr","Packr","encoder","TextEncoder","unpackMultiple","pack","layerJson","effect","layerNdjson","layerMsgPack","succeed"],"sources":["../../src/RpcSerialization.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/cjs/RpcServer.js b/dist/cjs/RpcServer.js
new file mode 100644
index 0000000000000000000000000000000000000000..7f46de12ef9cfde0961eeccee2ce0cdaedf38dd7
--- /dev/null
+++ b/dist/cjs/RpcServer.js
@@ -0,0 +1,878 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.toWebHandler = exports.toHttpAppWebsocket = exports.toHttpApp = exports.makeProtocolWorkerRunner = exports.makeProtocolWithHttpAppWebsocket = exports.makeProtocolWithHttpApp = exports.makeProtocolWebsocket = exports.makeProtocolSocketServer = exports.makeProtocolHttp = exports.makeNoSerialization = exports.make = exports.layerProtocolWorkerRunner = exports.layerProtocolWebsocket = exports.layerProtocolSocketServer = exports.layerProtocolHttp = exports.layer = exports.Protocol = void 0;
+var Headers = _interopRequireWildcard(require("@effect/platform/Headers"));
+var HttpApp = _interopRequireWildcard(require("@effect/platform/HttpApp"));
+var HttpRouter = _interopRequireWildcard(require("@effect/platform/HttpRouter"));
+var HttpServerRequest = _interopRequireWildcard(require("@effect/platform/HttpServerRequest"));
+var HttpServerResponse = _interopRequireWildcard(require("@effect/platform/HttpServerResponse"));
+var SocketServer = _interopRequireWildcard(require("@effect/platform/SocketServer"));
+var Transferable = _interopRequireWildcard(require("@effect/platform/Transferable"));
+var WorkerRunner = _interopRequireWildcard(require("@effect/platform/WorkerRunner"));
+var Arr = _interopRequireWildcard(require("effect/Array"));
+var Cause = _interopRequireWildcard(require("effect/Cause"));
+var Chunk = _interopRequireWildcard(require("effect/Chunk"));
+var Context = _interopRequireWildcard(require("effect/Context"));
+var Deferred = _interopRequireWildcard(require("effect/Deferred"));
+var Effect = _interopRequireWildcard(require("effect/Effect"));
+var Exit = _interopRequireWildcard(require("effect/Exit"));
+var Fiber = _interopRequireWildcard(require("effect/Fiber"));
+var FiberId = _interopRequireWildcard(require("effect/FiberId"));
+var FiberSet = _interopRequireWildcard(require("effect/FiberSet"));
+var _Function = require("effect/Function");
+var Layer = _interopRequireWildcard(require("effect/Layer"));
+var Mailbox = _interopRequireWildcard(require("effect/Mailbox"));
+var ManagedRuntime = _interopRequireWildcard(require("effect/ManagedRuntime"));
+var Option = _interopRequireWildcard(require("effect/Option"));
+var _ParseResult = require("effect/ParseResult");
+var Predicate = _interopRequireWildcard(require("effect/Predicate"));
+var Runtime = _interopRequireWildcard(require("effect/Runtime"));
+var Schema = _interopRequireWildcard(require("effect/Schema"));
+var Scope = _interopRequireWildcard(require("effect/Scope"));
+var Stream = _interopRequireWildcard(require("effect/Stream"));
+var Tracer = _interopRequireWildcard(require("effect/Tracer"));
+var _utils = require("./internal/utils.js");
+var Rpc = _interopRequireWildcard(require("./Rpc.js"));
+var _RpcMessage = require("./RpcMessage.js");
+var RpcSchema = _interopRequireWildcard(require("./RpcSchema.js"));
+var RpcSerialization = _interopRequireWildcard(require("./RpcSerialization.js"));
+function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
+function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
+/**
+ * @since 1.0.0
+ */
+
+/**
+ * @since 1.0.0
+ * @category server
+ */
+const makeNoSerialization = exports.makeNoSerialization = /*#__PURE__*/Effect.fnUntraced(function* (group, options) {
+  const enableTracing = options.disableTracing !== true;
+  const enableSpanPropagation = options.disableSpanPropagation !== true;
+  const supportsAck = options.disableClientAcks !== true;
+  const spanPrefix = options.spanPrefix ?? "RpcServer";
+  const concurrency = options.concurrency ?? "unbounded";
+  const context = yield* Effect.context();
+  const scope = Context.get(context, Scope.Scope);
+  const fiberSet = yield* FiberSet.make();
+  const runFork = yield* FiberSet.runtime(fiberSet)().pipe(Effect.interruptible);
+  const concurrencySemaphore = concurrency === "unbounded" ? undefined : yield* Effect.makeSemaphore(concurrency);
+  const clients = new Map();
+  let isShutdown = false;
+  const shutdownLatch = Effect.unsafeMakeLatch(false);
+  yield* Scope.addFinalizer(scope, Effect.fiberIdWith(fiberId => {
+    isShutdown = true;
+    for (const client of clients.values()) {
+      client.ended = true;
+      if (client.fibers.size === 0) {
+        runFork(endClient(client));
+        continue;
+      }
+      for (const fiber of client.fibers.values()) {
+        fiber.unsafeInterruptAsFork(fiberId);
+      }
+    }
+    if (clients.size === 0) {
+      return Effect.void;
+    }
+    return shutdownLatch.await;
+  }));
+  const disconnect = clientId => Effect.fiberIdWith(fiberId => {
+    const client = clients.get(clientId);
+    if (!client) return Effect.void;
+    for (const fiber of client.fibers.values()) {
+      fiber.unsafeInterruptAsFork(fiberId);
+    }
+    clients.delete(clientId);
+    return Effect.void;
+  });
+  const write = (clientId, message) => Effect.catchAllDefect(Effect.withFiberRuntime(requestFiber => {
+    if (isShutdown) return Effect.interrupt;
+    let client = clients.get(clientId);
+    if (!client) {
+      client = {
+        id: clientId,
+        latches: new Map(),
+        fibers: new Map(),
+        ended: false
+      };
+      clients.set(clientId, client);
+    } else if (client.ended) {
+      return Effect.interrupt;
+    }
+    switch (message._tag) {
+      case "Request":
+        {
+          return handleRequest(requestFiber, client, message);
+        }
+      case "Ack":
+        {
+          const latch = client.latches.get(message.requestId);
+          return latch ? latch.open : Effect.void;
+        }
+      case "Interrupt":
+        {
+          const fiber = client.fibers.get(message.requestId);
+          return fiber ? Fiber.interruptFork(fiber) : options.onFromServer({
+            _tag: "Exit",
+            clientId,
+            requestId: message.requestId,
+            exit: Exit.interrupt(FiberId.none)
+          });
+        }
+      case "Eof":
+        {
+          client.ended = true;
+          if (client.fibers.size > 0) return Effect.void;
+          return endClient(client);
+        }
+      default:
+        {
+          return sendDefect(client, `Unknown request tag: ${message._tag}`);
+        }
+    }
+  }), defect => sendDefect(clients.get(clientId), defect));
+  const endClient = client => {
+    clients.delete(client.id);
+    const write = options.onFromServer({
+      _tag: "ClientEnd",
+      clientId: client.id
+    });
+    if (isShutdown && clients.size === 0) {
+      return Effect.zipRight(write, shutdownLatch.open);
+    }
+    return write;
+  };
+  const handleRequest = (requestFiber, client, request) => {
+    if (client.fibers.has(request.id)) {
+      return Effect.interrupt;
+    }
+    const rpc = group.requests.get(request.tag);
+    const entry = context.unsafeMap.get(rpc?.key);
+    if (!rpc || !entry) {
+      const write = Effect.catchAllDefect(options.onFromServer({
+        _tag: "Exit",
+        clientId: client.id,
+        requestId: request.id,
+        exit: Exit.die(`Unknown request tag: ${request.tag}`)
+      }), defect => sendDefect(client, defect));
+      if (!client.ended || client.fibers.size > 0) return write;
+      return Effect.zipRight(write, endClient(client));
+    }
+    const isStream = RpcSchema.isStreamSchema(rpc.successSchema);
+    const result = entry.handler(request.payload, request.headers);
+    // if the handler requested forking, then we skip the concurrency control
+    const isFork = Rpc.isFork(result);
+    // unwrap the fork data type
+    const streamOrEffect = isFork ? result.value : result;
+    let responded = false;
+    let effect = Effect.uninterruptible(Effect.matchCauseEffect(Effect.interruptible(applyMiddleware(rpc, context, request.payload, request.headers, isStream ? streamEffect(client, request, streamOrEffect) : streamOrEffect)), {
+      onSuccess: value => {
+        responded = true;
+        return options.onFromServer({
+          _tag: "Exit",
+          clientId: client.id,
+          requestId: request.id,
+          exit: Exit.succeed(value)
+        });
+      },
+      onFailure: cause => {
+        responded = true;
+        return options.onFromServer({
+          _tag: "Exit",
+          clientId: client.id,
+          requestId: request.id,
+          exit: Exit.failCause(cause)
+        });
+      }
+    }));
+    if (enableTracing) {
+      const parentSpan = requestFiber.currentContext.unsafeMap.get(Tracer.ParentSpan.key);
+      effect = Effect.withSpan(effect, `${spanPrefix}.${request.tag}`, {
+        captureStackTrace: false,
+        parent: enableSpanPropagation ? {
+          _tag: "ExternalSpan",
+          traceId: request.traceId,
+          spanId: request.spanId,
+          sampled: request.sampled,
+          context: Context.empty()
+        } : undefined,
+        links: enableSpanPropagation && parentSpan ? [{
+          _tag: "SpanLink",
+          span: parentSpan,
+          attributes: {}
+        }] : undefined
+      });
+    }
+    if (!isFork && concurrencySemaphore) {
+      effect = concurrencySemaphore.withPermits(1)(effect);
+    }
+    const runtime = Runtime.make({
+      context: Context.merge(entry.context, requestFiber.currentContext),
+      fiberRefs: requestFiber.getFiberRefs(),
+      runtimeFlags: Runtime.defaultRuntime.runtimeFlags
+    });
+    const fiber = Runtime.runFork(runtime, effect);
+    FiberSet.unsafeAdd(fiberSet, fiber);
+    client.fibers.set(request.id, fiber);
+    fiber.addObserver(exit => {
+      if (!responded && exit._tag === "Failure") {
+        FiberSet.unsafeAdd(fiberSet, Runtime.runFork(runtime, options.onFromServer({
+          _tag: "Exit",
+          clientId: client.id,
+          requestId: request.id,
+          exit: Exit.interrupt(FiberId.none)
+        })));
+      }
+      client.fibers.delete(request.id);
+      client.latches.delete(request.id);
+      if (client.ended && client.fibers.size === 0) {
+        FiberSet.unsafeAdd(fiberSet, Runtime.runFork(runtime, endClient(client)));
+      }
+    });
+    return Effect.void;
+  };
+  const streamEffect = (client, request, stream) => {
+    let latch = client.latches.get(request.id);
+    if (supportsAck && !latch) {
+      latch = Effect.unsafeMakeLatch(false);
+      client.latches.set(request.id, latch);
+    }
+    if (Effect.isEffect(stream)) {
+      let done = false;
+      return stream.pipe(Effect.flatMap(mailbox => Effect.whileLoop({
+        while: () => !done,
+        body: (0, _Function.constant)(Effect.flatMap(mailbox.takeAll, ([chunk, done_]) => {
+          done = done_;
+          if (!Chunk.isNonEmpty(chunk)) return Effect.void;
+          const write = options.onFromServer({
+            _tag: "Chunk",
+            clientId: client.id,
+            requestId: request.id,
+            values: Chunk.toReadonlyArray(chunk)
+          });
+          if (!latch) return write;
+          latch.unsafeClose();
+          return Effect.zipRight(write, latch.await);
+        })),
+        step: _Function.constVoid
+      })), Effect.scoped);
+    }
+    return Stream.runForEachChunk(stream, chunk => {
+      if (!Chunk.isNonEmpty(chunk)) return Effect.void;
+      const write = options.onFromServer({
+        _tag: "Chunk",
+        clientId: client.id,
+        requestId: request.id,
+        values: Chunk.toReadonlyArray(chunk)
+      });
+      if (!latch) return write;
+      latch.unsafeClose();
+      return Effect.zipRight(write, latch.await);
+    });
+  };
+  const sendDefect = (client, defect) => Effect.suspend(() => {
+    const shouldEnd = client.ended && client.fibers.size === 0;
+    const write = options.onFromServer({
+      _tag: "Defect",
+      clientId: client.id,
+      defect
+    });
+    if (!shouldEnd) return write;
+    return Effect.zipRight(write, endClient(client));
+  });
+  return (0, _Function.identity)({
+    write,
+    disconnect
+  });
+});
+const applyMiddleware = (rpc, context, payload, headers, handler) => {
+  if (rpc.middlewares.size === 0) {
+    return handler;
+  }
+  const options = {
+    rpc,
+    payload,
+    headers
+  };
+  for (const tag of rpc.middlewares) {
+    const middleware = Context.unsafeGet(context, tag);
+    if (tag.optional) {
+      const previous = handler;
+      handler = Effect.matchEffect(middleware(options), {
+        onFailure: () => previous,
+        onSuccess: tag.provides !== undefined ? value => Effect.provideService(previous, tag.provides, value) : _ => previous
+      });
+    } else {
+      handler = tag.provides !== undefined ? Effect.provideServiceEffect(handler, tag.provides, middleware(options)) : Effect.zipRight(middleware(options), handler);
+    }
+  }
+  return handler;
+};
+/**
+ * @since 1.0.0
+ * @category server
+ */
+const make = exports.make = /*#__PURE__*/Effect.fnUntraced(function* (group, options) {
+  const {
+    disconnects,
+    end,
+    run,
+    send,
+    supportsAck,
+    supportsSpanPropagation,
+    supportsTransferables
+  } = yield* Protocol;
+  const context = yield* Effect.context();
+  const scope = yield* Scope.make();
+  const server = yield* makeNoSerialization(group, {
+    ...options,
+    disableClientAcks: !supportsAck,
+    disableSpanPropagation: !supportsSpanPropagation,
+    onFromServer(response) {
+      const client = clients.get(response.clientId);
+      if (!client) return Effect.void;
+      switch (response._tag) {
+        case "Chunk":
+          {
+            const schemas = client.schemas.get(response.requestId);
+            if (!schemas) return Effect.void;
+            return handleEncode(client, response.requestId, schemas.collector, Effect.provide(schemas.encodeChunk(response.values), schemas.context), values => ({
+              _tag: "Chunk",
+              requestId: response.requestId,
+              values
+            }));
+          }
+        case "Exit":
+          {
+            const schemas = client.schemas.get(response.requestId);
+            if (!schemas) return Effect.void;
+            client.schemas.delete(response.requestId);
+            return handleEncode(client, response.requestId, schemas.collector, Effect.provide(schemas.encodeExit(response.exit), schemas.context), exit => ({
+              _tag: "Exit",
+              requestId: response.requestId,
+              exit
+            }));
+          }
+        case "Defect":
+          {
+            return sendDefect(client, response.defect);
+          }
+        case "ClientEnd":
+          {
+            clients.delete(response.clientId);
+            return end(response.clientId);
+          }
+      }
+    }
+  }).pipe(Scope.extend(scope));
+  // handle disconnects
+  yield* Effect.fork(Effect.interruptible(Effect.whileLoop({
+    while: _Function.constTrue,
+    body: (0, _Function.constant)(Effect.flatMap(disconnects.take, clientId => {
+      clients.delete(clientId);
+      return server.disconnect(clientId);
+    })),
+    step: _Function.constVoid
+  })));
+  const schemasCache = new WeakMap();
+  const getSchemas = rpc => {
+    let schemas = schemasCache.get(rpc);
+    if (!schemas) {
+      const entry = context.unsafeMap.get(rpc.key);
+      const streamSchemas = RpcSchema.getStreamSchemas(rpc.successSchema.ast);
+      const failures = new Set([rpc.errorSchema]);
+      if (Option.isSome(streamSchemas)) {
+        failures.add(streamSchemas.value.failure);
+      }
+      for (const middleware of rpc.middlewares) {
+        failures.add(middleware.failure);
+      }
+      schemas = {
+        decode: Schema.decodeUnknown(rpc.payloadSchema),
+        encodeChunk: Schema.encodeUnknown(Schema.Array(Option.isSome(streamSchemas) ? streamSchemas.value.success : Schema.Any)),
+        encodeExit: Schema.encodeUnknown(Rpc.exitSchema(rpc)),
+        context: entry.context
+      };
+      schemasCache.set(rpc, schemas);
+    }
+    return schemas;
+  };
+  const clients = new Map();
+  const handleEncode = (client, requestId, collector, effect, onSuccess) => (collector ? Effect.provideService(effect, Transferable.Collector, collector) : effect).pipe(Effect.flatMap(a => send(client.id, onSuccess(a), collector && collector.unsafeClear())), Effect.catchAllCause(cause => {
+    client.schemas.delete(requestId);
+    const defect = Cause.squash(Cause.map(cause, _ParseResult.ArrayFormatter.formatErrorSync));
+    return Effect.zipRight(server.write(client.id, {
+      _tag: "Interrupt",
+      requestId,
+      interruptors: []
+    }), sendRequestDefect(client, requestId, defect));
+  }));
+  const sendRequestDefect = (client, requestId, defect) => Effect.catchAllCause(send(client.id, {
+    _tag: "Exit",
+    requestId,
+    exit: {
+      _tag: "Failure",
+      cause: {
+        _tag: "Die",
+        defect
+      }
+    }
+  }), cause => sendDefect(client, Cause.squash(cause)));
+  const sendDefect = (client, defect) => Effect.catchAllCause(send(client.id, {
+    _tag: "Defect",
+    defect
+  }), cause => Effect.annotateLogs(Effect.logDebug(cause), {
+    module: "RpcServer",
+    method: "sendDefect"
+  }));
+  // main server loop
+  return yield* run((clientId, request) => {
+    let client = clients.get(clientId);
+    if (!client) {
+      client = {
+        id: clientId,
+        schemas: new Map()
+      };
+      clients.set(clientId, client);
+    }
+    switch (request._tag) {
+      case "Request":
+        {
+          const tag = Predicate.hasProperty(request, "tag") ? request.tag : "";
+          const rpc = group.requests.get(tag);
+          if (!rpc) {
+            return sendDefect(client, `Unknown request tag: ${tag}`);
+          }
+          let requestId;
+          switch (typeof request.id) {
+            case "bigint":
+            case "string":
+              {
+                requestId = (0, _RpcMessage.RequestId)(request.id);
+                break;
+              }
+            default:
+              {
+                return sendDefect(client, `Invalid request id: ${request.id}`);
+              }
+          }
+          const schemas = getSchemas(rpc);
+          return Effect.matchEffect(Effect.provide(schemas.decode(request.payload), schemas.context), {
+            onFailure: error => sendRequestDefect(client, requestId, _ParseResult.ArrayFormatter.formatErrorSync(error)),
+            onSuccess: payload => {
+              client.schemas.set(requestId, supportsTransferables ? {
+                ...schemas,
+                collector: Transferable.unsafeMakeCollector()
+              } : schemas);
+              return server.write(clientId, {
+                ...request,
+                id: requestId,
+                payload,
+                headers: Headers.fromInput(request.headers)
+              });
+            }
+          });
+        }
+      case "Ping":
+        {
+          return Effect.catchAllCause(send(client.id, _RpcMessage.constPong), cause => sendDefect(client, Cause.squash(cause)));
+        }
+      case "Ack":
+      case "Eof":
+      case "Interrupt":
+        {
+          if ("requestId" in request && typeof request.requestId === "string") {
+            ;
+            request.requestId = BigInt(request.requestId);
+          }
+          return server.write(clientId, request._tag === "Interrupt" ? {
+            ...request,
+            interruptors: []
+          } : request);
+        }
+      default:
+        {
+          return sendDefect(client, `Unknown request tag: ${request._tag}`);
+        }
+    }
+  }).pipe(Effect.interruptible, Effect.tapErrorCause(cause => Effect.logFatal("BUG: RpcServer protocol crashed", cause)), Effect.onExit(exit => Scope.close(scope, exit)));
+});
+/**
+ * @since 1.0.0
+ * @category server
+ */
+const layer = (group, options) => Layer.scopedDiscard(Effect.forkScoped(Effect.interruptible(make(group, options))));
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+exports.layer = layer;
+class Protocol extends /*#__PURE__*/Context.Tag("@effect/rpc/RpcServer/Protocol")() {
+  /**
+   * @since 1.0.0
+   */
+  static make = /*#__PURE__*/(0, _utils.withRun)();
+}
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+exports.Protocol = Protocol;
+const makeProtocolSocketServer = exports.makeProtocolSocketServer = /*#__PURE__*/Effect.gen(function* () {
+  const server = yield* SocketServer.SocketServer;
+  const {
+    onSocket,
+    protocol
+  } = yield* makeSocketProtocol;
+  yield* Effect.forkScoped(Effect.interruptible(server.run(Effect.fnUntraced(onSocket, Effect.scoped))));
+  return protocol;
+});
+/**
+ * A rpc protocol that uses `SocketServer` for communication.
+ *
+ * @since 1.0.0
+ * @category protocol
+ */
+const layerProtocolSocketServer = exports.layerProtocolSocketServer = /*#__PURE__*/Layer.scoped(Protocol, makeProtocolSocketServer);
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+const makeProtocolWithHttpAppWebsocket = exports.makeProtocolWithHttpAppWebsocket = /*#__PURE__*/Effect.gen(function* () {
+  const {
+    onSocket,
+    protocol
+  } = yield* makeSocketProtocol;
+  const httpApp = Effect.gen(function* () {
+    const request = yield* HttpServerRequest.HttpServerRequest;
+    const socket = yield* Effect.orDie(request.upgrade);
+    yield* onSocket(socket);
+    return HttpServerResponse.empty();
+  });
+  return {
+    protocol,
+    httpApp
+  };
+});
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+const makeProtocolWebsocket = exports.makeProtocolWebsocket = /*#__PURE__*/Effect.fnUntraced(function* (options) {
+  const {
+    httpApp,
+    protocol
+  } = yield* makeProtocolWithHttpAppWebsocket;
+  const router = yield* options.routerTag ?? HttpRouter.Default;
+  yield* router.get(options.path, httpApp);
+  return protocol;
+});
+/**
+ * A rpc protocol that uses websockets for communication.
+ *
+ * @since 1.0.0
+ * @category protocol
+ */
+const layerProtocolWebsocket = options => {
+  const routerTag = options.routerTag ?? HttpRouter.Default;
+  return Layer.effect(Protocol, makeProtocolWebsocket(options)).pipe(Layer.provide(routerTag.Live));
+};
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+exports.layerProtocolWebsocket = layerProtocolWebsocket;
+const makeProtocolWithHttpApp = exports.makeProtocolWithHttpApp = /*#__PURE__*/Effect.gen(function* () {
+  const serialization = yield* RpcSerialization.RpcSerialization;
+  const isJson = serialization.contentType === "application/json";
+  const disconnects = yield* Mailbox.make();
+  let writeRequest;
+  let clientId = 0;
+  const clients = new Map();
+  const httpApp = Effect.gen(function* () {
+    const request = yield* HttpServerRequest.HttpServerRequest;
+    const data = yield* Effect.orDie(request.arrayBuffer);
+    const id = clientId++;
+    const mailbox = yield* Mailbox.make();
+    const parser = serialization.unsafeMake();
+    const encoder = new TextEncoder();
+    const offer = data => typeof data === "string" ? mailbox.offer(encoder.encode(data)) : mailbox.offer(data);
+    clients.set(id, {
+      write: response => {
+        try {
+          if (!serialization.supportsBigInt) {
+            transformBigInt(response);
+          }
+          return isJson ? mailbox.offer(response) : offer(parser.encode(response));
+        } catch (cause) {
+          return isJson ? mailbox.offer((0, _RpcMessage.ResponseDefectEncoded)(cause)) : offer(parser.encode((0, _RpcMessage.ResponseDefectEncoded)(cause)));
+        }
+      },
+      end: mailbox.end
+    });
+    const requestIds = [];
+    try {
+      const decoded = parser.decode(new Uint8Array(data));
+      for (const message of decoded) {
+        if (message._tag === "Request") {
+          requestIds.push((0, _RpcMessage.RequestId)(message.id));
+        }
+        yield* writeRequest(id, message);
+      }
+    } catch (cause) {
+      yield* offer(parser.encode((0, _RpcMessage.ResponseDefectEncoded)(cause)));
+    }
+    yield* writeRequest(id, _RpcMessage.constEof);
+    if (isJson) {
+      let done = false;
+      yield* Effect.addFinalizer(() => {
+        clients.delete(id);
+        disconnects.unsafeOffer(id);
+        if (done) return Effect.void;
+        return Effect.forEach(requestIds, requestId => writeRequest(id, {
+          _tag: "Interrupt",
+          requestId
+        }), {
+          discard: true
+        });
+      });
+      const responses = Arr.empty();
+      while (true) {
+        const [items, done] = yield* mailbox.takeAll;
+        // eslint-disable-next-line no-restricted-syntax
+        responses.push(...items);
+        if (done) break;
+      }
+      done = true;
+      return HttpServerResponse.unsafeJson(responses);
+    }
+    return HttpServerResponse.stream(Stream.ensuringWith(Mailbox.toStream(mailbox), exit => {
+      clients.delete(id);
+      disconnects.unsafeOffer(id);
+      if (!Exit.isInterrupted(exit)) return Effect.void;
+      return Effect.forEach(requestIds, requestId => writeRequest(id, {
+        _tag: "Interrupt",
+        requestId
+      }), {
+        discard: true
+      });
+    }), {
+      contentType: serialization.contentType
+    });
+  }).pipe(Effect.interruptible);
+  const protocol = yield* Protocol.make(writeRequest_ => {
+    writeRequest = writeRequest_;
+    return Effect.succeed({
+      disconnects,
+      send: (clientId, response) => {
+        const client = clients.get(clientId);
+        if (!client) return Effect.void;
+        return client.write(response);
+      },
+      end(clientId) {
+        const client = clients.get(clientId);
+        if (!client) return Effect.void;
+        return client.end;
+      },
+      initialMessage: Effect.succeedNone,
+      supportsAck: false,
+      supportsTransferables: false,
+      supportsSpanPropagation: false
+    });
+  });
+  return {
+    protocol,
+    httpApp
+  };
+});
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+const makeProtocolHttp = exports.makeProtocolHttp = /*#__PURE__*/Effect.fnUntraced(function* (options) {
+  const {
+    httpApp,
+    protocol
+  } = yield* makeProtocolWithHttpApp;
+  const router = yield* options.routerTag ?? HttpRouter.Default;
+  yield* router.post(options.path, httpApp);
+  return protocol;
+});
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+const makeProtocolWorkerRunner = exports.makeProtocolWorkerRunner = /*#__PURE__*/Protocol.make( /*#__PURE__*/Effect.fnUntraced(function* (writeRequest) {
+  const fiber = yield* Effect.withFiberRuntime(Effect.succeed);
+  const runner = yield* WorkerRunner.PlatformRunner;
+  const closeLatch = yield* WorkerRunner.CloseLatch;
+  const backing = yield* runner.start(closeLatch);
+  const initialMessage = yield* Deferred.make();
+  yield* Deferred.await(closeLatch).pipe(Effect.onExit(() => {
+    fiber.currentScheduler.scheduleTask(() => fiber.unsafeInterruptAsFork(fiber.id()), 0);
+    return Effect.void;
+  }), Effect.forkScoped);
+  yield* backing.run((clientId, message) => {
+    if (message._tag === "InitialMessage") {
+      return Deferred.succeed(initialMessage, message.value);
+    }
+    return writeRequest(clientId, message);
+  });
+  return {
+    disconnects: backing.disconnects ?? (yield* Mailbox.make()),
+    send: backing.send,
+    end(_clientId) {
+      return Effect.void;
+    },
+    initialMessage: Effect.asSome(Deferred.await(initialMessage)),
+    supportsAck: true,
+    supportsTransferables: true,
+    supportsSpanPropagation: true
+  };
+}));
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+const layerProtocolWorkerRunner = exports.layerProtocolWorkerRunner = /*#__PURE__*/Layer.scoped(Protocol, makeProtocolWorkerRunner);
+/**
+ * A rpc protocol that uses streaming http for communication.
+ *
+ * @since 1.0.0
+ * @category protocol
+ */
+const layerProtocolHttp = options => {
+  const routerTag = options.routerTag ?? HttpRouter.Default;
+  return Layer.effect(Protocol, makeProtocolHttp(options)).pipe(Layer.provide(routerTag.Live));
+};
+/**
+ * @since 1.0.0
+ * @category http app
+ */
+exports.layerProtocolHttp = layerProtocolHttp;
+const toHttpApp = exports.toHttpApp = /*#__PURE__*/Effect.fnUntraced(function* (group, options) {
+  const {
+    httpApp,
+    protocol
+  } = yield* makeProtocolWithHttpApp;
+  yield* make(group, options).pipe(Effect.provideService(Protocol, protocol), Effect.interruptible, Effect.forkScoped);
+  return httpApp;
+});
+/**
+ * @since 1.0.0
+ * @category http app
+ */
+const toHttpAppWebsocket = exports.toHttpAppWebsocket = /*#__PURE__*/Effect.fnUntraced(function* (group, options) {
+  const {
+    httpApp,
+    protocol
+  } = yield* makeProtocolWithHttpAppWebsocket;
+  yield* make(group, options).pipe(Effect.provideService(Protocol, protocol), Effect.interruptible, Effect.forkScoped);
+  return httpApp;
+});
+/**
+ * Construct an http web handler from an `RpcGroup`.
+ *
+ * @since 1.0.0
+ * @category constructors
+ */
+const toWebHandler = (group, options) => {
+  const runtime = ManagedRuntime.make(Layer.mergeAll(options.layer, Layer.scope), options?.memoMap);
+  let handlerCached;
+  const handlerPromise = Effect.gen(function* () {
+    const app = yield* toHttpApp(group, options);
+    const rt = yield* runtime.runtimeEffect;
+    const handler = HttpApp.toWebHandlerRuntime(rt)(options?.middleware ? options.middleware(app) : app);
+    handlerCached = handler;
+    return handler;
+  }).pipe(runtime.runPromise);
+  function handler(request, context) {
+    if (handlerCached !== undefined) {
+      return handlerCached(request, context);
+    }
+    return handlerPromise.then(handler => handler(request, context));
+  }
+  return {
+    handler,
+    dispose: runtime.dispose
+  };
+};
+// internal
+exports.toWebHandler = toWebHandler;
+const makeSocketProtocol = /*#__PURE__*/Effect.gen(function* () {
+  const serialization = yield* RpcSerialization.RpcSerialization;
+  const disconnects = yield* Mailbox.make();
+  let clientId = 0;
+  const clients = new Map();
+  let writeRequest;
+  const onSocket = function* (socket) {
+    const scope = yield* Effect.scope;
+    const parser = serialization.unsafeMake();
+    const id = clientId++;
+    yield* Scope.addFinalizerExit(scope, () => {
+      clients.delete(id);
+      return disconnects.offer(id);
+    });
+    const writeRaw = yield* socket.writer;
+    const write = response => {
+      try {
+        if (!serialization.supportsBigInt) {
+          transformBigInt(response);
+        }
+        return Effect.orDie(writeRaw(parser.encode(response)));
+      } catch (cause) {
+        return Effect.orDie(writeRaw(parser.encode((0, _RpcMessage.ResponseDefectEncoded)(cause))));
+      }
+    };
+    clients.set(id, {
+      write
+    });
+    yield* Effect.orDie(Effect.interruptible(socket.runRaw(data => {
+      try {
+        const decoded = parser.decode(data);
+        if (decoded.length === 0) return Effect.void;
+        let i = 0;
+        return Effect.whileLoop({
+          while: () => i < decoded.length,
+          body: () => writeRequest(id, decoded[i++]),
+          step: _Function.constVoid
+        });
+      } catch (cause) {
+        return writeRaw(parser.encode((0, _RpcMessage.ResponseDefectEncoded)(cause)));
+      }
+    })));
+  };
+  const protocol = yield* Protocol.make(writeRequest_ => {
+    writeRequest = writeRequest_;
+    return Effect.succeed({
+      disconnects,
+      send: (clientId, response) => {
+        const client = clients.get(clientId);
+        if (!client) return Effect.void;
+        return Effect.orDie(client.write(response));
+      },
+      end(_clientId) {
+        return Effect.void;
+      },
+      initialMessage: Effect.succeedNone,
+      supportsAck: true,
+      supportsTransferables: false,
+      supportsSpanPropagation: true
+    });
+  });
+  return {
+    protocol,
+    onSocket
+  };
+});
+const transformBigInt = response => {
+  if ("requestId" in response) {
+    ;
+    response.requestId = response.requestId.toString();
+  }
+};
+//# sourceMappingURL=RpcServer.js.map
\ No newline at end of file
diff --git a/dist/cjs/RpcServer.js.map b/dist/cjs/RpcServer.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..307b16b75e57efdb786162d4140a1054ecbb0a2b
--- /dev/null
+++ b/dist/cjs/RpcServer.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"RpcServer.js","names":["Headers","_interopRequireWildcard","require","HttpApp","HttpRouter","HttpServerRequest","HttpServerResponse","SocketServer","Transferable","WorkerRunner","Arr","Cause","Chunk","Context","Deferred","Effect","Exit","Fiber","FiberId","FiberSet","_Function","Layer","Mailbox","ManagedRuntime","Option","_ParseResult","Predicate","Runtime","Schema","Scope","Stream","Tracer","_utils","Rpc","_RpcMessage","RpcSchema","RpcSerialization","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","makeNoSerialization","exports","fnUntraced","group","options","enableTracing","disableTracing","enableSpanPropagation","disableSpanPropagation","supportsAck","disableClientAcks","spanPrefix","concurrency","context","scope","fiberSet","make","runFork","runtime","pipe","interruptible","concurrencySemaphore","undefined","makeSemaphore","clients","Map","isShutdown","shutdownLatch","unsafeMakeLatch","addFinalizer","fiberIdWith","fiberId","client","values","ended","fibers","size","endClient","fiber","unsafeInterruptAsFork","void","await","disconnect","clientId","delete","write","message","catchAllDefect","withFiberRuntime","requestFiber","interrupt","id","latches","_tag","handleRequest","latch","requestId","open","interruptFork","onFromServer","exit","none","sendDefect","defect","zipRight","request","rpc","requests","tag","entry","unsafeMap","key","die","isStream","isStreamSchema","successSchema","result","handler","payload","headers","isFork","streamOrEffect","value","responded","effect","uninterruptible","matchCauseEffect","applyMiddleware","streamEffect","onSuccess","succeed","onFailure","cause","failCause","parentSpan","currentContext","ParentSpan","withSpan","captureStackTrace","parent","traceId","spanId","sampled","empty","links","span","attributes","withPermits","merge","fiberRefs","getFiberRefs","runtimeFlags","defaultRuntime","unsafeAdd","addObserver","stream","isEffect","done","flatMap","mailbox","whileLoop","while","body","constant","takeAll","chunk","done_","isNonEmpty","toReadonlyArray","unsafeClose","step","constVoid","scoped","runForEachChunk","suspend","shouldEnd","identity","middlewares","middleware","unsafeGet","optional","previous","matchEffect","provides","provideService","_","provideServiceEffect","disconnects","end","run","send","supportsSpanPropagation","supportsTransferables","Protocol","server","response","schemas","handleEncode","collector","provide","encodeChunk","encodeExit","extend","fork","constTrue","take","schemasCache","getSchemas","streamSchemas","getStreamSchemas","ast","failures","Set","errorSchema","isSome","add","failure","decode","decodeUnknown","payloadSchema","encodeUnknown","Array","success","Any","exitSchema","Collector","unsafeClear","catchAllCause","squash","map","ArrayFormatter","formatErrorSync","interruptors","sendRequestDefect","annotateLogs","logDebug","module","method","hasProperty","RequestId","error","unsafeMakeCollector","fromInput","constPong","BigInt","tapErrorCause","logFatal","onExit","close","layer","scopedDiscard","forkScoped","Tag","withRun","makeProtocolSocketServer","gen","onSocket","protocol","makeSocketProtocol","layerProtocolSocketServer","makeProtocolWithHttpAppWebsocket","httpApp","socket","orDie","upgrade","makeProtocolWebsocket","router","routerTag","Default","path","layerProtocolWebsocket","Live","makeProtocolWithHttpApp","serialization","isJson","contentType","writeRequest","data","arrayBuffer","parser","unsafeMake","encoder","TextEncoder","offer","encode","supportsBigInt","transformBigInt","ResponseDefectEncoded","requestIds","decoded","Uint8Array","push","constEof","unsafeOffer","forEach","discard","responses","items","unsafeJson","ensuringWith","toStream","isInterrupted","writeRequest_","initialMessage","succeedNone","makeProtocolHttp","post","makeProtocolWorkerRunner","runner","PlatformRunner","closeLatch","CloseLatch","backing","start","currentScheduler","scheduleTask","_clientId","asSome","layerProtocolWorkerRunner","layerProtocolHttp","toHttpApp","toHttpAppWebsocket","toWebHandler","mergeAll","memoMap","handlerCached","handlerPromise","app","rt","runtimeEffect","toWebHandlerRuntime","runPromise","then","dispose","addFinalizerExit","writeRaw","writer","runRaw","length","toString"],"sources":["../../src/RpcServer.ts"],"sourcesContent":[null],"mappings":";;;;;;AAGA,IAAAA,OAAA,GAAAC,uBAAA,CAAAC,OAAA;AACA,IAAAC,OAAA,GAAAF,uBAAA,CAAAC,OAAA;AACA,IAAAE,UAAA,GAAAH,uBAAA,CAAAC,OAAA;AACA,IAAAG,iBAAA,GAAAJ,uBAAA,CAAAC,OAAA;AACA,IAAAI,kBAAA,GAAAL,uBAAA,CAAAC,OAAA;AAEA,IAAAK,YAAA,GAAAN,uBAAA,CAAAC,OAAA;AACA,IAAAM,YAAA,GAAAP,uBAAA,CAAAC,OAAA;AAEA,IAAAO,YAAA,GAAAR,uBAAA,CAAAC,OAAA;AAEA,IAAAQ,GAAA,GAAAT,uBAAA,CAAAC,OAAA;AACA,IAAAS,KAAA,GAAAV,uBAAA,CAAAC,OAAA;AACA,IAAAU,KAAA,GAAAX,uBAAA,CAAAC,OAAA;AACA,IAAAW,OAAA,GAAAZ,uBAAA,CAAAC,OAAA;AACA,IAAAY,QAAA,GAAAb,uBAAA,CAAAC,OAAA;AACA,IAAAa,MAAA,GAAAd,uBAAA,CAAAC,OAAA;AACA,IAAAc,IAAA,GAAAf,uBAAA,CAAAC,OAAA;AACA,IAAAe,KAAA,GAAAhB,uBAAA,CAAAC,OAAA;AACA,IAAAgB,OAAA,GAAAjB,uBAAA,CAAAC,OAAA;AACA,IAAAiB,QAAA,GAAAlB,uBAAA,CAAAC,OAAA;AACA,IAAAkB,SAAA,GAAAlB,OAAA;AACA,IAAAmB,KAAA,GAAApB,uBAAA,CAAAC,OAAA;AACA,IAAAoB,OAAA,GAAArB,uBAAA,CAAAC,OAAA;AACA,IAAAqB,cAAA,GAAAtB,uBAAA,CAAAC,OAAA;AACA,IAAAsB,MAAA,GAAAvB,uBAAA,CAAAC,OAAA;AACA,IAAAuB,YAAA,GAAAvB,OAAA;AACA,IAAAwB,SAAA,GAAAzB,uBAAA,CAAAC,OAAA;AACA,IAAAyB,OAAA,GAAA1B,uBAAA,CAAAC,OAAA;AACA,IAAA0B,MAAA,GAAA3B,uBAAA,CAAAC,OAAA;AACA,IAAA2B,KAAA,GAAA5B,uBAAA,CAAAC,OAAA;AACA,IAAA4B,MAAA,GAAA7B,uBAAA,CAAAC,OAAA;AACA,IAAA6B,MAAA,GAAA9B,uBAAA,CAAAC,OAAA;AACA,IAAA8B,MAAA,GAAA9B,OAAA;AACA,IAAA+B,GAAA,GAAAhC,uBAAA,CAAAC,OAAA;AAEA,IAAAgC,WAAA,GAAAhC,OAAA;AAWA,IAAAiC,SAAA,GAAAlC,uBAAA,CAAAC,OAAA;AACA,IAAAkC,gBAAA,GAAAnC,uBAAA,CAAAC,OAAA;AAAyD,SAAAmC,yBAAAC,CAAA,6BAAAC,OAAA,mBAAAC,CAAA,OAAAD,OAAA,IAAAE,CAAA,OAAAF,OAAA,YAAAF,wBAAA,YAAAA,CAAAC,CAAA,WAAAA,CAAA,GAAAG,CAAA,GAAAD,CAAA,KAAAF,CAAA;AAAA,SAAArC,wBAAAqC,CAAA,EAAAE,CAAA,SAAAA,CAAA,IAAAF,CAAA,IAAAA,CAAA,CAAAI,UAAA,SAAAJ,CAAA,eAAAA,CAAA,uBAAAA,CAAA,yBAAAA,CAAA,WAAAK,OAAA,EAAAL,CAAA,QAAAG,CAAA,GAAAJ,wBAAA,CAAAG,CAAA,OAAAC,CAAA,IAAAA,CAAA,CAAAG,GAAA,CAAAN,CAAA,UAAAG,CAAA,CAAAI,GAAA,CAAAP,CAAA,OAAAQ,CAAA,KAAAC,SAAA,UAAAC,CAAA,GAAAC,MAAA,CAAAC,cAAA,IAAAD,MAAA,CAAAE,wBAAA,WAAAC,CAAA,IAAAd,CAAA,oBAAAc,CAAA,OAAAC,cAAA,CAAAC,IAAA,CAAAhB,CAAA,EAAAc,CAAA,SAAAG,CAAA,GAAAP,CAAA,GAAAC,MAAA,CAAAE,wBAAA,CAAAb,CAAA,EAAAc,CAAA,UAAAG,CAAA,KAAAA,CAAA,CAAAV,GAAA,IAAAU,CAAA,CAAAC,GAAA,IAAAP,MAAA,CAAAC,cAAA,CAAAJ,CAAA,EAAAM,CAAA,EAAAG,CAAA,IAAAT,CAAA,CAAAM,CAAA,IAAAd,CAAA,CAAAc,CAAA,YAAAN,CAAA,CAAAH,OAAA,GAAAL,CAAA,EAAAG,CAAA,IAAAA,CAAA,CAAAe,GAAA,CAAAlB,CAAA,EAAAQ,CAAA,GAAAA,CAAA;AAnDzD;;;;AA+DA;;;;AAIO,MAAMW,mBAAmB,GAAAC,OAAA,CAAAD,mBAAA,gBAc5B1C,MAAM,CAAC4C,UAAU,CAAC,WACpBC,KAA8B,EAC9BC,OAOC;EAED,MAAMC,aAAa,GAAGD,OAAO,CAACE,cAAc,KAAK,IAAI;EACrD,MAAMC,qBAAqB,GAAGH,OAAO,CAACI,sBAAsB,KAAK,IAAI;EACrE,MAAMC,WAAW,GAAGL,OAAO,CAACM,iBAAiB,KAAK,IAAI;EACtD,MAAMC,UAAU,GAAGP,OAAO,CAACO,UAAU,IAAI,WAAW;EACpD,MAAMC,WAAW,GAAGR,OAAO,CAACQ,WAAW,IAAI,WAAW;EACtD,MAAMC,OAAO,GAAG,OAAOvD,MAAM,CAACuD,OAAO,EAAqC;EAC1E,MAAMC,KAAK,GAAG1D,OAAO,CAACgC,GAAG,CAACyB,OAAO,EAAEzC,KAAK,CAACA,KAAK,CAAC;EAC/C,MAAM2C,QAAQ,GAAG,OAAOrD,QAAQ,CAACsD,IAAI,EAAE;EACvC,MAAMC,OAAO,GAAG,OAAOvD,QAAQ,CAACwD,OAAO,CAACH,QAAQ,CAAC,EAAE,CAACI,IAAI,CACtD7D,MAAM,CAAC8D,aAAa,CACrB;EACD,MAAMC,oBAAoB,GAAGT,WAAW,KAAK,WAAW,GACpDU,SAAS,GACT,OAAOhE,MAAM,CAACiE,aAAa,CAACX,WAAW,CAAC;EAS5C,MAAMY,OAAO,GAAG,IAAIC,GAAG,EAAkB;EACzC,IAAIC,UAAU,GAAG,KAAK;EACtB,MAAMC,aAAa,GAAGrE,MAAM,CAACsE,eAAe,CAAC,KAAK,CAAC;EACnD,OAAOxD,KAAK,CAACyD,YAAY,CACvBf,KAAK,EACLxD,MAAM,CAACwE,WAAW,CAAEC,OAAO,IAAI;IAC7BL,UAAU,GAAG,IAAI;IACjB,KAAK,MAAMM,MAAM,IAAIR,OAAO,CAACS,MAAM,EAAE,EAAE;MACrCD,MAAM,CAACE,KAAK,GAAG,IAAI;MACnB,IAAIF,MAAM,CAACG,MAAM,CAACC,IAAI,KAAK,CAAC,EAAE;QAC5BnB,OAAO,CAACoB,SAAS,CAACL,MAAM,CAAC,CAAC;QAC1B;MACF;MACA,KAAK,MAAMM,KAAK,IAAIN,MAAM,CAACG,MAAM,CAACF,MAAM,EAAE,EAAE;QAC1CK,KAAK,CAACC,qBAAqB,CAACR,OAAO,CAAC;MACtC;IACF;IACA,IAAIP,OAAO,CAACY,IAAI,KAAK,CAAC,EAAE;MACtB,OAAO9E,MAAM,CAACkF,IAAI;IACpB;IACA,OAAOb,aAAa,CAACc,KAAK;EAC5B,CAAC,CAAC,CACH;EAED,MAAMC,UAAU,GAAIC,QAAgB,IAClCrF,MAAM,CAACwE,WAAW,CAAEC,OAAO,IAAI;IAC7B,MAAMC,MAAM,GAAGR,OAAO,CAACpC,GAAG,CAACuD,QAAQ,CAAC;IACpC,IAAI,CAACX,MAAM,EAAE,OAAO1E,MAAM,CAACkF,IAAI;IAC/B,KAAK,MAAMF,KAAK,IAAIN,MAAM,CAACG,MAAM,CAACF,MAAM,EAAE,EAAE;MAC1CK,KAAK,CAACC,qBAAqB,CAACR,OAAO,CAAC;IACtC;IACAP,OAAO,CAACoB,MAAM,CAACD,QAAQ,CAAC;IACxB,OAAOrF,MAAM,CAACkF,IAAI;EACpB,CAAC,CAAC;EAEJ,MAAMK,KAAK,GAAGA,CAACF,QAAgB,EAAEG,OAAyB,KACxDxF,MAAM,CAACyF,cAAc,CACnBzF,MAAM,CAAC0F,gBAAgB,CAAEC,YAAY,IAAI;IACvC,IAAIvB,UAAU,EAAE,OAAOpE,MAAM,CAAC4F,SAAS;IACvC,IAAIlB,MAAM,GAAGR,OAAO,CAACpC,GAAG,CAACuD,QAAQ,CAAC;IAClC,IAAI,CAACX,MAAM,EAAE;MACXA,MAAM,GAAG;QACPmB,EAAE,EAAER,QAAQ;QACZS,OAAO,EAAE,IAAI3B,GAAG,EAAE;QAClBU,MAAM,EAAE,IAAIV,GAAG,EAAE;QACjBS,KAAK,EAAE;OACR;MACDV,OAAO,CAACzB,GAAG,CAAC4C,QAAQ,EAAEX,MAAM,CAAC;IAC/B,CAAC,MAAM,IAAIA,MAAM,CAACE,KAAK,EAAE;MACvB,OAAO5E,MAAM,CAAC4F,SAAS;IACzB;IAEA,QAAQJ,OAAO,CAACO,IAAI;MAClB,KAAK,SAAS;QAAE;UACd,OAAOC,aAAa,CAACL,YAAY,EAAEjB,MAAM,EAAEc,OAAO,CAAC;QACrD;MACA,KAAK,KAAK;QAAE;UACV,MAAMS,KAAK,GAAGvB,MAAM,CAACoB,OAAO,CAAChE,GAAG,CAAC0D,OAAO,CAACU,SAAS,CAAC;UACnD,OAAOD,KAAK,GAAGA,KAAK,CAACE,IAAI,GAAGnG,MAAM,CAACkF,IAAI;QACzC;MACA,KAAK,WAAW;QAAE;UAChB,MAAMF,KAAK,GAAGN,MAAM,CAACG,MAAM,CAAC/C,GAAG,CAAC0D,OAAO,CAACU,SAAS,CAAC;UAClD,OAAOlB,KAAK,GAAG9E,KAAK,CAACkG,aAAa,CAACpB,KAAK,CAAC,GAAGlC,OAAO,CAACuD,YAAY,CAAC;YAC/DN,IAAI,EAAE,MAAM;YACZV,QAAQ;YACRa,SAAS,EAAEV,OAAO,CAACU,SAAS;YAC5BI,IAAI,EAAErG,IAAI,CAAC2F,SAAS,CAACzF,OAAO,CAACoG,IAAI;WAClC,CAAC;QACJ;MACA,KAAK,KAAK;QAAE;UACV7B,MAAM,CAACE,KAAK,GAAG,IAAI;UACnB,IAAIF,MAAM,CAACG,MAAM,CAACC,IAAI,GAAG,CAAC,EAAE,OAAO9E,MAAM,CAACkF,IAAI;UAC9C,OAAOH,SAAS,CAACL,MAAM,CAAC;QAC1B;MACA;QAAS;UACP,OAAO8B,UAAU,CAAC9B,MAAM,EAAE,wBAAyBc,OAAe,CAACO,IAAI,EAAE,CAAC;QAC5E;IACF;EACF,CAAC,CAAC,EACDU,MAAM,IAAKD,UAAU,CAACtC,OAAO,CAACpC,GAAG,CAACuD,QAAQ,CAAE,EAAEoB,MAAM,CAAC,CACvD;EAEH,MAAM1B,SAAS,GAAIL,MAAc,IAAI;IACnCR,OAAO,CAACoB,MAAM,CAACZ,MAAM,CAACmB,EAAE,CAAC;IACzB,MAAMN,KAAK,GAAGzC,OAAO,CAACuD,YAAY,CAAC;MACjCN,IAAI,EAAE,WAAW;MACjBV,QAAQ,EAAEX,MAAM,CAACmB;KAClB,CAAC;IACF,IAAIzB,UAAU,IAAIF,OAAO,CAACY,IAAI,KAAK,CAAC,EAAE;MACpC,OAAO9E,MAAM,CAAC0G,QAAQ,CAACnB,KAAK,EAAElB,aAAa,CAAC8B,IAAI,CAAC;IACnD;IACA,OAAOZ,KAAK;EACd,CAAC;EAED,MAAMS,aAAa,GAAGA,CACpBL,YAA0C,EAC1CjB,MAAc,EACdiC,OAAsB,KACC;IACvB,IAAIjC,MAAM,CAACG,MAAM,CAAChD,GAAG,CAAC8E,OAAO,CAACd,EAAE,CAAC,EAAE;MACjC,OAAO7F,MAAM,CAAC4F,SAAS;IACzB;IACA,MAAMgB,GAAG,GAAG/D,KAAK,CAACgE,QAAQ,CAAC/E,GAAG,CAAC6E,OAAO,CAACG,GAAG,CAA4B;IACtE,MAAMC,KAAK,GAAGxD,OAAO,CAACyD,SAAS,CAAClF,GAAG,CAAC8E,GAAG,EAAEK,GAAG,CAA8B;IAC1E,IAAI,CAACL,GAAG,IAAI,CAACG,KAAK,EAAE;MAClB,MAAMxB,KAAK,GAAGvF,MAAM,CAACyF,cAAc,CACjC3C,OAAO,CAACuD,YAAY,CAAC;QACnBN,IAAI,EAAE,MAAM;QACZV,QAAQ,EAAEX,MAAM,CAACmB,EAAE;QACnBK,SAAS,EAAES,OAAO,CAACd,EAAE;QACrBS,IAAI,EAAErG,IAAI,CAACiH,GAAG,CAAC,wBAAwBP,OAAO,CAACG,GAAG,EAAE;OACrD,CAAC,EACDL,MAAM,IAAKD,UAAU,CAAC9B,MAAM,EAAE+B,MAAM,CAAC,CACvC;MACD,IAAI,CAAC/B,MAAM,CAACE,KAAK,IAAIF,MAAM,CAACG,MAAM,CAACC,IAAI,GAAG,CAAC,EAAE,OAAOS,KAAK;MACzD,OAAOvF,MAAM,CAAC0G,QAAQ,CAACnB,KAAK,EAAER,SAAS,CAACL,MAAM,CAAC,CAAC;IAClD;IACA,MAAMyC,QAAQ,GAAG/F,SAAS,CAACgG,cAAc,CAACR,GAAG,CAACS,aAAa,CAAC;IAC5D,MAAMC,MAAM,GAAGP,KAAK,CAACQ,OAAO,CAACZ,OAAO,CAACa,OAAO,EAAEb,OAAO,CAACc,OAAO,CAAC;IAE9D;IACA,MAAMC,MAAM,GAAGxG,GAAG,CAACwG,MAAM,CAACJ,MAAM,CAAC;IACjC;IACA,MAAMK,cAAc,GAAGD,MAAM,GAAGJ,MAAM,CAACM,KAAK,GAAGN,MAAM;IAErD,IAAIO,SAAS,GAAG,KAAK;IACrB,IAAIC,MAAM,GAAG9H,MAAM,CAAC+H,eAAe,CAAC/H,MAAM,CAACgI,gBAAgB,CACzDhI,MAAM,CAAC8D,aAAa,CAACmE,eAAe,CAClCrB,GAAG,EACHrD,OAAO,EACPoD,OAAO,CAACa,OAAO,EACfb,OAAO,CAACc,OAAO,EACfN,QAAQ,GACJe,YAAY,CAACxD,MAAM,EAAEiC,OAAO,EAAEgB,cAAc,CAAC,GAC7CA,cAAoC,CACzC,CAAC,EACF;MACEQ,SAAS,EAAGP,KAAK,IAAI;QACnBC,SAAS,GAAG,IAAI;QAChB,OAAO/E,OAAO,CAACuD,YAAY,CAAC;UAC1BN,IAAI,EAAE,MAAM;UACZV,QAAQ,EAAEX,MAAM,CAACmB,EAAE;UACnBK,SAAS,EAAES,OAAO,CAACd,EAAE;UACrBS,IAAI,EAAErG,IAAI,CAACmI,OAAO,CAACR,KAAY;SAChC,CAAC;MACJ,CAAC;MACDS,SAAS,EAAGC,KAAK,IAAI;QACnBT,SAAS,GAAG,IAAI;QAChB,OAAO/E,OAAO,CAACuD,YAAY,CAAC;UAC1BN,IAAI,EAAE,MAAM;UACZV,QAAQ,EAAEX,MAAM,CAACmB,EAAE;UACnBK,SAAS,EAAES,OAAO,CAACd,EAAE;UACrBS,IAAI,EAAErG,IAAI,CAACsI,SAAS,CAACD,KAAK;SAC3B,CAAC;MACJ;KACD,CACF,CAAC;IACF,IAAIvF,aAAa,EAAE;MACjB,MAAMyF,UAAU,GAAG7C,YAAY,CAAC8C,cAAc,CAACzB,SAAS,CAAClF,GAAG,CAACd,MAAM,CAAC0H,UAAU,CAACzB,GAAG,CAA+B;MACjHa,MAAM,GAAG9H,MAAM,CAAC2I,QAAQ,CAACb,MAAM,EAAE,GAAGzE,UAAU,IAAIsD,OAAO,CAACG,GAAG,EAAE,EAAE;QAC/D8B,iBAAiB,EAAE,KAAK;QACxBC,MAAM,EAAE5F,qBAAqB,GAC3B;UACE8C,IAAI,EAAE,cAAc;UACpB+C,OAAO,EAAEnC,OAAO,CAACmC,OAAO;UACxBC,MAAM,EAAEpC,OAAO,CAACoC,MAAM;UACtBC,OAAO,EAAErC,OAAO,CAACqC,OAAO;UACxBzF,OAAO,EAAEzD,OAAO,CAACmJ,KAAK;SACvB,GACDjF,SAAS;QACXkF,KAAK,EAAEjG,qBAAqB,IAAIuF,UAAU,GACxC,CAAC;UACCzC,IAAI,EAAE,UAAU;UAChBoD,IAAI,EAAEX,UAAU;UAChBY,UAAU,EAAE;SACb,CAAC,GACFpF;OACH,CAAC;IACJ;IACA,IAAI,CAAC0D,MAAM,IAAI3D,oBAAoB,EAAE;MACnC+D,MAAM,GAAG/D,oBAAoB,CAACsF,WAAW,CAAC,CAAC,CAAC,CAACvB,MAAM,CAAC;IACtD;IACA,MAAMlE,OAAO,GAAGhD,OAAO,CAAC8C,IAAI,CAAC;MAC3BH,OAAO,EAAEzD,OAAO,CAACwJ,KAAK,CAACvC,KAAK,CAACxD,OAAO,EAAEoC,YAAY,CAAC8C,cAAc,CAAC;MAClEc,SAAS,EAAE5D,YAAY,CAAC6D,YAAY,EAAE;MACtCC,YAAY,EAAE7I,OAAO,CAAC8I,cAAc,CAACD;KACtC,CAAC;IACF,MAAMzE,KAAK,GAAGpE,OAAO,CAAC+C,OAAO,CAACC,OAAO,EAAEkE,MAAM,CAAC;IAC9C1H,QAAQ,CAACuJ,SAAS,CAAClG,QAAQ,EAAEuB,KAAK,CAAC;IACnCN,MAAM,CAACG,MAAM,CAACpC,GAAG,CAACkE,OAAO,CAACd,EAAE,EAAEb,KAAK,CAAC;IACpCA,KAAK,CAAC4E,WAAW,CAAEtD,IAAI,IAAI;MACzB,IAAI,CAACuB,SAAS,IAAIvB,IAAI,CAACP,IAAI,KAAK,SAAS,EAAE;QACzC3F,QAAQ,CAACuJ,SAAS,CAChBlG,QAAQ,EACR7C,OAAO,CAAC+C,OAAO,CACbC,OAAO,EACPd,OAAO,CAACuD,YAAY,CAAC;UACnBN,IAAI,EAAE,MAAM;UACZV,QAAQ,EAAEX,MAAM,CAACmB,EAAE;UACnBK,SAAS,EAAES,OAAO,CAACd,EAAE;UACrBS,IAAI,EAAErG,IAAI,CAAC2F,SAAS,CAACzF,OAAO,CAACoG,IAAI;SAClC,CAAC,CACH,CACF;MACH;MACA7B,MAAM,CAACG,MAAM,CAACS,MAAM,CAACqB,OAAO,CAACd,EAAE,CAAC;MAChCnB,MAAM,CAACoB,OAAO,CAACR,MAAM,CAACqB,OAAO,CAACd,EAAE,CAAC;MACjC,IAAInB,MAAM,CAACE,KAAK,IAAIF,MAAM,CAACG,MAAM,CAACC,IAAI,KAAK,CAAC,EAAE;QAC5C1E,QAAQ,CAACuJ,SAAS,CAChBlG,QAAQ,EACR7C,OAAO,CAAC+C,OAAO,CAACC,OAAO,EAAEmB,SAAS,CAACL,MAAM,CAAC,CAAC,CAC5C;MACH;IACF,CAAC,CAAC;IACF,OAAO1E,MAAM,CAACkF,IAAI;EACpB,CAAC;EAED,MAAMgD,YAAY,GAAGA,CACnBxD,MAAc,EACdiC,OAAsB,EACtBkD,MAAoG,KAClG;IACF,IAAI5D,KAAK,GAAGvB,MAAM,CAACoB,OAAO,CAAChE,GAAG,CAAC6E,OAAO,CAACd,EAAE,CAAC;IAC1C,IAAI1C,WAAW,IAAI,CAAC8C,KAAK,EAAE;MACzBA,KAAK,GAAGjG,MAAM,CAACsE,eAAe,CAAC,KAAK,CAAC;MACrCI,MAAM,CAACoB,OAAO,CAACrD,GAAG,CAACkE,OAAO,CAACd,EAAE,EAAEI,KAAK,CAAC;IACvC;IACA,IAAIjG,MAAM,CAAC8J,QAAQ,CAACD,MAAM,CAAC,EAAE;MAC3B,IAAIE,IAAI,GAAG,KAAK;MAChB,OAAOF,MAAM,CAAChG,IAAI,CAChB7D,MAAM,CAACgK,OAAO,CAAEC,OAAO,IACrBjK,MAAM,CAACkK,SAAS,CAAC;QACfC,KAAK,EAAEA,CAAA,KAAM,CAACJ,IAAI;QAClBK,IAAI,EAAE,IAAAC,kBAAQ,EAACrK,MAAM,CAACgK,OAAO,CAACC,OAAO,CAACK,OAAO,EAAE,CAAC,CAACC,KAAK,EAAEC,KAAK,CAAC,KAAI;UAChET,IAAI,GAAGS,KAAK;UACZ,IAAI,CAAC3K,KAAK,CAAC4K,UAAU,CAACF,KAAK,CAAC,EAAE,OAAOvK,MAAM,CAACkF,IAAI;UAChD,MAAMK,KAAK,GAAGzC,OAAO,CAACuD,YAAY,CAAC;YACjCN,IAAI,EAAE,OAAO;YACbV,QAAQ,EAAEX,MAAM,CAACmB,EAAE;YACnBK,SAAS,EAAES,OAAO,CAACd,EAAE;YACrBlB,MAAM,EAAE9E,KAAK,CAAC6K,eAAe,CAACH,KAAK;WACpC,CAAC;UACF,IAAI,CAACtE,KAAK,EAAE,OAAOV,KAAK;UACxBU,KAAK,CAAC0E,WAAW,EAAE;UACnB,OAAO3K,MAAM,CAAC0G,QAAQ,CAACnB,KAAK,EAAEU,KAAK,CAACd,KAAK,CAAC;QAC5C,CAAC,CAAC,CAAC;QACHyF,IAAI,EAAEC;OACP,CAAC,CACH,EACD7K,MAAM,CAAC8K,MAAM,CACd;IACH;IACA,OAAO/J,MAAM,CAACgK,eAAe,CAAClB,MAAM,EAAGU,KAAK,IAAI;MAC9C,IAAI,CAAC1K,KAAK,CAAC4K,UAAU,CAACF,KAAK,CAAC,EAAE,OAAOvK,MAAM,CAACkF,IAAI;MAChD,MAAMK,KAAK,GAAGzC,OAAO,CAACuD,YAAY,CAAC;QACjCN,IAAI,EAAE,OAAO;QACbV,QAAQ,EAAEX,MAAM,CAACmB,EAAE;QACnBK,SAAS,EAAES,OAAO,CAACd,EAAE;QACrBlB,MAAM,EAAE9E,KAAK,CAAC6K,eAAe,CAACH,KAAK;OACpC,CAAC;MACF,IAAI,CAACtE,KAAK,EAAE,OAAOV,KAAK;MACxBU,KAAK,CAAC0E,WAAW,EAAE;MACnB,OAAO3K,MAAM,CAAC0G,QAAQ,CAACnB,KAAK,EAAEU,KAAK,CAACd,KAAK,CAAC;IAC5C,CAAC,CAAC;EACJ,CAAC;EAED,MAAMqB,UAAU,GAAGA,CAAC9B,MAAc,EAAE+B,MAAe,KACjDzG,MAAM,CAACgL,OAAO,CAAC,MAAK;IAClB,MAAMC,SAAS,GAAGvG,MAAM,CAACE,KAAK,IAAIF,MAAM,CAACG,MAAM,CAACC,IAAI,KAAK,CAAC;IAC1D,MAAMS,KAAK,GAAGzC,OAAO,CAACuD,YAAY,CAAC;MACjCN,IAAI,EAAE,QAAQ;MACdV,QAAQ,EAAEX,MAAM,CAACmB,EAAE;MACnBY;KACD,CAAC;IACF,IAAI,CAACwE,SAAS,EAAE,OAAO1F,KAAK;IAC5B,OAAOvF,MAAM,CAAC0G,QAAQ,CAACnB,KAAK,EAAER,SAAS,CAACL,MAAM,CAAC,CAAC;EAClD,CAAC,CAAC;EAEJ,OAAO,IAAAwG,kBAAQ,EAAkB;IAC/B3F,KAAK;IACLH;GACD,CAAC;AACJ,CAAC,CAAC;AAEF,MAAM6C,eAAe,GAAGA,CACtBrB,GAAqB,EACrBrD,OAA+B,EAC/BiE,OAAU,EACVC,OAAwB,EACxBF,OAA+B,KAC7B;EACF,IAAIX,GAAG,CAACuE,WAAW,CAACrG,IAAI,KAAK,CAAC,EAAE;IAC9B,OAAOyC,OAAO;EAChB;EAEA,MAAMzE,OAAO,GAAG;IACd8D,GAAG;IACHY,OAAO;IACPC;GACD;EAED,KAAK,MAAMX,GAAG,IAAIF,GAAG,CAACuE,WAAW,EAAE;IACjC,MAAMC,UAAU,GAAGtL,OAAO,CAACuL,SAAS,CAAC9H,OAAO,EAAEuD,GAAG,CAAC;IAClD,IAAIA,GAAG,CAACwE,QAAQ,EAAE;MAChB,MAAMC,QAAQ,GAAGhE,OAAO;MACxBA,OAAO,GAAGvH,MAAM,CAACwL,WAAW,CAACJ,UAAU,CAACtI,OAAO,CAAC,EAAE;QAChDuF,SAAS,EAAEA,CAAA,KAAMkD,QAAQ;QACzBpD,SAAS,EAAErB,GAAG,CAAC2E,QAAQ,KAAKzH,SAAS,GAChC4D,KAAK,IAAK5H,MAAM,CAAC0L,cAAc,CAACH,QAAQ,EAAEzE,GAAG,CAAC2E,QAAe,EAAE7D,KAAK,CAAC,GACrE+D,CAAC,IAAKJ;OACZ,CAAC;IACJ,CAAC,MAAM;MACLhE,OAAO,GAAGT,GAAG,CAAC2E,QAAQ,KAAKzH,SAAS,GAChChE,MAAM,CAAC4L,oBAAoB,CAACrE,OAAO,EAAET,GAAG,CAAC2E,QAAe,EAAEL,UAAU,CAACtI,OAAO,CAAC,CAAC,GAC9E9C,MAAM,CAAC0G,QAAQ,CAAC0E,UAAU,CAACtI,OAAO,CAAC,EAAEyE,OAAO,CAAC;IACnD;EACF;EAEA,OAAOA,OAAO;AAChB,CAAC;AAED;;;;AAIO,MAAM7D,IAAI,GAAAf,OAAA,CAAAe,IAAA,gBAab1D,MAAM,CAAC4C,UAAU,CAAC,WACpBC,KAA8B,EAC9BC,OAIC;EAED,MAAM;IAAE+I,WAAW;IAAEC,GAAG;IAAEC,GAAG;IAAEC,IAAI;IAAE7I,WAAW;IAAE8I,uBAAuB;IAAEC;EAAqB,CAAE,GAAG,OAAOC,QAAQ;EACpH,MAAM5I,OAAO,GAAG,OAAOvD,MAAM,CAACuD,OAAO,EAA8C;EACnF,MAAMC,KAAK,GAAG,OAAO1C,KAAK,CAAC4C,IAAI,EAAE;EAEjC,MAAM0I,MAAM,GAAG,OAAO1J,mBAAmB,CAACG,KAAK,EAAE;IAC/C,GAAGC,OAAO;IACVM,iBAAiB,EAAE,CAACD,WAAW;IAC/BD,sBAAsB,EAAE,CAAC+I,uBAAuB;IAChD5F,YAAYA,CAACgG,QAAQ;MACnB,MAAM3H,MAAM,GAAGR,OAAO,CAACpC,GAAG,CAACuK,QAAQ,CAAChH,QAAQ,CAAC;MAC7C,IAAI,CAACX,MAAM,EAAE,OAAO1E,MAAM,CAACkF,IAAI;MAC/B,QAAQmH,QAAQ,CAACtG,IAAI;QACnB,KAAK,OAAO;UAAE;YACZ,MAAMuG,OAAO,GAAG5H,MAAM,CAAC4H,OAAO,CAACxK,GAAG,CAACuK,QAAQ,CAACnG,SAAS,CAAC;YACtD,IAAI,CAACoG,OAAO,EAAE,OAAOtM,MAAM,CAACkF,IAAI;YAChC,OAAOqH,YAAY,CACjB7H,MAAM,EACN2H,QAAQ,CAACnG,SAAS,EAClBoG,OAAO,CAACE,SAAS,EACjBxM,MAAM,CAACyM,OAAO,CAACH,OAAO,CAACI,WAAW,CAACL,QAAQ,CAAC1H,MAAM,CAAC,EAAE2H,OAAO,CAAC/I,OAAO,CAAC,EACpEoB,MAAM,KAAM;cAAEoB,IAAI,EAAE,OAAO;cAAEG,SAAS,EAAEmG,QAAQ,CAACnG,SAAS;cAAEvB;YAAM,CAAE,CAAC,CACvE;UACH;QACA,KAAK,MAAM;UAAE;YACX,MAAM2H,OAAO,GAAG5H,MAAM,CAAC4H,OAAO,CAACxK,GAAG,CAACuK,QAAQ,CAACnG,SAAS,CAAC;YACtD,IAAI,CAACoG,OAAO,EAAE,OAAOtM,MAAM,CAACkF,IAAI;YAChCR,MAAM,CAAC4H,OAAO,CAAChH,MAAM,CAAC+G,QAAQ,CAACnG,SAAS,CAAC;YACzC,OAAOqG,YAAY,CACjB7H,MAAM,EACN2H,QAAQ,CAACnG,SAAS,EAClBoG,OAAO,CAACE,SAAS,EACjBxM,MAAM,CAACyM,OAAO,CAACH,OAAO,CAACK,UAAU,CAACN,QAAQ,CAAC/F,IAAI,CAAC,EAAEgG,OAAO,CAAC/I,OAAO,CAAC,EACjE+C,IAAI,KAAM;cAAEP,IAAI,EAAE,MAAM;cAAEG,SAAS,EAAEmG,QAAQ,CAACnG,SAAS;cAAEI;YAAI,CAAE,CAAC,CAClE;UACH;QACA,KAAK,QAAQ;UAAE;YACb,OAAOE,UAAU,CAAC9B,MAAM,EAAE2H,QAAQ,CAAC5F,MAAM,CAAC;UAC5C;QACA,KAAK,WAAW;UAAE;YAChBvC,OAAO,CAACoB,MAAM,CAAC+G,QAAQ,CAAChH,QAAQ,CAAC;YACjC,OAAOyG,GAAG,CAACO,QAAQ,CAAChH,QAAQ,CAAC;UAC/B;MACF;IACF;GACD,CAAC,CAACxB,IAAI,CAAC/C,KAAK,CAAC8L,MAAM,CAACpJ,KAAK,CAAC,CAAC;EAE5B;EACA,OAAOxD,MAAM,CAAC6M,IAAI,CAAC7M,MAAM,CAAC8D,aAAa,CAAC9D,MAAM,CAACkK,SAAS,CAAC;IACvDC,KAAK,EAAE2C,mBAAS;IAChB1C,IAAI,EAAE,IAAAC,kBAAQ,EAACrK,MAAM,CAACgK,OAAO,CAAC6B,WAAW,CAACkB,IAAI,EAAG1H,QAAQ,IAAI;MAC3DnB,OAAO,CAACoB,MAAM,CAACD,QAAQ,CAAC;MACxB,OAAO+G,MAAM,CAAChH,UAAU,CAACC,QAAQ,CAAC;IACpC,CAAC,CAAC,CAAC;IACHuF,IAAI,EAAEC;GACP,CAAC,CAAC,CAAC;EAUJ,MAAMmC,YAAY,GAAG,IAAIxL,OAAO,EAAgB;EAChD,MAAMyL,UAAU,GAAIrG,GAAqB,IAAI;IAC3C,IAAI0F,OAAO,GAAGU,YAAY,CAAClL,GAAG,CAAC8E,GAAG,CAAC;IACnC,IAAI,CAAC0F,OAAO,EAAE;MACZ,MAAMvF,KAAK,GAAGxD,OAAO,CAACyD,SAAS,CAAClF,GAAG,CAAC8E,GAAG,CAACK,GAAG,CAA8B;MACzE,MAAMiG,aAAa,GAAG9L,SAAS,CAAC+L,gBAAgB,CAACvG,GAAG,CAACS,aAAa,CAAC+F,GAAG,CAAC;MACvE,MAAMC,QAAQ,GAAG,IAAIC,GAAG,CAAC,CAAC1G,GAAG,CAAC2G,WAAW,CAAC,CAAC;MAC3C,IAAI9M,MAAM,CAAC+M,MAAM,CAACN,aAAa,CAAC,EAAE;QAChCG,QAAQ,CAACI,GAAG,CAACP,aAAa,CAACtF,KAAK,CAAC8F,OAAO,CAAC;MAC3C;MACA,KAAK,MAAMtC,UAAU,IAAIxE,GAAG,CAACuE,WAAW,EAAE;QACxCkC,QAAQ,CAACI,GAAG,CAACrC,UAAU,CAACsC,OAAO,CAAC;MAClC;MACApB,OAAO,GAAG;QACRqB,MAAM,EAAE9M,MAAM,CAAC+M,aAAa,CAAChH,GAAG,CAACiH,aAAoB,CAAC;QACtDnB,WAAW,EAAE7L,MAAM,CAACiN,aAAa,CAC/BjN,MAAM,CAACkN,KAAK,CAACtN,MAAM,CAAC+M,MAAM,CAACN,aAAa,CAAC,GAAGA,aAAa,CAACtF,KAAK,CAACoG,OAAO,GAAGnN,MAAM,CAACoN,GAAG,CAAC,CAC/E;QACRtB,UAAU,EAAE9L,MAAM,CAACiN,aAAa,CAAC5M,GAAG,CAACgN,UAAU,CAACtH,GAAU,CAAC,CAAQ;QACnErD,OAAO,EAAEwD,KAAK,CAACxD;OAChB;MACDyJ,YAAY,CAACvK,GAAG,CAACmE,GAAG,EAAE0F,OAAO,CAAC;IAChC;IACA,OAAOA,OAAO;EAChB,CAAC;EAMD,MAAMpI,OAAO,GAAG,IAAIC,GAAG,EAAkB;EAEzC,MAAMoI,YAAY,GAAGA,CACnB7H,MAAc,EACdwB,SAAoB,EACpBsG,SAAoD,EACpD1E,MAAuC,EACvCK,SAAsC,KAEtC,CAACqE,SAAS,GAAGxM,MAAM,CAAC0L,cAAc,CAAC5D,MAAM,EAAErI,YAAY,CAAC0O,SAAS,EAAE3B,SAAS,CAAC,GAAG1E,MAAM,EAAEjE,IAAI,CAC1F7D,MAAM,CAACgK,OAAO,CAAE/H,CAAC,IAAK+J,IAAI,CAACtH,MAAM,CAACmB,EAAE,EAAEsC,SAAS,CAAClG,CAAC,CAAC,EAAEuK,SAAS,IAAIA,SAAS,CAAC4B,WAAW,EAAE,CAAC,CAAC,EAC1FpO,MAAM,CAACqO,aAAa,CAAE/F,KAAK,IAAI;IAC7B5D,MAAM,CAAC4H,OAAO,CAAChH,MAAM,CAACY,SAAS,CAAC;IAChC,MAAMO,MAAM,GAAG7G,KAAK,CAAC0O,MAAM,CAAC1O,KAAK,CAAC2O,GAAG,CAACjG,KAAK,EAAEkG,2BAAc,CAACC,eAAe,CAAC,CAAC;IAC7E,OAAOzO,MAAM,CAAC0G,QAAQ,CACpB0F,MAAM,CAAC7G,KAAK,CAACb,MAAM,CAACmB,EAAE,EAAE;MAAEE,IAAI,EAAE,WAAW;MAAEG,SAAS;MAAEwI,YAAY,EAAE;IAAE,CAAE,CAAC,EAC3EC,iBAAiB,CAACjK,MAAM,EAAEwB,SAAS,EAAEO,MAAM,CAAC,CAC7C;EACH,CAAC,CAAC,CACH;EAEH,MAAMkI,iBAAiB,GAAGA,CAACjK,MAAc,EAAEwB,SAAoB,EAAEO,MAAe,KAC9EzG,MAAM,CAACqO,aAAa,CAClBrC,IAAI,CAACtH,MAAM,CAACmB,EAAE,EAAE;IACdE,IAAI,EAAE,MAAM;IACZG,SAAS;IACTI,IAAI,EAAE;MACJP,IAAI,EAAE,SAAS;MACfuC,KAAK,EAAE;QACLvC,IAAI,EAAE,KAAK;QACXU;;;GAGL,CAAC,EACD6B,KAAK,IAAK9B,UAAU,CAAC9B,MAAM,EAAE9E,KAAK,CAAC0O,MAAM,CAAChG,KAAK,CAAC,CAAC,CACnD;EAEH,MAAM9B,UAAU,GAAGA,CAAC9B,MAAc,EAAE+B,MAAe,KACjDzG,MAAM,CAACqO,aAAa,CAClBrC,IAAI,CAACtH,MAAM,CAACmB,EAAE,EAAE;IAAEE,IAAI,EAAE,QAAQ;IAAEU;EAAM,CAAE,CAAC,EAC1C6B,KAAK,IACJtI,MAAM,CAAC4O,YAAY,CAAC5O,MAAM,CAAC6O,QAAQ,CAACvG,KAAK,CAAC,EAAE;IAC1CwG,MAAM,EAAE,WAAW;IACnBC,MAAM,EAAE;GACT,CAAC,CACL;EAEH;EACA,OAAO,OAAOhD,GAAG,CAAC,CAAC1G,QAAQ,EAAEsB,OAAO,KAAI;IACtC,IAAIjC,MAAM,GAAGR,OAAO,CAACpC,GAAG,CAACuD,QAAQ,CAAC;IAClC,IAAI,CAACX,MAAM,EAAE;MACXA,MAAM,GAAG;QACPmB,EAAE,EAAER,QAAQ;QACZiH,OAAO,EAAE,IAAInI,GAAG;OACjB;MACDD,OAAO,CAACzB,GAAG,CAAC4C,QAAQ,EAAEX,MAAM,CAAC;IAC/B;IAEA,QAAQiC,OAAO,CAACZ,IAAI;MAClB,KAAK,SAAS;QAAE;UACd,MAAMe,GAAG,GAAGnG,SAAS,CAACqO,WAAW,CAACrI,OAAO,EAAE,KAAK,CAAC,GAAGA,OAAO,CAACG,GAAa,GAAG,EAAE;UAC9E,MAAMF,GAAG,GAAG/D,KAAK,CAACgE,QAAQ,CAAC/E,GAAG,CAACgF,GAAG,CAAC;UACnC,IAAI,CAACF,GAAG,EAAE;YACR,OAAOJ,UAAU,CAAC9B,MAAM,EAAE,wBAAwBoC,GAAG,EAAE,CAAC;UAC1D;UACA,IAAIZ,SAAoB;UACxB,QAAQ,OAAOS,OAAO,CAACd,EAAE;YACvB,KAAK,QAAQ;YACb,KAAK,QAAQ;cAAE;gBACbK,SAAS,GAAG,IAAA+I,qBAAS,EAACtI,OAAO,CAACd,EAAE,CAAC;gBACjC;cACF;YACA;cAAS;gBACP,OAAOW,UAAU,CAAC9B,MAAM,EAAE,uBAAuBiC,OAAO,CAACd,EAAE,EAAE,CAAC;cAChE;UACF;UACA,MAAMyG,OAAO,GAAGW,UAAU,CAACrG,GAAU,CAAC;UACtC,OAAO5G,MAAM,CAACwL,WAAW,CACvBxL,MAAM,CAACyM,OAAO,CAACH,OAAO,CAACqB,MAAM,CAAChH,OAAO,CAACa,OAAO,CAAC,EAAE8E,OAAO,CAAC/I,OAAO,CAAC,EAChE;YACE8E,SAAS,EAAG6G,KAAK,IAAKP,iBAAiB,CAACjK,MAAM,EAAEwB,SAAS,EAAEsI,2BAAc,CAACC,eAAe,CAACS,KAAK,CAAC,CAAC;YACjG/G,SAAS,EAAGX,OAAO,IAAI;cACrB9C,MAAM,CAAC4H,OAAO,CAAC7J,GAAG,CAChByD,SAAS,EACTgG,qBAAqB,GACnB;gBACE,GAAGI,OAAO;gBACVE,SAAS,EAAE/M,YAAY,CAAC0P,mBAAmB;eAC5C,GACD7C,OAAO,CACV;cACD,OAAOF,MAAM,CAAC7G,KAAK,CAACF,QAAQ,EAAE;gBAC5B,GAAGsB,OAAO;gBACVd,EAAE,EAAEK,SAAS;gBACbsB,OAAO;gBACPC,OAAO,EAAExI,OAAO,CAACmQ,SAAS,CAACzI,OAAO,CAACc,OAAO;eACpC,CAAC;YACX;WACD,CACF;QACH;MACA,KAAK,MAAM;QAAE;UACX,OAAOzH,MAAM,CAACqO,aAAa,CACzBrC,IAAI,CAACtH,MAAM,CAACmB,EAAE,EAAEwJ,qBAAS,CAAC,EACzB/G,KAAK,IAAK9B,UAAU,CAAC9B,MAAM,EAAE9E,KAAK,CAAC0O,MAAM,CAAChG,KAAK,CAAC,CAAC,CACnD;QACH;MACA,KAAK,KAAK;MACV,KAAK,KAAK;MACV,KAAK,WAAW;QAAE;UAChB,IAAI,WAAW,IAAI3B,OAAO,IAAI,OAAOA,OAAO,CAACT,SAAS,KAAK,QAAQ,EAAE;YACnE;YAAES,OAAe,CAACT,SAAS,GAAGoJ,MAAM,CAAC3I,OAAO,CAACT,SAAS,CAAC;UACzD;UACA,OAAOkG,MAAM,CAAC7G,KAAK,CACjBF,QAAQ,EACRsB,OAAO,CAACZ,IAAI,KAAK,WAAW,GAC1B;YACE,GAAGY,OAAO;YACV+H,YAAY,EAAE;WACf,GACD/H,OAAO,CACV;QACH;MACA;QAAS;UACP,OAAOH,UAAU,CAAC9B,MAAM,EAAE,wBAAyBiC,OAAe,CAACZ,IAAI,EAAE,CAAC;QAC5E;IACF;EACF,CAAC,CAAC,CAAClC,IAAI,CACL7D,MAAM,CAAC8D,aAAa,EACpB9D,MAAM,CAACuP,aAAa,CAAEjH,KAAK,IAAKtI,MAAM,CAACwP,QAAQ,CAAC,iCAAiC,EAAElH,KAAK,CAAC,CAAC,EAC1FtI,MAAM,CAACyP,MAAM,CAAEnJ,IAAI,IAAKxF,KAAK,CAAC4O,KAAK,CAAClM,KAAK,EAAE8C,IAAI,CAAC,CAAC,CAClD;AACH,CAAC,CAAC;AAEF;;;;AAIO,MAAMqJ,KAAK,GAAGA,CACnB9M,KAA8B,EAC9BC,OAIC,KAOExC,KAAK,CAACsP,aAAa,CAAC5P,MAAM,CAAC6P,UAAU,CAAC7P,MAAM,CAAC8D,aAAa,CAACJ,IAAI,CAACb,KAAK,EAAEC,OAAO,CAAC,CAAC,CAAC,CAAC;AAEvF;;;;AAAAH,OAAA,CAAAgN,KAAA,GAAAA,KAAA;AAIM,MAAOxD,QAAS,sBAAQrM,OAAO,CAACgQ,GAAG,CAAC,gCAAgC,CAAC,EAevE;EACF;;;EAGA,OAAOpM,IAAI,gBAAG,IAAAqM,cAAO,GAAoB;;AAG3C;;;;AAAApN,OAAA,CAAAwJ,QAAA,GAAAA,QAAA;AAIO,MAAM6D,wBAAwB,GAAArN,OAAA,CAAAqN,wBAAA,gBAAGhQ,MAAM,CAACiQ,GAAG,CAAC,aAAS;EAC1D,MAAM7D,MAAM,GAAG,OAAO5M,YAAY,CAACA,YAAY;EAC/C,MAAM;IAAE0Q,QAAQ;IAAEC;EAAQ,CAAE,GAAG,OAAOC,kBAAkB;EACxD,OAAOpQ,MAAM,CAAC6P,UAAU,CAAC7P,MAAM,CAAC8D,aAAa,CAC3CsI,MAAM,CAACL,GAAG,CAAC/L,MAAM,CAAC4C,UAAU,CAACsN,QAAQ,EAAElQ,MAAM,CAAC8K,MAAM,CAAC,CAAC,CACvD,CAAC;EACF,OAAOqF,QAAQ;AACjB,CAAC,CAAC;AAEF;;;;;;AAMO,MAAME,yBAAyB,GAAA1N,OAAA,CAAA0N,yBAAA,gBAIlC/P,KAAK,CAACwK,MAAM,CAACqB,QAAQ,EAAE6D,wBAAwB,CAAC;AAEpD;;;;AAIO,MAAMM,gCAAgC,GAAA3N,OAAA,CAAA2N,gCAAA,gBAOzCtQ,MAAM,CAACiQ,GAAG,CAAC,aAAS;EACtB,MAAM;IAAEC,QAAQ;IAAEC;EAAQ,CAAE,GAAG,OAAOC,kBAAkB;EAExD,MAAMG,OAAO,GAAwCvQ,MAAM,CAACiQ,GAAG,CAAC,aAAS;IACvE,MAAMtJ,OAAO,GAAG,OAAOrH,iBAAiB,CAACA,iBAAiB;IAC1D,MAAMkR,MAAM,GAAG,OAAOxQ,MAAM,CAACyQ,KAAK,CAAC9J,OAAO,CAAC+J,OAAO,CAAC;IACnD,OAAOR,QAAQ,CAACM,MAAM,CAAC;IACvB,OAAOjR,kBAAkB,CAAC0J,KAAK,EAAE;EACnC,CAAC,CAAC;EAEF,OAAO;IAAEkH,QAAQ;IAAEI;EAAO,CAAW;AACvC,CAAC,CAAC;AAEF;;;;AAIO,MAAMI,qBAAqB,GAAAhO,OAAA,CAAAgO,qBAAA,gBAS9B3Q,MAAM,CAAC4C,UAAU,CAAC,WAAkCE,OAGvD;EACC,MAAM;IAAEyN,OAAO;IAAEJ;EAAQ,CAAE,GAAG,OAAOG,gCAAgC;EACrE,MAAMM,MAAM,GACV,OAAQ9N,OAAO,CAAC+N,SAAS,IAAIxR,UAAU,CAACyR,OAA0E;EACpH,OAAOF,MAAM,CAAC9O,GAAG,CAACgB,OAAO,CAACiO,IAAI,EAAER,OAAO,CAAC;EACxC,OAAOJ,QAAQ;AACjB,CAAC,CAAC;AAEF;;;;;;AAMO,MAAMa,sBAAsB,GAA4BlO,OAG9D,IAAqE;EACpE,MAAM+N,SAAS,GAAG/N,OAAO,CAAC+N,SAAS,IACjCxR,UAAU,CAACyR,OAAqE;EAClF,OAAOxQ,KAAK,CAACwH,MAAM,CAACqE,QAAQ,EAAEwE,qBAAqB,CAAC7N,OAAO,CAAC,CAAC,CAACe,IAAI,CAChEvD,KAAK,CAACmM,OAAO,CAACoE,SAAS,CAACI,IAAI,CAAC,CAC9B;AACH,CAAC;AAED;;;;AAAAtO,OAAA,CAAAqO,sBAAA,GAAAA,sBAAA;AAIO,MAAME,uBAAuB,GAAAvO,OAAA,CAAAuO,uBAAA,gBAOhClR,MAAM,CAACiQ,GAAG,CAAC,aAAS;EACtB,MAAMkB,aAAa,GAAG,OAAO9P,gBAAgB,CAACA,gBAAgB;EAC9D,MAAM+P,MAAM,GAAGD,aAAa,CAACE,WAAW,KAAK,kBAAkB;EAE/D,MAAMxF,WAAW,GAAG,OAAOtL,OAAO,CAACmD,IAAI,EAAU;EACjD,IAAI4N,YAAoF;EAExF,IAAIjM,QAAQ,GAAG,CAAC;EAEhB,MAAMnB,OAAO,GAAG,IAAIC,GAAG,EAGnB;EAEJ,MAAMoM,OAAO,GAAwCvQ,MAAM,CAACiQ,GAAG,CAAC,aAAS;IACvE,MAAMtJ,OAAO,GAAG,OAAOrH,iBAAiB,CAACA,iBAAiB;IAC1D,MAAMiS,IAAI,GAAG,OAAOvR,MAAM,CAACyQ,KAAK,CAAC9J,OAAO,CAAC6K,WAAW,CAAC;IACrD,MAAM3L,EAAE,GAAGR,QAAQ,EAAE;IACrB,MAAM4E,OAAO,GAAG,OAAO1J,OAAO,CAACmD,IAAI,EAAkC;IACrE,MAAM+N,MAAM,GAAGN,aAAa,CAACO,UAAU,EAAE;IACzC,MAAMC,OAAO,GAAG,IAAIC,WAAW,EAAE;IAEjC,MAAMC,KAAK,GAAIN,IAAyB,IACtC,OAAOA,IAAI,KAAK,QAAQ,GAAGtH,OAAO,CAAC4H,KAAK,CAACF,OAAO,CAACG,MAAM,CAACP,IAAI,CAAC,CAAC,GAAGtH,OAAO,CAAC4H,KAAK,CAACN,IAAI,CAAC;IAEtFrN,OAAO,CAACzB,GAAG,CAACoD,EAAE,EAAE;MACdN,KAAK,EAAG8G,QAAQ,IAAI;QAClB,IAAI;UACF,IAAI,CAAC8E,aAAa,CAACY,cAAc,EAAE;YACjCC,eAAe,CAAC3F,QAAQ,CAAC;UAC3B;UACA,OAAO+E,MAAM,GAAGnH,OAAO,CAAC4H,KAAK,CAACxF,QAAQ,CAAC,GAAGwF,KAAK,CAACJ,MAAM,CAACK,MAAM,CAACzF,QAAQ,CAAC,CAAC;QAC1E,CAAC,CAAC,OAAO/D,KAAK,EAAE;UACd,OAAO8I,MAAM,GACTnH,OAAO,CAAC4H,KAAK,CAAC,IAAAI,iCAAqB,EAAC3J,KAAK,CAAC,CAAC,GAC3CuJ,KAAK,CAACJ,MAAM,CAACK,MAAM,CAAC,IAAAG,iCAAqB,EAAC3J,KAAK,CAAC,CAAC,CAAC;QACxD;MACF,CAAC;MACDwD,GAAG,EAAE7B,OAAO,CAAC6B;KACd,CAAC;IAEF,MAAMoG,UAAU,GAAqB,EAAE;IAEvC,IAAI;MACF,MAAMC,OAAO,GAAGV,MAAM,CAAC9D,MAAM,CAAC,IAAIyE,UAAU,CAACb,IAAI,CAAC,CAAqC;MACvF,KAAK,MAAM/L,OAAO,IAAI2M,OAAO,EAAE;QAC7B,IAAI3M,OAAO,CAACO,IAAI,KAAK,SAAS,EAAE;UAC9BmM,UAAU,CAACG,IAAI,CAAC,IAAApD,qBAAS,EAACzJ,OAAO,CAACK,EAAE,CAAC,CAAC;QACxC;QACA,OAAOyL,YAAY,CAACzL,EAAE,EAAEL,OAAO,CAAC;MAClC;IACF,CAAC,CAAC,OAAO8C,KAAK,EAAE;MACd,OAAOuJ,KAAK,CAACJ,MAAM,CAACK,MAAM,CAAC,IAAAG,iCAAqB,EAAC3J,KAAK,CAAC,CAAC,CAAC;IAC3D;IAEA,OAAOgJ,YAAY,CAACzL,EAAE,EAAEyM,oBAAQ,CAAC;IAEjC,IAAIlB,MAAM,EAAE;MACV,IAAIrH,IAAI,GAAG,KAAK;MAChB,OAAO/J,MAAM,CAACuE,YAAY,CAAC,MAAK;QAC9BL,OAAO,CAACoB,MAAM,CAACO,EAAE,CAAC;QAClBgG,WAAW,CAAC0G,WAAW,CAAC1M,EAAE,CAAC;QAC3B,IAAIkE,IAAI,EAAE,OAAO/J,MAAM,CAACkF,IAAI;QAC5B,OAAOlF,MAAM,CAACwS,OAAO,CACnBN,UAAU,EACThM,SAAS,IAAKoL,YAAY,CAACzL,EAAE,EAAE;UAAEE,IAAI,EAAE,WAAW;UAAEG;QAAS,CAAE,CAAC,EACjE;UAAEuM,OAAO,EAAE;QAAI,CAAE,CAClB;MACH,CAAC,CAAC;MACF,MAAMC,SAAS,GAAG/S,GAAG,CAACsJ,KAAK,EAAqB;MAChD,OAAO,IAAI,EAAE;QACX,MAAM,CAAC0J,KAAK,EAAE5I,IAAI,CAAC,GAAG,OAAOE,OAAO,CAACK,OAAO;QAC5C;QACAoI,SAAS,CAACL,IAAI,CAAC,GAAGM,KAAY,CAAC;QAC/B,IAAI5I,IAAI,EAAE;MACZ;MACAA,IAAI,GAAG,IAAI;MACX,OAAOxK,kBAAkB,CAACqT,UAAU,CAACF,SAAS,CAAC;IACjD;IAEA,OAAOnT,kBAAkB,CAACsK,MAAM,CAC9B9I,MAAM,CAAC8R,YAAY,CAACtS,OAAO,CAACuS,QAAQ,CAAC7I,OAA8C,CAAC,EAAG3D,IAAI,IAAI;MAC7FpC,OAAO,CAACoB,MAAM,CAACO,EAAE,CAAC;MAClBgG,WAAW,CAAC0G,WAAW,CAAC1M,EAAE,CAAC;MAC3B,IAAI,CAAC5F,IAAI,CAAC8S,aAAa,CAACzM,IAAI,CAAC,EAAE,OAAOtG,MAAM,CAACkF,IAAI;MACjD,OAAOlF,MAAM,CAACwS,OAAO,CACnBN,UAAU,EACThM,SAAS,IAAKoL,YAAY,CAACzL,EAAE,EAAE;QAAEE,IAAI,EAAE,WAAW;QAAEG;MAAS,CAAE,CAAC,EACjE;QAAEuM,OAAO,EAAE;MAAI,CAAE,CAClB;IACH,CAAC,CAAC,EACF;MAAEpB,WAAW,EAAEF,aAAa,CAACE;IAAW,CAAE,CAC3C;EACH,CAAC,CAAC,CAACxN,IAAI,CAAC7D,MAAM,CAAC8D,aAAa,CAAC;EAE7B,MAAMqM,QAAQ,GAAG,OAAOhE,QAAQ,CAACzI,IAAI,CAAEsP,aAAa,IAAI;IACtD1B,YAAY,GAAG0B,aAAa;IAC5B,OAAOhT,MAAM,CAACoI,OAAO,CAAC;MACpByD,WAAW;MACXG,IAAI,EAAEA,CAAC3G,QAAQ,EAAEgH,QAAQ,KAAI;QAC3B,MAAM3H,MAAM,GAAGR,OAAO,CAACpC,GAAG,CAACuD,QAAQ,CAAC;QACpC,IAAI,CAACX,MAAM,EAAE,OAAO1E,MAAM,CAACkF,IAAI;QAC/B,OAAOR,MAAM,CAACa,KAAK,CAAC8G,QAAQ,CAAC;MAC/B,CAAC;MACDP,GAAGA,CAACzG,QAAQ;QACV,MAAMX,MAAM,GAAGR,OAAO,CAACpC,GAAG,CAACuD,QAAQ,CAAC;QACpC,IAAI,CAACX,MAAM,EAAE,OAAO1E,MAAM,CAACkF,IAAI;QAC/B,OAAOR,MAAM,CAACoH,GAAG;MACnB,CAAC;MACDmH,cAAc,EAAEjT,MAAM,CAACkT,WAAW;MAClC/P,WAAW,EAAE,KAAK;MAClB+I,qBAAqB,EAAE,KAAK;MAC5BD,uBAAuB,EAAE;KAC1B,CAAC;EACJ,CAAC,CAAC;EAEF,OAAO;IAAEkE,QAAQ;IAAEI;EAAO,CAAW;AACvC,CAAC,CAAC;AAEF;;;;AAIO,MAAM4C,gBAAgB,GAAAxQ,OAAA,CAAAwQ,gBAAA,gBAAGnT,MAAM,CAAC4C,UAAU,CAAC,WAAkCE,OAGnF;EACC,MAAM;IAAEyN,OAAO;IAAEJ;EAAQ,CAAE,GAAG,OAAOe,uBAAuB;EAC5D,MAAMN,MAAM,GACV,OAAQ9N,OAAO,CAAC+N,SAAS,IAAIxR,UAAU,CAACyR,OAAsE;EAChH,OAAOF,MAAM,CAACwC,IAAI,CAACtQ,OAAO,CAACiO,IAAI,EAAER,OAAO,CAAC;EACzC,OAAOJ,QAAQ;AACjB,CAAC,CAAC;AAEF;;;;AAIO,MAAMkD,wBAAwB,GAAA1Q,OAAA,CAAA0Q,wBAAA,gBAIjClH,QAAQ,CAACzI,IAAI,eAAC1D,MAAM,CAAC4C,UAAU,CAAC,WAAU0O,YAAY;EACxD,MAAMtM,KAAK,GAAG,OAAOhF,MAAM,CAAC0F,gBAAgB,CAA2B1F,MAAM,CAACoI,OAAc,CAAC;EAC7F,MAAMkL,MAAM,GAAG,OAAO5T,YAAY,CAAC6T,cAAc;EACjD,MAAMC,UAAU,GAAG,OAAO9T,YAAY,CAAC+T,UAAU;EACjD,MAAMC,OAAO,GAAG,OAAOJ,MAAM,CAACK,KAAK,CAAgEH,UAAU,CAAC;EAC9G,MAAMP,cAAc,GAAG,OAAOlT,QAAQ,CAAC2D,IAAI,EAAW;EAEtD,OAAO3D,QAAQ,CAACoF,KAAK,CAACqO,UAAU,CAAC,CAAC3P,IAAI,CACpC7D,MAAM,CAACyP,MAAM,CAAC,MAAK;IACjBzK,KAAK,CAAC4O,gBAAgB,CAACC,YAAY,CAAC,MAAM7O,KAAK,CAACC,qBAAqB,CAACD,KAAK,CAACa,EAAE,EAAE,CAAC,EAAE,CAAC,CAAC;IACrF,OAAO7F,MAAM,CAACkF,IAAI;EACpB,CAAC,CAAC,EACFlF,MAAM,CAAC6P,UAAU,CAClB;EAED,OAAO6D,OAAO,CAAC3H,GAAG,CAAC,CAAC1G,QAAQ,EAAEG,OAAO,KAAI;IACvC,IAAIA,OAAO,CAACO,IAAI,KAAK,gBAAgB,EAAE;MACrC,OAAOhG,QAAQ,CAACqI,OAAO,CAAC6K,cAAc,EAAEzN,OAAO,CAACoC,KAAK,CAAC;IACxD;IACA,OAAO0J,YAAY,CAACjM,QAAQ,EAAEG,OAAO,CAAC;EACxC,CAAC,CAAC;EAEF,OAAO;IACLqG,WAAW,EAAE6H,OAAO,CAAC7H,WAAW,KAAK,OAAOtL,OAAO,CAACmD,IAAI,EAAU,CAAC;IACnEsI,IAAI,EAAE0H,OAAO,CAAC1H,IAAI;IAClBF,GAAGA,CAACgI,SAAS;MACX,OAAO9T,MAAM,CAACkF,IAAI;IACpB,CAAC;IACD+N,cAAc,EAAEjT,MAAM,CAAC+T,MAAM,CAAChU,QAAQ,CAACoF,KAAK,CAAC8N,cAAc,CAAC,CAAC;IAC7D9P,WAAW,EAAE,IAAI;IACjB+I,qBAAqB,EAAE,IAAI;IAC3BD,uBAAuB,EAAE;GAC1B;AACH,CAAC,CAAC,CAAC;AAEH;;;;AAIO,MAAM+H,yBAAyB,GAAArR,OAAA,CAAAqR,yBAAA,gBAIlC1T,KAAK,CAACwK,MAAM,CAACqB,QAAQ,EAAEkH,wBAAwB,CAAC;AAEpD;;;;;;AAMO,MAAMY,iBAAiB,GAA4BnR,OAGzD,IAAqE;EACpE,MAAM+N,SAAS,GAAG/N,OAAO,CAAC+N,SAAS,IACjCxR,UAAU,CAACyR,OAAqE;EAClF,OAAOxQ,KAAK,CAACwH,MAAM,CAACqE,QAAQ,EAAEgH,gBAAgB,CAACrQ,OAAO,CAAC,CAAC,CAACe,IAAI,CAC3DvD,KAAK,CAACmM,OAAO,CAACoE,SAAS,CAACI,IAAI,CAAC,CAC9B;AACH,CAAC;AAED;;;;AAAAtO,OAAA,CAAAsR,iBAAA,GAAAA,iBAAA;AAIO,MAAMC,SAAS,GAAAvR,OAAA,CAAAuR,SAAA,gBAalBlU,MAAM,CAAC4C,UAAU,CAAC,WACpBC,KAA8B,EAC9BC,OAGC;EAED,MAAM;IAAEyN,OAAO;IAAEJ;EAAQ,CAAE,GAAG,OAAOe,uBAAuB;EAC5D,OAAOxN,IAAI,CAACb,KAAK,EAAEC,OAAO,CAAC,CAACe,IAAI,CAC9B7D,MAAM,CAAC0L,cAAc,CAACS,QAAQ,EAAEgE,QAAQ,CAAC,EACzCnQ,MAAM,CAAC8D,aAAa,EACpB9D,MAAM,CAAC6P,UAAU,CAClB;EACD,OAAOU,OAAO;AAChB,CAAC,CAAC;AAEF;;;;AAIO,MAAM4D,kBAAkB,GAAAxR,OAAA,CAAAwR,kBAAA,gBAa3BnU,MAAM,CAAC4C,UAAU,CAAC,WACpBC,KAA8B,EAC9BC,OAGC;EAED,MAAM;IAAEyN,OAAO;IAAEJ;EAAQ,CAAE,GAAG,OAAOG,gCAAgC;EACrE,OAAO5M,IAAI,CAACb,KAAK,EAAEC,OAAO,CAAC,CAACe,IAAI,CAC9B7D,MAAM,CAAC0L,cAAc,CAACS,QAAQ,EAAEgE,QAAQ,CAAC,EACzCnQ,MAAM,CAAC8D,aAAa,EACpB9D,MAAM,CAAC6P,UAAU,CAClB;EACD,OAAOU,OAAO;AAChB,CAAC,CAAC;AAEF;;;;;;AAMO,MAAM6D,YAAY,GAAGA,CAC1BvR,KAA8B,EAC9BC,OAiBC,KAIC;EACF,MAAMc,OAAO,GAAGpD,cAAc,CAACkD,IAAI,CAACpD,KAAK,CAAC+T,QAAQ,CAACvR,OAAO,CAAC6M,KAAK,EAAErP,KAAK,CAACkD,KAAK,CAAC,EAAEV,OAAO,EAAEwR,OAAO,CAAC;EACjG,IAAIC,aAES;EACb,MAAMC,cAAc,GAAGxU,MAAM,CAACiQ,GAAG,CAAC,aAAS;IACzC,MAAMwE,GAAG,GAAG,OAAOP,SAAS,CAACrR,KAAK,EAAEC,OAAO,CAAC;IAC5C,MAAM4R,EAAE,GAAG,OAAO9Q,OAAO,CAAC+Q,aAAa;IACvC,MAAMpN,OAAO,GAAGnI,OAAO,CAACwV,mBAAmB,CAACF,EAAE,CAAC,CAAC5R,OAAO,EAAEsI,UAAU,GAAGtI,OAAO,CAACsI,UAAU,CAACqJ,GAAU,CAAQ,GAAGA,GAAG,CAAC;IAClHF,aAAa,GAAGhN,OAAO;IACvB,OAAOA,OAAO;EAChB,CAAC,CAAC,CAAC1D,IAAI,CAACD,OAAO,CAACiR,UAAU,CAAC;EAC3B,SAAStN,OAAOA,CAACZ,OAA2B,EAAEpD,OAA4C;IACxF,IAAIgR,aAAa,KAAKvQ,SAAS,EAAE;MAC/B,OAAOuQ,aAAa,CAAC5N,OAAO,EAAEpD,OAAO,CAAC;IACxC;IACA,OAAOiR,cAAc,CAACM,IAAI,CAAEvN,OAAO,IAAKA,OAAO,CAACZ,OAAO,EAAEpD,OAAO,CAAC,CAAC;EACpE;EACA,OAAO;IAAEgE,OAAO;IAAEwN,OAAO,EAAEnR,OAAO,CAACmR;EAAO,CAAW;AACvD,CAAC;AAED;AAAApS,OAAA,CAAAyR,YAAA,GAAAA,YAAA;AAEA,MAAMhE,kBAAkB,gBAAGpQ,MAAM,CAACiQ,GAAG,CAAC,aAAS;EAC7C,MAAMkB,aAAa,GAAG,OAAO9P,gBAAgB,CAACA,gBAAgB;EAC9D,MAAMwK,WAAW,GAAG,OAAOtL,OAAO,CAACmD,IAAI,EAAU;EAEjD,IAAI2B,QAAQ,GAAG,CAAC;EAChB,MAAMnB,OAAO,GAAG,IAAIC,GAAG,EAEnB;EAEJ,IAAImN,YAAoF;EAExF,MAAMpB,QAAQ,GAAG,UAAAA,CAAUM,MAAqB;IAC9C,MAAMhN,KAAK,GAAG,OAAOxD,MAAM,CAACwD,KAAK;IACjC,MAAMiO,MAAM,GAAGN,aAAa,CAACO,UAAU,EAAE;IACzC,MAAM7L,EAAE,GAAGR,QAAQ,EAAE;IACrB,OAAOvE,KAAK,CAACkU,gBAAgB,CAACxR,KAAK,EAAE,MAAK;MACxCU,OAAO,CAACoB,MAAM,CAACO,EAAE,CAAC;MAClB,OAAOgG,WAAW,CAACgG,KAAK,CAAChM,EAAE,CAAC;IAC9B,CAAC,CAAC;IAEF,MAAMoP,QAAQ,GAAG,OAAOzE,MAAM,CAAC0E,MAAM;IACrC,MAAM3P,KAAK,GAAI8G,QAA2B,IAAI;MAC5C,IAAI;QACF,IAAI,CAAC8E,aAAa,CAACY,cAAc,EAAE;UACjCC,eAAe,CAAC3F,QAAQ,CAAC;QAC3B;QACA,OAAOrM,MAAM,CAACyQ,KAAK,CAACwE,QAAQ,CAACxD,MAAM,CAACK,MAAM,CAACzF,QAAQ,CAAC,CAAC,CAAC;MACxD,CAAC,CAAC,OAAO/D,KAAK,EAAE;QACd,OAAOtI,MAAM,CAACyQ,KAAK,CACjBwE,QAAQ,CAACxD,MAAM,CAACK,MAAM,CAAC,IAAAG,iCAAqB,EAAC3J,KAAK,CAAC,CAAC,CAAC,CACtD;MACH;IACF,CAAC;IACDpE,OAAO,CAACzB,GAAG,CAACoD,EAAE,EAAE;MAAEN;IAAK,CAAE,CAAC;IAE1B,OAAOvF,MAAM,CAACyQ,KAAK,CAACzQ,MAAM,CAAC8D,aAAa,CAAC0M,MAAM,CAAC2E,MAAM,CAAE5D,IAAI,IAAI;MAC9D,IAAI;QACF,MAAMY,OAAO,GAAGV,MAAM,CAAC9D,MAAM,CAAC4D,IAAI,CAAqC;QACvE,IAAIY,OAAO,CAACiD,MAAM,KAAK,CAAC,EAAE,OAAOpV,MAAM,CAACkF,IAAI;QAC5C,IAAI1C,CAAC,GAAG,CAAC;QACT,OAAOxC,MAAM,CAACkK,SAAS,CAAC;UACtBC,KAAK,EAAEA,CAAA,KAAM3H,CAAC,GAAG2P,OAAO,CAACiD,MAAM;UAC/BhL,IAAI,EAAEA,CAAA,KAAMkH,YAAY,CAACzL,EAAE,EAAEsM,OAAO,CAAC3P,CAAC,EAAE,CAAC,CAAC;UAC1CoI,IAAI,EAAEC;SACP,CAAC;MACJ,CAAC,CAAC,OAAOvC,KAAK,EAAE;QACd,OAAO2M,QAAQ,CAACxD,MAAM,CAACK,MAAM,CAAC,IAAAG,iCAAqB,EAAC3J,KAAK,CAAC,CAAC,CAAC;MAC9D;IACF,CAAC,CAAC,CAAC,CAAC;EACN,CAAC;EAED,MAAM6H,QAAQ,GAAG,OAAOhE,QAAQ,CAACzI,IAAI,CAAEsP,aAAa,IAAI;IACtD1B,YAAY,GAAG0B,aAAa;IAC5B,OAAOhT,MAAM,CAACoI,OAAO,CAAC;MACpByD,WAAW;MACXG,IAAI,EAAEA,CAAC3G,QAAQ,EAAEgH,QAAQ,KAAI;QAC3B,MAAM3H,MAAM,GAAGR,OAAO,CAACpC,GAAG,CAACuD,QAAQ,CAAC;QACpC,IAAI,CAACX,MAAM,EAAE,OAAO1E,MAAM,CAACkF,IAAI;QAC/B,OAAOlF,MAAM,CAACyQ,KAAK,CAAC/L,MAAM,CAACa,KAAK,CAAC8G,QAAQ,CAAC,CAAC;MAC7C,CAAC;MACDP,GAAGA,CAACgI,SAAS;QACX,OAAO9T,MAAM,CAACkF,IAAI;MACpB,CAAC;MACD+N,cAAc,EAAEjT,MAAM,CAACkT,WAAW;MAClC/P,WAAW,EAAE,IAAI;MACjB+I,qBAAqB,EAAE,KAAK;MAC5BD,uBAAuB,EAAE;KAC1B,CAAC;EACJ,CAAC,CAAC;EAEF,OAAO;IAAEkE,QAAQ;IAAED;EAAQ,CAAW;AACxC,CAAC,CAAC;AAEF,MAAM8B,eAAe,GAAI3F,QAA2B,IAAI;EACtD,IAAI,WAAW,IAAIA,QAAQ,EAAE;IAC3B;IAAEA,QAAgB,CAACnG,SAAS,GAAGmG,QAAQ,CAACnG,SAAS,CAACmP,QAAQ,EAAE;EAC9D;AACF,CAAC","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/cjs/RpcTest.js b/dist/cjs/RpcTest.js
new file mode 100644
index 0000000000000000000000000000000000000000..0feed5c410f0a3bad1aecbdc5baf3ab8284e7262
--- /dev/null
+++ b/dist/cjs/RpcTest.js
@@ -0,0 +1,38 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.makeClient = void 0;
+var Effect = _interopRequireWildcard(require("effect/Effect"));
+var RpcClient = _interopRequireWildcard(require("./RpcClient.js"));
+var RpcServer = _interopRequireWildcard(require("./RpcServer.js"));
+function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
+function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
+/**
+ * @since 1.0.0
+ */
+
+/**
+ * @since 1.0.0
+ * @category constructors
+ */
+const makeClient = exports.makeClient = /*#__PURE__*/Effect.fnUntraced(function* (group) {
+  // eslint-disable-next-line prefer-const
+  let client;
+  const server = yield* RpcServer.makeNoSerialization(group, {
+    onFromServer(response) {
+      return client.write(response);
+    }
+  });
+  client = yield* RpcClient.makeNoSerialization(group, {
+    supportsAck: true,
+    onFromClient({
+      message
+    }) {
+      return server.write(0, message);
+    }
+  });
+  return client.client;
+});
+//# sourceMappingURL=RpcTest.js.map
\ No newline at end of file
diff --git a/dist/cjs/RpcTest.js.map b/dist/cjs/RpcTest.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..8dd1c214019b01d385f13121b35e853d2e7a4b8e
--- /dev/null
+++ b/dist/cjs/RpcTest.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"RpcTest.js","names":["Effect","_interopRequireWildcard","require","RpcClient","RpcServer","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","makeClient","exports","fnUntraced","group","client","server","makeNoSerialization","onFromServer","response","write","supportsAck","onFromClient","message"],"sources":["../../src/RpcTest.ts"],"sourcesContent":[null],"mappings":";;;;;;AAGA,IAAAA,MAAA,GAAAC,uBAAA,CAAAC,OAAA;AAGA,IAAAC,SAAA,GAAAF,uBAAA,CAAAC,OAAA;AAEA,IAAAE,SAAA,GAAAH,uBAAA,CAAAC,OAAA;AAA2C,SAAAG,yBAAAC,CAAA,6BAAAC,OAAA,mBAAAC,CAAA,OAAAD,OAAA,IAAAE,CAAA,OAAAF,OAAA,YAAAF,wBAAA,YAAAA,CAAAC,CAAA,WAAAA,CAAA,GAAAG,CAAA,GAAAD,CAAA,KAAAF,CAAA;AAAA,SAAAL,wBAAAK,CAAA,EAAAE,CAAA,SAAAA,CAAA,IAAAF,CAAA,IAAAA,CAAA,CAAAI,UAAA,SAAAJ,CAAA,eAAAA,CAAA,uBAAAA,CAAA,yBAAAA,CAAA,WAAAK,OAAA,EAAAL,CAAA,QAAAG,CAAA,GAAAJ,wBAAA,CAAAG,CAAA,OAAAC,CAAA,IAAAA,CAAA,CAAAG,GAAA,CAAAN,CAAA,UAAAG,CAAA,CAAAI,GAAA,CAAAP,CAAA,OAAAQ,CAAA,KAAAC,SAAA,UAAAC,CAAA,GAAAC,MAAA,CAAAC,cAAA,IAAAD,MAAA,CAAAE,wBAAA,WAAAC,CAAA,IAAAd,CAAA,oBAAAc,CAAA,OAAAC,cAAA,CAAAC,IAAA,CAAAhB,CAAA,EAAAc,CAAA,SAAAG,CAAA,GAAAP,CAAA,GAAAC,MAAA,CAAAE,wBAAA,CAAAb,CAAA,EAAAc,CAAA,UAAAG,CAAA,KAAAA,CAAA,CAAAV,GAAA,IAAAU,CAAA,CAAAC,GAAA,IAAAP,MAAA,CAAAC,cAAA,CAAAJ,CAAA,EAAAM,CAAA,EAAAG,CAAA,IAAAT,CAAA,CAAAM,CAAA,IAAAd,CAAA,CAAAc,CAAA,YAAAN,CAAA,CAAAH,OAAA,GAAAL,CAAA,EAAAG,CAAA,IAAAA,CAAA,CAAAe,GAAA,CAAAlB,CAAA,EAAAQ,CAAA,GAAAA,CAAA;AAR3C;;;;AAUA;;;;AAIO,MAAMW,UAAU,GAAAC,OAAA,CAAAD,UAAA,gBAMnBzB,MAAM,CAAC2B,UAAU,CAAC,WACpBC,KAA8B;EAE9B;EACA,IAAIC,MAA6F;EACjG,MAAMC,MAAM,GAAG,OAAO1B,SAAS,CAAC2B,mBAAmB,CAACH,KAAK,EAAE;IACzDI,YAAYA,CAACC,QAAQ;MACnB,OAAOJ,MAAM,CAACK,KAAK,CAACD,QAAQ,CAAC;IAC/B;GACD,CAAC;EACFJ,MAAM,GAAG,OAAO1B,SAAS,CAAC4B,mBAAmB,CAACH,KAAK,EAAE;IACnDO,WAAW,EAAE,IAAI;IACjBC,YAAYA,CAAC;MAAEC;IAAO,CAAE;MACtB,OAAOP,MAAM,CAACI,KAAK,CAAC,CAAC,EAAEG,OAAO,CAAC;IACjC;GACD,CAAC;EACF,OAAOR,MAAM,CAACA,MAAM;AACtB,CAAC,CAAC","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/cjs/RpcWorker.js b/dist/cjs/RpcWorker.js
new file mode 100644
index 0000000000000000000000000000000000000000..74a1d52ac4ce964fc9726b2d4f9dd45e2cca85c5
--- /dev/null
+++ b/dist/cjs/RpcWorker.js
@@ -0,0 +1,46 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.makeInitialMessage = exports.layerInitialMessage = exports.initialMessage = exports.InitialMessage = void 0;
+var Transferable = _interopRequireWildcard(require("@effect/platform/Transferable"));
+var Context = _interopRequireWildcard(require("effect/Context"));
+var Effect = _interopRequireWildcard(require("effect/Effect"));
+var Layer = _interopRequireWildcard(require("effect/Layer"));
+var Schema = _interopRequireWildcard(require("effect/Schema"));
+function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
+function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
+/**
+ * @since 1.0.0
+ */
+
+/**
+ * @since 1.0.0
+ * @category initial message
+ */
+class InitialMessage extends /*#__PURE__*/Context.Tag("@effect/rpc/RpcWorker/InitialMessage")() {}
+exports.InitialMessage = InitialMessage;
+const ProtocolTag = /*#__PURE__*/Context.GenericTag("@effect/rpc/RpcServer/Protocol");
+/**
+ * @since 1.0.0
+ * @category initial message
+ */
+const makeInitialMessage = (schema, effect) => Effect.flatMap(effect, value => {
+  const collector = Transferable.unsafeMakeCollector();
+  return Schema.encode(schema)(value).pipe(Effect.provideService(Transferable.Collector, collector), Effect.map(encoded => [encoded, collector.unsafeClear()]));
+});
+/**
+ * @since 1.0.0
+ * @category initial message
+ */
+exports.makeInitialMessage = makeInitialMessage;
+const layerInitialMessage = (schema, build) => Layer.effect(InitialMessage, Effect.contextWith(context => Effect.provide(Effect.orDie(makeInitialMessage(schema, build)), context)));
+/**
+ * @since 1.0.0
+ * @category initial message
+ */
+exports.layerInitialMessage = layerInitialMessage;
+const initialMessage = schema => ProtocolTag.pipe(Effect.flatMap(protocol => protocol.initialMessage), Effect.flatten, Effect.flatMap(Schema.decodeUnknown(schema)));
+exports.initialMessage = initialMessage;
+//# sourceMappingURL=RpcWorker.js.map
\ No newline at end of file
diff --git a/dist/cjs/RpcWorker.js.map b/dist/cjs/RpcWorker.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..45a2665c2a16b789b8eb7d2cd3ceff8a6b388d28
--- /dev/null
+++ b/dist/cjs/RpcWorker.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"RpcWorker.js","names":["Transferable","_interopRequireWildcard","require","Context","Effect","Layer","Schema","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","InitialMessage","Tag","exports","ProtocolTag","GenericTag","makeInitialMessage","schema","effect","flatMap","value","collector","unsafeMakeCollector","encode","pipe","provideService","Collector","map","encoded","unsafeClear","layerInitialMessage","build","contextWith","context","provide","orDie","initialMessage","protocol","flatten","decodeUnknown"],"sources":["../../src/RpcWorker.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/cjs/index.js b/dist/cjs/index.js
index f731e8759717e1341ffc71bf93af665eb31cef79..3ba7d9e776531a53bd931b0c320ece9cbb23a0ef 100644
--- a/dist/cjs/index.js
+++ b/dist/cjs/index.js
@@ -3,15 +3,27 @@
 Object.defineProperty(exports, "__esModule", {
   value: true
 });
-exports.RpcRouter = exports.RpcResolverNoStream = exports.RpcResolver = exports.Rpc = void 0;
+exports.RpcWorker = exports.RpcTest = exports.RpcServer = exports.RpcSerialization = exports.RpcSchema = exports.RpcMiddleware = exports.RpcMessage = exports.RpcGroup = exports.RpcClient = exports.Rpc = void 0;
 var _Rpc = _interopRequireWildcard(require("./Rpc.js"));
 exports.Rpc = _Rpc;
-var _RpcResolver = _interopRequireWildcard(require("./RpcResolver.js"));
-exports.RpcResolver = _RpcResolver;
-var _RpcResolverNoStream = _interopRequireWildcard(require("./RpcResolverNoStream.js"));
-exports.RpcResolverNoStream = _RpcResolverNoStream;
-var _RpcRouter = _interopRequireWildcard(require("./RpcRouter.js"));
-exports.RpcRouter = _RpcRouter;
+var _RpcClient = _interopRequireWildcard(require("./RpcClient.js"));
+exports.RpcClient = _RpcClient;
+var _RpcGroup = _interopRequireWildcard(require("./RpcGroup.js"));
+exports.RpcGroup = _RpcGroup;
+var _RpcMessage = _interopRequireWildcard(require("./RpcMessage.js"));
+exports.RpcMessage = _RpcMessage;
+var _RpcMiddleware = _interopRequireWildcard(require("./RpcMiddleware.js"));
+exports.RpcMiddleware = _RpcMiddleware;
+var _RpcSchema = _interopRequireWildcard(require("./RpcSchema.js"));
+exports.RpcSchema = _RpcSchema;
+var _RpcSerialization = _interopRequireWildcard(require("./RpcSerialization.js"));
+exports.RpcSerialization = _RpcSerialization;
+var _RpcServer = _interopRequireWildcard(require("./RpcServer.js"));
+exports.RpcServer = _RpcServer;
+var _RpcTest = _interopRequireWildcard(require("./RpcTest.js"));
+exports.RpcTest = _RpcTest;
+var _RpcWorker = _interopRequireWildcard(require("./RpcWorker.js"));
+exports.RpcWorker = _RpcWorker;
 function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
 function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
 //# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/dist/cjs/internal/utils.js b/dist/cjs/internal/utils.js
new file mode 100644
index 0000000000000000000000000000000000000000..5eab1c528518929a9c3108c253f1cce263dc2496
--- /dev/null
+++ b/dist/cjs/internal/utils.js
@@ -0,0 +1,36 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.withRun = void 0;
+var Effect = _interopRequireWildcard(require("effect/Effect"));
+function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
+function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
+/** @internal */
+const withRun = () => f => Effect.suspend(() => {
+  const semaphore = Effect.unsafeMakeSemaphore(1);
+  let buffer = [];
+  let write = (...args) => Effect.contextWith(context => {
+    buffer.push([args, context]);
+  });
+  return Effect.map(f((...args) => write(...args)), a => ({
+    ...a,
+    run(f) {
+      return semaphore.withPermits(1)(Effect.gen(function* () {
+        const prev = write;
+        write = f;
+        for (const [args, context] of buffer) {
+          yield* Effect.provide(write(...args), context);
+        }
+        buffer = [];
+        return yield* Effect.onExit(Effect.never, () => {
+          write = prev;
+          return Effect.void;
+        });
+      }));
+    }
+  }));
+});
+exports.withRun = withRun;
+//# sourceMappingURL=utils.js.map
\ No newline at end of file
diff --git a/dist/cjs/internal/utils.js.map b/dist/cjs/internal/utils.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..a68432bd6ceb54a2f13acd2227c1705213e1b6ff
--- /dev/null
+++ b/dist/cjs/internal/utils.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"utils.js","names":["Effect","_interopRequireWildcard","require","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","withRun","f","suspend","semaphore","unsafeMakeSemaphore","buffer","write","args","contextWith","context","push","map","run","withPermits","gen","prev","provide","onExit","never","void","exports"],"sources":["../../../src/internal/utils.ts"],"sourcesContent":[null],"mappings":";;;;;;AACA,IAAAA,MAAA,GAAAC,uBAAA,CAAAC,OAAA;AAAuC,SAAAC,yBAAAC,CAAA,6BAAAC,OAAA,mBAAAC,CAAA,OAAAD,OAAA,IAAAE,CAAA,OAAAF,OAAA,YAAAF,wBAAA,YAAAA,CAAAC,CAAA,WAAAA,CAAA,GAAAG,CAAA,GAAAD,CAAA,KAAAF,CAAA;AAAA,SAAAH,wBAAAG,CAAA,EAAAE,CAAA,SAAAA,CAAA,IAAAF,CAAA,IAAAA,CAAA,CAAAI,UAAA,SAAAJ,CAAA,eAAAA,CAAA,uBAAAA,CAAA,yBAAAA,CAAA,WAAAK,OAAA,EAAAL,CAAA,QAAAG,CAAA,GAAAJ,wBAAA,CAAAG,CAAA,OAAAC,CAAA,IAAAA,CAAA,CAAAG,GAAA,CAAAN,CAAA,UAAAG,CAAA,CAAAI,GAAA,CAAAP,CAAA,OAAAQ,CAAA,KAAAC,SAAA,UAAAC,CAAA,GAAAC,MAAA,CAAAC,cAAA,IAAAD,MAAA,CAAAE,wBAAA,WAAAC,CAAA,IAAAd,CAAA,oBAAAc,CAAA,OAAAC,cAAA,CAAAC,IAAA,CAAAhB,CAAA,EAAAc,CAAA,SAAAG,CAAA,GAAAP,CAAA,GAAAC,MAAA,CAAAE,wBAAA,CAAAb,CAAA,EAAAc,CAAA,UAAAG,CAAA,KAAAA,CAAA,CAAAV,GAAA,IAAAU,CAAA,CAAAC,GAAA,IAAAP,MAAA,CAAAC,cAAA,CAAAJ,CAAA,EAAAM,CAAA,EAAAG,CAAA,IAAAT,CAAA,CAAAM,CAAA,IAAAd,CAAA,CAAAc,CAAA,YAAAN,CAAA,CAAAH,OAAA,GAAAL,CAAA,EAAAG,CAAA,IAAAA,CAAA,CAAAe,GAAA,CAAAlB,CAAA,EAAAQ,CAAA,GAAAA,CAAA;AAEvC;AACO,MAAMW,OAAO,GAAGA,CAAA,KAKdC,CAA4E,IACnFxB,MAAM,CAACyB,OAAO,CAAC,MAAK;EAClB,MAAMC,SAAS,GAAG1B,MAAM,CAAC2B,mBAAmB,CAAC,CAAC,CAAC;EAC/C,IAAIC,MAAM,GAAgD,EAAE;EAC5D,IAAIC,KAAK,GAAGA,CAAC,GAAGC,IAAgB,KAC9B9B,MAAM,CAAC+B,WAAW,CAAEC,OAAO,IAAI;IAC7BJ,MAAM,CAACK,IAAI,CAAC,CAACH,IAAI,EAAEE,OAAO,CAAC,CAAC;EAC9B,CAAC,CAAC;EACJ,OAAOhC,MAAM,CAACkC,GAAG,CAACV,CAAC,CAAC,CAAC,GAAGM,IAAI,KAAKD,KAAK,CAAC,GAAGC,IAAI,CAAC,CAAC,EAAGhB,CAAC,KAAM;IACxD,GAAGA,CAAC;IACJqB,GAAGA,CAACX,CAAC;MACH,OAAOE,SAAS,CAACU,WAAW,CAAC,CAAC,CAAC,CAACpC,MAAM,CAACqC,GAAG,CAAC,aAAS;QAClD,MAAMC,IAAI,GAAGT,KAAK;QAClBA,KAAK,GAAGL,CAAC;QAET,KAAK,MAAM,CAACM,IAAI,EAAEE,OAAO,CAAC,IAAIJ,MAAM,EAAE;UACpC,OAAO5B,MAAM,CAACuC,OAAO,CAACV,KAAK,CAAC,GAAGC,IAAI,CAAC,EAAEE,OAAO,CAAC;QAChD;QACAJ,MAAM,GAAG,EAAE;QAEX,OAAO,OAAO5B,MAAM,CAACwC,MAAM,CAACxC,MAAM,CAACyC,KAAK,EAAE,MAAK;UAC7CZ,KAAK,GAAGS,IAAI;UACZ,OAAOtC,MAAM,CAAC0C,IAAI;QACpB,CAAC,CAAC;MACJ,CAAC,CAAC,CAAC;IACL;GACK,EAAC;AACV,CAAC,CAAC;AAAAC,OAAA,CAAApB,OAAA,GAAAA,OAAA","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/dts/Rpc.d.ts b/dist/dts/Rpc.d.ts
index ea17729cad33fac41a5c316aac495d938f7c24be..e27e4886e4aecbec1b9a7f8496217ed63a88651b 100644
--- a/dist/dts/Rpc.d.ts
+++ b/dist/dts/Rpc.d.ts
@@ -1,20 +1,16 @@
 /**
  * @since 1.0.0
  */
-import * as Headers from "@effect/platform/Headers";
-import type * as Context from "effect/Context";
-import * as Effect from "effect/Effect";
-import * as FiberRef from "effect/FiberRef";
-import type * as ParseResult from "effect/ParseResult";
+import type { Headers } from "@effect/platform/Headers";
+import * as Context_ from "effect/Context";
+import type { Effect } from "effect/Effect";
+import type { Exit as Exit_ } from "effect/Exit";
 import { type Pipeable } from "effect/Pipeable";
-import type * as PrimaryKey from "effect/PrimaryKey";
-import type * as Record from "effect/Record";
-import type * as EffectRequest from "effect/Request";
-import type * as RequestResolver from "effect/RequestResolver";
 import * as Schema from "effect/Schema";
-import type { Scope } from "effect/Scope";
-import * as Stream from "effect/Stream";
-import type * as Types from "effect/Types";
+import type * as AST from "effect/SchemaAST";
+import type { Stream } from "effect/Stream";
+import type * as RpcMiddleware from "./RpcMiddleware.js";
+import * as RpcSchema from "./RpcSchema.js";
 /**
  * @since 1.0.0
  * @category type ids
@@ -27,221 +23,300 @@ export declare const TypeId: unique symbol;
 export type TypeId = typeof TypeId;
 /**
  * @since 1.0.0
- * @category refinements
+ * @category guards
  */
-export declare const isRpc: (u: unknown) => u is Rpc<any, any>;
+export declare const isRpc: (u: unknown) => u is Rpc<any, any, any>;
 /**
+ * Represents an API endpoint. An API endpoint is mapped to a single route on
+ * the underlying `HttpRouter`.
+ *
  * @since 1.0.0
  * @category models
  */
-export type Rpc<Req extends Schema.TaggedRequest.All, R> = RpcEffect<Req, R> | RpcStream<Req, R>;
+export interface Rpc<out Tag extends string, out Payload extends AnyStructSchema = Schema.Struct<{}>, out Success extends Schema.Schema.Any = typeof Schema.Void, out Error extends Schema.Schema.All = typeof Schema.Never, out Middleware extends RpcMiddleware.TagClassAny = never> extends Pipeable {
+    readonly [TypeId]: TypeId;
+    readonly _tag: Tag;
+    readonly key: string;
+    readonly payloadSchema: Payload;
+    readonly successSchema: Success;
+    readonly errorSchema: Error;
+    readonly annotations: Context_.Context<never>;
+    readonly middlewares: ReadonlySet<Middleware>;
+    /**
+     * Set the schema for the success response of the rpc.
+     */
+    setSuccess<S extends Schema.Schema.Any>(schema: S): Rpc<Tag, Payload, S, Error, Middleware>;
+    /**
+     * Set the schema for the error response of the rpc.
+     */
+    setError<E extends Schema.Schema.Any>(schema: E): Rpc<Tag, Payload, Success, E, Middleware>;
+    /**
+     * Set the schema for the payload of the rpc.
+     */
+    setPayload<P extends Schema.Struct<any> | Schema.Struct.Fields>(schema: P): Rpc<Tag, P extends Schema.Struct<infer _> ? P : P extends Schema.Struct.Fields ? Schema.Struct<P> : never, Success, Error, Middleware>;
+    /**
+     * Add an `RpcMiddleware` to this procedure.
+     */
+    middleware<M extends RpcMiddleware.TagClassAny>(middleware: M): Rpc<Tag, Payload, Success, Error, Middleware | M>;
+    /**
+     * Add an annotation on the rpc.
+     */
+    annotate<I, S>(tag: Context_.Tag<I, S>, value: S): Rpc<Tag, Payload, Success, Error, Middleware>;
+    /**
+     * Merge the annotations of the rpc with the provided context.
+     */
+    annotateContext<I>(context: Context_.Context<I>): Rpc<Tag, Payload, Success, Error, Middleware>;
+}
 /**
+ * Represents an implemented rpc.
+ *
  * @since 1.0.0
  * @category models
  */
-export interface RpcEffect<Req extends Schema.TaggedRequest.All, R> extends Rpc.Proto<Req> {
-    readonly _tag: "Effect";
-    readonly handler: (request: Req) => Effect.Effect<EffectRequest.Request.Success<Req>, EffectRequest.Request.Error<Req>, R>;
+export interface Handler<Tag extends string> {
+    readonly _: unique symbol;
+    readonly tag: Tag;
+    readonly handler: (request: any, headers: Headers) => Effect<any, any> | Stream<any, any>;
+    readonly context: Context<never>;
 }
 /**
  * @since 1.0.0
  * @category models
  */
-export interface RpcStream<Req extends Schema.TaggedRequest.All, R> extends Rpc.Proto<Req> {
-    readonly _tag: "Stream";
-    readonly handler: (request: Req) => Stream.Stream<Req extends Schema.WithResult<infer A, infer _I, infer _E, infer _EI, infer _R> ? A : never, Req extends Schema.WithResult<infer _A, infer _I, infer E, infer _EI, infer _R> ? E : never, R>;
+export interface Any extends Pipeable {
+    readonly [TypeId]: TypeId;
+    readonly _tag: string;
+    readonly key: string;
 }
 /**
  * @since 1.0.0
  * @category models
  */
-export declare namespace Rpc {
-    /**
-     * @since 1.0.0
-     * @category models
-     */
-    interface Proto<Req extends Schema.TaggedRequest.All> extends Pipeable {
-        readonly [TypeId]: TypeId;
-        readonly _tag: string;
-        readonly schema: Schema.Schema<Req, any, unknown>;
-    }
-    /**
-     * @since 1.0.0
-     * @category models
-     */
-    type Context<A extends Rpc<any, any>> = A extends Rpc<infer Req, infer R> ? R | Schema.SerializableWithResult.Context<Req> : never;
-    /**
-     * @since 1.0.0
-     * @category models
-     */
-    type Request<A extends Rpc<any, any>> = Schema.Schema.Type<A["schema"]>;
-    /**
-     * @since 1.0.0
-     * @category models
-     */
-    type Result<A extends Schema.TaggedRequest.All, R = never> = StreamRequestTypeId extends keyof A ? EffectRequest.Request.Success<A> : Effect.Effect<EffectRequest.Request.Success<A>, EffectRequest.Request.Error<A>, R>;
-    /**
-     * @since 1.0.0
-     * @category models
-     */
-    type ResultUndecoded<A extends Schema.TaggedRequest.All, R = never> = A extends Schema.WithResult<infer _A, infer I, infer E, infer _EI, infer _R> ? StreamRequestTypeId extends keyof A ? Stream.Stream<I, E, R> : Effect.Effect<I, E, R> : never;
+export interface AnyWithProps {
+    readonly [TypeId]: TypeId;
+    readonly _tag: string;
+    readonly key: string;
+    readonly payloadSchema: AnyStructSchema;
+    readonly successSchema: Schema.Schema.Any;
+    readonly errorSchema: Schema.Schema.All;
+    readonly annotations: Context_.Context<never>;
+    readonly middlewares: ReadonlySet<RpcMiddleware.TagClassAnyWithProps>;
 }
 /**
  * @since 1.0.0
- * @category constructors
+ * @category models
  */
-export declare const effect: <Req extends Schema.TaggedRequest.All, R>(schema: Schema.Schema<Req, any, unknown>, handler: (request: Req) => Effect.Effect<EffectRequest.Request.Success<Req>, EffectRequest.Request.Error<Req>, R>) => Rpc<Req, R>;
+export type Tag<R> = R extends Rpc<infer _Tag, infer _Payload, infer _Success, infer _Error, infer _Middleware> ? _Tag : never;
 /**
  * @since 1.0.0
- * @category type ids
+ * @category models
  */
-export declare const StreamRequestTypeId: unique symbol;
+export type Success<R> = R extends Rpc<infer _Tag, infer _Payload, infer _Success, infer _Error, infer _Middleware> ? _Success["Type"] : never;
 /**
  * @since 1.0.0
- * @category type ids
+ * @category models
  */
-export type StreamRequestTypeId = typeof StreamRequestTypeId;
+export type SuccessEncoded<R> = R extends Rpc<infer _Tag, infer _Payload, infer _Success, infer _Error, infer _Middleware> ? _Success["Encoded"] : never;
 /**
  * @since 1.0.0
- * @category schemas
+ * @category models
  */
-export interface StreamRequest<Tag extends string, SR, SI, S, RR, EI, E, AI, A> extends EffectRequest.Request<Stream.Stream<A, E, never>>, Schema.SerializableWithResult<S, SI, SR, A, AI, E, EI, RR> {
-    readonly [StreamRequestTypeId]: StreamRequestTypeId;
-    readonly _tag: Tag;
-}
+export type SuccessExit<R> = Success<R> extends infer T ? T extends Stream<infer _A, infer _E, infer _Env> ? void : T : never;
 /**
  * @since 1.0.0
- * @category schemas
+ * @category models
  */
-export declare namespace StreamRequest {
-    /**
-     * @since 1.0.0
-     * @category schemas
-     */
-    type Any = StreamRequest<string, any, any, any, any, any, any, any, any> | StreamRequest<string, any, any, any, any, never, never, any, any>;
-}
+export type SuccessExitEncoded<R> = SuccessEncoded<R> extends infer T ? T extends Stream<infer _A, infer _E, infer _Env> ? void : T : never;
 /**
  * @since 1.0.0
- * @category schemas
+ * @category models
  */
-export interface StreamRequestConstructor<Tag extends string, Self, R, IS, S, RR, IE, E, IA, A> extends Schema.Schema<Self, Types.Simplify<IS & {
-    readonly _tag: Tag;
-}>, R> {
-    new (props: Types.Equals<S, {}> extends true ? void : S, disableValidation?: boolean): StreamRequest<Tag, R, IS & {
-        readonly _tag: Tag;
-    }, Self, RR, IE, E, IA, A> & S;
-}
+export type SuccessChunk<R> = Success<R> extends Stream<infer _A, infer _E, infer _Env> ? _A : never;
 /**
  * @since 1.0.0
- * @category schemas
+ * @category models
  */
-export declare const StreamRequest: <Self>() => <Tag extends string, E, IE, RE, A, IA, RA, Payload extends Schema.Struct.Fields>(tag: Tag, options: {
-    readonly failure: Schema.Schema<E, IE, RE>;
-    readonly success: Schema.Schema<A, IA, RA>;
-    readonly payload: Payload;
-}) => StreamRequestConstructor<Tag, Self, Schema.Schema.Context<Payload[keyof Payload]>, Types.Simplify<Schema.Struct.Encoded<Payload>>, Types.Simplify<Schema.Struct.Type<Payload>>, RE | RA, IE, E, IA, A>;
+export type SuccessChunkEncoded<R> = SuccessEncoded<R> extends Stream<infer _A, infer _E, infer _Env> ? _A : never;
 /**
  * @since 1.0.0
- * @category constructors
+ * @category models
  */
-export declare const stream: <Req extends StreamRequest.Any, R>(schema: Schema.Schema<Req, any, unknown>, handler: (request: Req) => Stream.Stream<Req extends Schema.WithResult<infer A, infer _I, infer _E, infer _EI, infer _R> ? A : never, Req extends Schema.WithResult<infer _A, infer _I_1, infer E, infer _EI_1, infer _R_1> ? E : never, R>) => Rpc<Req, R>;
+export type ErrorSchema<R> = R extends Rpc<infer _Tag, infer _Payload, infer _Success, infer _Error, infer _Middleware> ? _Error | _Middleware : never;
 /**
  * @since 1.0.0
  * @category models
  */
-export interface Request<A extends Schema.TaggedRequest.All> extends EffectRequest.Request<EffectRequest.Request.Success<A>, EffectRequest.Request.Error<A>>, PrimaryKey.PrimaryKey, Schema.WithResult<Schema.WithResult.Context<A>, Schema.Schema.Encoded<A[typeof Schema.symbolWithResult]["failure"]>, Schema.Schema.Type<A[typeof Schema.symbolWithResult]["failure"]>, Schema.Schema.Encoded<A[typeof Schema.symbolWithResult]["success"]>, Schema.Schema.Type<A[typeof Schema.symbolWithResult]["success"]>> {
-    readonly request: A;
-    readonly traceId: string;
-    readonly spanId: string;
-    readonly sampled: boolean;
-    readonly headers: Headers.Headers;
-}
+export type Error<R> = Schema.Schema.Type<ErrorSchema<R>>;
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export type ErrorEncoded<R> = Schema.Schema.Encoded<ErrorSchema<R>>;
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export type ErrorExit<R> = Success<R> extends Stream<infer _A, infer _E, infer _Env> ? _E | Error<R> : Error<R>;
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export type ErrorExitEncoded<R> = SuccessEncoded<R> extends Stream<infer _A, infer _E, infer _Env> ? _E | ErrorEncoded<R> : ErrorEncoded<R>;
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export type Exit<R> = Exit_<SuccessExit<R>, ErrorExit<R>>;
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export type ExitEncoded<R, Defect = unknown> = Schema.ExitEncoded<SuccessExitEncoded<R>, ErrorExitEncoded<R>, Defect>;
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export type PayloadConstructor<R> = R extends Rpc<infer _Tag, infer _Payload, infer _Success, infer _Error, infer _Middleware> ? Schema.Struct.Constructor<_Payload["fields"]> extends infer T ? [
+    keyof T
+] extends [never] ? void | {} : Schema.Simplify<T> : never : never;
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export type Payload<R> = R extends Rpc<infer _Tag, infer _Payload, infer _Success, infer _Error, infer _Middleware> ? _Payload["Type"] : never;
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export type Context<R> = R extends Rpc<infer _Tag, infer _Payload, infer _Success, infer _Error, infer _Middleware> ? _Payload["Context"] | _Success["Context"] | _Error["Context"] : never;
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export type Middleware<R> = R extends Rpc<infer _Tag, infer _Payload, infer _Success, infer _Error, infer _Middleware> ? Context_.Tag.Identifier<_Middleware> : never;
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export type MiddlewareClient<R> = R extends Rpc<infer _Tag, infer _Payload, infer _Success, infer _Error, infer _Middleware> ? _Middleware extends {
+    readonly requiredForClient: true;
+} ? RpcMiddleware.ForClient<Context_.Tag.Identifier<_Middleware>> : never : never;
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export type AddError<R extends Any, Error extends Schema.Schema.All> = R extends Rpc<infer _Tag, infer _Payload, infer _Success, infer _Error, infer _Middleware> ? Rpc<_Tag, _Payload, _Success, _Error | Error, _Middleware> : never;
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export type AddMiddleware<R extends Any, Middleware extends RpcMiddleware.TagClassAny> = R extends Rpc<infer _Tag, infer _Payload, infer _Success, infer _Error, infer _Middleware> ? Rpc<_Tag, _Payload, _Success, _Error, _Middleware | Middleware> : never;
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export type ToHandler<R extends Any> = R extends Rpc<infer _Tag, infer _Payload, infer _Success, infer _Error, infer _Middleware> ? Handler<_Tag> : never;
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export type IsStream<R extends Any, Tag extends string> = R extends Rpc<Tag, infer _Payload, RpcSchema.Stream<infer _A, infer _E>, infer _Error, infer _Middleware> ? true : never;
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export type ExtractTag<R extends Any, Tag extends string> = R extends Rpc<Tag, infer _Payload, infer _Success, infer _Error, infer _Middleware> ? R : never;
 /**
  * @since 1.0.0
  * @category models
  */
-export interface RequestFrom<A> {
-    readonly request: A;
-    readonly traceId: string;
-    readonly spanId: string;
-    readonly sampled: boolean;
-    readonly headers: Record<string, string>;
+export type ExtractProvides<R extends Any, Tag extends string> = R extends Rpc<Tag, infer _Payload, infer _Success, infer _Error, infer _Middleware> ? _Middleware extends {
+    readonly provides: Context_.Tag<infer _I, infer _S>;
+} ? _I : never : never;
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export type ExcludeProvides<Env, R extends Any, Tag extends string> = Exclude<Env, ExtractProvides<R, Tag>>;
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export interface From<S extends AnyTaggedRequestSchema> extends Rpc<S["_tag"], S, S["success"], S["failure"]> {
 }
 /**
  * @since 1.0.0
- * @category schemas
+ * @category constructors
  */
-export declare const RequestSchema: <A, I, R>(schema: Schema.Schema<A, I, R>) => Schema.Schema<RequestFrom<A>, RequestFrom<I>, R>;
+export declare const make: <const Tag extends string, Payload extends AnyStructSchema | Schema.Struct.Fields = Schema.Struct<{}>, Success extends Schema.Schema.Any = typeof Schema.Void, Error extends Schema.Schema.All = typeof Schema.Never, const Stream extends boolean = false>(tag: Tag, options?: {
+    readonly payload?: Payload;
+    readonly success?: Success;
+    readonly error?: Error;
+    readonly stream?: Stream;
+}) => Rpc<Tag, Payload extends Schema.Struct.Fields ? Schema.Struct<Payload> : Payload, Stream extends true ? RpcSchema.Stream<Success, Error> : Success, Stream extends true ? typeof Schema.Never : Error>;
 /**
  * @since 1.0.0
- * @category headers
+ * @category constructors
  */
-export declare const currentHeaders: FiberRef.FiberRef<Headers.Headers>;
+export interface AnyStructSchema extends Pipeable {
+    readonly [Schema.TypeId]: any;
+    readonly make: any;
+    readonly Type: any;
+    readonly Encoded: any;
+    readonly Context: any;
+    readonly ast: AST.AST;
+    readonly fields: Schema.Struct.Fields;
+    readonly annotations: any;
+}
 /**
  * @since 1.0.0
- * @category headers
+ * @category constructors
  */
-export declare const annotateHeaders: {
-    /**
-     * @since 1.0.0
-     * @category headers
-     */
-    (headers: Headers.Input): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>;
-    /**
-     * @since 1.0.0
-     * @category headers
-     */
-    <A, E, R>(self: Effect.Effect<A, E, R>, headers: Headers.Input): Effect.Effect<A, E, R>;
-};
+export interface AnyTaggedRequestSchema extends AnyStructSchema {
+    readonly _tag: string;
+    readonly success: Schema.Schema.Any;
+    readonly failure: Schema.Schema.All;
+}
 /**
  * @since 1.0.0
- * @category headers
+ * @category constructors
  */
-export declare const schemaHeaders: <R, I extends Record.ReadonlyRecord<string, string | undefined>, A>(schema: Schema.Schema<R, I, A>) => Effect.Effect<R, ParseResult.ParseError, A>;
+export declare const fromTaggedRequest: <S extends AnyTaggedRequestSchema>(schema: S) => From<S>;
 /**
  * @since 1.0.0
- * @category requests
+ * @category constructors
  */
-export declare const request: <A extends Schema.TaggedRequest.All>(request: A, options?: {
-    readonly spanPrefix?: string;
-}) => Effect.Effect<Request<A>, never, Scope>;
+export declare const exitSchema: <R extends Any>(self: R) => Schema.Schema<Exit<R>, ExitEncoded<R>, Context<R>>;
 /**
  * @since 1.0.0
- * @category requests
+ * @category Fork
  */
-export declare const call: <A extends Schema.TaggedRequest.All, R extends RequestResolver.RequestResolver<Request<A>> | Effect.Effect<RequestResolver.RequestResolver<Request<A>>, never, any>>(req: A, resolver: R, options?: {
-    readonly spanPrefix?: string;
-}) => R extends Effect.Effect<infer _A, infer _E, infer R_1> ? Rpc.Result<A, R_1> : Rpc.Result<A>;
+export declare const ForkTypeId: unique symbol;
 /**
  * @since 1.0.0
- * @category context
+ * @category Fork
  */
-export declare const provideServiceEffect: {
-    /**
-     * @since 1.0.0
-     * @category context
-     */
-    <I, S, E, R2>(tag: Context.Tag<I, S>, effect: Effect.Effect<S, E, R2>): <Req extends Schema.TaggedRequest.All, R>(self: Rpc<Req, R>) => Rpc<Req, Exclude<R, I> | R2>;
-    /**
-     * @since 1.0.0
-     * @category context
-     */
-    <Req extends Schema.TaggedRequest.All, R, I, S, E, R2>(self: Rpc<Req, R>, tag: Context.Tag<I, S>, effect: Effect.Effect<S, E, R2>): Rpc<Req, Exclude<R, I> | R2>;
-};
+export type ForkTypeId = typeof ForkTypeId;
 /**
  * @since 1.0.0
- * @category context
+ * @category Fork
  */
-export declare const provideService: {
-    /**
-     * @since 1.0.0
-     * @category context
-     */
-    <I, S>(tag: Context.Tag<I, S>, service: S): <Req extends Schema.TaggedRequest.All, R>(self: Rpc<Req, R>) => Rpc<Req, Exclude<R, I>>;
-    /**
-     * @since 1.0.0
-     * @category context
-     */
-    <Req extends Schema.TaggedRequest.All, R, I, S>(self: Rpc<Req, R>, tag: Context.Tag<I, S>, service: S): Rpc<Req, Exclude<R, I>>;
-};
+export interface Fork<A> {
+    readonly [ForkTypeId]: ForkTypeId;
+    readonly value: A;
+}
+/**
+ * You can use `fork` to wrap a response Effect or Stream, to ensure that the
+ * response is executed concurrently regardless of the RpcServer concurrency
+ * setting.
+ *
+ * @since 1.0.0
+ * @category Fork
+ */
+export declare const fork: <A>(value: A) => Fork<A>;
+/**
+ * @since 1.0.0
+ * @category Fork
+ */
+export declare const isFork: (u: object) => u is Fork<any>;
 //# sourceMappingURL=Rpc.d.ts.map
\ No newline at end of file
diff --git a/dist/dts/Rpc.d.ts.map b/dist/dts/Rpc.d.ts.map
index 0377b43c75ba362cfffb72b46978cbd91ef8cbb0..4139d4c6e2a778e8e3b8d808d556a962c77745a6 100644
--- a/dist/dts/Rpc.d.ts.map
+++ b/dist/dts/Rpc.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"Rpc.d.ts","sourceRoot":"","sources":["../../src/Rpc.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"Rpc.d.ts","sourceRoot":"","sources":["../../src/Rpc.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/dts/RpcClient.d.ts b/dist/dts/RpcClient.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..fcbf513dfb2dd5648d9209e0d71940519f7e3757
--- /dev/null
+++ b/dist/dts/RpcClient.d.ts
@@ -0,0 +1,186 @@
+/**
+ * @since 1.0.0
+ */
+import * as Headers from "@effect/platform/Headers";
+import * as HttpClient from "@effect/platform/HttpClient";
+import * as Socket from "@effect/platform/Socket";
+import * as Worker from "@effect/platform/Worker";
+import type { WorkerError } from "@effect/platform/WorkerError";
+import * as Context from "effect/Context";
+import type * as Duration from "effect/Duration";
+import * as Effect from "effect/Effect";
+import * as FiberRef from "effect/FiberRef";
+import * as Layer from "effect/Layer";
+import * as Mailbox from "effect/Mailbox";
+import * as Scope from "effect/Scope";
+import * as Stream from "effect/Stream";
+import * as Rpc from "./Rpc.js";
+import type * as RpcGroup from "./RpcGroup.js";
+import type { FromClient, FromClientEncoded, FromServer, FromServerEncoded, RequestId } from "./RpcMessage.js";
+import * as RpcSerialization from "./RpcSerialization.js";
+/**
+ * @since 1.0.0
+ * @category client
+ */
+export type RpcClient<Rpcs extends Rpc.Any, E = never> = {
+    readonly [Current in Rpcs as Current["_tag"]]: <const AsMailbox extends boolean = false, const Discard = false>(input: Rpc.PayloadConstructor<Current>, options?: Rpc.Success<Current> extends Stream.Stream<infer _A, infer _E, infer _R> ? {
+        readonly asMailbox?: AsMailbox | undefined;
+        readonly streamBufferSize?: number | undefined;
+        readonly headers?: Headers.Input | undefined;
+        readonly context?: Context.Context<never> | undefined;
+    } : {
+        readonly headers?: Headers.Input | undefined;
+        readonly context?: Context.Context<never> | undefined;
+        readonly discard?: Discard | undefined;
+    }) => Rpc.Success<Current> extends Stream.Stream<infer _A, infer _E, infer _R> ? AsMailbox extends true ? Effect.Effect<Mailbox.ReadonlyMailbox<_A, _E | Rpc.Error<Current> | E>, never, Scope.Scope | Rpc.Context<Current>> : Stream.Stream<_A, _E | Rpc.Error<Current> | E, Rpc.Context<Current>> : Effect.Effect<Discard extends true ? void : Rpc.Success<Current>, Discard extends true ? never : Rpc.Error<Current> | E, Rpc.Context<Current>>;
+};
+/**
+ * @since 1.0.0
+ * @category client
+ */
+export type FromGroup<Group> = RpcClient<RpcGroup.Rpcs<Group>>;
+/**
+ * @since 1.0.0
+ * @category client
+ */
+export declare const makeNoSerialization: <Rpcs extends Rpc.Any, E>(group: RpcGroup.RpcGroup<Rpcs>, options: {
+    readonly onFromClient: (options: {
+        readonly message: FromClient<Rpcs>;
+        readonly context: Context.Context<never>;
+        readonly discard: boolean;
+    }) => Effect.Effect<void, E>;
+    readonly supportsAck?: boolean | undefined;
+    readonly spanPrefix?: string | undefined;
+    readonly generateRequestId?: (() => RequestId) | undefined;
+    readonly disableTracing?: boolean | undefined;
+}) => Effect.Effect<{
+    readonly client: RpcClient<Rpcs, E>;
+    readonly write: (message: FromServer<Rpcs>) => Effect.Effect<void>;
+}, never, Scope.Scope | Rpc.MiddlewareClient<Rpcs>>;
+/**
+ * @since 1.0.0
+ * @category client
+ */
+export declare const make: <Rpcs extends Rpc.Any>(group: RpcGroup.RpcGroup<Rpcs>, options?: {
+    readonly spanPrefix?: string | undefined;
+    readonly generateRequestId?: (() => RequestId) | undefined;
+    readonly disableTracing?: boolean | undefined;
+} | undefined) => Effect.Effect<RpcClient<Rpcs>, never, Protocol | Rpc.MiddlewareClient<Rpcs> | Scope.Scope>;
+/**
+ * @since 1.0.0
+ * @category headers
+ */
+export declare const currentHeaders: FiberRef.FiberRef<Headers.Headers>;
+/**
+ * @since 1.0.0
+ * @category headers
+ */
+export declare const withHeaders: {
+    /**
+     * @since 1.0.0
+     * @category headers
+     */
+    (headers: Headers.Input): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>;
+    /**
+     * @since 1.0.0
+     * @category headers
+     */
+    <A, E, R>(effect: Effect.Effect<A, E, R>, headers: Headers.Input): Effect.Effect<A, E, R>;
+};
+/**
+ * @since 1.0.0
+ * @category headers
+ */
+export declare const withHeadersEffect: {
+    /**
+     * @since 1.0.0
+     * @category headers
+     */
+    <E2, R2>(headers: Effect.Effect<Headers.Input, E2, R2>): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E | E2, R | R2>;
+    /**
+     * @since 1.0.0
+     * @category headers
+     */
+    <A, E, R, E2, R2>(effect: Effect.Effect<A, E, R>, headers: Effect.Effect<Headers.Input, E2, R2>): Effect.Effect<A, E | E2, R | R2>;
+};
+declare const Protocol_base: Context.TagClass<Protocol, "@effect/rpc/RpcClient/Protocol", {
+    readonly run: (f: (data: FromServerEncoded) => Effect.Effect<void>) => Effect.Effect<never>;
+    readonly send: (request: FromClientEncoded, transferables?: ReadonlyArray<globalThis.Transferable>) => Effect.Effect<void>;
+    readonly supportsAck: boolean;
+    readonly supportsTransferables: boolean;
+}>;
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+export declare class Protocol extends Protocol_base {
+    /**
+     * @since 1.0.0
+     */
+    static make: <EX, RX>(f: (write: (data: FromServerEncoded) => Effect.Effect<void>) => Effect.Effect<Omit<{
+        readonly run: (f: (data: FromServerEncoded) => Effect.Effect<void>) => Effect.Effect<never>;
+        readonly send: (request: FromClientEncoded, transferables?: ReadonlyArray<globalThis.Transferable>) => Effect.Effect<void>;
+        readonly supportsAck: boolean;
+        readonly supportsTransferables: boolean;
+    }, "run">, EX, RX>) => Effect.Effect<{
+        readonly run: (f: (data: FromServerEncoded) => Effect.Effect<void>) => Effect.Effect<never>;
+        readonly send: (request: FromClientEncoded, transferables?: ReadonlyArray<globalThis.Transferable>) => Effect.Effect<void>;
+        readonly supportsAck: boolean;
+        readonly supportsTransferables: boolean;
+    }, EX, RX>;
+}
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+export declare const makeProtocolHttp: (client: HttpClient.HttpClient) => Effect.Effect<Protocol["Type"], never, RpcSerialization.RpcSerialization>;
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+export declare const layerProtocolHttp: (options: {
+    readonly url: string;
+    readonly transformClient?: <E, R>(client: HttpClient.HttpClient.With<E, R>) => HttpClient.HttpClient.With<E, R>;
+}) => Layer.Layer<Protocol, never, RpcSerialization.RpcSerialization | HttpClient.HttpClient>;
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+export declare const makeProtocolSocket: Effect.Effect<Protocol["Type"], never, Scope.Scope | RpcSerialization.RpcSerialization | Socket.Socket>;
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+export declare const makeProtocolWorker: (options: {
+    readonly size: number;
+    readonly concurrency?: number | undefined;
+    readonly targetUtilization?: number | undefined;
+} | {
+    readonly minSize: number;
+    readonly maxSize: number;
+    readonly concurrency?: number | undefined;
+    readonly targetUtilization?: number | undefined;
+    readonly timeToLive: Duration.DurationInput;
+}) => Effect.Effect<Protocol["Type"], WorkerError, Scope.Scope | Worker.PlatformWorker | Worker.Spawner>;
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+export declare const layerProtocolWorker: (options: {
+    readonly size: number;
+    readonly concurrency?: number | undefined;
+    readonly targetUtilization?: number | undefined;
+} | {
+    readonly minSize: number;
+    readonly maxSize: number;
+    readonly concurrency?: number | undefined;
+    readonly targetUtilization?: number | undefined;
+    readonly timeToLive: Duration.DurationInput;
+}) => Layer.Layer<Protocol, WorkerError, Worker.PlatformWorker | Worker.Spawner>;
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+export declare const layerProtocolSocket: Layer.Layer<Protocol, never, Socket.Socket | RpcSerialization.RpcSerialization>;
+export {};
+//# sourceMappingURL=RpcClient.d.ts.map
\ No newline at end of file
diff --git a/dist/dts/RpcClient.d.ts.map b/dist/dts/RpcClient.d.ts.map
new file mode 100644
index 0000000000000000000000000000000000000000..70f51a9514d00d7cf27ae7457b25b951649e84b7
--- /dev/null
+++ b/dist/dts/RpcClient.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"RpcClient.d.ts","sourceRoot":"","sources":["../../src/RpcClient.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/dts/RpcGroup.d.ts b/dist/dts/RpcGroup.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1224bfec89288ffa893aaf9db17a218b56bda8c3
--- /dev/null
+++ b/dist/dts/RpcGroup.d.ts
@@ -0,0 +1,98 @@
+/**
+ * @since 1.0.0
+ */
+import type { Headers } from "@effect/platform/Headers";
+import * as Context from "effect/Context";
+import * as Effect from "effect/Effect";
+import * as Layer from "effect/Layer";
+import type { ReadonlyMailbox } from "effect/Mailbox";
+import { type Pipeable } from "effect/Pipeable";
+import type { Scope } from "effect/Scope";
+import type * as Stream from "effect/Stream";
+import * as Rpc from "./Rpc.js";
+import type * as RpcMiddleware from "./RpcMiddleware.js";
+/**
+ * @since 1.0.0
+ * @category type ids
+ */
+export declare const TypeId: unique symbol;
+/**
+ * @since 1.0.0
+ * @category type ids
+ */
+export type TypeId = typeof TypeId;
+/**
+ * @since 1.0.0
+ * @category groups
+ */
+export interface RpcGroup<in out Rpcs extends Rpc.Any> extends Pipeable {
+    new (_: never): {};
+    readonly [TypeId]: TypeId;
+    readonly requests: ReadonlyMap<string, Rpcs>;
+    readonly annotations: Context.Context<never>;
+    /**
+     * Add one or more procedures to the group.
+     */
+    add<const Rpcs2 extends ReadonlyArray<Rpc.Any>>(...rpcs: Rpcs2): RpcGroup<Rpcs | Rpcs2[number]>;
+    /**
+     * Merge this group with another group.
+     */
+    merge<Rpcs2 extends Rpc.Any>(that: RpcGroup<Rpcs2>): RpcGroup<Rpcs | Rpcs2>;
+    /**
+     * Add middleware to all the procedures added to the group until this point.
+     */
+    middleware<M extends RpcMiddleware.TagClassAny>(middleware: M): RpcGroup<Rpc.AddMiddleware<Rpcs, M>>;
+    /**
+     * Implement the handlers for the procedures in this group, returning a
+     * context object.
+     */
+    toHandlersContext<Handlers extends HandlersFrom<Rpcs>, EX = never, RX = never>(build: Handlers | Effect.Effect<Handlers, EX, RX>): Effect.Effect<Context.Context<Rpc.ToHandler<Rpcs>>, EX, RX | HandlersContext<Rpcs, Handlers>>;
+    /**
+     * Implement the handlers for the procedures in this group.
+     */
+    toLayer<Handlers extends HandlersFrom<Rpcs>, EX = never, RX = never>(build: Handlers | Effect.Effect<Handlers, EX, RX>): Layer.Layer<Rpc.ToHandler<Rpcs>, EX, Exclude<RX, Scope> | HandlersContext<Rpcs, Handlers>>;
+    /**
+     * Annotate the group with a value.
+     */
+    annotate<I, S>(tag: Context.Tag<I, S>, value: S): RpcGroup<Rpcs>;
+    /**
+     * Annotate the Rpc's above this point with a value.
+     */
+    annotateRpcs<I, S>(tag: Context.Tag<I, S>, value: S): RpcGroup<Rpcs>;
+    /**
+     * Annotate the group with a context object.
+     */
+    annotateContext<S>(context: Context.Context<S>): RpcGroup<Rpcs>;
+    /**
+     * Annotate the Rpc's above this point with a context object.
+     */
+    annotateRpcsContext<S>(context: Context.Context<S>): RpcGroup<Rpcs>;
+}
+/**
+ * @since 1.0.0
+ * @category groups
+ */
+export type HandlersFrom<Rpc extends Rpc.Any> = {
+    readonly [Current in Rpc as Current["_tag"]]: (payload: Rpc.Payload<Current>, headers: Headers) => ResultFrom<Current> | Rpc.Fork<ResultFrom<Current>>;
+};
+/**
+ * @since 1.0.0
+ * @category groups
+ */
+export type ResultFrom<Rpc extends Rpc.Any> = Rpc.Success<Rpc> extends Stream.Stream<infer _A, infer _E, infer _R> ? Stream.Stream<_A, _E | Rpc.Error<Rpc>, any> | Effect.Effect<ReadonlyMailbox<_A, _E | Rpc.Error<Rpc>>, _E | Rpc.Error<Rpc>, any> : Effect.Effect<Rpc.Success<Rpc>, Rpc.Error<Rpc>, any>;
+/**
+ * @since 1.0.0
+ * @category groups
+ */
+export type HandlersContext<Rpcs extends Rpc.Any, Handlers> = keyof Handlers extends infer K ? K extends keyof Handlers & string ? [Rpc.IsStream<Rpcs, K>] extends [true] ? Handlers[K] extends (...args: any) => Stream.Stream<infer _A, infer _E, infer _R> | Rpc.Fork<Stream.Stream<infer _A, infer _E, infer _R>> | Effect.Effect<ReadonlyMailbox<infer _A, infer _E>, infer _EX, infer _R> | Rpc.Fork<Effect.Effect<ReadonlyMailbox<infer _A, infer _E>, infer _EX, infer _R>> ? Exclude<Rpc.ExcludeProvides<_R, Rpcs, K>, Scope> : never : Handlers[K] extends (...args: any) => Effect.Effect<infer _A, infer _E, infer _R> | Rpc.Fork<Effect.Effect<infer _A, infer _E, infer _R>> ? Rpc.ExcludeProvides<_R, Rpcs, K> : never : never : never;
+/**
+ * @since 1.0.0
+ * @category groups
+ */
+export type Rpcs<Group> = Group extends RpcGroup<infer R> ? R : never;
+/**
+ * @since 1.0.0
+ * @category groups
+ */
+export declare const make: <const Rpcs extends ReadonlyArray<Rpc.Any>>(...rpcs: Rpcs) => RpcGroup<Rpcs[number]>;
+//# sourceMappingURL=RpcGroup.d.ts.map
\ No newline at end of file
diff --git a/dist/dts/RpcGroup.d.ts.map b/dist/dts/RpcGroup.d.ts.map
new file mode 100644
index 0000000000000000000000000000000000000000..c3b2fff83e3a5693d96cf98bc90045e49a76e378
--- /dev/null
+++ b/dist/dts/RpcGroup.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"RpcGroup.d.ts","sourceRoot":"","sources":["../../src/RpcGroup.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/dts/RpcMessage.d.ts b/dist/dts/RpcMessage.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..15ee2a97e538c927e7becc1c5fcf5e9697f72e94
--- /dev/null
+++ b/dist/dts/RpcMessage.d.ts
@@ -0,0 +1,222 @@
+/**
+ * @since 1.0.0
+ */
+import type { Headers } from "@effect/platform/Headers";
+import type { NonEmptyReadonlyArray } from "effect/Array";
+import type { Branded } from "effect/Brand";
+import type * as FiberId from "effect/FiberId";
+import * as Schema from "effect/Schema";
+import type * as Rpc from "./Rpc.js";
+/**
+ * @since 1.0.0
+ * @category request
+ */
+export type FromClient<A extends Rpc.Any> = Request<A> | Ack | Interrupt | Eof;
+/**
+ * @since 1.0.0
+ * @category request
+ */
+export type FromClientEncoded = RequestEncoded | Ack | InterruptEncoded | Ping | Eof;
+/**
+ * @since 1.0.0
+ * @category request
+ */
+export declare const RequestIdTypeId: unique symbol;
+/**
+ * @since 1.0.0
+ * @category request
+ */
+export type RequestIdTypeId = typeof RequestIdTypeId;
+/**
+ * @since 1.0.0
+ * @category request
+ */
+export type RequestId = Branded<bigint, RequestIdTypeId>;
+/**
+ * @since 1.0.0
+ * @category request
+ */
+export declare const RequestId: (id: bigint | string) => RequestId;
+/**
+ * @since 1.0.0
+ * @category request
+ */
+export interface RequestEncoded {
+    readonly _tag: "Request";
+    readonly id: bigint | string;
+    readonly tag: string;
+    readonly payload: unknown;
+    readonly traceId: string;
+    readonly spanId: string;
+    readonly sampled: boolean;
+    readonly headers: ReadonlyArray<[string, string]>;
+}
+/**
+ * @since 1.0.0
+ * @category request
+ */
+export interface Request<A extends Rpc.Any> {
+    readonly _tag: "Request";
+    readonly id: RequestId;
+    readonly tag: Rpc.Tag<A>;
+    readonly payload: Rpc.Payload<A>;
+    readonly traceId: string;
+    readonly spanId: string;
+    readonly sampled: boolean;
+    readonly headers: Headers;
+}
+/**
+ * @since 1.0.0
+ * @category request
+ */
+export interface Ack {
+    readonly _tag: "Ack";
+    readonly requestId: RequestId;
+}
+/**
+ * @since 1.0.0
+ * @category request
+ */
+export interface Interrupt {
+    readonly _tag: "Interrupt";
+    readonly requestId: RequestId;
+    readonly interruptors: ReadonlyArray<FiberId.FiberId>;
+}
+/**
+ * @since 1.0.0
+ * @category request
+ */
+export interface InterruptEncoded {
+    readonly _tag: "Interrupt";
+    readonly requestId: RequestId;
+}
+/**
+ * @since 1.0.0
+ * @category request
+ */
+export interface Eof {
+    readonly _tag: "Eof";
+}
+/**
+ * @since 1.0.0
+ * @category request
+ */
+export interface Ping {
+    readonly _tag: "Ping";
+}
+/**
+ * @since 1.0.0
+ * @category request
+ */
+export declare const constEof: Eof;
+/**
+ * @since 1.0.0
+ * @category request
+ */
+export declare const constPing: Ping;
+/**
+ * @since 1.0.0
+ * @category response
+ */
+export type FromServer<A extends Rpc.Any> = ResponseChunk<A> | ResponseExit<A> | ResponseDefect | ClientEnd;
+/**
+ * @since 1.0.0
+ * @category response
+ */
+export type FromServerEncoded = ResponseChunkEncoded | ResponseExitEncoded | ResponseDefectEncoded | Pong;
+/**
+ * @since 1.0.0
+ * @category response
+ */
+export declare const ResponseIdTypeId: unique symbol;
+/**
+ * @since 1.0.0
+ * @category response
+ */
+export type ResponseIdTypeId = typeof ResponseIdTypeId;
+/**
+ * @since 1.0.0
+ * @category response
+ */
+export type ResponseId = Branded<number, ResponseIdTypeId>;
+/**
+ * @since 1.0.0
+ * @category response
+ */
+export interface ResponseChunkEncoded {
+    readonly _tag: "Chunk";
+    readonly requestId: bigint | string;
+    readonly values: NonEmptyReadonlyArray<unknown>;
+}
+/**
+ * @since 1.0.0
+ * @category response
+ */
+export interface ResponseChunk<A extends Rpc.Any> {
+    readonly _tag: "Chunk";
+    readonly clientId: number;
+    readonly requestId: RequestId;
+    readonly values: NonEmptyReadonlyArray<Rpc.SuccessChunk<A>>;
+}
+/**
+ * @since 1.0.0
+ * @category response
+ */
+export interface ResponseExitEncoded {
+    readonly _tag: "Exit";
+    readonly requestId: bigint | string;
+    readonly exit: Schema.ExitEncoded<unknown, unknown, unknown>;
+}
+/**
+ * @since 1.0.0
+ * @category response
+ */
+export interface ResponseExit<A extends Rpc.Any> {
+    readonly _tag: "Exit";
+    readonly clientId: number;
+    readonly requestId: RequestId;
+    readonly exit: Rpc.Exit<A>;
+}
+/**
+ * @since 1.0.0
+ * @category response
+ */
+export interface ResponseDefectEncoded {
+    readonly _tag: "Defect";
+    readonly defect: unknown;
+}
+/**
+ * @since 1.0.0
+ * @category response
+ */
+export declare const ResponseDefectEncoded: (input: unknown) => ResponseDefectEncoded;
+/**
+ * @since 1.0.0
+ * @category response
+ */
+export interface ResponseDefect {
+    readonly _tag: "Defect";
+    readonly clientId: number;
+    readonly defect: unknown;
+}
+/**
+ * @since 1.0.0
+ * @category response
+ */
+export interface ClientEnd {
+    readonly _tag: "ClientEnd";
+    readonly clientId: number;
+}
+/**
+ * @since 1.0.0
+ * @category response
+ */
+export interface Pong {
+    readonly _tag: "Pong";
+}
+/**
+ * @since 1.0.0
+ * @category response
+ */
+export declare const constPong: Pong;
+//# sourceMappingURL=RpcMessage.d.ts.map
\ No newline at end of file
diff --git a/dist/dts/RpcMessage.d.ts.map b/dist/dts/RpcMessage.d.ts.map
new file mode 100644
index 0000000000000000000000000000000000000000..7b51b93b533f3dc272f0ca39d4184e8a6c12a435
--- /dev/null
+++ b/dist/dts/RpcMessage.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"RpcMessage.d.ts","sourceRoot":"","sources":["../../src/RpcMessage.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/dts/RpcMiddleware.d.ts b/dist/dts/RpcMiddleware.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..25de8a8ab7d5ca570b9fcc179257b70155462406
--- /dev/null
+++ b/dist/dts/RpcMiddleware.d.ts
@@ -0,0 +1,180 @@
+/**
+ * @since 1.0.0
+ */
+import type { Headers } from "@effect/platform/Headers";
+import * as Context from "effect/Context";
+import * as Effect from "effect/Effect";
+import * as Layer from "effect/Layer";
+import * as Schema from "effect/Schema";
+import { Scope } from "effect/Scope";
+import type * as Rpc from "./Rpc.js";
+import type { Request } from "./RpcMessage.js";
+/**
+ * @since 1.0.0
+ * @category type ids
+ */
+export declare const TypeId: unique symbol;
+/**
+ * @since 1.0.0
+ * @category type ids
+ */
+export type TypeId = typeof TypeId;
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export interface RpcMiddleware<Provides, E> {
+    (options: {
+        readonly rpc: Rpc.AnyWithProps;
+        readonly payload: unknown;
+        readonly headers: Headers;
+    }): Effect.Effect<Provides, E>;
+}
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export interface RpcMiddlewareClient<R = never> {
+    (options: {
+        readonly rpc: Rpc.AnyWithProps;
+        readonly request: Request<Rpc.Any>;
+    }): Effect.Effect<Request<Rpc.Any>, never, R>;
+}
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export interface ForClient<Id> {
+    readonly _: unique symbol;
+    readonly id: Id;
+}
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export interface Any {
+    (options: {
+        readonly rpc: Rpc.AnyWithProps;
+        readonly payload: unknown;
+        readonly headers: Headers;
+    }): Effect.Effect<any, any>;
+}
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export interface TagClass<Self, Name extends string, Options> extends TagClass.Base<Self, Name, Options, RpcMiddleware<TagClass.Service<Options>, TagClass.FailureService<Options>>> {
+}
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export declare namespace TagClass {
+    /**
+     * @since 1.0.0
+     * @category models
+     */
+    type Provides<Options> = Options extends {
+        readonly provides: Context.Tag<any, any>;
+        readonly optional?: false;
+    } ? Context.Tag.Identifier<Options["provides"]> : never;
+    /**
+     * @since 1.0.0
+     * @category models
+     */
+    type Service<Options> = Options extends {
+        readonly provides: Context.Tag<any, any>;
+    } ? Context.Tag.Service<Options["provides"]> : void;
+    /**
+     * @since 1.0.0
+     * @category models
+     */
+    type FailureSchema<Options> = Options extends {
+        readonly failure: Schema.Schema.All;
+        readonly optional?: false;
+    } ? Options["failure"] : typeof Schema.Never;
+    /**
+     * @since 1.0.0
+     * @category models
+     */
+    type Failure<Options> = Options extends {
+        readonly failure: Schema.Schema<infer _A, infer _I, infer _R>;
+        readonly optional?: false;
+    } ? _A : never;
+    /**
+     * @since 1.0.0
+     * @category models
+     */
+    type FailureContext<Options> = Schema.Schema.Context<FailureSchema<Options>>;
+    /**
+     * @since 1.0.0
+     * @category models
+     */
+    type FailureService<Options> = Optional<Options> extends true ? unknown : Failure<Options>;
+    /**
+     * @since 1.0.0
+     * @category models
+     */
+    type Optional<Options> = Options extends {
+        readonly optional: true;
+    } ? true : false;
+    /**
+     * @since 1.0.0
+     * @category models
+     */
+    type RequiredForClient<Options> = Options extends {
+        readonly requiredForClient: true;
+    } ? true : false;
+    /**
+     * @since 1.0.0
+     * @category models
+     */
+    interface Base<Self, Name extends string, Options, Service> extends Context.Tag<Self, Service> {
+        new (_: never): Context.TagClassShape<Name, Service>;
+        readonly [TypeId]: TypeId;
+        readonly optional: Optional<Options>;
+        readonly failure: FailureSchema<Options>;
+        readonly provides: Options extends {
+            readonly provides: Context.Tag<any, any>;
+        } ? Options["provides"] : undefined;
+        readonly requiredForClient: RequiredForClient<Options>;
+    }
+}
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export interface TagClassAny extends Context.Tag<any, any> {
+    readonly [TypeId]: TypeId;
+    readonly optional: boolean;
+    readonly provides?: Context.Tag<any, any> | undefined;
+    readonly failure: Schema.Schema.All;
+    readonly requiredForClient: boolean;
+}
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export interface TagClassAnyWithProps extends Context.Tag<any, RpcMiddleware<any, any>> {
+    readonly [TypeId]: TypeId;
+    readonly optional: boolean;
+    readonly provides?: Context.Tag<any, any>;
+    readonly failure: Schema.Schema.All;
+    readonly requiredForClient: boolean;
+}
+/**
+ * @since 1.0.0
+ * @category tags
+ */
+export declare const Tag: <Self>() => <const Name extends string, const Options extends {
+    readonly optional?: boolean;
+    readonly failure?: Schema.Schema.All;
+    readonly provides?: Context.Tag<any, any>;
+    readonly requiredForClient?: boolean;
+}>(id: Name, options?: Options | undefined) => TagClass<Self, Name, Options>;
+/**
+ * @since 1.0.0
+ * @category client
+ */
+export declare const layerClient: <Id, S, R, EX = never, RX = never>(tag: Context.Tag<Id, S>, service: RpcMiddlewareClient<R> | Effect.Effect<RpcMiddlewareClient<R>, EX, RX>) => Layer.Layer<ForClient<Id>, EX, R | Exclude<RX, Scope>>;
+//# sourceMappingURL=RpcMiddleware.d.ts.map
\ No newline at end of file
diff --git a/dist/dts/RpcMiddleware.d.ts.map b/dist/dts/RpcMiddleware.d.ts.map
new file mode 100644
index 0000000000000000000000000000000000000000..240631deb2f010a23e40b811decdd478b7de6c1f
--- /dev/null
+++ b/dist/dts/RpcMiddleware.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"RpcMiddleware.d.ts","sourceRoot":"","sources":["../../src/RpcMiddleware.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/dts/RpcSchema.d.ts b/dist/dts/RpcSchema.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d3c7e0a19f9860b6de262d614ee0e65373bc22ff
--- /dev/null
+++ b/dist/dts/RpcSchema.d.ts
@@ -0,0 +1,44 @@
+import * as Option from "effect/Option";
+import * as Schema from "effect/Schema";
+import * as AST from "effect/SchemaAST";
+import * as Stream_ from "effect/Stream";
+/**
+ * @since 1.0.0
+ * @category Stream
+ */
+export declare const StreamSchemaId: unique symbol;
+/**
+ * @since 1.0.0
+ * @category Stream
+ */
+export declare const isStreamSchema: (schema: Schema.Schema.All) => schema is Stream<any, any>;
+/**
+ * @since 1.0.0
+ * @category Stream
+ */
+export declare const isStreamSerializable: (schema: Schema.WithResult.Any) => boolean;
+/**
+ * @since 1.0.0
+ * @category Stream
+ */
+export declare const getStreamSchemas: (ast: AST.AST) => Option.Option<{
+    readonly success: Schema.Schema.Any;
+    readonly failure: Schema.Schema.All;
+}>;
+/**
+ * @since 1.0.0
+ * @category Stream
+ */
+export interface Stream<A extends Schema.Schema.Any, E extends Schema.Schema.All> extends Schema.Schema<Stream_.Stream<A["Type"], E["Type"]>, Stream_.Stream<A["Encoded"], E["Encoded"]>, A["Context"] | E["Context"]> {
+    readonly success: A;
+    readonly failure: E;
+}
+/**
+ * @since 1.0.0
+ * @category Stream
+ */
+export declare const Stream: <A extends Schema.Schema.Any, E extends Schema.Schema.All>({ failure, success }: {
+    readonly failure: E;
+    readonly success: A;
+}) => Stream<A, E>;
+//# sourceMappingURL=RpcSchema.d.ts.map
\ No newline at end of file
diff --git a/dist/dts/RpcSchema.d.ts.map b/dist/dts/RpcSchema.d.ts.map
new file mode 100644
index 0000000000000000000000000000000000000000..ce3583241a0be1391f6d1710d3e7db455acc5331
--- /dev/null
+++ b/dist/dts/RpcSchema.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"RpcSchema.d.ts","sourceRoot":"","sources":["../../src/RpcSchema.ts"],"names":[],"mappings":"AAKA,OAAO,KAAK,MAAM,MAAM,eAAe,CAAA;AAGvC,OAAO,KAAK,MAAM,MAAM,eAAe,CAAA;AACvC,OAAO,KAAK,GAAG,MAAM,kBAAkB,CAAA;AACvC,OAAO,KAAK,OAAO,MAAM,eAAe,CAAA;AAExC;;;GAGG;AACH,eAAO,MAAM,cAAc,EAAE,OAAO,MAAmD,CAAA;AAEvF;;;GAGG;AACH,eAAO,MAAM,cAAc,WAAY,MAAM,CAAC,MAAM,CAAC,GAAG,KAAG,MAAM,IAAI,MAAM,CAAC,GAAG,EAAE,GAAG,CACf,CAAA;AAErE;;;GAGG;AACH,eAAO,MAAM,oBAAoB,WAAY,MAAM,CAAC,UAAU,CAAC,GAAG,KAAG,OACvB,CAAA;AAE9C;;;GAGG;AACH,eAAO,MAAM,gBAAgB,QACtB,GAAG,CAAC,GAAG,KACX,MAAM,CAAC,MAAM,CAAC;IACf,QAAQ,CAAC,OAAO,EAAE,MAAM,CAAC,MAAM,CAAC,GAAG,CAAA;IACnC,QAAQ,CAAC,OAAO,EAAE,MAAM,CAAC,MAAM,CAAC,GAAG,CAAA;CACpC,CAA0G,CAAA;AAE3G;;;GAGG;AACH,MAAM,WAAW,MAAM,CAAC,CAAC,SAAS,MAAM,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC,SAAS,MAAM,CAAC,MAAM,CAAC,GAAG,CAAE,SAChF,MAAM,CAAC,MAAM,CACX,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,EACpC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC,SAAS,CAAC,CAAC,EAC1C,CAAC,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,SAAS,CAAC,CAC5B;IAED,QAAQ,CAAC,OAAO,EAAE,CAAC,CAAA;IACnB,QAAQ,CAAC,OAAO,EAAE,CAAC,CAAA;CACpB;AAED;;;GAGG;AACH,eAAO,MAAM,MAAM,GAAI,CAAC,SAAS,MAAM,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC,SAAS,MAAM,CAAC,MAAM,CAAC,GAAG,wBACvD;IACpB,QAAQ,CAAC,OAAO,EAAE,CAAC,CAAA;IACnB,QAAQ,CAAC,OAAO,EAAE,CAAC,CAAA;CACpB,KACA,MAAM,CAAC,CAAC,EAAE,CAAC,CAyBX,CAAA"}
\ No newline at end of file
diff --git a/dist/dts/RpcSerialization.d.ts b/dist/dts/RpcSerialization.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e2ad70a3c3ba425d160f22dd0487ab6da80797c5
--- /dev/null
+++ b/dist/dts/RpcSerialization.d.ts
@@ -0,0 +1,69 @@
+import * as Context from "effect/Context";
+import * as Effect from "effect/Effect";
+import * as Layer from "effect/Layer";
+declare const RpcSerialization_base: Context.TagClass<RpcSerialization, "@effect/rpc/RpcSerialization", {
+    unsafeMake(): Parser;
+    readonly contentType: string;
+    readonly supportsBigInt: boolean;
+}>;
+/**
+ * @since 1.0.0
+ * @category serialization
+ */
+export declare class RpcSerialization extends RpcSerialization_base {
+}
+/**
+ * @since 1.0.0
+ * @category serialization
+ */
+export interface Parser {
+    readonly decode: (data: Uint8Array | string) => ReadonlyArray<unknown>;
+    readonly encode: (response: unknown) => Uint8Array | string;
+}
+/**
+ * @since 1.0.0
+ * @category serialization
+ */
+export declare const json: Effect.Effect<RpcSerialization["Type"]>;
+/**
+ * @since 1.0.0
+ * @category serialization
+ */
+export declare const ndjson: Effect.Effect<RpcSerialization["Type"]>;
+/**
+ * @since 1.0.0
+ * @category serialization
+ */
+export declare const msgPack: RpcSerialization["Type"];
+/**
+ * A rpc serialization layer that uses JSON for serialization.
+ *
+ * Use this if your protocol supports framing for messages, otherwise use
+ * `layerSerializationNdjson`.
+ *
+ * @since 1.0.0
+ * @category serialization
+ */
+export declare const layerJson: Layer.Layer<RpcSerialization>;
+/**
+ * A rpc serialization layer that uses NDJSON for serialization.
+ *
+ * Use this if your protocol does not support framing for messages, otherwise
+ * use `layerSerializationJson`.
+ *
+ * @since 1.0.0
+ * @category serialization
+ */
+export declare const layerNdjson: Layer.Layer<RpcSerialization>;
+/**
+ * A rpc serialization layer that uses MessagePack for serialization.
+ *
+ * MessagePack has a more compact binary format compared to JSON and NDJSON. It
+ * also has better support for binary data.
+ *
+ * @since 1.0.0
+ * @category serialization
+ */
+export declare const layerMsgPack: Layer.Layer<RpcSerialization>;
+export {};
+//# sourceMappingURL=RpcSerialization.d.ts.map
\ No newline at end of file
diff --git a/dist/dts/RpcSerialization.d.ts.map b/dist/dts/RpcSerialization.d.ts.map
new file mode 100644
index 0000000000000000000000000000000000000000..9568622963e866233379112c2907f4a5372640f7
--- /dev/null
+++ b/dist/dts/RpcSerialization.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"RpcSerialization.d.ts","sourceRoot":"","sources":["../../src/RpcSerialization.ts"],"names":[],"mappings":"AAIA,OAAO,KAAK,OAAO,MAAM,gBAAgB,CAAA;AACzC,OAAO,KAAK,MAAM,MAAM,eAAe,CAAA;AACvC,OAAO,KAAK,KAAK,MAAM,cAAc,CAAA;;kBAOrB,MAAM;0BACE,MAAM;6BACH,OAAO;;AAPlC;;;GAGG;AACH,qBAAa,gBAAiB,SAAQ,qBAIlC;CAAG;AAEP;;;GAGG;AACH,MAAM,WAAW,MAAM;IACrB,QAAQ,CAAC,MAAM,EAAE,CAAC,IAAI,EAAE,UAAU,GAAG,MAAM,KAAK,aAAa,CAAC,OAAO,CAAC,CAAA;IACtE,QAAQ,CAAC,MAAM,EAAE,CAAC,QAAQ,EAAE,OAAO,KAAK,UAAU,GAAG,MAAM,CAAA;CAC5D;AAED;;;GAGG;AACH,eAAO,MAAM,IAAI,EAAE,MAAM,CAAC,MAAM,CAAC,gBAAgB,CAAC,MAAM,CAAC,CAUvD,CAAA;AAEF;;;GAGG;AACH,eAAO,MAAM,MAAM,EAAE,MAAM,CAAC,MAAM,CAAC,gBAAgB,CAAC,MAAM,CAAC,CA0BzD,CAAA;AAEF;;;GAGG;AACH,eAAO,MAAM,OAAO,EAAE,gBAAgB,CAAC,MAAM,CAY3C,CAAA;AAEF;;;;;;;;GAQG;AACH,eAAO,MAAM,SAAS,EAAE,KAAK,CAAC,KAAK,CAAC,gBAAgB,CAAwC,CAAA;AAE5F;;;;;;;;GAQG;AACH,eAAO,MAAM,WAAW,EAAE,KAAK,CAAC,KAAK,CAAC,gBAAgB,CAA0C,CAAA;AAEhG;;;;;;;;GAQG;AACH,eAAO,MAAM,YAAY,EAAE,KAAK,CAAC,KAAK,CAAC,gBAAgB,CAA4C,CAAA"}
\ No newline at end of file
diff --git a/dist/dts/RpcServer.d.ts b/dist/dts/RpcServer.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..fe5cd1c8cae74380ae63a31f61a5f72b2cea31e7
--- /dev/null
+++ b/dist/dts/RpcServer.d.ts
@@ -0,0 +1,217 @@
+import * as HttpApp from "@effect/platform/HttpApp";
+import * as HttpRouter from "@effect/platform/HttpRouter";
+import * as SocketServer from "@effect/platform/SocketServer";
+import type { WorkerError } from "@effect/platform/WorkerError";
+import * as WorkerRunner from "@effect/platform/WorkerRunner";
+import * as Context from "effect/Context";
+import * as Effect from "effect/Effect";
+import * as Layer from "effect/Layer";
+import * as Mailbox from "effect/Mailbox";
+import * as Option from "effect/Option";
+import * as Scope from "effect/Scope";
+import * as Rpc from "./Rpc.js";
+import type * as RpcGroup from "./RpcGroup.js";
+import { type FromClient, type FromClientEncoded, type FromServer, type FromServerEncoded } from "./RpcMessage.js";
+import * as RpcSerialization from "./RpcSerialization.js";
+/**
+ * @since 1.0.0
+ * @category server
+ */
+export interface RpcServer<A extends Rpc.Any> {
+    readonly write: (clientId: number, message: FromClient<A>) => Effect.Effect<void>;
+    readonly disconnect: (clientId: number) => Effect.Effect<void>;
+}
+/**
+ * @since 1.0.0
+ * @category server
+ */
+export declare const makeNoSerialization: <Rpcs extends Rpc.Any>(group: RpcGroup.RpcGroup<Rpcs>, options: {
+    readonly onFromServer: (response: FromServer<Rpcs>) => Effect.Effect<void>;
+    readonly disableTracing?: boolean | undefined;
+    readonly disableSpanPropagation?: boolean | undefined;
+    readonly spanPrefix?: string | undefined;
+    readonly disableClientAcks?: boolean | undefined;
+    readonly concurrency?: number | "unbounded" | undefined;
+}) => Effect.Effect<RpcServer<Rpcs>, never, Rpc.ToHandler<Rpcs> | Rpc.Middleware<Rpcs> | Scope.Scope>;
+/**
+ * @since 1.0.0
+ * @category server
+ */
+export declare const make: <Rpcs extends Rpc.Any>(group: RpcGroup.RpcGroup<Rpcs>, options?: {
+    readonly disableTracing?: boolean | undefined;
+    readonly spanPrefix?: string | undefined;
+    readonly concurrency?: number | "unbounded" | undefined;
+} | undefined) => Effect.Effect<never, never, Protocol | Rpc.ToHandler<Rpcs> | Rpc.Middleware<Rpcs>>;
+/**
+ * @since 1.0.0
+ * @category server
+ */
+export declare const layer: <Rpcs extends Rpc.Any>(group: RpcGroup.RpcGroup<Rpcs>, options?: {
+    readonly disableTracing?: boolean | undefined;
+    readonly spanPrefix?: string | undefined;
+    readonly concurrency?: number | "unbounded" | undefined;
+}) => Layer.Layer<never, never, Protocol | Rpc.ToHandler<Rpcs> | Rpc.Middleware<Rpcs>>;
+declare const Protocol_base: Context.TagClass<Protocol, "@effect/rpc/RpcServer/Protocol", {
+    readonly run: (f: (clientId: number, data: FromClientEncoded) => Effect.Effect<void>) => Effect.Effect<never>;
+    readonly disconnects: Mailbox.ReadonlyMailbox<number>;
+    readonly send: (clientId: number, response: FromServerEncoded, transferables?: ReadonlyArray<globalThis.Transferable>) => Effect.Effect<void>;
+    readonly end: (clientId: number) => Effect.Effect<void>;
+    readonly initialMessage: Effect.Effect<Option.Option<unknown>>;
+    readonly supportsAck: boolean;
+    readonly supportsTransferables: boolean;
+    readonly supportsSpanPropagation: boolean;
+}>;
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+export declare class Protocol extends Protocol_base {
+    /**
+     * @since 1.0.0
+     */
+    static make: <EX, RX>(f: (write: (clientId: number, data: FromClientEncoded) => Effect.Effect<void>) => Effect.Effect<Omit<{
+        readonly run: (f: (clientId: number, data: FromClientEncoded) => Effect.Effect<void>) => Effect.Effect<never>;
+        readonly disconnects: Mailbox.ReadonlyMailbox<number>;
+        readonly send: (clientId: number, response: FromServerEncoded, transferables?: ReadonlyArray<globalThis.Transferable>) => Effect.Effect<void>;
+        readonly end: (clientId: number) => Effect.Effect<void>;
+        readonly initialMessage: Effect.Effect<Option.Option<unknown>>;
+        readonly supportsAck: boolean;
+        readonly supportsTransferables: boolean;
+        readonly supportsSpanPropagation: boolean;
+    }, "run">, EX, RX>) => Effect.Effect<{
+        readonly run: (f: (clientId: number, data: FromClientEncoded) => Effect.Effect<void>) => Effect.Effect<never>;
+        readonly disconnects: Mailbox.ReadonlyMailbox<number>;
+        readonly send: (clientId: number, response: FromServerEncoded, transferables?: ReadonlyArray<globalThis.Transferable>) => Effect.Effect<void>;
+        readonly end: (clientId: number) => Effect.Effect<void>;
+        readonly initialMessage: Effect.Effect<Option.Option<unknown>>;
+        readonly supportsAck: boolean;
+        readonly supportsTransferables: boolean;
+        readonly supportsSpanPropagation: boolean;
+    }, EX, RX>;
+}
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+export declare const makeProtocolSocketServer: Effect.Effect<{
+    readonly run: (f: (clientId: number, data: FromClientEncoded) => Effect.Effect<void>) => Effect.Effect<never>;
+    readonly disconnects: Mailbox.ReadonlyMailbox<number>;
+    readonly send: (clientId: number, response: FromServerEncoded, transferables?: ReadonlyArray<globalThis.Transferable>) => Effect.Effect<void>;
+    readonly end: (clientId: number) => Effect.Effect<void>;
+    readonly initialMessage: Effect.Effect<Option.Option<unknown>>;
+    readonly supportsAck: boolean;
+    readonly supportsTransferables: boolean;
+    readonly supportsSpanPropagation: boolean;
+}, never, Scope.Scope | RpcSerialization.RpcSerialization | SocketServer.SocketServer>;
+/**
+ * A rpc protocol that uses `SocketServer` for communication.
+ *
+ * @since 1.0.0
+ * @category protocol
+ */
+export declare const layerProtocolSocketServer: Layer.Layer<Protocol, never, RpcSerialization.RpcSerialization | SocketServer.SocketServer>;
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+export declare const makeProtocolWithHttpAppWebsocket: Effect.Effect<{
+    readonly protocol: Protocol["Type"];
+    readonly httpApp: HttpApp.Default<never, Scope.Scope>;
+}, never, RpcSerialization.RpcSerialization>;
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+export declare const makeProtocolWebsocket: <I = HttpRouter.Default>(options: {
+    readonly path: HttpRouter.PathInput;
+    readonly routerTag?: Context.Tag<I, HttpRouter.HttpRouter.Service<any, any>>;
+}) => Effect.Effect<Protocol["Type"], never, RpcSerialization.RpcSerialization | I>;
+/**
+ * A rpc protocol that uses websockets for communication.
+ *
+ * @since 1.0.0
+ * @category protocol
+ */
+export declare const layerProtocolWebsocket: <I = HttpRouter.Default>(options: {
+    readonly path: HttpRouter.PathInput;
+    readonly routerTag?: HttpRouter.HttpRouter.TagClass<I, string, any, any>;
+}) => Layer.Layer<Protocol, never, RpcSerialization.RpcSerialization>;
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+export declare const makeProtocolWithHttpApp: Effect.Effect<{
+    readonly protocol: Protocol["Type"];
+    readonly httpApp: HttpApp.Default<never, Scope.Scope>;
+}, never, RpcSerialization.RpcSerialization>;
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+export declare const makeProtocolHttp: <I = HttpRouter.Default>(options: {
+    readonly path: HttpRouter.PathInput;
+    readonly routerTag?: HttpRouter.HttpRouter.TagClass<I, string, any, any>;
+}) => Effect.Effect<{
+    readonly run: (f: (clientId: number, data: FromClientEncoded) => Effect.Effect<void>) => Effect.Effect<never>;
+    readonly disconnects: Mailbox.ReadonlyMailbox<number>;
+    readonly send: (clientId: number, response: FromServerEncoded, transferables?: ReadonlyArray<globalThis.Transferable>) => Effect.Effect<void>;
+    readonly end: (clientId: number) => Effect.Effect<void>;
+    readonly initialMessage: Effect.Effect<Option.Option<unknown>>;
+    readonly supportsAck: boolean;
+    readonly supportsTransferables: boolean;
+    readonly supportsSpanPropagation: boolean;
+}, never, RpcSerialization.RpcSerialization | I>;
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+export declare const makeProtocolWorkerRunner: Effect.Effect<Protocol["Type"], WorkerError, WorkerRunner.PlatformRunner | Scope.Scope>;
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+export declare const layerProtocolWorkerRunner: Layer.Layer<Protocol, WorkerError, WorkerRunner.PlatformRunner>;
+/**
+ * A rpc protocol that uses streaming http for communication.
+ *
+ * @since 1.0.0
+ * @category protocol
+ */
+export declare const layerProtocolHttp: <I = HttpRouter.Default>(options: {
+    readonly path: HttpRouter.PathInput;
+    readonly routerTag?: HttpRouter.HttpRouter.TagClass<I, string, any, any>;
+}) => Layer.Layer<Protocol, never, RpcSerialization.RpcSerialization>;
+/**
+ * @since 1.0.0
+ * @category http app
+ */
+export declare const toHttpApp: <Rpcs extends Rpc.Any>(group: RpcGroup.RpcGroup<Rpcs>, options?: {
+    readonly disableTracing?: boolean | undefined;
+    readonly spanPrefix?: string | undefined;
+} | undefined) => Effect.Effect<HttpApp.Default<never, Scope.Scope>, never, Scope.Scope | RpcSerialization.RpcSerialization | Rpc.ToHandler<Rpcs> | Rpc.Middleware<Rpcs>>;
+/**
+ * @since 1.0.0
+ * @category http app
+ */
+export declare const toHttpAppWebsocket: <Rpcs extends Rpc.Any>(group: RpcGroup.RpcGroup<Rpcs>, options?: {
+    readonly disableTracing?: boolean | undefined;
+    readonly spanPrefix?: string | undefined;
+} | undefined) => Effect.Effect<HttpApp.Default<never, Scope.Scope>, never, Scope.Scope | RpcSerialization.RpcSerialization | Rpc.ToHandler<Rpcs> | Rpc.Middleware<Rpcs>>;
+/**
+ * Construct an http web handler from an `RpcGroup`.
+ *
+ * @since 1.0.0
+ * @category constructors
+ */
+export declare const toWebHandler: <Rpcs extends Rpc.Any, LE>(group: RpcGroup.RpcGroup<Rpcs>, options: {
+    readonly layer: Layer.Layer<Rpc.ToHandler<Rpcs> | Rpc.Middleware<Rpcs> | RpcSerialization.RpcSerialization | HttpRouter.HttpRouter.DefaultServices, LE>;
+    readonly disableTracing?: boolean | undefined;
+    readonly spanPrefix?: string | undefined;
+    readonly middleware?: (httpApp: HttpApp.Default) => HttpApp.Default<never, HttpRouter.HttpRouter.DefaultServices>;
+    readonly memoMap?: Layer.MemoMap;
+}) => {
+    readonly handler: (request: globalThis.Request, context?: Context.Context<never> | undefined) => Promise<Response>;
+    readonly dispose: () => Promise<void>;
+};
+export {};
+//# sourceMappingURL=RpcServer.d.ts.map
\ No newline at end of file
diff --git a/dist/dts/RpcServer.d.ts.map b/dist/dts/RpcServer.d.ts.map
new file mode 100644
index 0000000000000000000000000000000000000000..e89400ee70a5650bb94510251277ace9a40e968d
--- /dev/null
+++ b/dist/dts/RpcServer.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"RpcServer.d.ts","sourceRoot":"","sources":["../../src/RpcServer.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/dts/RpcTest.d.ts b/dist/dts/RpcTest.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..375d57de11c0df9ee7f8aa3f1cde2b01a23eaec8
--- /dev/null
+++ b/dist/dts/RpcTest.d.ts
@@ -0,0 +1,14 @@
+/**
+ * @since 1.0.0
+ */
+import * as Effect from "effect/Effect";
+import type * as Scope from "effect/Scope";
+import type * as Rpc from "./Rpc.js";
+import * as RpcClient from "./RpcClient.js";
+import type * as RpcGroup from "./RpcGroup.js";
+/**
+ * @since 1.0.0
+ * @category constructors
+ */
+export declare const makeClient: <Rpcs extends Rpc.Any>(group: RpcGroup.RpcGroup<Rpcs>) => Effect.Effect<RpcClient.RpcClient<Rpcs>, never, Scope.Scope | Rpc.ToHandler<Rpcs> | Rpc.Middleware<Rpcs> | Rpc.MiddlewareClient<Rpcs>>;
+//# sourceMappingURL=RpcTest.d.ts.map
\ No newline at end of file
diff --git a/dist/dts/RpcTest.d.ts.map b/dist/dts/RpcTest.d.ts.map
new file mode 100644
index 0000000000000000000000000000000000000000..2818d099369f90704c18e67a7f1ba64ffe3ed458
--- /dev/null
+++ b/dist/dts/RpcTest.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"RpcTest.d.ts","sourceRoot":"","sources":["../../src/RpcTest.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,OAAO,KAAK,MAAM,MAAM,eAAe,CAAA;AACvC,OAAO,KAAK,KAAK,KAAK,MAAM,cAAc,CAAA;AAC1C,OAAO,KAAK,KAAK,GAAG,MAAM,UAAU,CAAA;AACpC,OAAO,KAAK,SAAS,MAAM,gBAAgB,CAAA;AAC3C,OAAO,KAAK,KAAK,QAAQ,MAAM,eAAe,CAAA;AAG9C;;;GAGG;AACH,eAAO,MAAM,UAAU,EAAE,CAAC,IAAI,SAAS,GAAG,CAAC,GAAG,EAC5C,KAAK,EAAE,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,KAC3B,MAAM,CAAC,MAAM,CAChB,SAAS,CAAC,SAAS,CAAC,IAAI,CAAC,EACzB,KAAK,EACL,KAAK,CAAC,KAAK,GAAG,GAAG,CAAC,SAAS,CAAC,IAAI,CAAC,GAAG,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,GAAG,GAAG,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAkBrF,CAAA"}
\ No newline at end of file
diff --git a/dist/dts/RpcWorker.d.ts b/dist/dts/RpcWorker.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..bfcb8d162b738b30cc2c743086b7cd76cc897406
--- /dev/null
+++ b/dist/dts/RpcWorker.d.ts
@@ -0,0 +1,45 @@
+import type { NoSuchElementException } from "effect/Cause";
+import * as Context from "effect/Context";
+import * as Effect from "effect/Effect";
+import * as Layer from "effect/Layer";
+import type { ParseError } from "effect/ParseResult";
+import * as Schema from "effect/Schema";
+import type { Protocol } from "./RpcServer.js";
+declare const InitialMessage_base: Context.TagClass<InitialMessage, "@effect/rpc/RpcWorker/InitialMessage", Effect.Effect<readonly [data: unknown, transfers: readonly Transferable[]], never, never>>;
+/**
+ * @since 1.0.0
+ * @category initial message
+ */
+export declare class InitialMessage extends InitialMessage_base {
+}
+/**
+ * @since 1.0.0
+ * @category initial message
+ */
+export declare namespace InitialMessage {
+    /**
+     * @since 1.0.0
+     * @category initial message
+     */
+    interface Encoded {
+        readonly _tag: "InitialMessage";
+        readonly value: unknown;
+    }
+}
+/**
+ * @since 1.0.0
+ * @category initial message
+ */
+export declare const makeInitialMessage: <A, I, R, E, R2>(schema: Schema.Schema<A, I, R>, effect: Effect.Effect<A, E, R2>) => Effect.Effect<readonly [data: unknown, transferables: ReadonlyArray<globalThis.Transferable>], E | ParseError, R | R2>;
+/**
+ * @since 1.0.0
+ * @category initial message
+ */
+export declare const layerInitialMessage: <A, I, R, R2>(schema: Schema.Schema<A, I, R>, build: Effect.Effect<A, never, R2>) => Layer.Layer<InitialMessage, never, R | R2>;
+/**
+ * @since 1.0.0
+ * @category initial message
+ */
+export declare const initialMessage: <A, I, R>(schema: Schema.Schema<A, I, R>) => Effect.Effect<A, NoSuchElementException | ParseError, Protocol | R>;
+export {};
+//# sourceMappingURL=RpcWorker.d.ts.map
\ No newline at end of file
diff --git a/dist/dts/RpcWorker.d.ts.map b/dist/dts/RpcWorker.d.ts.map
new file mode 100644
index 0000000000000000000000000000000000000000..1fcff3a5619eeb773a25714ba0e63a13dc03b107
--- /dev/null
+++ b/dist/dts/RpcWorker.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"RpcWorker.d.ts","sourceRoot":"","sources":["../../src/RpcWorker.ts"],"names":[],"mappings":"AAIA,OAAO,KAAK,EAAE,sBAAsB,EAAE,MAAM,cAAc,CAAA;AAC1D,OAAO,KAAK,OAAO,MAAM,gBAAgB,CAAA;AACzC,OAAO,KAAK,MAAM,MAAM,eAAe,CAAA;AACvC,OAAO,KAAK,KAAK,MAAM,cAAc,CAAA;AACrC,OAAO,KAAK,EAAE,UAAU,EAAE,MAAM,oBAAoB,CAAA;AACpD,OAAO,KAAK,MAAM,MAAM,eAAe,CAAA;AACvC,OAAO,KAAK,EAAE,QAAQ,EAAE,MAAM,gBAAgB,CAAA;;AAE9C;;;GAGG;AACH,qBAAa,cAAe,SAAQ,mBAQjC;CAAG;AAEN;;;GAGG;AACH,MAAM,CAAC,OAAO,WAAW,cAAc,CAAC;IACtC;;;OAGG;IACH,UAAiB,OAAO;QACtB,QAAQ,CAAC,IAAI,EAAE,gBAAgB,CAAA;QAC/B,QAAQ,CAAC,KAAK,EAAE,OAAO,CAAA;KACxB;CACF;AAID;;;GAGG;AACH,eAAO,MAAM,kBAAkB,GAAI,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,UACvC,MAAM,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,UACtB,MAAM,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,KAC9B,MAAM,CAAC,MAAM,CACd,SAAS,CAAC,IAAI,EAAE,OAAO,EAAE,aAAa,EAAE,aAAa,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC,EAC/E,CAAC,GAAG,UAAU,EACd,CAAC,GAAG,EAAE,CAQJ,CAAA;AAEJ;;;GAGG;AACH,eAAO,MAAM,mBAAmB,GAAI,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,UACrC,MAAM,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,SACvB,MAAM,CAAC,MAAM,CAAC,CAAC,EAAE,KAAK,EAAE,EAAE,CAAC,KACjC,KAAK,CAAC,KAAK,CAAC,cAAc,EAAE,KAAK,EAAE,CAAC,GAAG,EAAE,CAMzC,CAAA;AAEH;;;GAGG;AACH,eAAO,MAAM,cAAc,GAAI,CAAC,EAAE,CAAC,EAAE,CAAC,UAC5B,MAAM,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,KAC7B,MAAM,CAAC,MAAM,CAAC,CAAC,EAAE,sBAAsB,GAAG,UAAU,EAAE,QAAQ,GAAG,CAAC,CAKlE,CAAA"}
\ No newline at end of file
diff --git a/dist/dts/index.d.ts b/dist/dts/index.d.ts
index 6fbf32b72167941044d14670e86fdc157ecd85d9..094390da9086d2fed5ff80522095c9942dae0a02 100644
--- a/dist/dts/index.d.ts
+++ b/dist/dts/index.d.ts
@@ -5,13 +5,37 @@ export * as Rpc from "./Rpc.js";
 /**
  * @since 1.0.0
  */
-export * as RpcResolver from "./RpcResolver.js";
+export * as RpcClient from "./RpcClient.js";
 /**
  * @since 1.0.0
  */
-export * as RpcResolverNoStream from "./RpcResolverNoStream.js";
+export * as RpcGroup from "./RpcGroup.js";
 /**
  * @since 1.0.0
  */
-export * as RpcRouter from "./RpcRouter.js";
+export * as RpcMessage from "./RpcMessage.js";
+/**
+ * @since 1.0.0
+ */
+export * as RpcMiddleware from "./RpcMiddleware.js";
+/**
+ * @since 1.0.0
+ */
+export * as RpcSchema from "./RpcSchema.js";
+/**
+ * @since 1.0.0
+ */
+export * as RpcSerialization from "./RpcSerialization.js";
+/**
+ * @since 1.0.0
+ */
+export * as RpcServer from "./RpcServer.js";
+/**
+ * @since 1.0.0
+ */
+export * as RpcTest from "./RpcTest.js";
+/**
+ * @since 1.0.0
+ */
+export * as RpcWorker from "./RpcWorker.js";
 //# sourceMappingURL=index.d.ts.map
\ No newline at end of file
diff --git a/dist/dts/index.d.ts.map b/dist/dts/index.d.ts.map
index 39ebfc50fb7607423585cce9f1d1051d8785f253..878530b5d20bccc53b9eb107e6fac2a39e98eb8e 100644
--- a/dist/dts/index.d.ts.map
+++ b/dist/dts/index.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,OAAO,KAAK,GAAG,MAAM,UAAU,CAAA;AAE/B;;GAEG;AACH,OAAO,KAAK,WAAW,MAAM,kBAAkB,CAAA;AAE/C;;GAEG;AACH,OAAO,KAAK,mBAAmB,MAAM,0BAA0B,CAAA;AAE/D;;GAEG;AACH,OAAO,KAAK,SAAS,MAAM,gBAAgB,CAAA"}
\ No newline at end of file
+{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,OAAO,KAAK,GAAG,MAAM,UAAU,CAAA;AAE/B;;GAEG;AACH,OAAO,KAAK,SAAS,MAAM,gBAAgB,CAAA;AAE3C;;GAEG;AACH,OAAO,KAAK,QAAQ,MAAM,eAAe,CAAA;AAEzC;;GAEG;AACH,OAAO,KAAK,UAAU,MAAM,iBAAiB,CAAA;AAE7C;;GAEG;AACH,OAAO,KAAK,aAAa,MAAM,oBAAoB,CAAA;AAEnD;;GAEG;AACH,OAAO,KAAK,SAAS,MAAM,gBAAgB,CAAA;AAE3C;;GAEG;AACH,OAAO,KAAK,gBAAgB,MAAM,uBAAuB,CAAA;AAEzD;;GAEG;AACH,OAAO,KAAK,SAAS,MAAM,gBAAgB,CAAA;AAE3C;;GAEG;AACH,OAAO,KAAK,OAAO,MAAM,cAAc,CAAA;AAEvC;;GAEG;AACH,OAAO,KAAK,SAAS,MAAM,gBAAgB,CAAA"}
\ No newline at end of file
diff --git a/dist/dts/internal/utils.d.ts b/dist/dts/internal/utils.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9c5cca70c8e02d0b305ca11b5f8b08febb270a7b
--- /dev/null
+++ b/dist/dts/internal/utils.d.ts
@@ -0,0 +1,2 @@
+export {};
+//# sourceMappingURL=utils.d.ts.map
\ No newline at end of file
diff --git a/dist/dts/internal/utils.d.ts.map b/dist/dts/internal/utils.d.ts.map
new file mode 100644
index 0000000000000000000000000000000000000000..7fef0f5d45ae0da3c44ec406aaaf377c9046b9ae
--- /dev/null
+++ b/dist/dts/internal/utils.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"utils.d.ts","sourceRoot":"","sources":["../../../src/internal/utils.ts"],"names":[],"mappings":""}
\ No newline at end of file
diff --git a/dist/esm/Rpc.js b/dist/esm/Rpc.js
index 89cd957cf6b6386c0ce07946abd18fcb78cefe6e..57a3104b3160da87d790ca49949da977c78847b8 100644
--- a/dist/esm/Rpc.js
+++ b/dist/esm/Rpc.js
@@ -1,16 +1,10 @@
-/**
- * @since 1.0.0
- */
-import * as Headers from "@effect/platform/Headers";
-import * as Effect from "effect/Effect";
-import * as FiberRef from "effect/FiberRef";
-import { dual, pipe } from "effect/Function";
+import * as Context_ from "effect/Context";
 import { globalValue } from "effect/GlobalValue";
+import * as Option from "effect/Option";
 import { pipeArguments } from "effect/Pipeable";
 import * as Predicate from "effect/Predicate";
 import * as Schema from "effect/Schema";
-import * as Stream from "effect/Stream";
-import * as Internal from "./internal/rpc.js";
+import * as RpcSchema from "./RpcSchema.js";
 /**
  * @since 1.0.0
  * @category type ids
@@ -18,121 +12,127 @@ import * as Internal from "./internal/rpc.js";
 export const TypeId = /*#__PURE__*/Symbol.for("@effect/rpc/Rpc");
 /**
  * @since 1.0.0
- * @category refinements
+ * @category guards
  */
 export const isRpc = u => Predicate.hasProperty(u, TypeId);
-/**
- * @since 1.0.0
- * @category constructors
- */
-export const effect = (schema, handler) => ({
+const Proto = {
   [TypeId]: TypeId,
-  _tag: "Effect",
-  schema,
-  handler,
   pipe() {
     return pipeArguments(this, arguments);
+  },
+  setSuccess(successSchema) {
+    return makeProto({
+      ...this,
+      successSchema
+    });
+  },
+  setError(errorSchema) {
+    return makeProto({
+      ...this,
+      errorSchema
+    });
+  },
+  setPayload(payloadSchema) {
+    return makeProto({
+      ...this,
+      payloadSchema: Schema.isSchema(payloadSchema) ? payloadSchema : Schema.Struct(payloadSchema)
+    });
+  },
+  middleware(middleware) {
+    return makeProto({
+      ...this,
+      middlewares: new Set([...this.middlewares, middleware])
+    });
+  },
+  annotate(tag, value) {
+    return makeProto({
+      ...this,
+      annotations: Context_.add(this.annotations, tag, value)
+    });
+  },
+  annotateContext(context) {
+    return makeProto({
+      ...this,
+      annotations: Context_.merge(this.annotations, context)
+    });
   }
-});
-/**
- * @since 1.0.0
- * @category type ids
- */
-export const StreamRequestTypeId = Internal.StreamRequestTypeId;
-/**
- * @since 1.0.0
- * @category schemas
- */
-export const StreamRequest = () => (tag, options) => {
-  return class extends Schema.TaggedRequest()(tag, options) {
-    constructor(props, disableValidation) {
-      super(props, disableValidation);
-      this[Internal.StreamRequestTypeId] = Internal.StreamRequestTypeId;
-    }
-  };
 };
+const makeProto = options => {
+  const self = Object.assign(Object.create(Proto), options);
+  self.key = `@effect/rpc/Rpc/${options._tag}`;
+  return self;
+};
+const constEmptyStruct = /*#__PURE__*/Schema.Struct({});
 /**
  * @since 1.0.0
  * @category constructors
  */
-export const stream = (schema, handler) => ({
-  [TypeId]: TypeId,
-  _tag: "Stream",
-  schema: schema,
-  handler,
-  pipe() {
-    return pipeArguments(this, arguments);
-  }
-});
-/**
- * @since 1.0.0
- * @category schemas
- */
-export const RequestSchema = schema => Schema.Struct({
-  request: schema,
-  traceId: Schema.String,
-  spanId: Schema.String,
-  sampled: Schema.Boolean,
-  headers: Schema.Record({
-    key: Schema.String,
-    value: Schema.String
-  })
-});
-/**
- * @since 1.0.0
- * @category headers
- */
-export const currentHeaders = /*#__PURE__*/globalValue("@effect/rpc/Rpc/currentHeaders", () => FiberRef.unsafeMake(Headers.empty));
+export const make = (tag, options) => {
+  const successSchema = options?.success ?? Schema.Void;
+  const errorSchema = options?.error ?? Schema.Never;
+  return makeProto({
+    _tag: tag,
+    payloadSchema: Schema.isSchema(options?.payload) ? options?.payload : options?.payload ? Schema.Struct(options?.payload) : constEmptyStruct,
+    successSchema: options?.stream ? RpcSchema.Stream({
+      success: successSchema,
+      failure: errorSchema
+    }) : successSchema,
+    errorSchema: options?.stream ? Schema.Never : errorSchema,
+    annotations: Context_.empty(),
+    middlewares: new Set()
+  });
+};
 /**
  * @since 1.0.0
- * @category headers
+ * @category constructors
  */
-export const annotateHeaders = /*#__PURE__*/dual(2, (self, headers) => {
-  const resolved = Headers.fromInput(headers);
-  return Effect.locallyWith(self, currentHeaders, prev => ({
-    ...prev,
-    ...resolved
-  }));
+export const fromTaggedRequest = schema => makeProto({
+  _tag: schema._tag,
+  payloadSchema: schema,
+  successSchema: schema.success,
+  errorSchema: schema.failure,
+  annotations: Context_.empty(),
+  middlewares: new Set()
 });
+const exitSchemaCache = /*#__PURE__*/globalValue("@effect/rpc/Rpc/exitSchemaCache", () => new WeakMap());
 /**
  * @since 1.0.0
- * @category headers
+ * @category constructors
  */
-export const schemaHeaders = schema => {
-  const decode = Schema.decodeUnknown(schema);
-  return Effect.flatMap(FiberRef.get(currentHeaders), decode);
+export const exitSchema = self => {
+  if (exitSchemaCache.has(self)) {
+    return exitSchemaCache.get(self);
+  }
+  const rpc = self;
+  const streamSchemas = RpcSchema.getStreamSchemas(rpc.successSchema.ast);
+  const schema = Schema.Exit({
+    success: Option.isSome(streamSchemas) ? Schema.Void : rpc.successSchema,
+    failure: Option.isSome(streamSchemas) ? Schema.Union(streamSchemas.value.failure, rpc.errorSchema) : rpc.errorSchema,
+    defect: Schema.Defect
+  });
+  exitSchemaCache.set(self, schema);
+  return schema;
 };
 /**
  * @since 1.0.0
- * @category requests
+ * @category Fork
  */
-export const request = (request, options) => pipe(Effect.makeSpanScoped(`${options?.spanPrefix ?? "Rpc.request "}${request._tag}`, {
-  kind: "client",
-  captureStackTrace: false
-}), Effect.zip(FiberRef.get(currentHeaders)), Effect.map(([span, headers]) => Internal.makeRequest({
-  request,
-  traceId: span.traceId,
-  spanId: span.spanId,
-  sampled: span.sampled,
-  headers
-})));
+export const ForkTypeId = /*#__PURE__*/Symbol.for("@effect/rpc/Rpc/Fork");
 /**
+ * You can use `fork` to wrap a response Effect or Stream, to ensure that the
+ * response is executed concurrently regardless of the RpcServer concurrency
+ * setting.
+ *
  * @since 1.0.0
- * @category requests
+ * @category Fork
  */
-export const call = (req, resolver, options) => {
-  const isStream = Internal.StreamRequestTypeId in req;
-  const res = pipe(request(req, options), Effect.flatMap(_ => Effect.request(_, resolver)));
-  return isStream ? Stream.unwrapScoped(res) : Effect.scoped(res);
-};
-/**
- * @since 1.0.0
- * @category context
- */
-export const provideServiceEffect = /*#__PURE__*/dual(3, (self, tag, make) => self._tag === "Effect" ? effect(self.schema, req => Effect.provideServiceEffect(self.handler(req), tag, Effect.orDie(make))) : stream(self.schema, req => Stream.provideServiceEffect(self.handler(req), tag, Effect.orDie(make))));
+export const fork = value => ({
+  [ForkTypeId]: ForkTypeId,
+  value
+});
 /**
  * @since 1.0.0
- * @category context
+ * @category Fork
  */
-export const provideService = /*#__PURE__*/dual(3, (self, tag, service) => self._tag === "Effect" ? effect(self.schema, req => Effect.provideService(self.handler(req), tag, service)) : stream(self.schema, req => Stream.provideService(self.handler(req), tag, service)));
+export const isFork = u => ForkTypeId in u;
 //# sourceMappingURL=Rpc.js.map
\ No newline at end of file
diff --git a/dist/esm/Rpc.js.map b/dist/esm/Rpc.js.map
index b52a11752bd9a0cbb11023afdc9effe576a09a14..954ab6307ef969cbde9316ce5a51685917d75d39 100644
--- a/dist/esm/Rpc.js.map
+++ b/dist/esm/Rpc.js.map
@@ -1 +1 @@
-{"version":3,"file":"Rpc.js","names":["Headers","Effect","FiberRef","dual","pipe","globalValue","pipeArguments","Predicate","Schema","Stream","Internal","TypeId","Symbol","for","isRpc","u","hasProperty","effect","schema","handler","_tag","arguments","StreamRequestTypeId","StreamRequest","tag","options","TaggedRequest","constructor","props","disableValidation","stream","RequestSchema","Struct","request","traceId","String","spanId","sampled","Boolean","headers","Record","key","value","currentHeaders","unsafeMake","empty","annotateHeaders","self","resolved","fromInput","locallyWith","prev","schemaHeaders","decode","decodeUnknown","flatMap","get","makeSpanScoped","spanPrefix","kind","captureStackTrace","zip","map","span","makeRequest","call","req","resolver","isStream","res","_","unwrapScoped","scoped","provideServiceEffect","make","orDie","provideService","service"],"sources":["../../src/Rpc.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
+{"version":3,"file":"Rpc.js","names":["Context_","globalValue","Option","pipeArguments","Predicate","Schema","RpcSchema","TypeId","Symbol","for","isRpc","u","hasProperty","Proto","pipe","arguments","setSuccess","successSchema","makeProto","setError","errorSchema","setPayload","payloadSchema","isSchema","Struct","middleware","middlewares","Set","annotate","tag","value","annotations","add","annotateContext","context","merge","options","self","Object","assign","create","key","_tag","constEmptyStruct","make","success","Void","error","Never","payload","stream","Stream","failure","empty","fromTaggedRequest","schema","exitSchemaCache","WeakMap","exitSchema","has","get","rpc","streamSchemas","getStreamSchemas","ast","Exit","isSome","Union","defect","Defect","set","ForkTypeId","fork","isFork"],"sources":["../../src/Rpc.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/esm/RpcClient.js b/dist/esm/RpcClient.js
new file mode 100644
index 0000000000000000000000000000000000000000..af1370630c8435919d4763f121c432b12fba9c2e
--- /dev/null
+++ b/dist/esm/RpcClient.js
@@ -0,0 +1,642 @@
+/**
+ * @since 1.0.0
+ */
+import * as Headers from "@effect/platform/Headers";
+import * as HttpBody from "@effect/platform/HttpBody";
+import * as HttpClient from "@effect/platform/HttpClient";
+import * as HttpClientRequest from "@effect/platform/HttpClientRequest";
+import * as Socket from "@effect/platform/Socket";
+import * as Transferable from "@effect/platform/Transferable";
+import * as Worker from "@effect/platform/Worker";
+import * as Cause from "effect/Cause";
+import * as Chunk from "effect/Chunk";
+import * as Context from "effect/Context";
+import * as Effect from "effect/Effect";
+import * as Exit from "effect/Exit";
+import * as Fiber from "effect/Fiber";
+import * as FiberId from "effect/FiberId";
+import * as FiberRef from "effect/FiberRef";
+import { constVoid, dual, identity } from "effect/Function";
+import { globalValue } from "effect/GlobalValue";
+import * as Layer from "effect/Layer";
+import * as Mailbox from "effect/Mailbox";
+import * as Option from "effect/Option";
+import * as Pool from "effect/Pool";
+import * as Runtime from "effect/Runtime";
+import * as Schedule from "effect/Schedule";
+import * as Schema from "effect/Schema";
+import * as Scope from "effect/Scope";
+import * as Stream from "effect/Stream";
+import { withRun } from "./internal/utils.js";
+import * as Rpc from "./Rpc.js";
+import { constPing } from "./RpcMessage.js";
+import * as RpcSchema from "./RpcSchema.js";
+import * as RpcSerialization from "./RpcSerialization.js";
+import * as RpcWorker from "./RpcWorker.js";
+let requestIdCounter = /*#__PURE__*/BigInt(0);
+/**
+ * @since 1.0.0
+ * @category client
+ */
+export const makeNoSerialization = /*#__PURE__*/Effect.fnUntraced(function* (group, options) {
+  const spanPrefix = options?.spanPrefix ?? "RpcClient";
+  const supportsAck = options?.supportsAck ?? true;
+  const disableTracing = options?.disableTracing ?? false;
+  const generateRequestId = options?.generateRequestId ?? (() => requestIdCounter++);
+  const context = yield* Effect.context();
+  const scope = Context.get(context, Scope.Scope);
+  const entries = new Map();
+  let isShutdown = false;
+  yield* Scope.addFinalizer(scope, Effect.fiberIdWith(fiberId => {
+    isShutdown = true;
+    return clearEntries(Exit.interrupt(fiberId));
+  }));
+  const clearEntries = Effect.fnUntraced(function* (exit) {
+    for (const [id, entry] of entries) {
+      entries.delete(id);
+      if (entry._tag === "Mailbox") {
+        yield* entry.mailbox.done(exit);
+      } else {
+        entry.resume(exit);
+      }
+    }
+  });
+  const onRequest = rpc => {
+    const isStream = RpcSchema.isStreamSchema(rpc.successSchema);
+    const middleware = getRpcClientMiddleware(rpc);
+    return (payload, options) => {
+      const headers = options?.headers ? Headers.fromInput(options.headers) : Headers.empty;
+      if (!isStream) {
+        const effect = Effect.useSpan(`${spanPrefix}.${rpc._tag}`, {
+          captureStackTrace: false
+        }, span => onEffectRequest(rpc, middleware, span, payload ? rpc.payloadSchema.make(payload) : {}, headers, options?.context ?? Context.empty(), options?.discard ?? false));
+        return disableTracing ? Effect.withTracerEnabled(effect, false) : effect;
+      }
+      const mailbox = Effect.suspend(() => onStreamRequest(rpc, middleware, payload ? rpc.payloadSchema.make(payload) : {}, headers, options?.streamBufferSize ?? 16, options?.context ?? Context.empty()));
+      if (options?.asMailbox) return mailbox;
+      return Stream.unwrapScoped(Effect.map(mailbox, Mailbox.toStream));
+    };
+  };
+  const onEffectRequest = (rpc, middleware, span, payload, headers, context, discard) => Effect.withFiberRuntime(parentFiber => {
+    if (isShutdown) {
+      return Effect.interrupt;
+    }
+    const id = generateRequestId();
+    const send = middleware({
+      _tag: "Request",
+      id,
+      tag: rpc._tag,
+      payload,
+      traceId: span.traceId,
+      spanId: span.spanId,
+      sampled: span.sampled,
+      headers: Headers.merge(parentFiber.getFiberRef(currentHeaders), headers)
+    });
+    if (discard) {
+      return Effect.flatMap(send, message => options.onFromClient({
+        message,
+        context,
+        discard
+      }));
+    }
+    const runtime = Runtime.make({
+      context: parentFiber.currentContext,
+      fiberRefs: parentFiber.getFiberRefs(),
+      runtimeFlags: Runtime.defaultRuntime.runtimeFlags
+    });
+    let fiber;
+    return Effect.onInterrupt(Effect.async(resume => {
+      const entry = {
+        _tag: "Effect",
+        rpc,
+        context,
+        resume(exit) {
+          resume(exit);
+          if (!fiber.unsafePoll()) {
+            parentFiber.currentScheduler.scheduleTask(() => {
+              fiber.unsafeInterruptAsFork(parentFiber.id());
+            }, 0);
+          }
+        }
+      };
+      entries.set(id, entry);
+      fiber = send.pipe(Effect.flatMap(request => options.onFromClient({
+        message: request,
+        context,
+        discard
+      })), Effect.withParentSpan(span), Runtime.runFork(runtime));
+      fiber.addObserver(exit => {
+        if (exit._tag === "Failure") {
+          return resume(exit);
+        }
+      });
+    }), interruptors => {
+      entries.delete(id);
+      const ids = Array.from(interruptors).flatMap(id => Array.from(FiberId.toSet(id)));
+      return Effect.zipRight(Fiber.interrupt(fiber), sendInterrupt(id, ids, context));
+    });
+  });
+  const onStreamRequest = Effect.fnUntraced(function* (rpc, middleware, payload, headers, streamBufferSize, context) {
+    if (isShutdown) {
+      return yield* Effect.interrupt;
+    }
+    const span = yield* Effect.makeSpanScoped(`${spanPrefix}.${rpc._tag}`, {
+      captureStackTrace: false
+    }).pipe(disableTracing ? Effect.withTracerEnabled(false) : identity);
+    const fiber = Option.getOrThrow(Fiber.getCurrentFiber());
+    const id = generateRequestId();
+    const scope = Context.unsafeGet(fiber.currentContext, Scope.Scope);
+    yield* Scope.addFinalizerExit(scope, exit => {
+      if (!entries.has(id)) return Effect.void;
+      entries.delete(id);
+      return sendInterrupt(id, Exit.isFailure(exit) ? Array.from(Cause.interruptors(exit.cause)).flatMap(id => Array.from(FiberId.toSet(id))) : [], context);
+    });
+    const mailbox = yield* Mailbox.make(streamBufferSize);
+    entries.set(id, {
+      _tag: "Mailbox",
+      rpc,
+      mailbox,
+      scope,
+      context
+    });
+    yield* middleware({
+      _tag: "Request",
+      id,
+      tag: rpc._tag,
+      traceId: span.traceId,
+      payload,
+      spanId: span.spanId,
+      sampled: span.sampled,
+      headers: Headers.merge(fiber.getFiberRef(currentHeaders), headers)
+    }).pipe(Effect.flatMap(request => options.onFromClient({
+      message: request,
+      context,
+      discard: false
+    })), Effect.withParentSpan(span), Effect.catchAllCause(error => mailbox.failCause(error)), Effect.interruptible, Effect.forkIn(scope));
+    return mailbox;
+  });
+  const getRpcClientMiddleware = rpc => {
+    const middlewares = [];
+    for (const tag of rpc.middlewares.values()) {
+      const middleware = context.unsafeMap.get(`${tag.key}/Client`);
+      if (!middleware) continue;
+      middlewares.push(middleware);
+    }
+    return middlewares.length === 0 ? Effect.succeed : function (request) {
+      let i = 0;
+      return Effect.map(Effect.whileLoop({
+        while: () => i < middlewares.length,
+        body: () => middlewares[i]({
+          rpc,
+          request
+        }),
+        step(nextRequest) {
+          request = nextRequest;
+          i++;
+        }
+      }), () => request);
+    };
+  };
+  const sendInterrupt = (requestId, interruptors, context) => Effect.async(resume => {
+    const parentFiber = Option.getOrThrow(Fiber.getCurrentFiber());
+    const runtime = Runtime.make({
+      context: parentFiber.currentContext,
+      fiberRefs: parentFiber.getFiberRefs(),
+      runtimeFlags: Runtime.defaultRuntime.runtimeFlags
+    });
+    const fiber = options.onFromClient({
+      message: {
+        _tag: "Interrupt",
+        requestId,
+        interruptors
+      },
+      context,
+      discard: false
+    }).pipe(Effect.timeout(1000), Runtime.runFork(runtime));
+    fiber.addObserver(() => {
+      resume(Effect.void);
+    });
+  });
+  const write = message => {
+    switch (message._tag) {
+      case "Chunk":
+        {
+          const requestId = parseRequestId(message.requestId);
+          const entry = entries.get(requestId);
+          if (!entry || entry._tag !== "Mailbox") return Effect.void;
+          return entry.mailbox.offerAll(message.values).pipe(supportsAck ? Effect.zipRight(options.onFromClient({
+            message: {
+              _tag: "Ack",
+              requestId: message.requestId
+            },
+            context: entry.context,
+            discard: false
+          })) : identity, Effect.onError(cause => entry.mailbox.done(Exit.failCause(cause))), Effect.forkIn(entry.scope));
+        }
+      case "Exit":
+        {
+          const requestId = parseRequestId(message.requestId);
+          const entry = entries.get(requestId);
+          if (!entry) return Effect.void;
+          entries.delete(requestId);
+          if (entry._tag === "Effect") {
+            entry.resume(message.exit);
+            return Effect.void;
+          }
+          return entry.mailbox.done(Exit.asVoid(message.exit));
+        }
+      case "Defect":
+        {
+          return clearEntries(Exit.die(message.defect));
+        }
+      case "ClientEnd":
+        {
+          return Effect.void;
+        }
+    }
+  };
+  const client = {};
+  for (const rpc of group.requests.values()) {
+    ;
+    client[rpc._tag] = onRequest(rpc);
+  }
+  return {
+    client: client,
+    write
+  };
+});
+/**
+ * @since 1.0.0
+ * @category client
+ */
+export const make = /*#__PURE__*/Effect.fnUntraced(function* (group, options) {
+  const {
+    run,
+    send,
+    supportsAck,
+    supportsTransferables
+  } = yield* Protocol;
+  const entries = new Map();
+  const {
+    client,
+    write
+  } = yield* makeNoSerialization(group, {
+    ...options,
+    supportsAck,
+    onFromClient({
+      message
+    }) {
+      switch (message._tag) {
+        case "Request":
+          {
+            const rpc = group.requests.get(message.tag);
+            const schemas = RpcSchema.getStreamSchemas(rpc.successSchema.ast);
+            const collector = supportsTransferables ? Transferable.unsafeMakeCollector() : undefined;
+            const fiber = Option.getOrThrow(Fiber.getCurrentFiber());
+            const entry = {
+              rpc,
+              context: collector ? Context.add(fiber.currentContext, Transferable.Collector, collector) : fiber.currentContext,
+              decodeChunk: Option.isSome(schemas) ? Schema.decodeUnknown(Schema.NonEmptyArray(schemas.value.success)) : undefined
+            };
+            entries.set(message.id, entry);
+            return Schema.encode(rpc.payloadSchema)(message.payload).pipe(Effect.locally(FiberRef.currentContext, entry.context), Effect.orDie, Effect.flatMap(payload => send({
+              ...message,
+              payload,
+              headers: Object.entries(message.headers)
+            }, collector && collector.unsafeClear())));
+          }
+        case "Ack":
+          {
+            const entry = entries.get(message.requestId);
+            if (!entry) return Effect.void;
+            return send(message);
+          }
+        case "Interrupt":
+          {
+            const entry = entries.get(message.requestId);
+            if (!entry) return Effect.void;
+            entries.delete(message.requestId);
+            return send({
+              _tag: "Interrupt",
+              requestId: message.requestId
+            });
+          }
+        case "Eof":
+          {
+            return Effect.void;
+          }
+      }
+    }
+  });
+  yield* run(message => {
+    switch (message._tag) {
+      case "Chunk":
+        {
+          const requestId = parseRequestId(message.requestId);
+          const entry = entries.get(requestId);
+          if (!entry || !entry.decodeChunk) return Effect.void;
+          return entry.decodeChunk(message.values).pipe(Effect.locally(FiberRef.currentContext, entry.context), Effect.orDie, Effect.flatMap(chunk => write({
+            _tag: "Chunk",
+            clientId: 0,
+            requestId: parseRequestId(message.requestId),
+            values: chunk
+          })), Effect.onError(cause => write({
+            _tag: "Exit",
+            clientId: 0,
+            requestId: parseRequestId(message.requestId),
+            exit: Exit.failCause(cause)
+          })));
+        }
+      case "Exit":
+        {
+          const requestId = parseRequestId(message.requestId);
+          const entry = entries.get(requestId);
+          if (!entry) return Effect.void;
+          entries.delete(requestId);
+          return Schema.decode(Rpc.exitSchema(entry.rpc))(message.exit).pipe(Effect.locally(FiberRef.currentContext, entry.context), Effect.orDie, Effect.matchCauseEffect({
+            onSuccess: exit => write({
+              _tag: "Exit",
+              clientId: 0,
+              requestId,
+              exit
+            }),
+            onFailure: cause => write({
+              _tag: "Exit",
+              clientId: 0,
+              requestId,
+              exit: Exit.failCause(cause)
+            })
+          }));
+        }
+      case "Defect":
+        {
+          return write({
+            _tag: "Defect",
+            clientId: 0,
+            defect: decodeDefect(message.defect)
+          });
+        }
+      default:
+        {
+          return Effect.void;
+        }
+    }
+  }).pipe(Effect.catchAllCause(Effect.logError), Effect.interruptible, Effect.forkScoped);
+  return client;
+});
+const parseRequestId = input => typeof input === "string" ? BigInt(input) : input;
+/**
+ * @since 1.0.0
+ * @category headers
+ */
+export const currentHeaders = /*#__PURE__*/globalValue("@effect/rpc/RpcClient/currentHeaders", () => FiberRef.unsafeMake(Headers.empty));
+/**
+ * @since 1.0.0
+ * @category headers
+ */
+export const withHeaders = /*#__PURE__*/dual(2, (effect, headers) => Effect.locallyWith(effect, currentHeaders, Headers.merge(Headers.fromInput(headers))));
+/**
+ * @since 1.0.0
+ * @category headers
+ */
+export const withHeadersEffect = /*#__PURE__*/dual(2, (effect, headers) => Effect.flatMap(headers, headers => withHeaders(effect, headers)));
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+export class Protocol extends /*#__PURE__*/Context.Tag("@effect/rpc/RpcClient/Protocol")() {
+  /**
+   * @since 1.0.0
+   */
+  static make = /*#__PURE__*/withRun();
+}
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+export const makeProtocolHttp = client => Protocol.make(Effect.fnUntraced(function* (writeResponse) {
+  const serialization = yield* RpcSerialization.RpcSerialization;
+  const isJson = serialization.contentType === "application/json";
+  const send = request => {
+    if (request._tag !== "Request") {
+      return Effect.void;
+    }
+    const parser = serialization.unsafeMake();
+    if (!serialization.supportsBigInt) transformBigInt(request);
+    const encoded = parser.encode(request);
+    const body = typeof encoded === "string" ? HttpBody.text(encoded, serialization.contentType) : HttpBody.uint8Array(encoded, serialization.contentType);
+    if (isJson) {
+      return client.post("/", {
+        body
+      }).pipe(Effect.flatMap(r => r.json), Effect.scoped, Effect.flatMap(u => {
+        if (!Array.isArray(u)) {
+          return Effect.dieMessage(`Expected an array of responses, but got: ${u}`);
+        }
+        let i = 0;
+        return Effect.whileLoop({
+          while: () => i < u.length,
+          body: () => writeResponse(u[i++]),
+          step: constVoid
+        });
+      }), Effect.orDie);
+    }
+    return client.post("/", {
+      body
+    }).pipe(Effect.flatMap(r => Stream.runForEachChunk(r.stream, chunk => {
+      const responses = Chunk.toReadonlyArray(chunk).flatMap(parser.decode);
+      if (responses.length === 0) return Effect.void;
+      let i = 0;
+      return Effect.whileLoop({
+        while: () => i < responses.length,
+        body: () => writeResponse(responses[i++]),
+        step: constVoid
+      });
+    })), Effect.orDie);
+  };
+  return {
+    send,
+    supportsAck: false,
+    supportsTransferables: false
+  };
+}));
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+export const layerProtocolHttp = options => Layer.scoped(Protocol, Effect.flatMap(HttpClient.HttpClient, client => {
+  client = HttpClient.mapRequest(client, HttpClientRequest.prependUrl(options.url));
+  return makeProtocolHttp(options.transformClient ? options.transformClient(client) : client);
+}));
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+export const makeProtocolSocket = /*#__PURE__*/Protocol.make( /*#__PURE__*/Effect.fnUntraced(function* (writeResponse) {
+  const socket = yield* Socket.Socket;
+  const serialization = yield* RpcSerialization.RpcSerialization;
+  const write = yield* socket.writer;
+  let parser = serialization.unsafeMake();
+  yield* Effect.suspend(() => {
+    parser = serialization.unsafeMake();
+    return socket.runRaw(message => {
+      try {
+        const responses = parser.decode(message);
+        if (responses.length === 0) return;
+        let i = 0;
+        return Effect.whileLoop({
+          while: () => i < responses.length,
+          body: () => writeResponse(responses[i++]),
+          step: constVoid
+        });
+      } catch (defect) {
+        return writeResponse({
+          _tag: "Defect",
+          defect
+        });
+      }
+    });
+  }).pipe(Effect.zipRight(Effect.fail(new Socket.SocketCloseError({
+    reason: "Close",
+    code: 1000
+  }))), Effect.tapErrorCause(cause => writeResponse({
+    _tag: "Defect",
+    defect: Cause.squash(cause)
+  })), Effect.retry(Schedule.spaced(1000)), Effect.annotateLogs({
+    module: "RpcClient",
+    method: "makeProtocolSocket"
+  }), Effect.interruptible, Effect.forkScoped);
+  yield* Effect.suspend(() => write(parser.encode(constPing))).pipe(Effect.delay("30 seconds"), Effect.ignore, Effect.forever, Effect.interruptible, Effect.forkScoped);
+  return {
+    send(request) {
+      if (!serialization.supportsBigInt) transformBigInt(request);
+      return Effect.orDie(write(parser.encode(request)));
+    },
+    supportsAck: true,
+    supportsTransferables: false
+  };
+}));
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+export const makeProtocolWorker = options => Protocol.make(Effect.fnUntraced(function* (writeResponse) {
+  const worker = yield* Worker.PlatformWorker;
+  const scope = yield* Effect.scope;
+  let workerId = 0;
+  const initialMessage = yield* Effect.serviceOption(RpcWorker.InitialMessage);
+  const entries = new Map();
+  yield* Scope.addFinalizerExit(scope, exit => Effect.forEach(entries, ([_, entry]) => Scope.close(entry.scope, exit), {
+    discard: true,
+    concurrency: "unbounded"
+  }));
+  const acquire = Effect.gen(function* () {
+    const id = workerId++;
+    const backing = yield* worker.spawn(id);
+    const readyLatch = yield* Effect.makeLatch();
+    yield* backing.run(message => {
+      if (message[0] === 0) {
+        return readyLatch.open;
+      }
+      const response = message[1];
+      if (response._tag === "Exit") {
+        const entry = entries.get(response.requestId);
+        if (entry) {
+          entries.delete(response.requestId);
+          return Effect.ensuring(writeResponse(response), Scope.close(entry.scope, Exit.void));
+        }
+      } else if (response._tag === "Defect") {
+        return Effect.zipRight(Effect.forEach(entries, ([requestId, entry]) => {
+          entries.delete(requestId);
+          return Scope.close(entry.scope, Exit.die(response.defect));
+        }, {
+          discard: true
+        }), writeResponse(response));
+      }
+      return writeResponse(response);
+    }).pipe(Effect.tapErrorCause(cause => writeResponse({
+      _tag: "Defect",
+      defect: Cause.squash(cause)
+    })), Effect.retry(Schedule.spaced(1000)), Effect.annotateLogs({
+      module: "RpcClient",
+      method: "makeProtocolWorker"
+    }), Effect.interruptible, Effect.forkScoped);
+    yield* readyLatch.await;
+    if (Option.isSome(initialMessage)) {
+      const [value, transfers] = yield* initialMessage.value;
+      yield* backing.send({
+        _tag: "InitialMessage",
+        value
+      }, transfers);
+    }
+    return backing;
+  });
+  const pool = "minSize" in options ? yield* Pool.makeWithTTL({
+    acquire,
+    min: options.minSize,
+    max: options.maxSize,
+    concurrency: options.concurrency,
+    targetUtilization: options.targetUtilization,
+    timeToLive: options.timeToLive
+  }) : yield* Pool.make({
+    acquire,
+    size: options.size,
+    concurrency: options.concurrency,
+    targetUtilization: options.targetUtilization
+  });
+  const send = (request, transferables) => {
+    switch (request._tag) {
+      case "Request":
+        {
+          return Scope.make().pipe(Effect.flatMap(scope => Effect.flatMap(Scope.extend(pool.get, scope), worker => {
+            entries.set(request.id, {
+              worker,
+              scope
+            });
+            return Effect.orDie(worker.send(request, transferables));
+          })), Effect.orDie);
+        }
+      case "Interrupt":
+        {
+          const entry = entries.get(request.requestId);
+          if (!entry) return Effect.void;
+          entries.delete(request.requestId);
+          return Effect.ensuring(Effect.orDie(entry.worker.send(request)), Scope.close(entry.scope, Exit.void));
+        }
+      case "Ack":
+        {
+          const entry = entries.get(request.requestId);
+          if (!entry) return Effect.void;
+          return Effect.orDie(entry.worker.send(request));
+        }
+    }
+    return Effect.void;
+  };
+  yield* Effect.scoped(pool.get);
+  return {
+    send,
+    supportsAck: true,
+    supportsTransferables: true
+  };
+}));
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+export const layerProtocolWorker = options => Layer.scoped(Protocol, makeProtocolWorker(options));
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+export const layerProtocolSocket = /*#__PURE__*/Layer.scoped(Protocol, makeProtocolSocket);
+// internal
+const decodeDefect = /*#__PURE__*/Schema.decodeSync(Schema.Defect);
+const transformBigInt = request => {
+  if (request._tag === "Request") {
+    ;
+    request.id = request.id.toString();
+  } else if ("requestId" in request) {
+    ;
+    request.requestId = request.requestId.toString();
+  }
+};
+//# sourceMappingURL=RpcClient.js.map
\ No newline at end of file
diff --git a/dist/esm/RpcClient.js.map b/dist/esm/RpcClient.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..50445d0cef9c3710e4315015d1a5cd9a783dbdce
--- /dev/null
+++ b/dist/esm/RpcClient.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"RpcClient.js","names":["Headers","HttpBody","HttpClient","HttpClientRequest","Socket","Transferable","Worker","Cause","Chunk","Context","Effect","Exit","Fiber","FiberId","FiberRef","constVoid","dual","identity","globalValue","Layer","Mailbox","Option","Pool","Runtime","Schedule","Schema","Scope","Stream","withRun","Rpc","constPing","RpcSchema","RpcSerialization","RpcWorker","requestIdCounter","BigInt","makeNoSerialization","fnUntraced","group","options","spanPrefix","supportsAck","disableTracing","generateRequestId","context","scope","get","entries","Map","isShutdown","addFinalizer","fiberIdWith","fiberId","clearEntries","interrupt","exit","id","entry","delete","_tag","mailbox","done","resume","onRequest","rpc","isStream","isStreamSchema","successSchema","middleware","getRpcClientMiddleware","payload","headers","fromInput","empty","effect","useSpan","captureStackTrace","span","onEffectRequest","payloadSchema","make","discard","withTracerEnabled","suspend","onStreamRequest","streamBufferSize","asMailbox","unwrapScoped","map","toStream","withFiberRuntime","parentFiber","send","tag","traceId","spanId","sampled","merge","getFiberRef","currentHeaders","flatMap","message","onFromClient","runtime","currentContext","fiberRefs","getFiberRefs","runtimeFlags","defaultRuntime","fiber","onInterrupt","async","unsafePoll","currentScheduler","scheduleTask","unsafeInterruptAsFork","set","pipe","request","withParentSpan","runFork","addObserver","interruptors","ids","Array","from","toSet","zipRight","sendInterrupt","makeSpanScoped","getOrThrow","getCurrentFiber","unsafeGet","addFinalizerExit","has","void","isFailure","cause","catchAllCause","error","failCause","interruptible","forkIn","middlewares","values","unsafeMap","key","push","length","succeed","i","whileLoop","while","body","step","nextRequest","requestId","timeout","write","parseRequestId","offerAll","onError","asVoid","die","defect","client","requests","run","supportsTransferables","Protocol","schemas","getStreamSchemas","ast","collector","unsafeMakeCollector","undefined","add","Collector","decodeChunk","isSome","decodeUnknown","NonEmptyArray","value","success","encode","locally","orDie","Object","unsafeClear","chunk","clientId","decode","exitSchema","matchCauseEffect","onSuccess","onFailure","decodeDefect","logError","forkScoped","input","unsafeMake","withHeaders","locallyWith","withHeadersEffect","Tag","makeProtocolHttp","writeResponse","serialization","isJson","contentType","parser","supportsBigInt","transformBigInt","encoded","text","uint8Array","post","r","json","scoped","u","isArray","dieMessage","runForEachChunk","stream","responses","toReadonlyArray","layerProtocolHttp","mapRequest","prependUrl","url","transformClient","makeProtocolSocket","socket","writer","runRaw","fail","SocketCloseError","reason","code","tapErrorCause","squash","retry","spaced","annotateLogs","module","method","delay","ignore","forever","makeProtocolWorker","worker","PlatformWorker","workerId","initialMessage","serviceOption","InitialMessage","forEach","_","close","concurrency","acquire","gen","backing","spawn","readyLatch","makeLatch","open","response","ensuring","await","transfers","pool","makeWithTTL","min","minSize","max","maxSize","targetUtilization","timeToLive","size","transferables","extend","layerProtocolWorker","layerProtocolSocket","decodeSync","Defect","toString"],"sources":["../../src/RpcClient.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/esm/RpcGroup.js b/dist/esm/RpcGroup.js
new file mode 100644
index 0000000000000000000000000000000000000000..1753ddfa79bc9b0f7b9d53342e69fac637126ff8
--- /dev/null
+++ b/dist/esm/RpcGroup.js
@@ -0,0 +1,101 @@
+import * as Context from "effect/Context";
+import * as Effect from "effect/Effect";
+import * as Layer from "effect/Layer";
+import * as Schema from "effect/Schema";
+import * as Rpc from "./Rpc.js";
+/**
+ * @since 1.0.0
+ * @category type ids
+ */
+export const TypeId = /*#__PURE__*/Symbol.for("@effect/rpc/RpcGroup");
+const RpcGroupProto = {
+  add(...rpcs) {
+    return makeProto({
+      requests: resolveInput(...this.requests.values(), ...rpcs),
+      annotations: this.annotations
+    });
+  },
+  merge(that) {
+    const requests = new Map(this.requests);
+    for (const rpc of that.requests.values()) {
+      requests.set(rpc._tag, rpc);
+    }
+    return makeProto({
+      requests,
+      annotations: Context.merge(this.annotations, that.annotations)
+    });
+  },
+  middleware(middleware) {
+    const requests = new Map();
+    for (const [tag, rpc] of this.requests) {
+      requests.set(tag, rpc.middleware(middleware));
+    }
+    return makeProto({
+      requests,
+      annotations: this.annotations
+    });
+  },
+  toHandlersContext(build) {
+    return Effect.gen(this, function* () {
+      const context = yield* Effect.context();
+      const handlers = Effect.isEffect(build) ? yield* build : build;
+      const contextMap = new Map();
+      for (const [tag, handler] of Object.entries(handlers)) {
+        const rpc = this.requests.get(tag);
+        contextMap.set(rpc.key, {
+          handler,
+          context
+        });
+      }
+      return Context.unsafeMake(contextMap);
+    });
+  },
+  toLayer(build) {
+    return Layer.scopedContext(this.toHandlersContext(build));
+  },
+  annotate(tag, value) {
+    return makeProto({
+      requests: this.requests,
+      annotations: Context.add(this.annotations, tag, value)
+    });
+  },
+  annotateRpcs(tag, value) {
+    return this.annotateRpcsContext(Context.make(tag, value));
+  },
+  annotateContext(context) {
+    return makeProto({
+      requests: this.requests,
+      annotations: Context.merge(this.annotations, context)
+    });
+  },
+  annotateRpcsContext(context) {
+    const requests = new Map();
+    for (const [tag, rpc] of this.requests) {
+      requests.set(tag, rpc.annotateContext(Context.merge(context, rpc.annotations)));
+    }
+    return makeProto({
+      requests,
+      annotations: this.annotations
+    });
+  }
+};
+const makeProto = options => Object.assign(function () {}, RpcGroupProto, {
+  requests: options.requests,
+  annotations: options.annotations
+});
+const resolveInput = (...rpcs) => {
+  const requests = new Map();
+  for (const rpc of rpcs) {
+    requests.set(rpc._tag, Schema.isSchema(rpc) ? Rpc.fromTaggedRequest(rpc) : rpc);
+  }
+  return requests;
+};
+/**
+ * @since 1.0.0
+ * @category groups
+ */
+export const make = (...rpcs) => makeProto({
+  requests: resolveInput(...rpcs),
+  annotations: Context.empty()
+});
+//# sourceMappingURL=RpcGroup.js.map
\ No newline at end of file
diff --git a/dist/esm/RpcGroup.js.map b/dist/esm/RpcGroup.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..fc3522a06690ecc978e7dccab4ec146695f250cf
--- /dev/null
+++ b/dist/esm/RpcGroup.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"RpcGroup.js","names":["Context","Effect","Layer","Schema","Rpc","TypeId","Symbol","for","RpcGroupProto","add","rpcs","makeProto","requests","resolveInput","values","annotations","merge","that","Map","rpc","set","_tag","middleware","tag","toHandlersContext","build","gen","context","handlers","isEffect","contextMap","handler","Object","entries","get","key","unsafeMake","toLayer","scopedContext","annotate","value","annotateRpcs","annotateRpcsContext","make","annotateContext","options","assign","isSchema","fromTaggedRequest","empty"],"sources":["../../src/RpcGroup.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/esm/RpcMessage.js b/dist/esm/RpcMessage.js
new file mode 100644
index 0000000000000000000000000000000000000000..627350f5b78192c8b6ee8584541a630c0158f7b7
--- /dev/null
+++ b/dist/esm/RpcMessage.js
@@ -0,0 +1,47 @@
+import * as Schema from "effect/Schema";
+/**
+ * @since 1.0.0
+ * @category request
+ */
+export const RequestIdTypeId = /*#__PURE__*/Symbol.for("@effect/rpc/RpcServer/RequestId");
+/**
+ * @since 1.0.0
+ * @category request
+ */
+export const RequestId = id => typeof id === "bigint" ? id : BigInt(id);
+/**
+ * @since 1.0.0
+ * @category request
+ */
+export const constEof = {
+  _tag: "Eof"
+};
+/**
+ * @since 1.0.0
+ * @category request
+ */
+export const constPing = {
+  _tag: "Ping"
+};
+/**
+ * @since 1.0.0
+ * @category response
+ */
+export const ResponseIdTypeId = /*#__PURE__*/Symbol.for("@effect/rpc/RpcServer/ResponseId");
+const encodeDefect = /*#__PURE__*/Schema.encodeSync(Schema.Defect);
+/**
+ * @since 1.0.0
+ * @category response
+ */
+export const ResponseDefectEncoded = input => ({
+  _tag: "Defect",
+  defect: encodeDefect(input)
+});
+/**
+ * @since 1.0.0
+ * @category response
+ */
+export const constPong = {
+  _tag: "Pong"
+};
+//# sourceMappingURL=RpcMessage.js.map
\ No newline at end of file
diff --git a/dist/esm/RpcMessage.js.map b/dist/esm/RpcMessage.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..98f57d84541fd14a31d042ddef574d0c8f0df680
--- /dev/null
+++ b/dist/esm/RpcMessage.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"RpcMessage.js","names":["Schema","RequestIdTypeId","Symbol","for","RequestId","id","BigInt","constEof","_tag","constPing","ResponseIdTypeId","encodeDefect","encodeSync","Defect","ResponseDefectEncoded","input","defect","constPong"],"sources":["../../src/RpcMessage.ts"],"sourcesContent":[null],"mappings":"AAOA,OAAO,KAAKA,MAAM,MAAM,eAAe;AAevC;;;;AAIA,OAAO,MAAMC,eAAe,gBAAkBC,MAAM,CAACC,GAAG,CAAC,iCAAiC,CAAC;AAc3F;;;;AAIA,OAAO,MAAMC,SAAS,GAAIC,EAAmB,IAC3C,OAAOA,EAAE,KAAK,QAAQ,GAAGA,EAAe,GAAGC,MAAM,CAACD,EAAE,CAAc;AA4EpE;;;;AAIA,OAAO,MAAME,QAAQ,GAAQ;EAAEC,IAAI,EAAE;AAAK,CAAE;AAE5C;;;;AAIA,OAAO,MAAMC,SAAS,GAAS;EAAED,IAAI,EAAE;AAAM,CAAE;AAkB/C;;;;AAIA,OAAO,MAAME,gBAAgB,gBAAkBR,MAAM,CAACC,GAAG,CAAC,kCAAkC,CAAC;AAiE7F,MAAMQ,YAAY,gBAAGX,MAAM,CAACY,UAAU,CAACZ,MAAM,CAACa,MAAM,CAAC;AAErD;;;;AAIA,OAAO,MAAMC,qBAAqB,GAAIC,KAAc,KAA6B;EAC/EP,IAAI,EAAE,QAAQ;EACdQ,MAAM,EAAEL,YAAY,CAACI,KAAK;CAC3B,CAAC;AA6BF;;;;AAIA,OAAO,MAAME,SAAS,GAAS;EAAET,IAAI,EAAE;AAAM,CAAE","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/esm/RpcMiddleware.js b/dist/esm/RpcMiddleware.js
new file mode 100644
index 0000000000000000000000000000000000000000..d203ceac2b513b4a497dfd70d7fdd6fa2d047650
--- /dev/null
+++ b/dist/esm/RpcMiddleware.js
@@ -0,0 +1,48 @@
+import * as Context from "effect/Context";
+import * as Effect from "effect/Effect";
+import * as Layer from "effect/Layer";
+import * as Schema from "effect/Schema";
+import { Scope } from "effect/Scope";
+/**
+ * @since 1.0.0
+ * @category type ids
+ */
+export const TypeId = /*#__PURE__*/Symbol.for("@effect/rpc/RpcMiddleware");
+/**
+ * @since 1.0.0
+ * @category tags
+ */
+export const Tag = () => (id, options) => {
+  const Err = globalThis.Error;
+  const limit = Err.stackTraceLimit;
+  Err.stackTraceLimit = 2;
+  const creationError = new Err();
+  Err.stackTraceLimit = limit;
+  function TagClass() {}
+  const TagClass_ = TagClass;
+  Object.setPrototypeOf(TagClass, Object.getPrototypeOf(Context.GenericTag(id)));
+  TagClass.key = id;
+  Object.defineProperty(TagClass, "stack", {
+    get() {
+      return creationError.stack;
+    }
+  });
+  TagClass_[TypeId] = TypeId;
+  TagClass_.failure = options?.optional === true || options?.failure === undefined ? Schema.Never : options.failure;
+  if (options?.provides) {
+    TagClass_.provides = options.provides;
+  }
+  TagClass_.optional = options?.optional ?? false;
+  TagClass_.requiredForClient = options?.requiredForClient ?? false;
+  return TagClass;
+};
+/**
+ * @since 1.0.0
+ * @category client
+ */
+export const layerClient = (tag, service) => Layer.scopedContext(Effect.gen(function* () {
+  const context = (yield* Effect.context()).pipe(Context.omit(Scope));
+  const middleware = Effect.isEffect(service) ? yield* service : service;
+  return Context.unsafeMake(new Map([[`${tag.key}/Client`, options => Effect.mapInputContext(middleware(options), requestContext => Context.merge(context, requestContext))]]));
+}));
+//# sourceMappingURL=RpcMiddleware.js.map
\ No newline at end of file
diff --git a/dist/esm/RpcMiddleware.js.map b/dist/esm/RpcMiddleware.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..7dbf6517b0cce4da3d1370731eeda712d68a773b
--- /dev/null
+++ b/dist/esm/RpcMiddleware.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"RpcMiddleware.js","names":["Context","Effect","Layer","Schema","Scope","TypeId","Symbol","for","Tag","id","options","Err","globalThis","Error","limit","stackTraceLimit","creationError","TagClass","TagClass_","Object","setPrototypeOf","getPrototypeOf","GenericTag","key","defineProperty","get","stack","failure","optional","undefined","Never","provides","requiredForClient","layerClient","tag","service","scopedContext","gen","context","pipe","omit","middleware","isEffect","unsafeMake","Map","mapInputContext","requestContext","merge"],"sources":["../../src/RpcMiddleware.ts"],"sourcesContent":[null],"mappings":"AAIA,OAAO,KAAKA,OAAO,MAAM,gBAAgB;AACzC,OAAO,KAAKC,MAAM,MAAM,eAAe;AACvC,OAAO,KAAKC,KAAK,MAAM,cAAc;AACrC,OAAO,KAAKC,MAAM,MAAM,eAAe;AACvC,SAASC,KAAK,QAAQ,cAAc;AAKpC;;;;AAIA,OAAO,MAAMC,MAAM,gBAAkBC,MAAM,CAACC,GAAG,CAAC,2BAA2B,CAAC;AA8K5E;;;;AAIA,OAAO,MAAMC,GAAG,GAAGA,CAAA,KAYnB,CACEC,EAAU,EACVC,OAKC,KACC;EACF,MAAMC,GAAG,GAAGC,UAAU,CAACC,KAAY;EACnC,MAAMC,KAAK,GAAGH,GAAG,CAACI,eAAe;EACjCJ,GAAG,CAACI,eAAe,GAAG,CAAC;EACvB,MAAMC,aAAa,GAAG,IAAIL,GAAG,EAAE;EAC/BA,GAAG,CAACI,eAAe,GAAGD,KAAK;EAE3B,SAASG,QAAQA,CAAA,GAAI;EACrB,MAAMC,SAAS,GAAGD,QAAuC;EACzDE,MAAM,CAACC,cAAc,CAACH,QAAQ,EAAEE,MAAM,CAACE,cAAc,CAACrB,OAAO,CAACsB,UAAU,CAAYb,EAAE,CAAC,CAAC,CAAC;EACzFQ,QAAQ,CAACM,GAAG,GAAGd,EAAE;EACjBU,MAAM,CAACK,cAAc,CAACP,QAAQ,EAAE,OAAO,EAAE;IACvCQ,GAAGA,CAAA;MACD,OAAOT,aAAa,CAACU,KAAK;IAC5B;GACD,CAAC;EACFR,SAAS,CAACb,MAAM,CAAC,GAAGA,MAAM;EAC1Ba,SAAS,CAACS,OAAO,GAAGjB,OAAO,EAAEkB,QAAQ,KAAK,IAAI,IAAIlB,OAAO,EAAEiB,OAAO,KAAKE,SAAS,GAAG1B,MAAM,CAAC2B,KAAK,GAAGpB,OAAO,CAACiB,OAAO;EACjH,IAAIjB,OAAO,EAAEqB,QAAQ,EAAE;IACrBb,SAAS,CAACa,QAAQ,GAAGrB,OAAO,CAACqB,QAAQ;EACvC;EACAb,SAAS,CAACU,QAAQ,GAAGlB,OAAO,EAAEkB,QAAQ,IAAI,KAAK;EAC/CV,SAAS,CAACc,iBAAiB,GAAGtB,OAAO,EAAEsB,iBAAiB,IAAI,KAAK;EACjE,OAAOf,QAAe;AACxB,CAAC;AAED;;;;AAIA,OAAO,MAAMgB,WAAW,GAAGA,CACzBC,GAAuB,EACvBC,OAA+E,KAE/EjC,KAAK,CAACkC,aAAa,CAACnC,MAAM,CAACoC,GAAG,CAAC,aAAS;EACtC,MAAMC,OAAO,GAAG,CAAC,OAAOrC,MAAM,CAACqC,OAAO,EAAa,EAAEC,IAAI,CACvDvC,OAAO,CAACwC,IAAI,CAACpC,KAAK,CAAC,CACE;EACvB,MAAMqC,UAAU,GAAGxC,MAAM,CAACyC,QAAQ,CAACP,OAAO,CAAC,GAAG,OAAOA,OAAO,GAAGA,OAAO;EACtE,OAAOnC,OAAO,CAAC2C,UAAU,CACvB,IAAIC,GAAG,CAAC,CAAC,CACP,GAAGV,GAAG,CAACX,GAAG,SAAS,EAClBb,OAAY,IACXT,MAAM,CAAC4C,eAAe,CACpBJ,UAAU,CAAC/B,OAAO,CAAC,EAClBoC,cAAc,IAAK9C,OAAO,CAAC+C,KAAK,CAACT,OAAO,EAAEQ,cAAc,CAAC,CAC3D,CACJ,CAAC,CAAC,CACJ;AACH,CAAC,CAAC,CAAC","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/esm/RpcSchema.js b/dist/esm/RpcSchema.js
new file mode 100644
index 0000000000000000000000000000000000000000..e148c73e6867999256315cc329f4cc529c03342a
--- /dev/null
+++ b/dist/esm/RpcSchema.js
@@ -0,0 +1,59 @@
+import * as Effect from "effect/Effect";
+import * as Option from "effect/Option";
+import * as ParseResult from "effect/ParseResult";
+import { hasProperty } from "effect/Predicate";
+import * as Schema from "effect/Schema";
+import * as AST from "effect/SchemaAST";
+import * as Stream_ from "effect/Stream";
+/**
+ * @since 1.0.0
+ * @category Stream
+ */
+export const StreamSchemaId = /*#__PURE__*/Symbol.for("@effect/rpc/RpcSchema/Stream");
+/**
+ * @since 1.0.0
+ * @category Stream
+ */
+export const isStreamSchema = schema => schema.ast.annotations[AST.SchemaIdAnnotationId] === StreamSchemaId;
+/**
+ * @since 1.0.0
+ * @category Stream
+ */
+export const isStreamSerializable = schema => isStreamSchema(Schema.successSchema(schema));
+/**
+ * @since 1.0.0
+ * @category Stream
+ */
+export const getStreamSchemas = ast => ast.annotations[StreamSchemaId] ? Option.some(ast.annotations[StreamSchemaId]) : Option.none();
+/**
+ * @since 1.0.0
+ * @category Stream
+ */
+export const Stream = ({
+  failure,
+  success
+}) => Object.assign(Schema.declare([success, failure], {
+  decode: (success, failure) => parseStream(ParseResult.decodeUnknown(Schema.ChunkFromSelf(success)), ParseResult.decodeUnknown(failure)),
+  encode: (success, failure) => parseStream(ParseResult.encodeUnknown(Schema.ChunkFromSelf(success)), ParseResult.encodeUnknown(failure))
+}, {
+  schemaId: StreamSchemaId,
+  [StreamSchemaId]: {
+    success,
+    failure
+  }
+}), {
+  success,
+  failure
+});
+const isStream = u => hasProperty(u, Stream_.StreamTypeId);
+const parseStream = (decodeSuccess, decodeFailure) => (u, options, ast) => Effect.flatMap(Effect.context(), context => {
+  if (!isStream(u)) return Effect.fail(new ParseResult.Type(ast, u));
+  return Effect.succeed(u.pipe(Stream_.mapChunksEffect(value => decodeSuccess(value, options)), Stream_.catchAll(error => {
+    if (ParseResult.isParseError(error)) return Stream_.die(error);
+    return Effect.matchEffect(decodeFailure(error, options), {
+      onFailure: Effect.die,
+      onSuccess: Effect.fail
+    });
+  }), Stream_.provideContext(context)));
+});
+//# sourceMappingURL=RpcSchema.js.map
\ No newline at end of file
diff --git a/dist/esm/RpcSchema.js.map b/dist/esm/RpcSchema.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..4432a186f3ed82e9abf0c9c331ab115d03256bdb
--- /dev/null
+++ b/dist/esm/RpcSchema.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"RpcSchema.js","names":["Effect","Option","ParseResult","hasProperty","Schema","AST","Stream_","StreamSchemaId","Symbol","for","isStreamSchema","schema","ast","annotations","SchemaIdAnnotationId","isStreamSerializable","successSchema","getStreamSchemas","some","none","Stream","failure","success","Object","assign","declare","decode","parseStream","decodeUnknown","ChunkFromSelf","encode","encodeUnknown","schemaId","isStream","u","StreamTypeId","decodeSuccess","decodeFailure","options","flatMap","context","fail","Type","succeed","pipe","mapChunksEffect","value","catchAll","error","isParseError","die","matchEffect","onFailure","onSuccess","provideContext"],"sources":["../../src/RpcSchema.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/esm/RpcSerialization.js b/dist/esm/RpcSerialization.js
new file mode 100644
index 0000000000000000000000000000000000000000..706ef915baf4160d8bdfa5dc430459a322b1138d
--- /dev/null
+++ b/dist/esm/RpcSerialization.js
@@ -0,0 +1,106 @@
+/**
+ * @since 1.0.0
+ */
+import { Msgpackr } from "@effect/platform/MsgPack";
+import * as Context from "effect/Context";
+import * as Effect from "effect/Effect";
+import * as Layer from "effect/Layer";
+/**
+ * @since 1.0.0
+ * @category serialization
+ */
+export class RpcSerialization extends /*#__PURE__*/Context.Tag("@effect/rpc/RpcSerialization")() {}
+/**
+ * @since 1.0.0
+ * @category serialization
+ */
+export const json = /*#__PURE__*/Effect.sync(() => {
+  const decoder = new TextDecoder();
+  return RpcSerialization.of({
+    contentType: "application/json",
+    supportsBigInt: false,
+    unsafeMake: () => ({
+      decode: bytes => [JSON.parse(typeof bytes === "string" ? bytes : decoder.decode(bytes))],
+      encode: response => JSON.stringify(response)
+    })
+  });
+});
+/**
+ * @since 1.0.0
+ * @category serialization
+ */
+export const ndjson = /*#__PURE__*/Effect.sync(() => {
+  const decoder = new TextDecoder();
+  return RpcSerialization.of({
+    contentType: "application/ndjson",
+    supportsBigInt: false,
+    unsafeMake: () => {
+      let buffer = "";
+      return {
+        decode: bytes => {
+          buffer += typeof bytes === "string" ? bytes : decoder.decode(bytes);
+          let position = 0;
+          let nlIndex = buffer.indexOf("\n", position);
+          const items = [];
+          while (nlIndex !== -1) {
+            const item = JSON.parse(buffer.slice(position, nlIndex));
+            items.push(item);
+            position = nlIndex + 1;
+            nlIndex = buffer.indexOf("\n", position);
+          }
+          buffer = buffer.slice(position);
+          return items;
+        },
+        encode: response => JSON.stringify(response) + "\n"
+      };
+    }
+  });
+});
+/**
+ * @since 1.0.0
+ * @category serialization
+ */
+export const msgPack = /*#__PURE__*/RpcSerialization.of({
+  contentType: "application/msgpack",
+  supportsBigInt: true,
+  unsafeMake: () => {
+    const unpackr = new Msgpackr.Unpackr();
+    const packr = new Msgpackr.Packr();
+    const encoder = new TextEncoder();
+    return {
+      decode: bytes => unpackr.unpackMultiple(typeof bytes === "string" ? encoder.encode(bytes) : bytes),
+      encode: response => packr.pack(response)
+    };
+  }
+});
+/**
+ * A rpc serialization layer that uses JSON for serialization.
+ *
+ * Use this if your protocol supports framing for messages, otherwise use
+ * `layerSerializationNdjson`.
+ *
+ * @since 1.0.0
+ * @category serialization
+ */
+export const layerJson = /*#__PURE__*/Layer.effect(RpcSerialization, json);
+/**
+ * A rpc serialization layer that uses NDJSON for serialization.
+ *
+ * Use this if your protocol does not support framing for messages, otherwise
+ * use `layerSerializationJson`.
+ *
+ * @since 1.0.0
+ * @category serialization
+ */
+export const layerNdjson = /*#__PURE__*/Layer.effect(RpcSerialization, ndjson);
+/**
+ * A rpc serialization layer that uses MessagePack for serialization.
+ *
+ * MessagePack has a more compact binary format compared to JSON and NDJSON. It
+ * also has better support for binary data.
+ *
+ * @since 1.0.0
+ * @category serialization
+ */
+export const layerMsgPack = /*#__PURE__*/Layer.succeed(RpcSerialization, msgPack);
+//# sourceMappingURL=RpcSerialization.js.map
\ No newline at end of file
diff --git a/dist/esm/RpcSerialization.js.map b/dist/esm/RpcSerialization.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..80bd3aae0bd0eb2027a32612b3e7c7a2c5637a42
--- /dev/null
+++ b/dist/esm/RpcSerialization.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"RpcSerialization.js","names":["Msgpackr","Context","Effect","Layer","RpcSerialization","Tag","json","sync","decoder","TextDecoder","of","contentType","supportsBigInt","unsafeMake","decode","bytes","JSON","parse","encode","response","stringify","ndjson","buffer","position","nlIndex","indexOf","items","item","slice","push","msgPack","unpackr","Unpackr","packr","Packr","encoder","TextEncoder","unpackMultiple","pack","layerJson","effect","layerNdjson","layerMsgPack","succeed"],"sources":["../../src/RpcSerialization.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/esm/RpcServer.js b/dist/esm/RpcServer.js
new file mode 100644
index 0000000000000000000000000000000000000000..06899526e9fa3bd73bdd1968c8e29d30160ba502
--- /dev/null
+++ b/dist/esm/RpcServer.js
@@ -0,0 +1,864 @@
+/**
+ * @since 1.0.0
+ */
+import * as Headers from "@effect/platform/Headers";
+import * as HttpApp from "@effect/platform/HttpApp";
+import * as HttpRouter from "@effect/platform/HttpRouter";
+import * as HttpServerRequest from "@effect/platform/HttpServerRequest";
+import * as HttpServerResponse from "@effect/platform/HttpServerResponse";
+import * as SocketServer from "@effect/platform/SocketServer";
+import * as Transferable from "@effect/platform/Transferable";
+import * as WorkerRunner from "@effect/platform/WorkerRunner";
+import * as Arr from "effect/Array";
+import * as Cause from "effect/Cause";
+import * as Chunk from "effect/Chunk";
+import * as Context from "effect/Context";
+import * as Deferred from "effect/Deferred";
+import * as Effect from "effect/Effect";
+import * as Exit from "effect/Exit";
+import * as Fiber from "effect/Fiber";
+import * as FiberId from "effect/FiberId";
+import * as FiberSet from "effect/FiberSet";
+import { constant, constTrue, constVoid, identity } from "effect/Function";
+import * as Layer from "effect/Layer";
+import * as Mailbox from "effect/Mailbox";
+import * as ManagedRuntime from "effect/ManagedRuntime";
+import * as Option from "effect/Option";
+import { ArrayFormatter } from "effect/ParseResult";
+import * as Predicate from "effect/Predicate";
+import * as Runtime from "effect/Runtime";
+import * as Schema from "effect/Schema";
+import * as Scope from "effect/Scope";
+import * as Stream from "effect/Stream";
+import * as Tracer from "effect/Tracer";
+import { withRun } from "./internal/utils.js";
+import * as Rpc from "./Rpc.js";
+import { constEof, constPong, RequestId, ResponseDefectEncoded } from "./RpcMessage.js";
+import * as RpcSchema from "./RpcSchema.js";
+import * as RpcSerialization from "./RpcSerialization.js";
+/**
+ * @since 1.0.0
+ * @category server
+ */
+export const makeNoSerialization = /*#__PURE__*/Effect.fnUntraced(function* (group, options) {
+  const enableTracing = options.disableTracing !== true;
+  const enableSpanPropagation = options.disableSpanPropagation !== true;
+  const supportsAck = options.disableClientAcks !== true;
+  const spanPrefix = options.spanPrefix ?? "RpcServer";
+  const concurrency = options.concurrency ?? "unbounded";
+  const context = yield* Effect.context();
+  const scope = Context.get(context, Scope.Scope);
+  const fiberSet = yield* FiberSet.make();
+  const runFork = yield* FiberSet.runtime(fiberSet)().pipe(Effect.interruptible);
+  const concurrencySemaphore = concurrency === "unbounded" ? undefined : yield* Effect.makeSemaphore(concurrency);
+  const clients = new Map();
+  let isShutdown = false;
+  const shutdownLatch = Effect.unsafeMakeLatch(false);
+  yield* Scope.addFinalizer(scope, Effect.fiberIdWith(fiberId => {
+    isShutdown = true;
+    for (const client of clients.values()) {
+      client.ended = true;
+      if (client.fibers.size === 0) {
+        runFork(endClient(client));
+        continue;
+      }
+      for (const fiber of client.fibers.values()) {
+        fiber.unsafeInterruptAsFork(fiberId);
+      }
+    }
+    if (clients.size === 0) {
+      return Effect.void;
+    }
+    return shutdownLatch.await;
+  }));
+  const disconnect = clientId => Effect.fiberIdWith(fiberId => {
+    const client = clients.get(clientId);
+    if (!client) return Effect.void;
+    for (const fiber of client.fibers.values()) {
+      fiber.unsafeInterruptAsFork(fiberId);
+    }
+    clients.delete(clientId);
+    return Effect.void;
+  });
+  const write = (clientId, message) => Effect.catchAllDefect(Effect.withFiberRuntime(requestFiber => {
+    if (isShutdown) return Effect.interrupt;
+    let client = clients.get(clientId);
+    if (!client) {
+      client = {
+        id: clientId,
+        latches: new Map(),
+        fibers: new Map(),
+        ended: false
+      };
+      clients.set(clientId, client);
+    } else if (client.ended) {
+      return Effect.interrupt;
+    }
+    switch (message._tag) {
+      case "Request":
+        {
+          return handleRequest(requestFiber, client, message);
+        }
+      case "Ack":
+        {
+          const latch = client.latches.get(message.requestId);
+          return latch ? latch.open : Effect.void;
+        }
+      case "Interrupt":
+        {
+          const fiber = client.fibers.get(message.requestId);
+          return fiber ? Fiber.interruptFork(fiber) : options.onFromServer({
+            _tag: "Exit",
+            clientId,
+            requestId: message.requestId,
+            exit: Exit.interrupt(FiberId.none)
+          });
+        }
+      case "Eof":
+        {
+          client.ended = true;
+          if (client.fibers.size > 0) return Effect.void;
+          return endClient(client);
+        }
+      default:
+        {
+          return sendDefect(client, `Unknown request tag: ${message._tag}`);
+        }
+    }
+  }), defect => sendDefect(clients.get(clientId), defect));
+  const endClient = client => {
+    clients.delete(client.id);
+    const write = options.onFromServer({
+      _tag: "ClientEnd",
+      clientId: client.id
+    });
+    if (isShutdown && clients.size === 0) {
+      return Effect.zipRight(write, shutdownLatch.open);
+    }
+    return write;
+  };
+  const handleRequest = (requestFiber, client, request) => {
+    if (client.fibers.has(request.id)) {
+      return Effect.interrupt;
+    }
+    const rpc = group.requests.get(request.tag);
+    const entry = context.unsafeMap.get(rpc?.key);
+    if (!rpc || !entry) {
+      const write = Effect.catchAllDefect(options.onFromServer({
+        _tag: "Exit",
+        clientId: client.id,
+        requestId: request.id,
+        exit: Exit.die(`Unknown request tag: ${request.tag}`)
+      }), defect => sendDefect(client, defect));
+      if (!client.ended || client.fibers.size > 0) return write;
+      return Effect.zipRight(write, endClient(client));
+    }
+    const isStream = RpcSchema.isStreamSchema(rpc.successSchema);
+    const result = entry.handler(request.payload, request.headers);
+    // if the handler requested forking, then we skip the concurrency control
+    const isFork = Rpc.isFork(result);
+    // unwrap the fork data type
+    const streamOrEffect = isFork ? result.value : result;
+    let responded = false;
+    let effect = Effect.uninterruptible(Effect.matchCauseEffect(Effect.interruptible(applyMiddleware(rpc, context, request.payload, request.headers, isStream ? streamEffect(client, request, streamOrEffect) : streamOrEffect)), {
+      onSuccess: value => {
+        responded = true;
+        return options.onFromServer({
+          _tag: "Exit",
+          clientId: client.id,
+          requestId: request.id,
+          exit: Exit.succeed(value)
+        });
+      },
+      onFailure: cause => {
+        responded = true;
+        return options.onFromServer({
+          _tag: "Exit",
+          clientId: client.id,
+          requestId: request.id,
+          exit: Exit.failCause(cause)
+        });
+      }
+    }));
+    if (enableTracing) {
+      const parentSpan = requestFiber.currentContext.unsafeMap.get(Tracer.ParentSpan.key);
+      effect = Effect.withSpan(effect, `${spanPrefix}.${request.tag}`, {
+        captureStackTrace: false,
+        parent: enableSpanPropagation ? {
+          _tag: "ExternalSpan",
+          traceId: request.traceId,
+          spanId: request.spanId,
+          sampled: request.sampled,
+          context: Context.empty()
+        } : undefined,
+        links: enableSpanPropagation && parentSpan ? [{
+          _tag: "SpanLink",
+          span: parentSpan,
+          attributes: {}
+        }] : undefined
+      });
+    }
+    if (!isFork && concurrencySemaphore) {
+      effect = concurrencySemaphore.withPermits(1)(effect);
+    }
+    const runtime = Runtime.make({
+      context: Context.merge(entry.context, requestFiber.currentContext),
+      fiberRefs: requestFiber.getFiberRefs(),
+      runtimeFlags: Runtime.defaultRuntime.runtimeFlags
+    });
+    const fiber = Runtime.runFork(runtime, effect);
+    FiberSet.unsafeAdd(fiberSet, fiber);
+    client.fibers.set(request.id, fiber);
+    fiber.addObserver(exit => {
+      if (!responded && exit._tag === "Failure") {
+        FiberSet.unsafeAdd(fiberSet, Runtime.runFork(runtime, options.onFromServer({
+          _tag: "Exit",
+          clientId: client.id,
+          requestId: request.id,
+          exit: Exit.interrupt(FiberId.none)
+        })));
+      }
+      client.fibers.delete(request.id);
+      client.latches.delete(request.id);
+      if (client.ended && client.fibers.size === 0) {
+        FiberSet.unsafeAdd(fiberSet, Runtime.runFork(runtime, endClient(client)));
+      }
+    });
+    return Effect.void;
+  };
+  const streamEffect = (client, request, stream) => {
+    let latch = client.latches.get(request.id);
+    if (supportsAck && !latch) {
+      latch = Effect.unsafeMakeLatch(false);
+      client.latches.set(request.id, latch);
+    }
+    if (Effect.isEffect(stream)) {
+      let done = false;
+      return stream.pipe(Effect.flatMap(mailbox => Effect.whileLoop({
+        while: () => !done,
+        body: constant(Effect.flatMap(mailbox.takeAll, ([chunk, done_]) => {
+          done = done_;
+          if (!Chunk.isNonEmpty(chunk)) return Effect.void;
+          const write = options.onFromServer({
+            _tag: "Chunk",
+            clientId: client.id,
+            requestId: request.id,
+            values: Chunk.toReadonlyArray(chunk)
+          });
+          if (!latch) return write;
+          latch.unsafeClose();
+          return Effect.zipRight(write, latch.await);
+        })),
+        step: constVoid
+      })), Effect.scoped);
+    }
+    return Stream.runForEachChunk(stream, chunk => {
+      if (!Chunk.isNonEmpty(chunk)) return Effect.void;
+      const write = options.onFromServer({
+        _tag: "Chunk",
+        clientId: client.id,
+        requestId: request.id,
+        values: Chunk.toReadonlyArray(chunk)
+      });
+      if (!latch) return write;
+      latch.unsafeClose();
+      return Effect.zipRight(write, latch.await);
+    });
+  };
+  const sendDefect = (client, defect) => Effect.suspend(() => {
+    const shouldEnd = client.ended && client.fibers.size === 0;
+    const write = options.onFromServer({
+      _tag: "Defect",
+      clientId: client.id,
+      defect
+    });
+    if (!shouldEnd) return write;
+    return Effect.zipRight(write, endClient(client));
+  });
+  return identity({
+    write,
+    disconnect
+  });
+});
+const applyMiddleware = (rpc, context, payload, headers, handler) => {
+  if (rpc.middlewares.size === 0) {
+    return handler;
+  }
+  const options = {
+    rpc,
+    payload,
+    headers
+  };
+  for (const tag of rpc.middlewares) {
+    const middleware = Context.unsafeGet(context, tag);
+    if (tag.optional) {
+      const previous = handler;
+      handler = Effect.matchEffect(middleware(options), {
+        onFailure: () => previous,
+        onSuccess: tag.provides !== undefined ? value => Effect.provideService(previous, tag.provides, value) : _ => previous
+      });
+    } else {
+      handler = tag.provides !== undefined ? Effect.provideServiceEffect(handler, tag.provides, middleware(options)) : Effect.zipRight(middleware(options), handler);
+    }
+  }
+  return handler;
+};
+/**
+ * @since 1.0.0
+ * @category server
+ */
+export const make = /*#__PURE__*/Effect.fnUntraced(function* (group, options) {
+  const {
+    disconnects,
+    end,
+    run,
+    send,
+    supportsAck,
+    supportsSpanPropagation,
+    supportsTransferables
+  } = yield* Protocol;
+  const context = yield* Effect.context();
+  const scope = yield* Scope.make();
+  const server = yield* makeNoSerialization(group, {
+    ...options,
+    disableClientAcks: !supportsAck,
+    disableSpanPropagation: !supportsSpanPropagation,
+    onFromServer(response) {
+      const client = clients.get(response.clientId);
+      if (!client) return Effect.void;
+      switch (response._tag) {
+        case "Chunk":
+          {
+            const schemas = client.schemas.get(response.requestId);
+            if (!schemas) return Effect.void;
+            return handleEncode(client, response.requestId, schemas.collector, Effect.provide(schemas.encodeChunk(response.values), schemas.context), values => ({
+              _tag: "Chunk",
+              requestId: response.requestId,
+              values
+            }));
+          }
+        case "Exit":
+          {
+            const schemas = client.schemas.get(response.requestId);
+            if (!schemas) return Effect.void;
+            client.schemas.delete(response.requestId);
+            return handleEncode(client, response.requestId, schemas.collector, Effect.provide(schemas.encodeExit(response.exit), schemas.context), exit => ({
+              _tag: "Exit",
+              requestId: response.requestId,
+              exit
+            }));
+          }
+        case "Defect":
+          {
+            return sendDefect(client, response.defect);
+          }
+        case "ClientEnd":
+          {
+            clients.delete(response.clientId);
+            return end(response.clientId);
+          }
+      }
+    }
+  }).pipe(Scope.extend(scope));
+  // handle disconnects
+  yield* Effect.fork(Effect.interruptible(Effect.whileLoop({
+    while: constTrue,
+    body: constant(Effect.flatMap(disconnects.take, clientId => {
+      clients.delete(clientId);
+      return server.disconnect(clientId);
+    })),
+    step: constVoid
+  })));
+  const schemasCache = new WeakMap();
+  const getSchemas = rpc => {
+    let schemas = schemasCache.get(rpc);
+    if (!schemas) {
+      const entry = context.unsafeMap.get(rpc.key);
+      const streamSchemas = RpcSchema.getStreamSchemas(rpc.successSchema.ast);
+      const failures = new Set([rpc.errorSchema]);
+      if (Option.isSome(streamSchemas)) {
+        failures.add(streamSchemas.value.failure);
+      }
+      for (const middleware of rpc.middlewares) {
+        failures.add(middleware.failure);
+      }
+      schemas = {
+        decode: Schema.decodeUnknown(rpc.payloadSchema),
+        encodeChunk: Schema.encodeUnknown(Schema.Array(Option.isSome(streamSchemas) ? streamSchemas.value.success : Schema.Any)),
+        encodeExit: Schema.encodeUnknown(Rpc.exitSchema(rpc)),
+        context: entry.context
+      };
+      schemasCache.set(rpc, schemas);
+    }
+    return schemas;
+  };
+  const clients = new Map();
+  const handleEncode = (client, requestId, collector, effect, onSuccess) => (collector ? Effect.provideService(effect, Transferable.Collector, collector) : effect).pipe(Effect.flatMap(a => send(client.id, onSuccess(a), collector && collector.unsafeClear())), Effect.catchAllCause(cause => {
+    client.schemas.delete(requestId);
+    const defect = Cause.squash(Cause.map(cause, ArrayFormatter.formatErrorSync));
+    return Effect.zipRight(server.write(client.id, {
+      _tag: "Interrupt",
+      requestId,
+      interruptors: []
+    }), sendRequestDefect(client, requestId, defect));
+  }));
+  const sendRequestDefect = (client, requestId, defect) => Effect.catchAllCause(send(client.id, {
+    _tag: "Exit",
+    requestId,
+    exit: {
+      _tag: "Failure",
+      cause: {
+        _tag: "Die",
+        defect
+      }
+    }
+  }), cause => sendDefect(client, Cause.squash(cause)));
+  const sendDefect = (client, defect) => Effect.catchAllCause(send(client.id, {
+    _tag: "Defect",
+    defect
+  }), cause => Effect.annotateLogs(Effect.logDebug(cause), {
+    module: "RpcServer",
+    method: "sendDefect"
+  }));
+  // main server loop
+  return yield* run((clientId, request) => {
+    let client = clients.get(clientId);
+    if (!client) {
+      client = {
+        id: clientId,
+        schemas: new Map()
+      };
+      clients.set(clientId, client);
+    }
+    switch (request._tag) {
+      case "Request":
+        {
+          const tag = Predicate.hasProperty(request, "tag") ? request.tag : "";
+          const rpc = group.requests.get(tag);
+          if (!rpc) {
+            return sendDefect(client, `Unknown request tag: ${tag}`);
+          }
+          let requestId;
+          switch (typeof request.id) {
+            case "bigint":
+            case "string":
+              {
+                requestId = RequestId(request.id);
+                break;
+              }
+            default:
+              {
+                return sendDefect(client, `Invalid request id: ${request.id}`);
+              }
+          }
+          const schemas = getSchemas(rpc);
+          return Effect.matchEffect(Effect.provide(schemas.decode(request.payload), schemas.context), {
+            onFailure: error => sendRequestDefect(client, requestId, ArrayFormatter.formatErrorSync(error)),
+            onSuccess: payload => {
+              client.schemas.set(requestId, supportsTransferables ? {
+                ...schemas,
+                collector: Transferable.unsafeMakeCollector()
+              } : schemas);
+              return server.write(clientId, {
+                ...request,
+                id: requestId,
+                payload,
+                headers: Headers.fromInput(request.headers)
+              });
+            }
+          });
+        }
+      case "Ping":
+        {
+          return Effect.catchAllCause(send(client.id, constPong), cause => sendDefect(client, Cause.squash(cause)));
+        }
+      case "Ack":
+      case "Eof":
+      case "Interrupt":
+        {
+          if ("requestId" in request && typeof request.requestId === "string") {
+            ;
+            request.requestId = BigInt(request.requestId);
+          }
+          return server.write(clientId, request._tag === "Interrupt" ? {
+            ...request,
+            interruptors: []
+          } : request);
+        }
+      default:
+        {
+          return sendDefect(client, `Unknown request tag: ${request._tag}`);
+        }
+    }
+  }).pipe(Effect.interruptible, Effect.tapErrorCause(cause => Effect.logFatal("BUG: RpcServer protocol crashed", cause)), Effect.onExit(exit => Scope.close(scope, exit)));
+});
+/**
+ * @since 1.0.0
+ * @category server
+ */
+export const layer = (group, options) => Layer.scopedDiscard(Effect.forkScoped(Effect.interruptible(make(group, options))));
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+export class Protocol extends /*#__PURE__*/Context.Tag("@effect/rpc/RpcServer/Protocol")() {
+  /**
+   * @since 1.0.0
+   */
+  static make = /*#__PURE__*/withRun();
+}
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+export const makeProtocolSocketServer = /*#__PURE__*/Effect.gen(function* () {
+  const server = yield* SocketServer.SocketServer;
+  const {
+    onSocket,
+    protocol
+  } = yield* makeSocketProtocol;
+  yield* Effect.forkScoped(Effect.interruptible(server.run(Effect.fnUntraced(onSocket, Effect.scoped))));
+  return protocol;
+});
+/**
+ * A rpc protocol that uses `SocketServer` for communication.
+ *
+ * @since 1.0.0
+ * @category protocol
+ */
+export const layerProtocolSocketServer = /*#__PURE__*/Layer.scoped(Protocol, makeProtocolSocketServer);
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+export const makeProtocolWithHttpAppWebsocket = /*#__PURE__*/Effect.gen(function* () {
+  const {
+    onSocket,
+    protocol
+  } = yield* makeSocketProtocol;
+  const httpApp = Effect.gen(function* () {
+    const request = yield* HttpServerRequest.HttpServerRequest;
+    const socket = yield* Effect.orDie(request.upgrade);
+    yield* onSocket(socket);
+    return HttpServerResponse.empty();
+  });
+  return {
+    protocol,
+    httpApp
+  };
+});
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+export const makeProtocolWebsocket = /*#__PURE__*/Effect.fnUntraced(function* (options) {
+  const {
+    httpApp,
+    protocol
+  } = yield* makeProtocolWithHttpAppWebsocket;
+  const router = yield* options.routerTag ?? HttpRouter.Default;
+  yield* router.get(options.path, httpApp);
+  return protocol;
+});
+/**
+ * A rpc protocol that uses websockets for communication.
+ *
+ * @since 1.0.0
+ * @category protocol
+ */
+export const layerProtocolWebsocket = options => {
+  const routerTag = options.routerTag ?? HttpRouter.Default;
+  return Layer.effect(Protocol, makeProtocolWebsocket(options)).pipe(Layer.provide(routerTag.Live));
+};
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+export const makeProtocolWithHttpApp = /*#__PURE__*/Effect.gen(function* () {
+  const serialization = yield* RpcSerialization.RpcSerialization;
+  const isJson = serialization.contentType === "application/json";
+  const disconnects = yield* Mailbox.make();
+  let writeRequest;
+  let clientId = 0;
+  const clients = new Map();
+  const httpApp = Effect.gen(function* () {
+    const request = yield* HttpServerRequest.HttpServerRequest;
+    const data = yield* Effect.orDie(request.arrayBuffer);
+    const id = clientId++;
+    const mailbox = yield* Mailbox.make();
+    const parser = serialization.unsafeMake();
+    const encoder = new TextEncoder();
+    const offer = data => typeof data === "string" ? mailbox.offer(encoder.encode(data)) : mailbox.offer(data);
+    clients.set(id, {
+      write: response => {
+        try {
+          if (!serialization.supportsBigInt) {
+            transformBigInt(response);
+          }
+          return isJson ? mailbox.offer(response) : offer(parser.encode(response));
+        } catch (cause) {
+          return isJson ? mailbox.offer(ResponseDefectEncoded(cause)) : offer(parser.encode(ResponseDefectEncoded(cause)));
+        }
+      },
+      end: mailbox.end
+    });
+    const requestIds = [];
+    try {
+      const decoded = parser.decode(new Uint8Array(data));
+      for (const message of decoded) {
+        if (message._tag === "Request") {
+          requestIds.push(RequestId(message.id));
+        }
+        yield* writeRequest(id, message);
+      }
+    } catch (cause) {
+      yield* offer(parser.encode(ResponseDefectEncoded(cause)));
+    }
+    yield* writeRequest(id, constEof);
+    if (isJson) {
+      let done = false;
+      yield* Effect.addFinalizer(() => {
+        clients.delete(id);
+        disconnects.unsafeOffer(id);
+        if (done) return Effect.void;
+        return Effect.forEach(requestIds, requestId => writeRequest(id, {
+          _tag: "Interrupt",
+          requestId
+        }), {
+          discard: true
+        });
+      });
+      const responses = Arr.empty();
+      while (true) {
+        const [items, done] = yield* mailbox.takeAll;
+        // eslint-disable-next-line no-restricted-syntax
+        responses.push(...items);
+        if (done) break;
+      }
+      done = true;
+      return HttpServerResponse.unsafeJson(responses);
+    }
+    return HttpServerResponse.stream(Stream.ensuringWith(Mailbox.toStream(mailbox), exit => {
+      clients.delete(id);
+      disconnects.unsafeOffer(id);
+      if (!Exit.isInterrupted(exit)) return Effect.void;
+      return Effect.forEach(requestIds, requestId => writeRequest(id, {
+        _tag: "Interrupt",
+        requestId
+      }), {
+        discard: true
+      });
+    }), {
+      contentType: serialization.contentType
+    });
+  }).pipe(Effect.interruptible);
+  const protocol = yield* Protocol.make(writeRequest_ => {
+    writeRequest = writeRequest_;
+    return Effect.succeed({
+      disconnects,
+      send: (clientId, response) => {
+        const client = clients.get(clientId);
+        if (!client) return Effect.void;
+        return client.write(response);
+      },
+      end(clientId) {
+        const client = clients.get(clientId);
+        if (!client) return Effect.void;
+        return client.end;
+      },
+      initialMessage: Effect.succeedNone,
+      supportsAck: false,
+      supportsTransferables: false,
+      supportsSpanPropagation: false
+    });
+  });
+  return {
+    protocol,
+    httpApp
+  };
+});
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+export const makeProtocolHttp = /*#__PURE__*/Effect.fnUntraced(function* (options) {
+  const {
+    httpApp,
+    protocol
+  } = yield* makeProtocolWithHttpApp;
+  const router = yield* options.routerTag ?? HttpRouter.Default;
+  yield* router.post(options.path, httpApp);
+  return protocol;
+});
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+export const makeProtocolWorkerRunner = /*#__PURE__*/Protocol.make( /*#__PURE__*/Effect.fnUntraced(function* (writeRequest) {
+  const fiber = yield* Effect.withFiberRuntime(Effect.succeed);
+  const runner = yield* WorkerRunner.PlatformRunner;
+  const closeLatch = yield* WorkerRunner.CloseLatch;
+  const backing = yield* runner.start(closeLatch);
+  const initialMessage = yield* Deferred.make();
+  yield* Deferred.await(closeLatch).pipe(Effect.onExit(() => {
+    fiber.currentScheduler.scheduleTask(() => fiber.unsafeInterruptAsFork(fiber.id()), 0);
+    return Effect.void;
+  }), Effect.forkScoped);
+  yield* backing.run((clientId, message) => {
+    if (message._tag === "InitialMessage") {
+      return Deferred.succeed(initialMessage, message.value);
+    }
+    return writeRequest(clientId, message);
+  });
+  return {
+    disconnects: backing.disconnects ?? (yield* Mailbox.make()),
+    send: backing.send,
+    end(_clientId) {
+      return Effect.void;
+    },
+    initialMessage: Effect.asSome(Deferred.await(initialMessage)),
+    supportsAck: true,
+    supportsTransferables: true,
+    supportsSpanPropagation: true
+  };
+}));
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+export const layerProtocolWorkerRunner = /*#__PURE__*/Layer.scoped(Protocol, makeProtocolWorkerRunner);
+/**
+ * A rpc protocol that uses streaming http for communication.
+ *
+ * @since 1.0.0
+ * @category protocol
+ */
+export const layerProtocolHttp = options => {
+  const routerTag = options.routerTag ?? HttpRouter.Default;
+  return Layer.effect(Protocol, makeProtocolHttp(options)).pipe(Layer.provide(routerTag.Live));
+};
+/**
+ * @since 1.0.0
+ * @category http app
+ */
+export const toHttpApp = /*#__PURE__*/Effect.fnUntraced(function* (group, options) {
+  const {
+    httpApp,
+    protocol
+  } = yield* makeProtocolWithHttpApp;
+  yield* make(group, options).pipe(Effect.provideService(Protocol, protocol), Effect.interruptible, Effect.forkScoped);
+  return httpApp;
+});
+/**
+ * @since 1.0.0
+ * @category http app
+ */
+export const toHttpAppWebsocket = /*#__PURE__*/Effect.fnUntraced(function* (group, options) {
+  const {
+    httpApp,
+    protocol
+  } = yield* makeProtocolWithHttpAppWebsocket;
+  yield* make(group, options).pipe(Effect.provideService(Protocol, protocol), Effect.interruptible, Effect.forkScoped);
+  return httpApp;
+});
+/**
+ * Construct an http web handler from an `RpcGroup`.
+ *
+ * @since 1.0.0
+ * @category constructors
+ */
+export const toWebHandler = (group, options) => {
+  const runtime = ManagedRuntime.make(Layer.mergeAll(options.layer, Layer.scope), options?.memoMap);
+  let handlerCached;
+  const handlerPromise = Effect.gen(function* () {
+    const app = yield* toHttpApp(group, options);
+    const rt = yield* runtime.runtimeEffect;
+    const handler = HttpApp.toWebHandlerRuntime(rt)(options?.middleware ? options.middleware(app) : app);
+    handlerCached = handler;
+    return handler;
+  }).pipe(runtime.runPromise);
+  function handler(request, context) {
+    if (handlerCached !== undefined) {
+      return handlerCached(request, context);
+    }
+    return handlerPromise.then(handler => handler(request, context));
+  }
+  return {
+    handler,
+    dispose: runtime.dispose
+  };
+};
+// internal
+const makeSocketProtocol = /*#__PURE__*/Effect.gen(function* () {
+  const serialization = yield* RpcSerialization.RpcSerialization;
+  const disconnects = yield* Mailbox.make();
+  let clientId = 0;
+  const clients = new Map();
+  let writeRequest;
+  const onSocket = function* (socket) {
+    const scope = yield* Effect.scope;
+    const parser = serialization.unsafeMake();
+    const id = clientId++;
+    yield* Scope.addFinalizerExit(scope, () => {
+      clients.delete(id);
+      return disconnects.offer(id);
+    });
+    const writeRaw = yield* socket.writer;
+    const write = response => {
+      try {
+        if (!serialization.supportsBigInt) {
+          transformBigInt(response);
+        }
+        return Effect.orDie(writeRaw(parser.encode(response)));
+      } catch (cause) {
+        return Effect.orDie(writeRaw(parser.encode(ResponseDefectEncoded(cause))));
+      }
+    };
+    clients.set(id, {
+      write
+    });
+    yield* Effect.orDie(Effect.interruptible(socket.runRaw(data => {
+      try {
+        const decoded = parser.decode(data);
+        if (decoded.length === 0) return Effect.void;
+        let i = 0;
+        return Effect.whileLoop({
+          while: () => i < decoded.length,
+          body: () => writeRequest(id, decoded[i++]),
+          step: constVoid
+        });
+      } catch (cause) {
+        return writeRaw(parser.encode(ResponseDefectEncoded(cause)));
+      }
+    })));
+  };
+  const protocol = yield* Protocol.make(writeRequest_ => {
+    writeRequest = writeRequest_;
+    return Effect.succeed({
+      disconnects,
+      send: (clientId, response) => {
+        const client = clients.get(clientId);
+        if (!client) return Effect.void;
+        return Effect.orDie(client.write(response));
+      },
+      end(_clientId) {
+        return Effect.void;
+      },
+      initialMessage: Effect.succeedNone,
+      supportsAck: true,
+      supportsTransferables: false,
+      supportsSpanPropagation: true
+    });
+  });
+  return {
+    protocol,
+    onSocket
+  };
+});
+const transformBigInt = response => {
+  if ("requestId" in response) {
+    ;
+    response.requestId = response.requestId.toString();
+  }
+};
+//# sourceMappingURL=RpcServer.js.map
\ No newline at end of file
diff --git a/dist/esm/RpcServer.js.map b/dist/esm/RpcServer.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..4222535d1c2b0017ff544c4a29b0bff5470d34b2
--- /dev/null
+++ b/dist/esm/RpcServer.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"RpcServer.js","names":["Headers","HttpApp","HttpRouter","HttpServerRequest","HttpServerResponse","SocketServer","Transferable","WorkerRunner","Arr","Cause","Chunk","Context","Deferred","Effect","Exit","Fiber","FiberId","FiberSet","constant","constTrue","constVoid","identity","Layer","Mailbox","ManagedRuntime","Option","ArrayFormatter","Predicate","Runtime","Schema","Scope","Stream","Tracer","withRun","Rpc","constEof","constPong","RequestId","ResponseDefectEncoded","RpcSchema","RpcSerialization","makeNoSerialization","fnUntraced","group","options","enableTracing","disableTracing","enableSpanPropagation","disableSpanPropagation","supportsAck","disableClientAcks","spanPrefix","concurrency","context","scope","get","fiberSet","make","runFork","runtime","pipe","interruptible","concurrencySemaphore","undefined","makeSemaphore","clients","Map","isShutdown","shutdownLatch","unsafeMakeLatch","addFinalizer","fiberIdWith","fiberId","client","values","ended","fibers","size","endClient","fiber","unsafeInterruptAsFork","void","await","disconnect","clientId","delete","write","message","catchAllDefect","withFiberRuntime","requestFiber","interrupt","id","latches","set","_tag","handleRequest","latch","requestId","open","interruptFork","onFromServer","exit","none","sendDefect","defect","zipRight","request","has","rpc","requests","tag","entry","unsafeMap","key","die","isStream","isStreamSchema","successSchema","result","handler","payload","headers","isFork","streamOrEffect","value","responded","effect","uninterruptible","matchCauseEffect","applyMiddleware","streamEffect","onSuccess","succeed","onFailure","cause","failCause","parentSpan","currentContext","ParentSpan","withSpan","captureStackTrace","parent","traceId","spanId","sampled","empty","links","span","attributes","withPermits","merge","fiberRefs","getFiberRefs","runtimeFlags","defaultRuntime","unsafeAdd","addObserver","stream","isEffect","done","flatMap","mailbox","whileLoop","while","body","takeAll","chunk","done_","isNonEmpty","toReadonlyArray","unsafeClose","step","scoped","runForEachChunk","suspend","shouldEnd","middlewares","middleware","unsafeGet","optional","previous","matchEffect","provides","provideService","_","provideServiceEffect","disconnects","end","run","send","supportsSpanPropagation","supportsTransferables","Protocol","server","response","schemas","handleEncode","collector","provide","encodeChunk","encodeExit","extend","fork","take","schemasCache","WeakMap","getSchemas","streamSchemas","getStreamSchemas","ast","failures","Set","errorSchema","isSome","add","failure","decode","decodeUnknown","payloadSchema","encodeUnknown","Array","success","Any","exitSchema","Collector","a","unsafeClear","catchAllCause","squash","map","formatErrorSync","interruptors","sendRequestDefect","annotateLogs","logDebug","module","method","hasProperty","error","unsafeMakeCollector","fromInput","BigInt","tapErrorCause","logFatal","onExit","close","layer","scopedDiscard","forkScoped","Tag","makeProtocolSocketServer","gen","onSocket","protocol","makeSocketProtocol","layerProtocolSocketServer","makeProtocolWithHttpAppWebsocket","httpApp","socket","orDie","upgrade","makeProtocolWebsocket","router","routerTag","Default","path","layerProtocolWebsocket","Live","makeProtocolWithHttpApp","serialization","isJson","contentType","writeRequest","data","arrayBuffer","parser","unsafeMake","encoder","TextEncoder","offer","encode","supportsBigInt","transformBigInt","requestIds","decoded","Uint8Array","push","unsafeOffer","forEach","discard","responses","items","unsafeJson","ensuringWith","toStream","isInterrupted","writeRequest_","initialMessage","succeedNone","makeProtocolHttp","post","makeProtocolWorkerRunner","runner","PlatformRunner","closeLatch","CloseLatch","backing","start","currentScheduler","scheduleTask","_clientId","asSome","layerProtocolWorkerRunner","layerProtocolHttp","toHttpApp","toHttpAppWebsocket","toWebHandler","mergeAll","memoMap","handlerCached","handlerPromise","app","rt","runtimeEffect","toWebHandlerRuntime","runPromise","then","dispose","addFinalizerExit","writeRaw","writer","runRaw","length","i","toString"],"sources":["../../src/RpcServer.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/esm/RpcTest.js b/dist/esm/RpcTest.js
new file mode 100644
index 0000000000000000000000000000000000000000..fc33ca6c2f60b8f19c9c7b1e8588e9296c5bec16
--- /dev/null
+++ b/dist/esm/RpcTest.js
@@ -0,0 +1,29 @@
+/**
+ * @since 1.0.0
+ */
+import * as Effect from "effect/Effect";
+import * as RpcClient from "./RpcClient.js";
+import * as RpcServer from "./RpcServer.js";
+/**
+ * @since 1.0.0
+ * @category constructors
+ */
+export const makeClient = /*#__PURE__*/Effect.fnUntraced(function* (group) {
+  // eslint-disable-next-line prefer-const
+  let client;
+  const server = yield* RpcServer.makeNoSerialization(group, {
+    onFromServer(response) {
+      return client.write(response);
+    }
+  });
+  client = yield* RpcClient.makeNoSerialization(group, {
+    supportsAck: true,
+    onFromClient({
+      message
+    }) {
+      return server.write(0, message);
+    }
+  });
+  return client.client;
+});
+//# sourceMappingURL=RpcTest.js.map
\ No newline at end of file
diff --git a/dist/esm/RpcTest.js.map b/dist/esm/RpcTest.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..41c2958083c9902a2e59bd5f23e95f691010ee20
--- /dev/null
+++ b/dist/esm/RpcTest.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"RpcTest.js","names":["Effect","RpcClient","RpcServer","makeClient","fnUntraced","group","client","server","makeNoSerialization","onFromServer","response","write","supportsAck","onFromClient","message"],"sources":["../../src/RpcTest.ts"],"sourcesContent":[null],"mappings":"AAAA;;;AAGA,OAAO,KAAKA,MAAM,MAAM,eAAe;AAGvC,OAAO,KAAKC,SAAS,MAAM,gBAAgB;AAE3C,OAAO,KAAKC,SAAS,MAAM,gBAAgB;AAE3C;;;;AAIA,OAAO,MAAMC,UAAU,gBAMnBH,MAAM,CAACI,UAAU,CAAC,WACpBC,KAA8B;EAE9B;EACA,IAAIC,MAA6F;EACjG,MAAMC,MAAM,GAAG,OAAOL,SAAS,CAACM,mBAAmB,CAACH,KAAK,EAAE;IACzDI,YAAYA,CAACC,QAAQ;MACnB,OAAOJ,MAAM,CAACK,KAAK,CAACD,QAAQ,CAAC;IAC/B;GACD,CAAC;EACFJ,MAAM,GAAG,OAAOL,SAAS,CAACO,mBAAmB,CAACH,KAAK,EAAE;IACnDO,WAAW,EAAE,IAAI;IACjBC,YAAYA,CAAC;MAAEC;IAAO,CAAE;MACtB,OAAOP,MAAM,CAACI,KAAK,CAAC,CAAC,EAAEG,OAAO,CAAC;IACjC;GACD,CAAC;EACF,OAAOR,MAAM,CAACA,MAAM;AACtB,CAAC,CAAC","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/esm/RpcWorker.js b/dist/esm/RpcWorker.js
new file mode 100644
index 0000000000000000000000000000000000000000..7d1b8d743ac93b5a8d948f1998436b08fffb4cf1
--- /dev/null
+++ b/dist/esm/RpcWorker.js
@@ -0,0 +1,33 @@
+/**
+ * @since 1.0.0
+ */
+import * as Transferable from "@effect/platform/Transferable";
+import * as Context from "effect/Context";
+import * as Effect from "effect/Effect";
+import * as Layer from "effect/Layer";
+import * as Schema from "effect/Schema";
+/**
+ * @since 1.0.0
+ * @category initial message
+ */
+export class InitialMessage extends /*#__PURE__*/Context.Tag("@effect/rpc/RpcWorker/InitialMessage")() {}
+const ProtocolTag = /*#__PURE__*/Context.GenericTag("@effect/rpc/RpcServer/Protocol");
+/**
+ * @since 1.0.0
+ * @category initial message
+ */
+export const makeInitialMessage = (schema, effect) => Effect.flatMap(effect, value => {
+  const collector = Transferable.unsafeMakeCollector();
+  return Schema.encode(schema)(value).pipe(Effect.provideService(Transferable.Collector, collector), Effect.map(encoded => [encoded, collector.unsafeClear()]));
+});
+/**
+ * @since 1.0.0
+ * @category initial message
+ */
+export const layerInitialMessage = (schema, build) => Layer.effect(InitialMessage, Effect.contextWith(context => Effect.provide(Effect.orDie(makeInitialMessage(schema, build)), context)));
+/**
+ * @since 1.0.0
+ * @category initial message
+ */
+export const initialMessage = schema => ProtocolTag.pipe(Effect.flatMap(protocol => protocol.initialMessage), Effect.flatten, Effect.flatMap(Schema.decodeUnknown(schema)));
+//# sourceMappingURL=RpcWorker.js.map
\ No newline at end of file
diff --git a/dist/esm/RpcWorker.js.map b/dist/esm/RpcWorker.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..79707767a911283c5d67ea6e92b5c18b6bbb3c3b
--- /dev/null
+++ b/dist/esm/RpcWorker.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"RpcWorker.js","names":["Transferable","Context","Effect","Layer","Schema","InitialMessage","Tag","ProtocolTag","GenericTag","makeInitialMessage","schema","effect","flatMap","value","collector","unsafeMakeCollector","encode","pipe","provideService","Collector","map","encoded","unsafeClear","layerInitialMessage","build","contextWith","context","provide","orDie","initialMessage","protocol","flatten","decodeUnknown"],"sources":["../../src/RpcWorker.ts"],"sourcesContent":[null],"mappings":"AAAA;;;AAGA,OAAO,KAAKA,YAAY,MAAM,+BAA+B;AAE7D,OAAO,KAAKC,OAAO,MAAM,gBAAgB;AACzC,OAAO,KAAKC,MAAM,MAAM,eAAe;AACvC,OAAO,KAAKC,KAAK,MAAM,cAAc;AAErC,OAAO,KAAKC,MAAM,MAAM,eAAe;AAGvC;;;;AAIA,OAAM,MAAOC,cAAe,sBAAQJ,OAAO,CAACK,GAAG,CAAC,sCAAsC,CAAC,EAQpF;AAiBH,MAAMC,WAAW,gBAAoBN,OAAO,CAACO,UAAU,CAAC,gCAAgC,CAAQ;AAEhG;;;;AAIA,OAAO,MAAMC,kBAAkB,GAAGA,CAChCC,MAA8B,EAC9BC,MAA+B,KAM/BT,MAAM,CAACU,OAAO,CAACD,MAAM,EAAGE,KAAK,IAAI;EAC/B,MAAMC,SAAS,GAAGd,YAAY,CAACe,mBAAmB,EAAE;EACpD,OAAOX,MAAM,CAACY,MAAM,CAACN,MAAM,CAAC,CAACG,KAAK,CAAC,CAACI,IAAI,CACtCf,MAAM,CAACgB,cAAc,CAAClB,YAAY,CAACmB,SAAS,EAAEL,SAAS,CAAC,EACxDZ,MAAM,CAACkB,GAAG,CAAEC,OAAO,IAAK,CAACA,OAAO,EAAEP,SAAS,CAACQ,WAAW,EAAE,CAAU,CAAC,CACrE;AACH,CAAC,CAAC;AAEJ;;;;AAIA,OAAO,MAAMC,mBAAmB,GAAGA,CACjCb,MAA8B,EAC9Bc,KAAkC,KAElCrB,KAAK,CAACQ,MAAM,CACVN,cAAc,EACdH,MAAM,CAACuB,WAAW,CAAEC,OAAgC,IAClDxB,MAAM,CAACyB,OAAO,CAACzB,MAAM,CAAC0B,KAAK,CAACnB,kBAAkB,CAACC,MAAM,EAAEc,KAAK,CAAC,CAAC,EAAEE,OAAO,CAAC,CACzE,CACF;AAEH;;;;AAIA,OAAO,MAAMG,cAAc,GACzBnB,MAA8B,IAE9BH,WAAW,CAACU,IAAI,CACdf,MAAM,CAACU,OAAO,CAAEkB,QAAQ,IAAKA,QAAQ,CAACD,cAAc,CAAC,EACrD3B,MAAM,CAAC6B,OAAO,EACd7B,MAAM,CAACU,OAAO,CAACR,MAAM,CAAC4B,aAAa,CAACtB,MAAM,CAAC,CAAC,CAC7C","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/esm/index.js b/dist/esm/index.js
index 460563cdf2a7e60badb88dd7f0fbd2c9bd8b860f..5c2ff392f8da296f8dc79dfd9adb8e091fd5fceb 100644
--- a/dist/esm/index.js
+++ b/dist/esm/index.js
@@ -5,13 +5,37 @@ export * as Rpc from "./Rpc.js";
 /**
  * @since 1.0.0
  */
-export * as RpcResolver from "./RpcResolver.js";
+export * as RpcClient from "./RpcClient.js";
 /**
  * @since 1.0.0
  */
-export * as RpcResolverNoStream from "./RpcResolverNoStream.js";
+export * as RpcGroup from "./RpcGroup.js";
 /**
  * @since 1.0.0
  */
-export * as RpcRouter from "./RpcRouter.js";
+export * as RpcMessage from "./RpcMessage.js";
+/**
+ * @since 1.0.0
+ */
+export * as RpcMiddleware from "./RpcMiddleware.js";
+/**
+ * @since 1.0.0
+ */
+export * as RpcSchema from "./RpcSchema.js";
+/**
+ * @since 1.0.0
+ */
+export * as RpcSerialization from "./RpcSerialization.js";
+/**
+ * @since 1.0.0
+ */
+export * as RpcServer from "./RpcServer.js";
+/**
+ * @since 1.0.0
+ */
+export * as RpcTest from "./RpcTest.js";
+/**
+ * @since 1.0.0
+ */
+export * as RpcWorker from "./RpcWorker.js";
 //# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/dist/esm/index.js.map b/dist/esm/index.js.map
index 393465860be424b2a84a4211585c7c10056e5538..7a25ae3c5434e44d82ef35add4dc008bb9f87509 100644
--- a/dist/esm/index.js.map
+++ b/dist/esm/index.js.map
@@ -1 +1 @@
-{"version":3,"file":"index.js","names":["Rpc","RpcResolver","RpcResolverNoStream","RpcRouter"],"sources":["../../src/index.ts"],"sourcesContent":[null],"mappings":"AAAA;;;AAGA,OAAO,KAAKA,GAAG,MAAM,UAAU;AAE/B;;;AAGA,OAAO,KAAKC,WAAW,MAAM,kBAAkB;AAE/C;;;AAGA,OAAO,KAAKC,mBAAmB,MAAM,0BAA0B;AAE/D;;;AAGA,OAAO,KAAKC,SAAS,MAAM,gBAAgB","ignoreList":[]}
\ No newline at end of file
+{"version":3,"file":"index.js","names":["Rpc","RpcClient","RpcGroup","RpcMessage","RpcMiddleware","RpcSchema","RpcSerialization","RpcServer","RpcTest","RpcWorker"],"sources":["../../src/index.ts"],"sourcesContent":[null],"mappings":"AAAA;;;AAGA,OAAO,KAAKA,GAAG,MAAM,UAAU;AAE/B;;;AAGA,OAAO,KAAKC,SAAS,MAAM,gBAAgB;AAE3C;;;AAGA,OAAO,KAAKC,QAAQ,MAAM,eAAe;AAEzC;;;AAGA,OAAO,KAAKC,UAAU,MAAM,iBAAiB;AAE7C;;;AAGA,OAAO,KAAKC,aAAa,MAAM,oBAAoB;AAEnD;;;AAGA,OAAO,KAAKC,SAAS,MAAM,gBAAgB;AAE3C;;;AAGA,OAAO,KAAKC,gBAAgB,MAAM,uBAAuB;AAEzD;;;AAGA,OAAO,KAAKC,SAAS,MAAM,gBAAgB;AAE3C;;;AAGA,OAAO,KAAKC,OAAO,MAAM,cAAc;AAEvC;;;AAGA,OAAO,KAAKC,SAAS,MAAM,gBAAgB","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/esm/internal/utils.js b/dist/esm/internal/utils.js
new file mode 100644
index 0000000000000000000000000000000000000000..8bf131a6224883a97240203ba1b2b47517adf7bf
--- /dev/null
+++ b/dist/esm/internal/utils.js
@@ -0,0 +1,27 @@
+import * as Effect from "effect/Effect";
+/** @internal */
+export const withRun = () => f => Effect.suspend(() => {
+  const semaphore = Effect.unsafeMakeSemaphore(1);
+  let buffer = [];
+  let write = (...args) => Effect.contextWith(context => {
+    buffer.push([args, context]);
+  });
+  return Effect.map(f((...args) => write(...args)), a => ({
+    ...a,
+    run(f) {
+      return semaphore.withPermits(1)(Effect.gen(function* () {
+        const prev = write;
+        write = f;
+        for (const [args, context] of buffer) {
+          yield* Effect.provide(write(...args), context);
+        }
+        buffer = [];
+        return yield* Effect.onExit(Effect.never, () => {
+          write = prev;
+          return Effect.void;
+        });
+      }));
+    }
+  }));
+});
+//# sourceMappingURL=utils.js.map
\ No newline at end of file
diff --git a/dist/esm/internal/utils.js.map b/dist/esm/internal/utils.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..596447d178e964154b9b5d98c01662f1d2daa41e
--- /dev/null
+++ b/dist/esm/internal/utils.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"utils.js","names":["Effect","withRun","f","suspend","semaphore","unsafeMakeSemaphore","buffer","write","args","contextWith","context","push","map","a","run","withPermits","gen","prev","provide","onExit","never","void"],"sources":["../../../src/internal/utils.ts"],"sourcesContent":[null],"mappings":"AACA,OAAO,KAAKA,MAAM,MAAM,eAAe;AAEvC;AACA,OAAO,MAAMC,OAAO,GAAGA,CAAA,KAKdC,CAA4E,IACnFF,MAAM,CAACG,OAAO,CAAC,MAAK;EAClB,MAAMC,SAAS,GAAGJ,MAAM,CAACK,mBAAmB,CAAC,CAAC,CAAC;EAC/C,IAAIC,MAAM,GAAgD,EAAE;EAC5D,IAAIC,KAAK,GAAGA,CAAC,GAAGC,IAAgB,KAC9BR,MAAM,CAACS,WAAW,CAAEC,OAAO,IAAI;IAC7BJ,MAAM,CAACK,IAAI,CAAC,CAACH,IAAI,EAAEE,OAAO,CAAC,CAAC;EAC9B,CAAC,CAAC;EACJ,OAAOV,MAAM,CAACY,GAAG,CAACV,CAAC,CAAC,CAAC,GAAGM,IAAI,KAAKD,KAAK,CAAC,GAAGC,IAAI,CAAC,CAAC,EAAGK,CAAC,KAAM;IACxD,GAAGA,CAAC;IACJC,GAAGA,CAACZ,CAAC;MACH,OAAOE,SAAS,CAACW,WAAW,CAAC,CAAC,CAAC,CAACf,MAAM,CAACgB,GAAG,CAAC,aAAS;QAClD,MAAMC,IAAI,GAAGV,KAAK;QAClBA,KAAK,GAAGL,CAAC;QAET,KAAK,MAAM,CAACM,IAAI,EAAEE,OAAO,CAAC,IAAIJ,MAAM,EAAE;UACpC,OAAON,MAAM,CAACkB,OAAO,CAACX,KAAK,CAAC,GAAGC,IAAI,CAAC,EAAEE,OAAO,CAAC;QAChD;QACAJ,MAAM,GAAG,EAAE;QAEX,OAAO,OAAON,MAAM,CAACmB,MAAM,CAACnB,MAAM,CAACoB,KAAK,EAAE,MAAK;UAC7Cb,KAAK,GAAGU,IAAI;UACZ,OAAOjB,MAAM,CAACqB,IAAI;QACpB,CAAC,CAAC;MACJ,CAAC,CAAC,CAAC;IACL;GACK,EAAC;AACV,CAAC,CAAC","ignoreList":[]}
\ No newline at end of file
diff --git a/package.json b/package.json
index b07a40113377421098c95208008a05717bb58807..6c09637fb6f5f392c1e168a2698ef3577a1b2052 100644
--- a/package.json
+++ b/package.json
@@ -31,20 +31,50 @@
       "import": "./dist/esm/Rpc.js",
       "default": "./dist/cjs/Rpc.js"
     },
-    "./RpcResolver": {
-      "types": "./dist/dts/RpcResolver.d.ts",
-      "import": "./dist/esm/RpcResolver.js",
-      "default": "./dist/cjs/RpcResolver.js"
+    "./RpcClient": {
+      "types": "./dist/dts/RpcClient.d.ts",
+      "import": "./dist/esm/RpcClient.js",
+      "default": "./dist/cjs/RpcClient.js"
     },
-    "./RpcResolverNoStream": {
-      "types": "./dist/dts/RpcResolverNoStream.d.ts",
-      "import": "./dist/esm/RpcResolverNoStream.js",
-      "default": "./dist/cjs/RpcResolverNoStream.js"
+    "./RpcGroup": {
+      "types": "./dist/dts/RpcGroup.d.ts",
+      "import": "./dist/esm/RpcGroup.js",
+      "default": "./dist/cjs/RpcGroup.js"
     },
-    "./RpcRouter": {
-      "types": "./dist/dts/RpcRouter.d.ts",
-      "import": "./dist/esm/RpcRouter.js",
-      "default": "./dist/cjs/RpcRouter.js"
+    "./RpcMessage": {
+      "types": "./dist/dts/RpcMessage.d.ts",
+      "import": "./dist/esm/RpcMessage.js",
+      "default": "./dist/cjs/RpcMessage.js"
+    },
+    "./RpcMiddleware": {
+      "types": "./dist/dts/RpcMiddleware.d.ts",
+      "import": "./dist/esm/RpcMiddleware.js",
+      "default": "./dist/cjs/RpcMiddleware.js"
+    },
+    "./RpcSchema": {
+      "types": "./dist/dts/RpcSchema.d.ts",
+      "import": "./dist/esm/RpcSchema.js",
+      "default": "./dist/cjs/RpcSchema.js"
+    },
+    "./RpcSerialization": {
+      "types": "./dist/dts/RpcSerialization.d.ts",
+      "import": "./dist/esm/RpcSerialization.js",
+      "default": "./dist/cjs/RpcSerialization.js"
+    },
+    "./RpcServer": {
+      "types": "./dist/dts/RpcServer.d.ts",
+      "import": "./dist/esm/RpcServer.js",
+      "default": "./dist/cjs/RpcServer.js"
+    },
+    "./RpcTest": {
+      "types": "./dist/dts/RpcTest.d.ts",
+      "import": "./dist/esm/RpcTest.js",
+      "default": "./dist/cjs/RpcTest.js"
+    },
+    "./RpcWorker": {
+      "types": "./dist/dts/RpcWorker.d.ts",
+      "import": "./dist/esm/RpcWorker.js",
+      "default": "./dist/cjs/RpcWorker.js"
     }
   },
   "typesVersions": {
@@ -52,14 +82,32 @@
       "Rpc": [
         "./dist/dts/Rpc.d.ts"
       ],
-      "RpcResolver": [
-        "./dist/dts/RpcResolver.d.ts"
+      "RpcClient": [
+        "./dist/dts/RpcClient.d.ts"
+      ],
+      "RpcGroup": [
+        "./dist/dts/RpcGroup.d.ts"
+      ],
+      "RpcMessage": [
+        "./dist/dts/RpcMessage.d.ts"
+      ],
+      "RpcMiddleware": [
+        "./dist/dts/RpcMiddleware.d.ts"
+      ],
+      "RpcSchema": [
+        "./dist/dts/RpcSchema.d.ts"
+      ],
+      "RpcSerialization": [
+        "./dist/dts/RpcSerialization.d.ts"
+      ],
+      "RpcServer": [
+        "./dist/dts/RpcServer.d.ts"
       ],
-      "RpcResolverNoStream": [
-        "./dist/dts/RpcResolverNoStream.d.ts"
+      "RpcTest": [
+        "./dist/dts/RpcTest.d.ts"
       ],
-      "RpcRouter": [
-        "./dist/dts/RpcRouter.d.ts"
+      "RpcWorker": [
+        "./dist/dts/RpcWorker.d.ts"
       ]
     }
   }
diff --git a/src/Rpc.ts b/src/Rpc.ts
index ab2bfa8194660328278890dc7a4e48a266cc2d89..c64bb521d96658e9e6199b0015e4bfa3e70f92a3 100644
--- a/src/Rpc.ts
+++ b/src/Rpc.ts
@@ -1,24 +1,19 @@
 /**
  * @since 1.0.0
  */
-import * as Headers from "@effect/platform/Headers"
-import type * as Context from "effect/Context"
-import * as Effect from "effect/Effect"
-import * as FiberRef from "effect/FiberRef"
-import { dual, pipe } from "effect/Function"
+import type { Headers } from "@effect/platform/Headers"
+import * as Context_ from "effect/Context"
+import type { Effect } from "effect/Effect"
+import type { Exit as Exit_ } from "effect/Exit"
 import { globalValue } from "effect/GlobalValue"
-import type * as ParseResult from "effect/ParseResult"
+import * as Option from "effect/Option"
 import { type Pipeable, pipeArguments } from "effect/Pipeable"
 import * as Predicate from "effect/Predicate"
-import type * as PrimaryKey from "effect/PrimaryKey"
-import type * as Record from "effect/Record"
-import type * as EffectRequest from "effect/Request"
-import type * as RequestResolver from "effect/RequestResolver"
 import * as Schema from "effect/Schema"
-import type { Scope } from "effect/Scope"
-import * as Stream from "effect/Stream"
-import type * as Types from "effect/Types"
-import * as Internal from "./internal/rpc.js"
+import type * as AST from "effect/SchemaAST"
+import type { Stream } from "effect/Stream"
+import type * as RpcMiddleware from "./RpcMiddleware.js"
+import * as RpcSchema from "./RpcSchema.js"
 
 /**
  * @since 1.0.0
@@ -34,410 +29,622 @@ export type TypeId = typeof TypeId
 
 /**
  * @since 1.0.0
- * @category refinements
+ * @category guards
  */
-export const isRpc = (u: unknown): u is Rpc<any, any> => Predicate.hasProperty(u, TypeId)
+export const isRpc = (u: unknown): u is Rpc<any, any, any> => Predicate.hasProperty(u, TypeId)
 
 /**
+ * Represents an API endpoint. An API endpoint is mapped to a single route on
+ * the underlying `HttpRouter`.
+ *
  * @since 1.0.0
  * @category models
  */
-export type Rpc<Req extends Schema.TaggedRequest.All, R> = RpcEffect<Req, R> | RpcStream<Req, R>
+export interface Rpc<
+  out Tag extends string,
+  out Payload extends AnyStructSchema = Schema.Struct<{}>,
+  out Success extends Schema.Schema.Any = typeof Schema.Void,
+  out Error extends Schema.Schema.All = typeof Schema.Never,
+  out Middleware extends RpcMiddleware.TagClassAny = never
+> extends Pipeable {
+  readonly [TypeId]: TypeId
+  readonly _tag: Tag
+  readonly key: string
+  readonly payloadSchema: Payload
+  readonly successSchema: Success
+  readonly errorSchema: Error
+  readonly annotations: Context_.Context<never>
+  readonly middlewares: ReadonlySet<Middleware>
+
+  /**
+   * Set the schema for the success response of the rpc.
+   */
+  setSuccess<S extends Schema.Schema.Any>(schema: S): Rpc<
+    Tag,
+    Payload,
+    S,
+    Error,
+    Middleware
+  >
+
+  /**
+   * Set the schema for the error response of the rpc.
+   */
+  setError<E extends Schema.Schema.Any>(schema: E): Rpc<
+    Tag,
+    Payload,
+    Success,
+    E,
+    Middleware
+  >
+
+  /**
+   * Set the schema for the payload of the rpc.
+   */
+  setPayload<P extends Schema.Struct<any> | Schema.Struct.Fields>(
+    schema: P
+  ): Rpc<
+    Tag,
+    P extends Schema.Struct<infer _> ? P : P extends Schema.Struct.Fields ? Schema.Struct<P> : never,
+    Success,
+    Error,
+    Middleware
+  >
+
+  /**
+   * Add an `RpcMiddleware` to this procedure.
+   */
+  middleware<M extends RpcMiddleware.TagClassAny>(middleware: M): Rpc<
+    Tag,
+    Payload,
+    Success,
+    Error,
+    Middleware | M
+  >
+
+  /**
+   * Add an annotation on the rpc.
+   */
+  annotate<I, S>(
+    tag: Context_.Tag<I, S>,
+    value: S
+  ): Rpc<Tag, Payload, Success, Error, Middleware>
+
+  /**
+   * Merge the annotations of the rpc with the provided context.
+   */
+  annotateContext<I>(
+    context: Context_.Context<I>
+  ): Rpc<Tag, Payload, Success, Error, Middleware>
+}
 
 /**
+ * Represents an implemented rpc.
+ *
  * @since 1.0.0
  * @category models
  */
-export interface RpcEffect<Req extends Schema.TaggedRequest.All, R> extends Rpc.Proto<Req> {
-  readonly _tag: "Effect"
-  readonly handler: (
-    request: Req
-  ) => Effect.Effect<
-    EffectRequest.Request.Success<Req>,
-    EffectRequest.Request.Error<Req>,
-    R
-  >
+export interface Handler<Tag extends string> {
+  readonly _: unique symbol
+  readonly tag: Tag
+  readonly handler: (request: any, headers: Headers) => Effect<any, any> | Stream<any, any>
+  readonly context: Context<never>
 }
 
 /**
  * @since 1.0.0
  * @category models
  */
-export interface RpcStream<Req extends Schema.TaggedRequest.All, R> extends Rpc.Proto<Req> {
-  readonly _tag: "Stream"
-  readonly handler: (
-    request: Req
-  ) => Stream.Stream<
-    Req extends Schema.WithResult<infer A, infer _I, infer _E, infer _EI, infer _R> ? A : never,
-    Req extends Schema.WithResult<infer _A, infer _I, infer E, infer _EI, infer _R> ? E : never,
-    R
-  >
+export interface Any extends Pipeable {
+  readonly [TypeId]: TypeId
+  readonly _tag: string
+  readonly key: string
 }
 
 /**
  * @since 1.0.0
  * @category models
  */
-export declare namespace Rpc {
-  /**
-   * @since 1.0.0
-   * @category models
-   */
-  export interface Proto<Req extends Schema.TaggedRequest.All> extends Pipeable {
-    readonly [TypeId]: TypeId
-    readonly _tag: string
-    readonly schema: Schema.Schema<Req, any, unknown>
-  }
+export interface AnyWithProps {
+  readonly [TypeId]: TypeId
+  readonly _tag: string
+  readonly key: string
+  readonly payloadSchema: AnyStructSchema
+  readonly successSchema: Schema.Schema.Any
+  readonly errorSchema: Schema.Schema.All
+  readonly annotations: Context_.Context<never>
+  readonly middlewares: ReadonlySet<RpcMiddleware.TagClassAnyWithProps>
+}
 
-  /**
-   * @since 1.0.0
-   * @category models
-   */
-  export type Context<A extends Rpc<any, any>> = A extends Rpc<infer Req, infer R>
-    ? R | Schema.SerializableWithResult.Context<Req>
-    : never
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export type Tag<R> = R extends Rpc<
+  infer _Tag,
+  infer _Payload,
+  infer _Success,
+  infer _Error,
+  infer _Middleware
+> ? _Tag
+  : never
 
-  /**
-   * @since 1.0.0
-   * @category models
-   */
-  export type Request<A extends Rpc<any, any>> = Schema.Schema.Type<A["schema"]>
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export type Success<R> = R extends Rpc<
+  infer _Tag,
+  infer _Payload,
+  infer _Success,
+  infer _Error,
+  infer _Middleware
+> ? _Success["Type"]
+  : never
 
-  /**
-   * @since 1.0.0
-   * @category models
-   */
-  export type Result<A extends Schema.TaggedRequest.All, R = never> = StreamRequestTypeId extends keyof A ?
-    EffectRequest.Request.Success<A> :
-    Effect.Effect<EffectRequest.Request.Success<A>, EffectRequest.Request.Error<A>, R>
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export type SuccessEncoded<R> = R extends Rpc<
+  infer _Tag,
+  infer _Payload,
+  infer _Success,
+  infer _Error,
+  infer _Middleware
+> ? _Success["Encoded"]
+  : never
 
-  /**
-   * @since 1.0.0
-   * @category models
-   */
-  export type ResultUndecoded<A extends Schema.TaggedRequest.All, R = never> = A extends
-    Schema.WithResult<infer _A, infer I, infer E, infer _EI, infer _R>
-    ? StreamRequestTypeId extends keyof A ? Stream.Stream<I, E, R>
-    : Effect.Effect<I, E, R>
-    : never
-}
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export type SuccessExit<R> = Success<R> extends infer T ? T extends Stream<infer _A, infer _E, infer _Env> ? void : T
+  : never
 
 /**
  * @since 1.0.0
- * @category constructors
+ * @category models
  */
-export const effect = <Req extends Schema.TaggedRequest.All, R>(
-  schema: Schema.Schema<Req, any, unknown>,
-  handler: (request: Req) => Effect.Effect<EffectRequest.Request.Success<Req>, EffectRequest.Request.Error<Req>, R>
-): Rpc<Req, R> => ({
-  [TypeId]: TypeId,
-  _tag: "Effect",
-  schema,
-  handler,
-  pipe() {
-    return pipeArguments(this, arguments)
-  }
-})
+export type SuccessExitEncoded<R> = SuccessEncoded<R> extends infer T ?
+  T extends Stream<infer _A, infer _E, infer _Env> ? void : T
+  : never
 
 /**
  * @since 1.0.0
- * @category type ids
+ * @category models
  */
-export const StreamRequestTypeId: unique symbol = Internal.StreamRequestTypeId
+export type SuccessChunk<R> = Success<R> extends Stream<infer _A, infer _E, infer _Env> ? _A : never
 
 /**
  * @since 1.0.0
- * @category type ids
+ * @category models
  */
-export type StreamRequestTypeId = typeof StreamRequestTypeId
+export type SuccessChunkEncoded<R> = SuccessEncoded<R> extends Stream<infer _A, infer _E, infer _Env> ? _A : never
 
 /**
  * @since 1.0.0
- * @category schemas
+ * @category models
  */
-export interface StreamRequest<Tag extends string, SR, SI, S, RR, EI, E, AI, A>
-  extends EffectRequest.Request<Stream.Stream<A, E, never>>, Schema.SerializableWithResult<S, SI, SR, A, AI, E, EI, RR>
-{
-  readonly [StreamRequestTypeId]: StreamRequestTypeId
-  readonly _tag: Tag
-}
+export type ErrorSchema<R> = R extends Rpc<
+  infer _Tag,
+  infer _Payload,
+  infer _Success,
+  infer _Error,
+  infer _Middleware
+> ? _Error | _Middleware
+  : never
 
 /**
  * @since 1.0.0
- * @category schemas
+ * @category models
  */
-export declare namespace StreamRequest {
-  /**
-   * @since 1.0.0
-   * @category schemas
-   */
-  export type Any =
-    | StreamRequest<string, any, any, any, any, any, any, any, any>
-    | StreamRequest<string, any, any, any, any, never, never, any, any>
-}
+export type Error<R> = Schema.Schema.Type<ErrorSchema<R>>
 
 /**
  * @since 1.0.0
- * @category schemas
+ * @category models
  */
-export interface StreamRequestConstructor<Tag extends string, Self, R, IS, S, RR, IE, E, IA, A>
-  extends Schema.Schema<Self, Types.Simplify<IS & { readonly _tag: Tag }>, R>
-{
-  new(
-    props: Types.Equals<S, {}> extends true ? void : S,
-    disableValidation?: boolean
-  ): StreamRequest<Tag, R, IS & { readonly _tag: Tag }, Self, RR, IE, E, IA, A> & S
-}
+export type ErrorEncoded<R> = Schema.Schema.Encoded<ErrorSchema<R>>
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export type ErrorExit<R> = Success<R> extends Stream<infer _A, infer _E, infer _Env> ? _E | Error<R> : Error<R>
 
 /**
  * @since 1.0.0
- * @category schemas
+ * @category models
  */
-export const StreamRequest =
-  <Self>() =>
-  <Tag extends string, E, IE, RE, A, IA, RA, Payload extends Schema.Struct.Fields>(
-    tag: Tag,
-    options: {
-      readonly failure: Schema.Schema<E, IE, RE>
-      readonly success: Schema.Schema<A, IA, RA>
-      readonly payload: Payload
-    }
-  ): StreamRequestConstructor<
-    Tag,
-    Self,
-    Schema.Schema.Context<Payload[keyof Payload]>,
-    Types.Simplify<Schema.Struct.Encoded<Payload>>,
-    Types.Simplify<Schema.Struct.Type<Payload>>,
-    RE | RA,
-    IE,
-    E,
-    IA,
-    A
-  > => {
-    return class extends (Schema.TaggedRequest<{}>()(tag, options) as any) {
-      constructor(props: any, disableValidation?: boolean) {
-        super(props, disableValidation)
-        ;(this as any)[Internal.StreamRequestTypeId] = Internal.StreamRequestTypeId
-      }
-    } as any
-  }
+export type ErrorExitEncoded<R> = SuccessEncoded<R> extends Stream<infer _A, infer _E, infer _Env>
+  ? _E | ErrorEncoded<R>
+  : ErrorEncoded<R>
 
 /**
  * @since 1.0.0
- * @category constructors
+ * @category models
  */
-export const stream = <Req extends StreamRequest.Any, R>(
-  schema: Schema.Schema<Req, any, unknown>,
-  handler: (
-    request: Req
-  ) => Stream.Stream<
-    Req extends Schema.WithResult<infer A, infer _I, infer _E, infer _EI, infer _R> ? A : never,
-    Req extends Schema.WithResult<infer _A, infer _I, infer E, infer _EI, infer _R> ? E : never,
-    R
-  >
-): Rpc<Req, R> => ({
+export type Exit<R> = Exit_<SuccessExit<R>, ErrorExit<R>>
+
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export type ExitEncoded<R, Defect = unknown> = Schema.ExitEncoded<SuccessExitEncoded<R>, ErrorExitEncoded<R>, Defect>
+
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export type PayloadConstructor<R> = R extends Rpc<
+  infer _Tag,
+  infer _Payload,
+  infer _Success,
+  infer _Error,
+  infer _Middleware
+> ?
+  Schema.Struct.Constructor<_Payload["fields"]> extends infer T ?
+    [keyof T] extends [never] ? void | {} : Schema.Simplify<T>
+  : never
+  : never
+
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export type Payload<R> = R extends Rpc<
+  infer _Tag,
+  infer _Payload,
+  infer _Success,
+  infer _Error,
+  infer _Middleware
+> ? _Payload["Type"]
+  : never
+
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export type Context<R> = R extends Rpc<
+  infer _Tag,
+  infer _Payload,
+  infer _Success,
+  infer _Error,
+  infer _Middleware
+> ? _Payload["Context"] | _Success["Context"] | _Error["Context"]
+  : never
+
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export type Middleware<R> = R extends Rpc<
+  infer _Tag,
+  infer _Payload,
+  infer _Success,
+  infer _Error,
+  infer _Middleware
+> ? Context_.Tag.Identifier<_Middleware>
+  : never
+
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export type MiddlewareClient<R> = R extends Rpc<
+  infer _Tag,
+  infer _Payload,
+  infer _Success,
+  infer _Error,
+  infer _Middleware
+> ?
+  _Middleware extends { readonly requiredForClient: true }
+    ? RpcMiddleware.ForClient<Context_.Tag.Identifier<_Middleware>>
+  : never
+  : never
+
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export type AddError<R extends Any, Error extends Schema.Schema.All> = R extends Rpc<
+  infer _Tag,
+  infer _Payload,
+  infer _Success,
+  infer _Error,
+  infer _Middleware
+> ? Rpc<
+    _Tag,
+    _Payload,
+    _Success,
+    _Error | Error,
+    _Middleware
+  > :
+  never
+
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export type AddMiddleware<R extends Any, Middleware extends RpcMiddleware.TagClassAny> = R extends Rpc<
+  infer _Tag,
+  infer _Payload,
+  infer _Success,
+  infer _Error,
+  infer _Middleware
+> ? Rpc<
+    _Tag,
+    _Payload,
+    _Success,
+    _Error,
+    _Middleware | Middleware
+  > :
+  never
+
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export type ToHandler<R extends Any> = R extends Rpc<
+  infer _Tag,
+  infer _Payload,
+  infer _Success,
+  infer _Error,
+  infer _Middleware
+> ? Handler<_Tag> :
+  never
+
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export type IsStream<R extends Any, Tag extends string> = R extends
+  Rpc<Tag, infer _Payload, RpcSchema.Stream<infer _A, infer _E>, infer _Error, infer _Middleware> ? true : never
+
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export type ExtractTag<R extends Any, Tag extends string> = R extends
+  Rpc<Tag, infer _Payload, infer _Success, infer _Error, infer _Middleware> ? R : never
+
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export type ExtractProvides<R extends Any, Tag extends string> = R extends
+  Rpc<Tag, infer _Payload, infer _Success, infer _Error, infer _Middleware> ? _Middleware extends {
+    readonly provides: Context_.Tag<infer _I, infer _S>
+  } ? _I :
+  never :
+  never
+
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export type ExcludeProvides<Env, R extends Any, Tag extends string> = Exclude<
+  Env,
+  ExtractProvides<R, Tag>
+>
+
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export interface From<S extends AnyTaggedRequestSchema> extends Rpc<S["_tag"], S, S["success"], S["failure"]> {}
+
+const Proto = {
   [TypeId]: TypeId,
-  _tag: "Stream",
-  schema: schema as any,
-  handler,
   pipe() {
     return pipeArguments(this, arguments)
+  },
+  setSuccess(
+    this: AnyWithProps,
+    successSchema: Schema.Schema.Any
+  ) {
+    return makeProto({
+      ...this,
+      successSchema
+    })
+  },
+  setError(this: AnyWithProps, errorSchema: Schema.Schema.All) {
+    return makeProto({
+      ...this,
+      errorSchema
+    })
+  },
+  setPayload(this: AnyWithProps, payloadSchema: Schema.Struct<any> | Schema.Struct.Fields) {
+    return makeProto({
+      ...this,
+      payloadSchema: Schema.isSchema(payloadSchema) ? payloadSchema as any : Schema.Struct(payloadSchema as any)
+    })
+  },
+  middleware(this: AnyWithProps, middleware: RpcMiddleware.TagClassAny) {
+    return makeProto({
+      ...this,
+      middlewares: new Set([...this.middlewares, middleware])
+    })
+  },
+  annotate(this: AnyWithProps, tag: Context_.Tag<any, any>, value: any) {
+    return makeProto({
+      ...this,
+      annotations: Context_.add(this.annotations, tag, value)
+    })
+  },
+  annotateContext(this: AnyWithProps, context: Context_.Context<any>) {
+    return makeProto({
+      ...this,
+      annotations: Context_.merge(this.annotations, context)
+    })
   }
-})
+}
+
+const makeProto = <
+  const Tag extends string,
+  Payload extends AnyStructSchema,
+  Success extends Schema.Schema.Any,
+  Error extends Schema.Schema.All,
+  Middleware extends RpcMiddleware.TagClassAny
+>(options: {
+  readonly _tag: Tag
+  readonly payloadSchema: Payload
+  readonly successSchema: Success
+  readonly errorSchema: Error
+  readonly annotations: Context_.Context<never>
+  readonly middlewares: ReadonlySet<Middleware>
+}): Rpc<Tag, Payload, Success, Error, Middleware> => {
+  const self = Object.assign(Object.create(Proto), options)
+  self.key = `@effect/rpc/Rpc/${options._tag}`
+  return self
+}
+
+const constEmptyStruct = Schema.Struct({})
 
 /**
  * @since 1.0.0
- * @category models
+ * @category constructors
  */
-export interface Request<A extends Schema.TaggedRequest.All> extends
-  EffectRequest.Request<
-    EffectRequest.Request.Success<A>,
-    EffectRequest.Request.Error<A>
-  >,
-  PrimaryKey.PrimaryKey,
-  Schema.WithResult<
-    Schema.WithResult.Context<A>,
-    Schema.Schema.Encoded<A[typeof Schema.symbolWithResult]["failure"]>,
-    Schema.Schema.Type<A[typeof Schema.symbolWithResult]["failure"]>,
-    Schema.Schema.Encoded<A[typeof Schema.symbolWithResult]["success"]>,
-    Schema.Schema.Type<A[typeof Schema.symbolWithResult]["success"]>
-  >
-{
-  readonly request: A
-  readonly traceId: string
-  readonly spanId: string
-  readonly sampled: boolean
-  readonly headers: Headers.Headers
+export const make = <
+  const Tag extends string,
+  Payload extends AnyStructSchema | Schema.Struct.Fields = Schema.Struct<{}>,
+  Success extends Schema.Schema.Any = typeof Schema.Void,
+  Error extends Schema.Schema.All = typeof Schema.Never,
+  const Stream extends boolean = false
+>(tag: Tag, options?: {
+  readonly payload?: Payload
+  readonly success?: Success
+  readonly error?: Error
+  readonly stream?: Stream
+}): Rpc<
+  Tag,
+  Payload extends Schema.Struct.Fields ? Schema.Struct<Payload> : Payload,
+  Stream extends true ? RpcSchema.Stream<Success, Error> : Success,
+  Stream extends true ? typeof Schema.Never : Error
+> => {
+  const successSchema = options?.success ?? Schema.Void
+  const errorSchema = options?.error ?? Schema.Never
+  return makeProto({
+    _tag: tag,
+    payloadSchema: Schema.isSchema(options?.payload)
+      ? options?.payload as any
+      : options?.payload
+      ? Schema.Struct(options?.payload as any)
+      : constEmptyStruct,
+    successSchema: options?.stream ?
+      RpcSchema.Stream({
+        success: successSchema,
+        failure: errorSchema
+      }) :
+      successSchema,
+    errorSchema: options?.stream ? Schema.Never : errorSchema,
+    annotations: Context_.empty(),
+    middlewares: new Set<never>()
+  }) as any
 }
 
 /**
  * @since 1.0.0
- * @category models
+ * @category constructors
  */
-export interface RequestFrom<A> {
-  readonly request: A
-  readonly traceId: string
-  readonly spanId: string
-  readonly sampled: boolean
-  readonly headers: Record<string, string>
+export interface AnyStructSchema extends Pipeable {
+  readonly [Schema.TypeId]: any
+  readonly make: any
+  readonly Type: any
+  readonly Encoded: any
+  readonly Context: any
+  readonly ast: AST.AST
+  readonly fields: Schema.Struct.Fields
+  readonly annotations: any
 }
 
 /**
  * @since 1.0.0
- * @category schemas
+ * @category constructors
  */
-export const RequestSchema = <A, I, R>(
-  schema: Schema.Schema<A, I, R>
-): Schema.Schema<RequestFrom<A>, RequestFrom<I>, R> =>
-  Schema.Struct({
-    request: schema,
-    traceId: Schema.String,
-    spanId: Schema.String,
-    sampled: Schema.Boolean,
-    headers: Schema.Record({ key: Schema.String, value: Schema.String })
+export interface AnyTaggedRequestSchema extends AnyStructSchema {
+  readonly _tag: string
+  readonly success: Schema.Schema.Any
+  readonly failure: Schema.Schema.All
+}
+
+/**
+ * @since 1.0.0
+ * @category constructors
+ */
+export const fromTaggedRequest = <S extends AnyTaggedRequestSchema>(
+  schema: S
+): From<S> =>
+  makeProto({
+    _tag: schema._tag,
+    payloadSchema: schema as any,
+    successSchema: schema.success as any,
+    errorSchema: schema.failure,
+    annotations: Context_.empty(),
+    middlewares: new Set()
   })
 
+const exitSchemaCache = globalValue("@effect/rpc/Rpc/exitSchemaCache", () => new WeakMap<Any, Schema.Schema.Any>())
+
 /**
  * @since 1.0.0
- * @category headers
+ * @category constructors
  */
-export const currentHeaders: FiberRef.FiberRef<Headers.Headers> = globalValue(
-  "@effect/rpc/Rpc/currentHeaders",
-  () => FiberRef.unsafeMake(Headers.empty)
-)
+export const exitSchema = <R extends Any>(
+  self: R
+): Schema.Schema<Exit<R>, ExitEncoded<R>, Context<R>> => {
+  if (exitSchemaCache.has(self)) {
+    return exitSchemaCache.get(self) as any
+  }
+  const rpc = self as any as AnyWithProps
+  const streamSchemas = RpcSchema.getStreamSchemas(rpc.successSchema.ast)
+  const schema = Schema.Exit({
+    success: Option.isSome(streamSchemas) ? Schema.Void : rpc.successSchema,
+    failure: Option.isSome(streamSchemas) ?
+      Schema.Union(
+        streamSchemas.value.failure,
+        rpc.errorSchema
+      ) :
+      rpc.errorSchema,
+    defect: Schema.Defect
+  })
+  exitSchemaCache.set(self, schema)
+  return schema as any
+}
 
 /**
  * @since 1.0.0
- * @category headers
+ * @category Fork
  */
-export const annotateHeaders: {
-  /**
-   * @since 1.0.0
-   * @category headers
-   */
-  (headers: Headers.Input): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>
-  /**
-   * @since 1.0.0
-   * @category headers
-   */
-  <A, E, R>(self: Effect.Effect<A, E, R>, headers: Headers.Input): Effect.Effect<A, E, R>
-} = dual(2, (self, headers) => {
-  const resolved = Headers.fromInput(headers)
-  return Effect.locallyWith(self, currentHeaders, (prev) => ({ ...prev, ...resolved }))
-})
+export const ForkTypeId: unique symbol = Symbol.for("@effect/rpc/Rpc/Fork")
 
 /**
  * @since 1.0.0
- * @category headers
+ * @category Fork
  */
-export const schemaHeaders = <R, I extends Record.ReadonlyRecord<string, string | undefined>, A>(
-  schema: Schema.Schema<R, I, A>
-): Effect.Effect<R, ParseResult.ParseError, A> => {
-  const decode = Schema.decodeUnknown(schema)
-  return Effect.flatMap(FiberRef.get(currentHeaders), decode)
-}
+export type ForkTypeId = typeof ForkTypeId
 
 /**
  * @since 1.0.0
- * @category requests
+ * @category Fork
  */
-export const request = <A extends Schema.TaggedRequest.All>(
-  request: A,
-  options?: {
-    readonly spanPrefix?: string
-  }
-): Effect.Effect<Request<A>, never, Scope> =>
-  pipe(
-    Effect.makeSpanScoped(`${options?.spanPrefix ?? "Rpc.request "}${request._tag}`, {
-      kind: "client",
-      captureStackTrace: false
-    }),
-    Effect.zip(FiberRef.get(currentHeaders)),
-    Effect.map(([span, headers]) =>
-      Internal.makeRequest({
-        request,
-        traceId: span.traceId,
-        spanId: span.spanId,
-        sampled: span.sampled,
-        headers
-      })
-    )
-  )
-
-/**
- * @since 1.0.0
- * @category requests
- */
-export const call = <
-  A extends Schema.TaggedRequest.All,
-  R extends
-    | RequestResolver.RequestResolver<Request<A>>
-    | Effect.Effect<RequestResolver.RequestResolver<Request<A>>, never, any>
->(
-  req: A,
-  resolver: R,
-  options?: {
-    readonly spanPrefix?: string
-  }
-): R extends Effect.Effect<infer _A, infer _E, infer R> ? Rpc.Result<A, R> : Rpc.Result<A> => {
-  const isStream = Internal.StreamRequestTypeId in req
-  const res = pipe(
-    request(req, options),
-    Effect.flatMap((_) => Effect.request(_, resolver))
-  )
-  return isStream ? Stream.unwrapScoped(res as any) : Effect.scoped(res) as any
+export interface Fork<A> {
+  readonly [ForkTypeId]: ForkTypeId
+  readonly value: A
 }
 
 /**
+ * You can use `fork` to wrap a response Effect or Stream, to ensure that the
+ * response is executed concurrently regardless of the RpcServer concurrency
+ * setting.
+ *
  * @since 1.0.0
- * @category context
+ * @category Fork
  */
-export const provideServiceEffect: {
-  /**
-   * @since 1.0.0
-   * @category context
-   */
-  <I, S, E, R2>(tag: Context.Tag<I, S>, effect: Effect.Effect<S, E, R2>): <Req extends Schema.TaggedRequest.All, R>(self: Rpc<Req, R>) => Rpc<Req, Exclude<R, I> | R2>
-  /**
-   * @since 1.0.0
-   * @category context
-   */
-  <Req extends Schema.TaggedRequest.All, R, I, S, E, R2>(self: Rpc<Req, R>, tag: Context.Tag<I, S>, effect: Effect.Effect<S, E, R2>): Rpc<Req, Exclude<R, I> | R2>
-} = dual(3, <Req extends Schema.TaggedRequest.All, R, I, S, E, R2>(
-  self: Rpc<Req, R>,
-  tag: Context.Tag<I, S>,
-  make: Effect.Effect<S, E, R2>
-): Rpc<Req, Exclude<R, I> | R2> =>
-  self._tag === "Effect"
-    ? effect(self.schema, (req) => Effect.provideServiceEffect(self.handler(req), tag, Effect.orDie(make))) as any
-    : stream(
-      self.schema as any,
-      (req) => Stream.provideServiceEffect(self.handler(req as any), tag, Effect.orDie(make))
-    ))
+export const fork = <A>(value: A): Fork<A> => ({ [ForkTypeId]: ForkTypeId, value })
 
 /**
  * @since 1.0.0
- * @category context
+ * @category Fork
  */
-export const provideService: {
-  /**
-   * @since 1.0.0
-   * @category context
-   */
-  <I, S>(tag: Context.Tag<I, S>, service: S): <Req extends Schema.TaggedRequest.All, R>(self: Rpc<Req, R>) => Rpc<Req, Exclude<R, I>>
-  /**
-   * @since 1.0.0
-   * @category context
-   */
-  <Req extends Schema.TaggedRequest.All, R, I, S>(self: Rpc<Req, R>, tag: Context.Tag<I, S>, service: S): Rpc<Req, Exclude<R, I>>
-} = dual(3, <Req extends Schema.TaggedRequest.All, R, I, S>(
-  self: Rpc<Req, R>,
-  tag: Context.Tag<I, S>,
-  service: S
-): Rpc<Req, Exclude<R, I>> =>
-  self._tag === "Effect"
-    ? effect(self.schema, (req) => Effect.provideService(self.handler(req), tag, service)) as any
-    : stream(
-      self.schema as any,
-      (req) => Stream.provideService(self.handler(req as any), tag, service)
-    ))
+export const isFork = (u: object): u is Fork<any> => ForkTypeId in u
diff --git a/src/RpcClient.ts b/src/RpcClient.ts
new file mode 100644
index 0000000000000000000000000000000000000000..18416a1183d509787aff3cfe8cd1ba7d7c9fa7f7
--- /dev/null
+++ b/src/RpcClient.ts
@@ -0,0 +1,1028 @@
+/**
+ * @since 1.0.0
+ */
+import * as Headers from "@effect/platform/Headers"
+import * as HttpBody from "@effect/platform/HttpBody"
+import * as HttpClient from "@effect/platform/HttpClient"
+import * as HttpClientRequest from "@effect/platform/HttpClientRequest"
+import * as Socket from "@effect/platform/Socket"
+import * as Transferable from "@effect/platform/Transferable"
+import * as Worker from "@effect/platform/Worker"
+import type { WorkerError } from "@effect/platform/WorkerError"
+import type { NonEmptyReadonlyArray } from "effect/Array"
+import * as Cause from "effect/Cause"
+import * as Chunk from "effect/Chunk"
+import * as Context from "effect/Context"
+import type * as Duration from "effect/Duration"
+import * as Effect from "effect/Effect"
+import * as Exit from "effect/Exit"
+import * as Fiber from "effect/Fiber"
+import * as FiberId from "effect/FiberId"
+import * as FiberRef from "effect/FiberRef"
+import { constVoid, dual, identity } from "effect/Function"
+import { globalValue } from "effect/GlobalValue"
+import * as Layer from "effect/Layer"
+import * as Mailbox from "effect/Mailbox"
+import * as Option from "effect/Option"
+import type { ParseError } from "effect/ParseResult"
+import * as Pool from "effect/Pool"
+import * as Runtime from "effect/Runtime"
+import * as Schedule from "effect/Schedule"
+import * as Schema from "effect/Schema"
+import * as Scope from "effect/Scope"
+import * as Stream from "effect/Stream"
+import type { Span } from "effect/Tracer"
+import type { Mutable } from "effect/Types"
+import { withRun } from "./internal/utils.js"
+import * as Rpc from "./Rpc.js"
+import type * as RpcGroup from "./RpcGroup.js"
+import type { FromClient, FromClientEncoded, FromServer, FromServerEncoded, Request, RequestId } from "./RpcMessage.js"
+import { constPing } from "./RpcMessage.js"
+import type * as RpcMiddleware from "./RpcMiddleware.js"
+import * as RpcSchema from "./RpcSchema.js"
+import * as RpcSerialization from "./RpcSerialization.js"
+import * as RpcWorker from "./RpcWorker.js"
+
+/**
+ * @since 1.0.0
+ * @category client
+ */
+export type RpcClient<Rpcs extends Rpc.Any, E = never> = {
+  readonly [Current in Rpcs as Current["_tag"]]: <const AsMailbox extends boolean = false, const Discard = false>(
+    input: Rpc.PayloadConstructor<Current>,
+    options?: Rpc.Success<Current> extends Stream.Stream<infer _A, infer _E, infer _R> ? {
+        readonly asMailbox?: AsMailbox | undefined
+        readonly streamBufferSize?: number | undefined
+        readonly headers?: Headers.Input | undefined
+        readonly context?: Context.Context<never> | undefined
+      } :
+      {
+        readonly headers?: Headers.Input | undefined
+        readonly context?: Context.Context<never> | undefined
+        readonly discard?: Discard | undefined
+      }
+  ) => Rpc.Success<Current> extends Stream.Stream<infer _A, infer _E, infer _R>
+    ? AsMailbox extends true ? Effect.Effect<
+        Mailbox.ReadonlyMailbox<_A, _E | Rpc.Error<Current> | E>,
+        never,
+        Scope.Scope | Rpc.Context<Current>
+      >
+    : Stream.Stream<_A, _E | Rpc.Error<Current> | E, Rpc.Context<Current>>
+    : Effect.Effect<
+      Discard extends true ? void : Rpc.Success<Current>,
+      Discard extends true ? never : Rpc.Error<Current> | E,
+      Rpc.Context<Current>
+    >
+}
+
+/**
+ * @since 1.0.0
+ * @category client
+ */
+export type FromGroup<Group> = RpcClient<RpcGroup.Rpcs<Group>>
+
+let requestIdCounter = BigInt(0)
+
+/**
+ * @since 1.0.0
+ * @category client
+ */
+export const makeNoSerialization: <Rpcs extends Rpc.Any, E>(
+  group: RpcGroup.RpcGroup<Rpcs>,
+  options: {
+    readonly onFromClient: (
+      options: {
+        readonly message: FromClient<Rpcs>
+        readonly context: Context.Context<never>
+        readonly discard: boolean
+      }
+    ) => Effect.Effect<void, E>
+    readonly supportsAck?: boolean | undefined
+    readonly spanPrefix?: string | undefined
+    readonly generateRequestId?: (() => RequestId) | undefined
+    readonly disableTracing?: boolean | undefined
+  }
+) => Effect.Effect<
+  {
+    readonly client: RpcClient<Rpcs, E>
+    readonly write: (message: FromServer<Rpcs>) => Effect.Effect<void>
+  },
+  never,
+  Scope.Scope | Rpc.MiddlewareClient<Rpcs>
+> = Effect.fnUntraced(function*<Rpcs extends Rpc.Any, E>(
+  group: RpcGroup.RpcGroup<Rpcs>,
+  options: {
+    readonly onFromClient: (
+      options: {
+        readonly message: FromClient<Rpcs>
+        readonly context: Context.Context<never>
+        readonly discard: boolean
+      }
+    ) => Effect.Effect<void, E>
+    readonly supportsAck?: boolean | undefined
+    readonly spanPrefix?: string | undefined
+    readonly generateRequestId?: (() => RequestId) | undefined
+    readonly disableTracing?: boolean | undefined
+  }
+) {
+  const spanPrefix = options?.spanPrefix ?? "RpcClient"
+  const supportsAck = options?.supportsAck ?? true
+  const disableTracing = options?.disableTracing ?? false
+  const generateRequestId = options?.generateRequestId ?? (() => requestIdCounter++ as RequestId)
+
+  const context = yield* Effect.context<Rpc.MiddlewareClient<Rpcs> | Scope.Scope>()
+  const scope = Context.get(context, Scope.Scope)
+
+  type ClientEntry = {
+    readonly _tag: "Effect"
+    readonly rpc: Rpc.AnyWithProps
+    readonly context: Context.Context<never>
+    resume: (_: Exit.Exit<any, any>) => void
+  } | {
+    readonly _tag: "Mailbox"
+    readonly rpc: Rpc.AnyWithProps
+    readonly mailbox: Mailbox.Mailbox<any, any>
+    readonly scope: Scope.Scope
+    readonly context: Context.Context<never>
+  }
+  const entries = new Map<RequestId, ClientEntry>()
+
+  let isShutdown = false
+  yield* Scope.addFinalizer(
+    scope,
+    Effect.fiberIdWith((fiberId) => {
+      isShutdown = true
+      return clearEntries(Exit.interrupt(fiberId))
+    })
+  )
+
+  const clearEntries = Effect.fnUntraced(function*(exit: Exit.Exit<never>) {
+    for (const [id, entry] of entries) {
+      entries.delete(id)
+      if (entry._tag === "Mailbox") {
+        yield* entry.mailbox.done(exit)
+      } else {
+        entry.resume(exit)
+      }
+    }
+  })
+
+  const onRequest = (rpc: Rpc.AnyWithProps) => {
+    const isStream = RpcSchema.isStreamSchema(rpc.successSchema)
+    const middleware = getRpcClientMiddleware(rpc)
+    return (payload: any, options?: {
+      readonly asMailbox?: boolean | undefined
+      readonly streamBufferSize?: number | undefined
+      readonly headers?: Headers.Input | undefined
+      readonly context?: Context.Context<never> | undefined
+      readonly discard?: boolean | undefined
+    }) => {
+      const headers = options?.headers ? Headers.fromInput(options.headers) : Headers.empty
+      if (!isStream) {
+        const effect = Effect.useSpan(
+          `${spanPrefix}.${rpc._tag}`,
+          { captureStackTrace: false },
+          (span) =>
+            onEffectRequest(
+              rpc,
+              middleware,
+              span,
+              payload ? rpc.payloadSchema.make(payload) : {},
+              headers,
+              options?.context ?? Context.empty(),
+              options?.discard ?? false
+            )
+        )
+        return disableTracing ? Effect.withTracerEnabled(effect, false) : effect
+      }
+      const mailbox = Effect.suspend(() =>
+        onStreamRequest(
+          rpc,
+          middleware,
+          payload ? rpc.payloadSchema.make(payload) : {},
+          headers,
+          options?.streamBufferSize ?? 16,
+          options?.context ?? Context.empty()
+        )
+      )
+      if (options?.asMailbox) return mailbox
+      return Stream.unwrapScoped(Effect.map(mailbox, Mailbox.toStream))
+    }
+  }
+
+  const onEffectRequest = (
+    rpc: Rpc.AnyWithProps,
+    middleware: (request: Request<Rpcs>) => Effect.Effect<Request<Rpcs>>,
+    span: Span,
+    payload: any,
+    headers: Headers.Headers,
+    context: Context.Context<never>,
+    discard: boolean
+  ) =>
+    Effect.withFiberRuntime<any, any, any>((parentFiber) => {
+      if (isShutdown) {
+        return Effect.interrupt
+      }
+      const id = generateRequestId()
+      const send = middleware({
+        _tag: "Request",
+        id,
+        tag: rpc._tag as Rpc.Tag<Rpcs>,
+        payload,
+        traceId: span.traceId,
+        spanId: span.spanId,
+        sampled: span.sampled,
+        headers: Headers.merge(parentFiber.getFiberRef(currentHeaders), headers)
+      })
+      if (discard) {
+        return Effect.flatMap(send, (message) =>
+          options.onFromClient({
+            message,
+            context,
+            discard
+          }))
+      }
+      const runtime = Runtime.make({
+        context: parentFiber.currentContext,
+        fiberRefs: parentFiber.getFiberRefs(),
+        runtimeFlags: Runtime.defaultRuntime.runtimeFlags
+      })
+      let fiber: Fiber.RuntimeFiber<any, any>
+      return Effect.onInterrupt(
+        Effect.async<any, any>((resume) => {
+          const entry: ClientEntry = {
+            _tag: "Effect",
+            rpc,
+            context,
+            resume(exit) {
+              resume(exit)
+              if (!fiber.unsafePoll()) {
+                parentFiber.currentScheduler.scheduleTask(() => {
+                  fiber.unsafeInterruptAsFork(parentFiber.id())
+                }, 0)
+              }
+            }
+          }
+          entries.set(id, entry)
+          fiber = send.pipe(
+            Effect.flatMap((request) =>
+              options.onFromClient({
+                message: request,
+                context,
+                discard
+              })
+            ),
+            Effect.withParentSpan(span),
+            Runtime.runFork(runtime)
+          )
+          fiber.addObserver((exit) => {
+            if (exit._tag === "Failure") {
+              return resume(exit)
+            }
+          })
+        }),
+        (interruptors) => {
+          entries.delete(id)
+          const ids = Array.from(interruptors).flatMap((id) => Array.from(FiberId.toSet(id)))
+          return Effect.zipRight(
+            Fiber.interrupt(fiber),
+            sendInterrupt(id, ids, context)
+          )
+        }
+      )
+    })
+
+  const onStreamRequest = Effect.fnUntraced(function*(
+    rpc: Rpc.AnyWithProps,
+    middleware: (request: Request<Rpcs>) => Effect.Effect<Request<Rpcs>>,
+    payload: any,
+    headers: Headers.Headers,
+    streamBufferSize: number,
+    context: Context.Context<never>
+  ) {
+    if (isShutdown) {
+      return yield* Effect.interrupt
+    }
+
+    const span = yield* Effect.makeSpanScoped(`${spanPrefix}.${rpc._tag}`, { captureStackTrace: false }).pipe(
+      disableTracing ? Effect.withTracerEnabled(false) : identity
+    )
+    const fiber = Option.getOrThrow(Fiber.getCurrentFiber())
+    const id = generateRequestId()
+
+    const scope = Context.unsafeGet(fiber.currentContext, Scope.Scope)
+    yield* Scope.addFinalizerExit(
+      scope,
+      (exit) => {
+        if (!entries.has(id)) return Effect.void
+        entries.delete(id)
+        return sendInterrupt(
+          id,
+          Exit.isFailure(exit)
+            ? Array.from(Cause.interruptors(exit.cause)).flatMap((id) => Array.from(FiberId.toSet(id)))
+            : [],
+          context
+        )
+      }
+    )
+
+    const mailbox = yield* Mailbox.make<any, any>(streamBufferSize)
+    entries.set(id, {
+      _tag: "Mailbox",
+      rpc,
+      mailbox,
+      scope,
+      context
+    })
+
+    yield* middleware({
+      _tag: "Request",
+      id,
+      tag: rpc._tag as Rpc.Tag<Rpcs>,
+      traceId: span.traceId,
+      payload,
+      spanId: span.spanId,
+      sampled: span.sampled,
+      headers: Headers.merge(fiber.getFiberRef(currentHeaders), headers)
+    }).pipe(
+      Effect.flatMap(
+        (request) =>
+          options.onFromClient({
+            message: request,
+            context,
+            discard: false
+          })
+      ),
+      Effect.withParentSpan(span),
+      Effect.catchAllCause((error) => mailbox.failCause(error)),
+      Effect.interruptible,
+      Effect.forkIn(scope)
+    )
+
+    return mailbox
+  })
+
+  const getRpcClientMiddleware = (rpc: Rpc.AnyWithProps): (request: Request<Rpcs>) => Effect.Effect<Request<Rpcs>> => {
+    const middlewares: Array<RpcMiddleware.RpcMiddlewareClient> = []
+    for (const tag of rpc.middlewares.values()) {
+      const middleware = context.unsafeMap.get(`${tag.key}/Client`)
+      if (!middleware) continue
+      middlewares.push(middleware)
+    }
+    return middlewares.length === 0
+      ? Effect.succeed
+      : function(request) {
+        let i = 0
+        return Effect.map(
+          Effect.whileLoop({
+            while: () => i < middlewares.length,
+            body: () =>
+              middlewares[i]({
+                rpc,
+                request
+              }) as Effect.Effect<Request<Rpcs>>,
+            step(nextRequest) {
+              request = nextRequest
+              i++
+            }
+          }),
+          () => request
+        )
+      }
+  }
+
+  const sendInterrupt = (
+    requestId: RequestId,
+    interruptors: ReadonlyArray<FiberId.FiberId>,
+    context: Context.Context<never>
+  ): Effect.Effect<void> =>
+    Effect.async<void>((resume) => {
+      const parentFiber = Option.getOrThrow(Fiber.getCurrentFiber())
+      const runtime = Runtime.make({
+        context: parentFiber.currentContext,
+        fiberRefs: parentFiber.getFiberRefs(),
+        runtimeFlags: Runtime.defaultRuntime.runtimeFlags
+      })
+      const fiber = options.onFromClient({
+        message: { _tag: "Interrupt", requestId, interruptors },
+        context,
+        discard: false
+      }).pipe(
+        Effect.timeout(1000),
+        Runtime.runFork(runtime)
+      )
+      fiber.addObserver(() => {
+        resume(Effect.void)
+      })
+    })
+
+  const write = (message: FromServer<Rpcs>): Effect.Effect<void> => {
+    switch (message._tag) {
+      case "Chunk": {
+        const requestId = parseRequestId(message.requestId)
+        const entry = entries.get(requestId)
+        if (!entry || entry._tag !== "Mailbox") return Effect.void
+        return entry.mailbox.offerAll(message.values).pipe(
+          supportsAck
+            ? Effect.zipRight(
+              options.onFromClient({
+                message: { _tag: "Ack", requestId: message.requestId },
+                context: entry.context,
+                discard: false
+              })
+            )
+            : identity,
+          Effect.onError((cause) => entry.mailbox.done(Exit.failCause(cause))),
+          Effect.forkIn(entry.scope)
+        )
+      }
+      case "Exit": {
+        const requestId = parseRequestId(message.requestId)
+        const entry = entries.get(requestId)
+        if (!entry) return Effect.void
+        entries.delete(requestId)
+        if (entry._tag === "Effect") {
+          entry.resume(message.exit)
+          return Effect.void
+        }
+        return entry.mailbox.done(Exit.asVoid(message.exit))
+      }
+      case "Defect": {
+        return clearEntries(Exit.die(message.defect))
+      }
+      case "ClientEnd": {
+        return Effect.void
+      }
+    }
+  }
+
+  const client = {} as Mutable<RpcClient<Rpcs>>
+  for (const rpc of group.requests.values()) {
+    ;(client as any)[rpc._tag] = onRequest(rpc as any)
+  }
+
+  return {
+    client: client as RpcClient<Rpcs>,
+    write
+  } as const
+})
+
+/**
+ * @since 1.0.0
+ * @category client
+ */
+export const make: <Rpcs extends Rpc.Any>(
+  group: RpcGroup.RpcGroup<Rpcs>,
+  options?: {
+    readonly spanPrefix?: string | undefined
+    readonly generateRequestId?: (() => RequestId) | undefined
+    readonly disableTracing?: boolean | undefined
+  } | undefined
+) => Effect.Effect<
+  RpcClient<Rpcs>,
+  never,
+  Protocol | Rpc.MiddlewareClient<Rpcs> | Scope.Scope
+> = Effect.fnUntraced(function*<Rpcs extends Rpc.Any>(
+  group: RpcGroup.RpcGroup<Rpcs>,
+  options?: {
+    readonly spanPrefix?: string | undefined
+    readonly generateRequestId?: (() => RequestId) | undefined
+    readonly disableTracing?: boolean | undefined
+  } | undefined
+) {
+  const { run, send, supportsAck, supportsTransferables } = yield* Protocol
+
+  type ClientEntry = {
+    readonly rpc: Rpc.AnyWithProps
+    readonly context: Context.Context<never>
+    readonly decodeChunk:
+      | ((chunk: ReadonlyArray<unknown>) => Effect.Effect<NonEmptyReadonlyArray<any>, ParseError, unknown>)
+      | undefined
+  }
+  const entries = new Map<RequestId, ClientEntry>()
+
+  const { client, write } = yield* makeNoSerialization(group, {
+    ...options,
+    supportsAck,
+    onFromClient({ message }) {
+      switch (message._tag) {
+        case "Request": {
+          const rpc = group.requests.get(message.tag)! as any as Rpc.AnyWithProps
+          const schemas = RpcSchema.getStreamSchemas(rpc.successSchema.ast)
+          const collector = supportsTransferables ? Transferable.unsafeMakeCollector() : undefined
+
+          const fiber = Option.getOrThrow(Fiber.getCurrentFiber())
+
+          const entry: ClientEntry = {
+            rpc,
+            context: collector
+              ? Context.add(fiber.currentContext, Transferable.Collector, collector)
+              : fiber.currentContext,
+            decodeChunk: Option.isSome(schemas)
+              ? Schema.decodeUnknown(Schema.NonEmptyArray(schemas.value.success))
+              : undefined
+          }
+          entries.set(message.id, entry)
+
+          return Schema.encode(rpc.payloadSchema)(message.payload).pipe(
+            Effect.locally(FiberRef.currentContext, entry.context),
+            Effect.orDie,
+            Effect.flatMap((payload) =>
+              send({
+                ...message,
+                payload,
+                headers: Object.entries(message.headers)
+              }, collector && collector.unsafeClear())
+            )
+          ) as Effect.Effect<void>
+        }
+        case "Ack": {
+          const entry = entries.get(message.requestId)
+          if (!entry) return Effect.void
+          return send(message) as Effect.Effect<void>
+        }
+        case "Interrupt": {
+          const entry = entries.get(message.requestId)
+          if (!entry) return Effect.void
+          entries.delete(message.requestId)
+          return send({
+            _tag: "Interrupt",
+            requestId: message.requestId
+          }) as Effect.Effect<void>
+        }
+        case "Eof": {
+          return Effect.void
+        }
+      }
+    }
+  })
+
+  yield* run((message) => {
+    switch (message._tag) {
+      case "Chunk": {
+        const requestId = parseRequestId(message.requestId)
+        const entry = entries.get(requestId)
+        if (!entry || !entry.decodeChunk) return Effect.void
+        return entry.decodeChunk(message.values).pipe(
+          Effect.locally(FiberRef.currentContext, entry.context),
+          Effect.orDie,
+          Effect.flatMap((chunk) =>
+            write({ _tag: "Chunk", clientId: 0, requestId: parseRequestId(message.requestId), values: chunk })
+          ),
+          Effect.onError((cause) =>
+            write({
+              _tag: "Exit",
+              clientId: 0,
+              requestId: parseRequestId(message.requestId),
+              exit: Exit.failCause(cause)
+            })
+          )
+        ) as Effect.Effect<void>
+      }
+      case "Exit": {
+        const requestId = parseRequestId(message.requestId)
+        const entry = entries.get(requestId)
+        if (!entry) return Effect.void
+        entries.delete(requestId)
+        return Schema.decode(Rpc.exitSchema(entry.rpc as any))(message.exit).pipe(
+          Effect.locally(FiberRef.currentContext, entry.context),
+          Effect.orDie,
+          Effect.matchCauseEffect({
+            onSuccess: (exit) => write({ _tag: "Exit", clientId: 0, requestId, exit }),
+            onFailure: (cause) => write({ _tag: "Exit", clientId: 0, requestId, exit: Exit.failCause(cause) })
+          })
+        ) as Effect.Effect<void>
+      }
+      case "Defect": {
+        return write({ _tag: "Defect", clientId: 0, defect: decodeDefect(message.defect) })
+      }
+      default: {
+        return Effect.void
+      }
+    }
+  }).pipe(
+    Effect.catchAllCause(Effect.logError),
+    Effect.interruptible,
+    Effect.forkScoped
+  )
+
+  return client
+})
+
+const parseRequestId = (input: string | bigint): RequestId => typeof input === "string" ? BigInt(input) : input as any
+
+/**
+ * @since 1.0.0
+ * @category headers
+ */
+export const currentHeaders: FiberRef.FiberRef<Headers.Headers> = globalValue(
+  "@effect/rpc/RpcClient/currentHeaders",
+  () => FiberRef.unsafeMake(Headers.empty)
+)
+
+/**
+ * @since 1.0.0
+ * @category headers
+ */
+export const withHeaders: {
+  /**
+   * @since 1.0.0
+   * @category headers
+   */
+  (headers: Headers.Input): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>
+  /**
+   * @since 1.0.0
+   * @category headers
+   */
+  <A, E, R>(effect: Effect.Effect<A, E, R>, headers: Headers.Input): Effect.Effect<A, E, R>
+} = dual(
+  2,
+  <A, E, R>(effect: Effect.Effect<A, E, R>, headers: Headers.Input): Effect.Effect<A, E, R> =>
+    Effect.locallyWith(effect, currentHeaders, Headers.merge(Headers.fromInput(headers)))
+)
+
+/**
+ * @since 1.0.0
+ * @category headers
+ */
+export const withHeadersEffect: {
+  /**
+   * @since 1.0.0
+   * @category headers
+   */
+  <E2, R2>(
+    headers: Effect.Effect<Headers.Input, E2, R2>
+  ): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E | E2, R | R2>
+  /**
+   * @since 1.0.0
+   * @category headers
+   */
+  <A, E, R, E2, R2>(
+    effect: Effect.Effect<A, E, R>,
+    headers: Effect.Effect<Headers.Input, E2, R2>
+  ): Effect.Effect<A, E | E2, R | R2>
+} = dual(
+  2,
+  <A, E, R, E2, R2>(
+    effect: Effect.Effect<A, E, R>,
+    headers: Effect.Effect<Headers.Input, E2, R2>
+  ): Effect.Effect<A, E | E2, R | R2> => Effect.flatMap(headers, (headers) => withHeaders(effect, headers))
+)
+
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+export class Protocol extends Context.Tag("@effect/rpc/RpcClient/Protocol")<Protocol, {
+  readonly run: (
+    f: (data: FromServerEncoded) => Effect.Effect<void>
+  ) => Effect.Effect<never>
+  readonly send: (
+    request: FromClientEncoded,
+    transferables?: ReadonlyArray<globalThis.Transferable>
+  ) => Effect.Effect<void>
+  readonly supportsAck: boolean
+  readonly supportsTransferables: boolean
+}>() {
+  /**
+   * @since 1.0.0
+   */
+  static make = withRun<Protocol["Type"]>()
+}
+
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+export const makeProtocolHttp = (client: HttpClient.HttpClient): Effect.Effect<
+  Protocol["Type"],
+  never,
+  RpcSerialization.RpcSerialization
+> =>
+  Protocol.make(Effect.fnUntraced(function*(writeResponse) {
+    const serialization = yield* RpcSerialization.RpcSerialization
+    const isJson = serialization.contentType === "application/json"
+
+    const send = (request: FromClientEncoded): Effect.Effect<void> => {
+      if (request._tag !== "Request") {
+        return Effect.void
+      }
+
+      const parser = serialization.unsafeMake()
+      if (!serialization.supportsBigInt) transformBigInt(request)
+
+      const encoded = parser.encode(request)
+      const body = typeof encoded === "string" ?
+        HttpBody.text(encoded, serialization.contentType) :
+        HttpBody.uint8Array(encoded, serialization.contentType)
+
+      if (isJson) {
+        return client.post("/", { body }).pipe(
+          Effect.flatMap((r) => r.json),
+          Effect.scoped,
+          Effect.flatMap((u) => {
+            if (!Array.isArray(u)) {
+              return Effect.dieMessage(`Expected an array of responses, but got: ${u}`)
+            }
+            let i = 0
+            return Effect.whileLoop({
+              while: () => i < u.length,
+              body: () => writeResponse(u[i++]),
+              step: constVoid
+            })
+          }),
+          Effect.orDie
+        )
+      }
+
+      return client.post("/", { body }).pipe(
+        Effect.flatMap((r) =>
+          Stream.runForEachChunk(r.stream, (chunk) => {
+            const responses = Chunk.toReadonlyArray(chunk).flatMap(parser.decode) as Array<FromServerEncoded>
+            if (responses.length === 0) return Effect.void
+            let i = 0
+            return Effect.whileLoop({
+              while: () => i < responses.length,
+              body: () => writeResponse(responses[i++]),
+              step: constVoid
+            })
+          })
+        ),
+        Effect.orDie
+      )
+    }
+
+    return {
+      send,
+      supportsAck: false,
+      supportsTransferables: false
+    }
+  }))
+
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+export const layerProtocolHttp = (options: {
+  readonly url: string
+  readonly transformClient?: <E, R>(client: HttpClient.HttpClient.With<E, R>) => HttpClient.HttpClient.With<E, R>
+}): Layer.Layer<Protocol, never, RpcSerialization.RpcSerialization | HttpClient.HttpClient> =>
+  Layer.scoped(
+    Protocol,
+    Effect.flatMap(
+      HttpClient.HttpClient,
+      (client) => {
+        client = HttpClient.mapRequest(client, HttpClientRequest.prependUrl(options.url))
+        return makeProtocolHttp(options.transformClient ? options.transformClient(client) : client)
+      }
+    )
+  )
+
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+export const makeProtocolSocket: Effect.Effect<
+  Protocol["Type"],
+  never,
+  Scope.Scope | RpcSerialization.RpcSerialization | Socket.Socket
+> = Protocol.make(Effect.fnUntraced(function*(writeResponse) {
+  const socket = yield* Socket.Socket
+  const serialization = yield* RpcSerialization.RpcSerialization
+
+  const write = yield* socket.writer
+
+  let parser = serialization.unsafeMake()
+
+  yield* Effect.suspend(() => {
+    parser = serialization.unsafeMake()
+    return socket.runRaw((message) => {
+      try {
+        const responses = parser.decode(message) as Array<FromServerEncoded>
+        if (responses.length === 0) return
+        let i = 0
+        return Effect.whileLoop({
+          while: () => i < responses.length,
+          body: () => writeResponse(responses[i++]),
+          step: constVoid
+        })
+      } catch (defect) {
+        return writeResponse({ _tag: "Defect", defect })
+      }
+    })
+  }).pipe(
+    Effect.zipRight(Effect.fail(
+      new Socket.SocketCloseError({
+        reason: "Close",
+        code: 1000
+      })
+    )),
+    Effect.tapErrorCause((cause) => writeResponse({ _tag: "Defect", defect: Cause.squash(cause) })),
+    Effect.retry(Schedule.spaced(1000)),
+    Effect.annotateLogs({
+      module: "RpcClient",
+      method: "makeProtocolSocket"
+    }),
+    Effect.interruptible,
+    Effect.forkScoped
+  )
+
+  yield* Effect.suspend(() => write(parser.encode(constPing))).pipe(
+    Effect.delay("30 seconds"),
+    Effect.ignore,
+    Effect.forever,
+    Effect.interruptible,
+    Effect.forkScoped
+  )
+
+  return {
+    send(request) {
+      if (!serialization.supportsBigInt) transformBigInt(request)
+      return Effect.orDie(write(parser.encode(request)))
+    },
+    supportsAck: true,
+    supportsTransferables: false
+  }
+}))
+
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+export const makeProtocolWorker = (
+  options: {
+    readonly size: number
+    readonly concurrency?: number | undefined
+    readonly targetUtilization?: number | undefined
+  } | {
+    readonly minSize: number
+    readonly maxSize: number
+    readonly concurrency?: number | undefined
+    readonly targetUtilization?: number | undefined
+    readonly timeToLive: Duration.DurationInput
+  }
+): Effect.Effect<
+  Protocol["Type"],
+  WorkerError,
+  Scope.Scope | Worker.PlatformWorker | Worker.Spawner
+> =>
+  Protocol.make(Effect.fnUntraced(function*(writeResponse) {
+    const worker = yield* Worker.PlatformWorker
+    const scope = yield* Effect.scope
+    let workerId = 0
+    const initialMessage = yield* Effect.serviceOption(RpcWorker.InitialMessage)
+
+    const entries = new Map<string | bigint, {
+      readonly worker: Worker.BackingWorker<FromClientEncoded | RpcWorker.InitialMessage.Encoded, FromServerEncoded>
+      readonly scope: Scope.CloseableScope
+    }>()
+
+    yield* Scope.addFinalizerExit(
+      scope,
+      (exit) =>
+        Effect.forEach(entries, ([_, entry]) => Scope.close(entry.scope, exit), {
+          discard: true,
+          concurrency: "unbounded"
+        })
+    )
+
+    const acquire = Effect.gen(function*() {
+      const id = workerId++
+      const backing = yield* worker.spawn<FromClientEncoded | RpcWorker.InitialMessage.Encoded, FromServerEncoded>(id)
+      const readyLatch = yield* Effect.makeLatch()
+
+      yield* backing.run((message) => {
+        if (message[0] === 0) {
+          return readyLatch.open
+        }
+        const response = message[1]
+        if (response._tag === "Exit") {
+          const entry = entries.get(response.requestId)
+          if (entry) {
+            entries.delete(response.requestId)
+            return Effect.ensuring(writeResponse(response), Scope.close(entry.scope, Exit.void))
+          }
+        } else if (response._tag === "Defect") {
+          return Effect.zipRight(
+            Effect.forEach(entries, ([requestId, entry]) => {
+              entries.delete(requestId)
+              return Scope.close(entry.scope, Exit.die(response.defect))
+            }, { discard: true }),
+            writeResponse(response)
+          )
+        }
+        return writeResponse(response)
+      }).pipe(
+        Effect.tapErrorCause((cause) => writeResponse({ _tag: "Defect", defect: Cause.squash(cause) })),
+        Effect.retry(Schedule.spaced(1000)),
+        Effect.annotateLogs({
+          module: "RpcClient",
+          method: "makeProtocolWorker"
+        }),
+        Effect.interruptible,
+        Effect.forkScoped
+      )
+
+      yield* readyLatch.await
+
+      if (Option.isSome(initialMessage)) {
+        const [value, transfers] = yield* initialMessage.value
+        yield* backing.send({ _tag: "InitialMessage", value }, transfers)
+      }
+
+      return backing
+    })
+
+    const pool = "minSize" in options ?
+      yield* Pool.makeWithTTL({
+        acquire,
+        min: options.minSize,
+        max: options.maxSize,
+        concurrency: options.concurrency,
+        targetUtilization: options.targetUtilization,
+        timeToLive: options.timeToLive
+      }) :
+      yield* Pool.make({
+        acquire,
+        size: options.size,
+        concurrency: options.concurrency,
+        targetUtilization: options.targetUtilization
+      })
+
+    const send = (request: FromClientEncoded, transferables?: ReadonlyArray<globalThis.Transferable>) => {
+      switch (request._tag) {
+        case "Request": {
+          return Scope.make().pipe(
+            Effect.flatMap((scope) =>
+              Effect.flatMap(Scope.extend(pool.get, scope), (worker) => {
+                entries.set(request.id, { worker, scope })
+                return Effect.orDie(worker.send(request, transferables))
+              })
+            ),
+            Effect.orDie
+          )
+        }
+        case "Interrupt": {
+          const entry = entries.get(request.requestId)
+          if (!entry) return Effect.void
+          entries.delete(request.requestId)
+          return Effect.ensuring(
+            Effect.orDie(entry.worker.send(request)),
+            Scope.close(entry.scope, Exit.void)
+          )
+        }
+        case "Ack": {
+          const entry = entries.get(request.requestId)
+          if (!entry) return Effect.void
+          return Effect.orDie(entry.worker.send(request))
+        }
+      }
+      return Effect.void
+    }
+
+    yield* Effect.scoped(pool.get)
+
+    return {
+      send,
+      supportsAck: true,
+      supportsTransferables: true
+    }
+  }))
+
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+export const layerProtocolWorker = (
+  options: {
+    readonly size: number
+    readonly concurrency?: number | undefined
+    readonly targetUtilization?: number | undefined
+  } | {
+    readonly minSize: number
+    readonly maxSize: number
+    readonly concurrency?: number | undefined
+    readonly targetUtilization?: number | undefined
+    readonly timeToLive: Duration.DurationInput
+  }
+): Layer.Layer<Protocol, WorkerError, Worker.PlatformWorker | Worker.Spawner> =>
+  Layer.scoped(Protocol, makeProtocolWorker(options))
+
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+export const layerProtocolSocket: Layer.Layer<Protocol, never, Socket.Socket | RpcSerialization.RpcSerialization> =
+  Layer.scoped(Protocol, makeProtocolSocket)
+
+// internal
+
+const decodeDefect = Schema.decodeSync(Schema.Defect)
+
+const transformBigInt = (request: FromClientEncoded) => {
+  if (request._tag === "Request") {
+    ;(request as any).id = request.id.toString()
+  } else if ("requestId" in request) {
+    ;(request as any).requestId = request.requestId.toString()
+  }
+}
diff --git a/src/RpcGroup.ts b/src/RpcGroup.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b15236c74e22e1fb13111982c7f6cadf939f3530
--- /dev/null
+++ b/src/RpcGroup.ts
@@ -0,0 +1,284 @@
+/**
+ * @since 1.0.0
+ */
+import type { Headers } from "@effect/platform/Headers"
+import * as Context from "effect/Context"
+import * as Effect from "effect/Effect"
+import * as Layer from "effect/Layer"
+import type { ReadonlyMailbox } from "effect/Mailbox"
+import { type Pipeable } from "effect/Pipeable"
+import type * as Record from "effect/Record"
+import * as Schema from "effect/Schema"
+import type { Scope } from "effect/Scope"
+import type * as Stream from "effect/Stream"
+import * as Rpc from "./Rpc.js"
+import type * as RpcMiddleware from "./RpcMiddleware.js"
+
+/**
+ * @since 1.0.0
+ * @category type ids
+ */
+export const TypeId: unique symbol = Symbol.for("@effect/rpc/RpcGroup")
+
+/**
+ * @since 1.0.0
+ * @category type ids
+ */
+export type TypeId = typeof TypeId
+
+/**
+ * @since 1.0.0
+ * @category groups
+ */
+export interface RpcGroup<in out Rpcs extends Rpc.Any> extends Pipeable {
+  new(_: never): {}
+
+  readonly [TypeId]: TypeId
+  readonly requests: ReadonlyMap<string, Rpcs>
+  readonly annotations: Context.Context<never>
+
+  /**
+   * Add one or more procedures to the group.
+   */
+  add<const Rpcs2 extends ReadonlyArray<Rpc.Any>>(
+    ...rpcs: Rpcs2
+  ): RpcGroup<Rpcs | Rpcs2[number]>
+
+  /**
+   * Merge this group with another group.
+   */
+  merge<Rpcs2 extends Rpc.Any>(
+    that: RpcGroup<Rpcs2>
+  ): RpcGroup<Rpcs | Rpcs2>
+
+  /**
+   * Add middleware to all the procedures added to the group until this point.
+   */
+  middleware<M extends RpcMiddleware.TagClassAny>(middleware: M): RpcGroup<Rpc.AddMiddleware<Rpcs, M>>
+
+  /**
+   * Implement the handlers for the procedures in this group, returning a
+   * context object.
+   */
+  toHandlersContext<
+    Handlers extends HandlersFrom<Rpcs>,
+    EX = never,
+    RX = never
+  >(
+    build:
+      | Handlers
+      | Effect.Effect<Handlers, EX, RX>
+  ): Effect.Effect<
+    Context.Context<Rpc.ToHandler<Rpcs>>,
+    EX,
+    | RX
+    | HandlersContext<Rpcs, Handlers>
+  >
+
+  /**
+   * Implement the handlers for the procedures in this group.
+   */
+  toLayer<
+    Handlers extends HandlersFrom<Rpcs>,
+    EX = never,
+    RX = never
+  >(
+    build:
+      | Handlers
+      | Effect.Effect<Handlers, EX, RX>
+  ): Layer.Layer<
+    Rpc.ToHandler<Rpcs>,
+    EX,
+    | Exclude<RX, Scope>
+    | HandlersContext<Rpcs, Handlers>
+  >
+
+  /**
+   * Annotate the group with a value.
+   */
+  annotate<I, S>(tag: Context.Tag<I, S>, value: S): RpcGroup<Rpcs>
+
+  /**
+   * Annotate the Rpc's above this point with a value.
+   */
+  annotateRpcs<I, S>(tag: Context.Tag<I, S>, value: S): RpcGroup<Rpcs>
+
+  /**
+   * Annotate the group with a context object.
+   */
+  annotateContext<S>(context: Context.Context<S>): RpcGroup<Rpcs>
+
+  /**
+   * Annotate the Rpc's above this point with a context object.
+   */
+  annotateRpcsContext<S>(context: Context.Context<S>): RpcGroup<Rpcs>
+}
+
+/**
+ * @since 1.0.0
+ * @category groups
+ */
+export type HandlersFrom<Rpc extends Rpc.Any> = {
+  readonly [Current in Rpc as Current["_tag"]]: (
+    payload: Rpc.Payload<Current>,
+    headers: Headers
+  ) => ResultFrom<Current> | Rpc.Fork<ResultFrom<Current>>
+}
+
+/**
+ * @since 1.0.0
+ * @category groups
+ */
+export type ResultFrom<Rpc extends Rpc.Any> = Rpc.Success<Rpc> extends Stream.Stream<infer _A, infer _E, infer _R> ?
+    | Stream.Stream<
+      _A,
+      _E | Rpc.Error<Rpc>,
+      any
+    >
+    | Effect.Effect<ReadonlyMailbox<_A, _E | Rpc.Error<Rpc>>, _E | Rpc.Error<Rpc>, any> :
+  Effect.Effect<
+    Rpc.Success<Rpc>,
+    Rpc.Error<Rpc>,
+    any
+  >
+
+/**
+ * @since 1.0.0
+ * @category groups
+ */
+export type HandlersContext<Rpcs extends Rpc.Any, Handlers> = keyof Handlers extends infer K ?
+  K extends keyof Handlers & string ? [Rpc.IsStream<Rpcs, K>] extends [true] ? Handlers[K] extends (...args: any) =>
+        | Stream.Stream<infer _A, infer _E, infer _R>
+        | Rpc.Fork<Stream.Stream<infer _A, infer _E, infer _R>>
+        | Effect.Effect<
+          ReadonlyMailbox<infer _A, infer _E>,
+          infer _EX,
+          infer _R
+        >
+        | Rpc.Fork<
+          Effect.Effect<
+            ReadonlyMailbox<infer _A, infer _E>,
+            infer _EX,
+            infer _R
+          >
+        > ? Exclude<Rpc.ExcludeProvides<_R, Rpcs, K>, Scope> :
+      never :
+    Handlers[K] extends (
+      ...args: any
+    ) => Effect.Effect<infer _A, infer _E, infer _R> | Rpc.Fork<Effect.Effect<infer _A, infer _E, infer _R>> ?
+      Rpc.ExcludeProvides<_R, Rpcs, K>
+    : never
+  : never
+  : never
+
+/**
+ * @since 1.0.0
+ * @category groups
+ */
+export type Rpcs<Group> = Group extends RpcGroup<infer R> ? R : never
+
+const RpcGroupProto = {
+  add(this: RpcGroup<any>, ...rpcs: Array<any>) {
+    return makeProto({
+      requests: resolveInput(
+        ...this.requests.values(),
+        ...rpcs
+      ),
+      annotations: this.annotations
+    })
+  },
+  merge(this: RpcGroup<any>, that: RpcGroup<any>) {
+    const requests = new Map(this.requests)
+    for (const rpc of that.requests.values()) {
+      requests.set(rpc._tag, rpc)
+    }
+    return makeProto({
+      requests,
+      annotations: Context.merge(this.annotations, that.annotations)
+    })
+  },
+  middleware(this: RpcGroup<any>, middleware: RpcMiddleware.TagClassAny) {
+    const requests = new Map<string, any>()
+    for (const [tag, rpc] of this.requests) {
+      requests.set(tag, rpc.middleware(middleware))
+    }
+    return makeProto({
+      requests,
+      annotations: this.annotations
+    })
+  },
+  toHandlersContext(this: RpcGroup<any>, build: Effect.Effect<Record<string, (request: any) => any>>) {
+    return Effect.gen(this, function*() {
+      const context = yield* Effect.context<never>()
+      const handlers = Effect.isEffect(build) ? yield* build : build
+      const contextMap = new Map<string, unknown>()
+      for (const [tag, handler] of Object.entries(handlers)) {
+        const rpc = this.requests.get(tag)!
+        contextMap.set(rpc.key, {
+          handler,
+          context
+        })
+      }
+      return Context.unsafeMake(contextMap)
+    })
+  },
+  toLayer(this: RpcGroup<any>, build: Effect.Effect<Record<string, (request: any) => any>>) {
+    return Layer.scopedContext(this.toHandlersContext(build))
+  },
+  annotate(this: RpcGroup<any>, tag: Context.Tag<any, any>, value: any) {
+    return makeProto({
+      requests: this.requests,
+      annotations: Context.add(this.annotations, tag, value)
+    })
+  },
+  annotateRpcs(this: RpcGroup<any>, tag: Context.Tag<any, any>, value: any) {
+    return this.annotateRpcsContext(Context.make(tag, value))
+  },
+  annotateContext(this: RpcGroup<any>, context: Context.Context<any>) {
+    return makeProto({
+      requests: this.requests,
+      annotations: Context.merge(this.annotations, context)
+    })
+  },
+  annotateRpcsContext(this: RpcGroup<any>, context: Context.Context<any>) {
+    const requests = new Map<string, any>()
+    for (const [tag, rpc] of this.requests) {
+      requests.set(tag, rpc.annotateContext(Context.merge(context, rpc.annotations)))
+    }
+    return makeProto({
+      requests,
+      annotations: this.annotations
+    })
+  }
+}
+
+const makeProto = <Rpcs extends Rpc.Any>(options: {
+  readonly requests: ReadonlyMap<string, Rpcs>
+  readonly annotations: Context.Context<never>
+}): RpcGroup<Rpcs> =>
+  Object.assign(function() {}, RpcGroupProto, {
+    requests: options.requests,
+    annotations: options.annotations
+  }) as any
+
+const resolveInput = <Rpcs extends ReadonlyArray<Rpc.Any>>(
+  ...rpcs: Rpcs
+): ReadonlyMap<string, Rpcs[number]> => {
+  const requests = new Map<string, Rpcs[number]>()
+  for (const rpc of rpcs) {
+    requests.set(rpc._tag, Schema.isSchema(rpc) ? Rpc.fromTaggedRequest(rpc as any) : rpc as any)
+  }
+  return requests
+}
+
+/**
+ * @since 1.0.0
+ * @category groups
+ */
+export const make = <const Rpcs extends ReadonlyArray<Rpc.Any>>(
+  ...rpcs: Rpcs
+): RpcGroup<Rpcs[number]> =>
+  makeProto({
+    requests: resolveInput(...rpcs),
+    annotations: Context.empty()
+  })
diff --git a/src/RpcMessage.ts b/src/RpcMessage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52ecdec307240f431a6cf1a73862166620423b16
--- /dev/null
+++ b/src/RpcMessage.ts
@@ -0,0 +1,261 @@
+/**
+ * @since 1.0.0
+ */
+import type { Headers } from "@effect/platform/Headers"
+import type { NonEmptyReadonlyArray } from "effect/Array"
+import type { Branded } from "effect/Brand"
+import type * as FiberId from "effect/FiberId"
+import * as Schema from "effect/Schema"
+import type * as Rpc from "./Rpc.js"
+
+/**
+ * @since 1.0.0
+ * @category request
+ */
+export type FromClient<A extends Rpc.Any> = Request<A> | Ack | Interrupt | Eof
+
+/**
+ * @since 1.0.0
+ * @category request
+ */
+export type FromClientEncoded = RequestEncoded | Ack | InterruptEncoded | Ping | Eof
+
+/**
+ * @since 1.0.0
+ * @category request
+ */
+export const RequestIdTypeId: unique symbol = Symbol.for("@effect/rpc/RpcServer/RequestId")
+
+/**
+ * @since 1.0.0
+ * @category request
+ */
+export type RequestIdTypeId = typeof RequestIdTypeId
+
+/**
+ * @since 1.0.0
+ * @category request
+ */
+export type RequestId = Branded<bigint, RequestIdTypeId>
+
+/**
+ * @since 1.0.0
+ * @category request
+ */
+export const RequestId = (id: bigint | string): RequestId =>
+  typeof id === "bigint" ? id as RequestId : BigInt(id) as RequestId
+
+/**
+ * @since 1.0.0
+ * @category request
+ */
+export interface RequestEncoded {
+  readonly _tag: "Request"
+  readonly id: bigint | string
+  readonly tag: string
+  readonly payload: unknown
+  readonly traceId: string
+  readonly spanId: string
+  readonly sampled: boolean
+  readonly headers: ReadonlyArray<[string, string]>
+}
+
+/**
+ * @since 1.0.0
+ * @category request
+ */
+export interface Request<A extends Rpc.Any> {
+  readonly _tag: "Request"
+  readonly id: RequestId
+  readonly tag: Rpc.Tag<A>
+  readonly payload: Rpc.Payload<A>
+  readonly traceId: string
+  readonly spanId: string
+  readonly sampled: boolean
+  readonly headers: Headers
+}
+
+/**
+ * @since 1.0.0
+ * @category request
+ */
+export interface Ack {
+  readonly _tag: "Ack"
+  readonly requestId: RequestId
+}
+
+/**
+ * @since 1.0.0
+ * @category request
+ */
+export interface Interrupt {
+  readonly _tag: "Interrupt"
+  readonly requestId: RequestId
+  readonly interruptors: ReadonlyArray<FiberId.FiberId>
+}
+
+/**
+ * @since 1.0.0
+ * @category request
+ */
+export interface InterruptEncoded {
+  readonly _tag: "Interrupt"
+  readonly requestId: RequestId
+}
+
+/**
+ * @since 1.0.0
+ * @category request
+ */
+export interface Eof {
+  readonly _tag: "Eof"
+}
+
+/**
+ * @since 1.0.0
+ * @category request
+ */
+export interface Ping {
+  readonly _tag: "Ping"
+}
+
+/**
+ * @since 1.0.0
+ * @category request
+ */
+export const constEof: Eof = { _tag: "Eof" }
+
+/**
+ * @since 1.0.0
+ * @category request
+ */
+export const constPing: Ping = { _tag: "Ping" }
+
+/**
+ * @since 1.0.0
+ * @category response
+ */
+export type FromServer<A extends Rpc.Any> =
+  | ResponseChunk<A>
+  | ResponseExit<A>
+  | ResponseDefect
+  | ClientEnd
+
+/**
+ * @since 1.0.0
+ * @category response
+ */
+export type FromServerEncoded = ResponseChunkEncoded | ResponseExitEncoded | ResponseDefectEncoded | Pong
+
+/**
+ * @since 1.0.0
+ * @category response
+ */
+export const ResponseIdTypeId: unique symbol = Symbol.for("@effect/rpc/RpcServer/ResponseId")
+
+/**
+ * @since 1.0.0
+ * @category response
+ */
+export type ResponseIdTypeId = typeof ResponseIdTypeId
+
+/**
+ * @since 1.0.0
+ * @category response
+ */
+export type ResponseId = Branded<number, ResponseIdTypeId>
+
+/**
+ * @since 1.0.0
+ * @category response
+ */
+export interface ResponseChunkEncoded {
+  readonly _tag: "Chunk"
+  readonly requestId: bigint | string
+  readonly values: NonEmptyReadonlyArray<unknown>
+}
+
+/**
+ * @since 1.0.0
+ * @category response
+ */
+export interface ResponseChunk<A extends Rpc.Any> {
+  readonly _tag: "Chunk"
+  readonly clientId: number
+  readonly requestId: RequestId
+  readonly values: NonEmptyReadonlyArray<Rpc.SuccessChunk<A>>
+}
+
+/**
+ * @since 1.0.0
+ * @category response
+ */
+export interface ResponseExitEncoded {
+  readonly _tag: "Exit"
+  readonly requestId: bigint | string
+  readonly exit: Schema.ExitEncoded<unknown, unknown, unknown>
+}
+
+/**
+ * @since 1.0.0
+ * @category response
+ */
+export interface ResponseExit<A extends Rpc.Any> {
+  readonly _tag: "Exit"
+  readonly clientId: number
+  readonly requestId: RequestId
+  readonly exit: Rpc.Exit<A>
+}
+
+/**
+ * @since 1.0.0
+ * @category response
+ */
+export interface ResponseDefectEncoded {
+  readonly _tag: "Defect"
+  readonly defect: unknown
+}
+
+const encodeDefect = Schema.encodeSync(Schema.Defect)
+
+/**
+ * @since 1.0.0
+ * @category response
+ */
+export const ResponseDefectEncoded = (input: unknown): ResponseDefectEncoded => ({
+  _tag: "Defect",
+  defect: encodeDefect(input)
+})
+
+/**
+ * @since 1.0.0
+ * @category response
+ */
+export interface ResponseDefect {
+  readonly _tag: "Defect"
+  readonly clientId: number
+  readonly defect: unknown
+}
+
+/**
+ * @since 1.0.0
+ * @category response
+ */
+export interface ClientEnd {
+  readonly _tag: "ClientEnd"
+  readonly clientId: number
+}
+
+/**
+ * @since 1.0.0
+ * @category response
+ */
+export interface Pong {
+  readonly _tag: "Pong"
+}
+
+/**
+ * @since 1.0.0
+ * @category response
+ */
+export const constPong: Pong = { _tag: "Pong" }
diff --git a/src/RpcMiddleware.ts b/src/RpcMiddleware.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4168d1802472a68e1a10a2c1d91e91e3bfac41a2
--- /dev/null
+++ b/src/RpcMiddleware.ts
@@ -0,0 +1,265 @@
+/**
+ * @since 1.0.0
+ */
+import type { Headers } from "@effect/platform/Headers"
+import * as Context from "effect/Context"
+import * as Effect from "effect/Effect"
+import * as Layer from "effect/Layer"
+import * as Schema from "effect/Schema"
+import { Scope } from "effect/Scope"
+import type { Mutable } from "effect/Types"
+import type * as Rpc from "./Rpc.js"
+import type { Request } from "./RpcMessage.js"
+
+/**
+ * @since 1.0.0
+ * @category type ids
+ */
+export const TypeId: unique symbol = Symbol.for("@effect/rpc/RpcMiddleware")
+
+/**
+ * @since 1.0.0
+ * @category type ids
+ */
+export type TypeId = typeof TypeId
+
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export interface RpcMiddleware<Provides, E> {
+  (options: {
+    readonly rpc: Rpc.AnyWithProps
+    readonly payload: unknown
+    readonly headers: Headers
+  }): Effect.Effect<Provides, E>
+}
+
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export interface RpcMiddlewareClient<R = never> {
+  (options: {
+    readonly rpc: Rpc.AnyWithProps
+    readonly request: Request<Rpc.Any>
+  }): Effect.Effect<Request<Rpc.Any>, never, R>
+}
+
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export interface ForClient<Id> {
+  readonly _: unique symbol
+  readonly id: Id
+}
+
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export interface Any {
+  (options: {
+    readonly rpc: Rpc.AnyWithProps
+    readonly payload: unknown
+    readonly headers: Headers
+  }): Effect.Effect<any, any>
+}
+
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export interface TagClass<
+  Self,
+  Name extends string,
+  Options
+> extends
+  TagClass.Base<
+    Self,
+    Name,
+    Options,
+    RpcMiddleware<
+      TagClass.Service<Options>,
+      TagClass.FailureService<Options>
+    >
+  >
+{}
+
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export declare namespace TagClass {
+  /**
+   * @since 1.0.0
+   * @category models
+   */
+  export type Provides<Options> = Options extends {
+    readonly provides: Context.Tag<any, any>
+    readonly optional?: false
+  } ? Context.Tag.Identifier<Options["provides"]>
+    : never
+
+  /**
+   * @since 1.0.0
+   * @category models
+   */
+  export type Service<Options> = Options extends { readonly provides: Context.Tag<any, any> }
+    ? Context.Tag.Service<Options["provides"]>
+    : void
+
+  /**
+   * @since 1.0.0
+   * @category models
+   */
+  export type FailureSchema<Options> = Options extends
+    { readonly failure: Schema.Schema.All; readonly optional?: false } ? Options["failure"]
+    : typeof Schema.Never
+
+  /**
+   * @since 1.0.0
+   * @category models
+   */
+  export type Failure<Options> = Options extends
+    { readonly failure: Schema.Schema<infer _A, infer _I, infer _R>; readonly optional?: false } ? _A
+    : never
+
+  /**
+   * @since 1.0.0
+   * @category models
+   */
+  export type FailureContext<Options> = Schema.Schema.Context<FailureSchema<Options>>
+
+  /**
+   * @since 1.0.0
+   * @category models
+   */
+  export type FailureService<Options> = Optional<Options> extends true ? unknown : Failure<Options>
+
+  /**
+   * @since 1.0.0
+   * @category models
+   */
+  export type Optional<Options> = Options extends { readonly optional: true } ? true : false
+
+  /**
+   * @since 1.0.0
+   * @category models
+   */
+  export type RequiredForClient<Options> = Options extends { readonly requiredForClient: true } ? true : false
+
+  /**
+   * @since 1.0.0
+   * @category models
+   */
+  export interface Base<Self, Name extends string, Options, Service> extends Context.Tag<Self, Service> {
+    new(_: never): Context.TagClassShape<Name, Service>
+    readonly [TypeId]: TypeId
+    readonly optional: Optional<Options>
+    readonly failure: FailureSchema<Options>
+    readonly provides: Options extends { readonly provides: Context.Tag<any, any> } ? Options["provides"]
+      : undefined
+    readonly requiredForClient: RequiredForClient<Options>
+  }
+}
+
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export interface TagClassAny extends Context.Tag<any, any> {
+  readonly [TypeId]: TypeId
+  readonly optional: boolean
+  readonly provides?: Context.Tag<any, any> | undefined
+  readonly failure: Schema.Schema.All
+  readonly requiredForClient: boolean
+}
+
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export interface TagClassAnyWithProps extends Context.Tag<any, RpcMiddleware<any, any>> {
+  readonly [TypeId]: TypeId
+  readonly optional: boolean
+  readonly provides?: Context.Tag<any, any>
+  readonly failure: Schema.Schema.All
+  readonly requiredForClient: boolean
+}
+
+/**
+ * @since 1.0.0
+ * @category tags
+ */
+export const Tag = <Self>(): <
+  const Name extends string,
+  const Options extends {
+    readonly optional?: boolean
+    readonly failure?: Schema.Schema.All
+    readonly provides?: Context.Tag<any, any>
+    readonly requiredForClient?: boolean
+  }
+>(
+  id: Name,
+  options?: Options | undefined
+) => TagClass<Self, Name, Options> =>
+(
+  id: string,
+  options?: {
+    readonly optional?: boolean
+    readonly failure?: Schema.Schema.All
+    readonly provides?: Context.Tag<any, any>
+    readonly requiredForClient?: boolean
+  }
+) => {
+  const Err = globalThis.Error as any
+  const limit = Err.stackTraceLimit
+  Err.stackTraceLimit = 2
+  const creationError = new Err()
+  Err.stackTraceLimit = limit
+
+  function TagClass() {}
+  const TagClass_ = TagClass as any as Mutable<TagClassAny>
+  Object.setPrototypeOf(TagClass, Object.getPrototypeOf(Context.GenericTag<Self, any>(id)))
+  TagClass.key = id
+  Object.defineProperty(TagClass, "stack", {
+    get() {
+      return creationError.stack
+    }
+  })
+  TagClass_[TypeId] = TypeId
+  TagClass_.failure = options?.optional === true || options?.failure === undefined ? Schema.Never : options.failure
+  if (options?.provides) {
+    TagClass_.provides = options.provides
+  }
+  TagClass_.optional = options?.optional ?? false
+  TagClass_.requiredForClient = options?.requiredForClient ?? false
+  return TagClass as any
+}
+
+/**
+ * @since 1.0.0
+ * @category client
+ */
+export const layerClient = <Id, S, R, EX = never, RX = never>(
+  tag: Context.Tag<Id, S>,
+  service: RpcMiddlewareClient<R> | Effect.Effect<RpcMiddlewareClient<R>, EX, RX>
+): Layer.Layer<ForClient<Id>, EX, R | Exclude<RX, Scope>> =>
+  Layer.scopedContext(Effect.gen(function*() {
+    const context = (yield* Effect.context<R | Scope>()).pipe(
+      Context.omit(Scope)
+    ) as Context.Context<R>
+    const middleware = Effect.isEffect(service) ? yield* service : service
+    return Context.unsafeMake(
+      new Map([[
+        `${tag.key}/Client`,
+        (options: any) =>
+          Effect.mapInputContext(
+            middleware(options),
+            (requestContext) => Context.merge(context, requestContext)
+          )
+      ]])
+    )
+  }))
diff --git a/src/RpcSchema.ts b/src/RpcSchema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..36014df95b96ac4540d1115f082606c18a20dcb4
--- /dev/null
+++ b/src/RpcSchema.ts
@@ -0,0 +1,121 @@
+/**
+ * @since 1.0.0
+ */
+import type * as Chunk from "effect/Chunk"
+import * as Effect from "effect/Effect"
+import * as Option from "effect/Option"
+import * as ParseResult from "effect/ParseResult"
+import { hasProperty } from "effect/Predicate"
+import * as Schema from "effect/Schema"
+import * as AST from "effect/SchemaAST"
+import * as Stream_ from "effect/Stream"
+
+/**
+ * @since 1.0.0
+ * @category Stream
+ */
+export const StreamSchemaId: unique symbol = Symbol.for("@effect/rpc/RpcSchema/Stream")
+
+/**
+ * @since 1.0.0
+ * @category Stream
+ */
+export const isStreamSchema = (schema: Schema.Schema.All): schema is Stream<any, any> =>
+  schema.ast.annotations[AST.SchemaIdAnnotationId] === StreamSchemaId
+
+/**
+ * @since 1.0.0
+ * @category Stream
+ */
+export const isStreamSerializable = (schema: Schema.WithResult.Any): boolean =>
+  isStreamSchema(Schema.successSchema(schema))
+
+/**
+ * @since 1.0.0
+ * @category Stream
+ */
+export const getStreamSchemas = (
+  ast: AST.AST
+): Option.Option<{
+  readonly success: Schema.Schema.Any
+  readonly failure: Schema.Schema.All
+}> => ast.annotations[StreamSchemaId] ? Option.some(ast.annotations[StreamSchemaId] as any) : Option.none()
+
+/**
+ * @since 1.0.0
+ * @category Stream
+ */
+export interface Stream<A extends Schema.Schema.Any, E extends Schema.Schema.All> extends
+  Schema.Schema<
+    Stream_.Stream<A["Type"], E["Type"]>,
+    Stream_.Stream<A["Encoded"], E["Encoded"]>,
+    A["Context"] | E["Context"]
+  >
+{
+  readonly success: A
+  readonly failure: E
+}
+
+/**
+ * @since 1.0.0
+ * @category Stream
+ */
+export const Stream = <A extends Schema.Schema.Any, E extends Schema.Schema.All>(
+  { failure, success }: {
+    readonly failure: E
+    readonly success: A
+  }
+): Stream<A, E> =>
+  Object.assign(
+    Schema.declare(
+      [success, failure],
+      {
+        decode: (success, failure) =>
+          parseStream(
+            ParseResult.decodeUnknown(Schema.ChunkFromSelf(success)),
+            ParseResult.decodeUnknown(failure)
+          ),
+        encode: (success, failure) =>
+          parseStream(
+            ParseResult.encodeUnknown(Schema.ChunkFromSelf(success)),
+            ParseResult.encodeUnknown(failure)
+          )
+      },
+      {
+        schemaId: StreamSchemaId,
+        [StreamSchemaId]: { success, failure }
+      }
+    ),
+    {
+      success,
+      failure
+    }
+  )
+
+const isStream = (u: unknown): u is Stream_.Stream<unknown, unknown> => hasProperty(u, Stream_.StreamTypeId)
+
+const parseStream = <A, E, RA, RE>(
+  decodeSuccess: (
+    u: Chunk.Chunk<unknown>,
+    overrideOptions?: AST.ParseOptions
+  ) => Effect.Effect<Chunk.Chunk<A>, ParseResult.ParseIssue, RA>,
+  decodeFailure: (u: unknown, overrideOptions?: AST.ParseOptions) => Effect.Effect<E, ParseResult.ParseIssue, RE>
+) =>
+(u: unknown, options: AST.ParseOptions, ast: AST.AST) =>
+  Effect.flatMap(
+    Effect.context<RA | RE>(),
+    (context) => {
+      if (!isStream(u)) return Effect.fail(new ParseResult.Type(ast, u))
+      return Effect.succeed(u.pipe(
+        Stream_.mapChunksEffect((value) => decodeSuccess(value, options)),
+        Stream_.catchAll((error) => {
+          if (ParseResult.isParseError(error)) return Stream_.die(error)
+          return Effect.matchEffect(decodeFailure(error, options), {
+            onFailure: Effect.die,
+            onSuccess: Effect.fail
+          })
+        }),
+        Stream_.provideContext(context)
+      ))
+    }
+  )
diff --git a/src/RpcSerialization.ts b/src/RpcSerialization.ts
new file mode 100644
index 0000000000000000000000000000000000000000..358f884ccc88039a8293c08a357874ccdf76c76a
--- /dev/null
+++ b/src/RpcSerialization.ts
@@ -0,0 +1,125 @@
+/**
+ * @since 1.0.0
+ */
+import { Msgpackr } from "@effect/platform/MsgPack"
+import * as Context from "effect/Context"
+import * as Effect from "effect/Effect"
+import * as Layer from "effect/Layer"
+
+/**
+ * @since 1.0.0
+ * @category serialization
+ */
+export class RpcSerialization extends Context.Tag("@effect/rpc/RpcSerialization")<RpcSerialization, {
+  unsafeMake(): Parser
+  readonly contentType: string
+  readonly supportsBigInt: boolean
+}>() {}
+
+/**
+ * @since 1.0.0
+ * @category serialization
+ */
+export interface Parser {
+  readonly decode: (data: Uint8Array | string) => ReadonlyArray<unknown>
+  readonly encode: (response: unknown) => Uint8Array | string
+}
+
+/**
+ * @since 1.0.0
+ * @category serialization
+ */
+export const json: Effect.Effect<RpcSerialization["Type"]> = Effect.sync(() => {
+  const decoder = new TextDecoder()
+  return RpcSerialization.of({
+    contentType: "application/json",
+    supportsBigInt: false,
+    unsafeMake: () => ({
+      decode: (bytes) => [JSON.parse(typeof bytes === "string" ? bytes : decoder.decode(bytes))],
+      encode: (response) => JSON.stringify(response)
+    })
+  })
+})
+
+/**
+ * @since 1.0.0
+ * @category serialization
+ */
+export const ndjson: Effect.Effect<RpcSerialization["Type"]> = Effect.sync(() => {
+  const decoder = new TextDecoder()
+  return RpcSerialization.of({
+    contentType: "application/ndjson",
+    supportsBigInt: false,
+    unsafeMake: () => {
+      let buffer = ""
+      return ({
+        decode: (bytes) => {
+          buffer += typeof bytes === "string" ? bytes : decoder.decode(bytes)
+          let position = 0
+          let nlIndex = buffer.indexOf("\n", position)
+          const items: Array<unknown> = []
+          while (nlIndex !== -1) {
+            const item = JSON.parse(buffer.slice(position, nlIndex))
+            items.push(item)
+            position = nlIndex + 1
+            nlIndex = buffer.indexOf("\n", position)
+          }
+          buffer = buffer.slice(position)
+          return items
+        },
+        encode: (response) => JSON.stringify(response) + "\n"
+      })
+    }
+  })
+})
+
+/**
+ * @since 1.0.0
+ * @category serialization
+ */
+export const msgPack: RpcSerialization["Type"] = RpcSerialization.of({
+  contentType: "application/msgpack",
+  supportsBigInt: true,
+  unsafeMake: () => {
+    const unpackr = new Msgpackr.Unpackr()
+    const packr = new Msgpackr.Packr()
+    const encoder = new TextEncoder()
+    return ({
+      decode: (bytes) => unpackr.unpackMultiple(typeof bytes === "string" ? encoder.encode(bytes) : bytes),
+      encode: (response) => packr.pack(response)
+    })
+  }
+})
+
+/**
+ * A rpc serialization layer that uses JSON for serialization.
+ *
+ * Use this if your protocol supports framing for messages, otherwise use
+ * `layerSerializationNdjson`.
+ *
+ * @since 1.0.0
+ * @category serialization
+ */
+export const layerJson: Layer.Layer<RpcSerialization> = Layer.effect(RpcSerialization, json)
+
+/**
+ * A rpc serialization layer that uses NDJSON for serialization.
+ *
+ * Use this if your protocol does not support framing for messages, otherwise
+ * use `layerSerializationJson`.
+ *
+ * @since 1.0.0
+ * @category serialization
+ */
+export const layerNdjson: Layer.Layer<RpcSerialization> = Layer.effect(RpcSerialization, ndjson)
+
+/**
+ * A rpc serialization layer that uses MessagePack for serialization.
+ *
+ * MessagePack has a more compact binary format compared to JSON and NDJSON. It
+ * also has better support for binary data.
+ *
+ * @since 1.0.0
+ * @category serialization
+ */
+export const layerMsgPack: Layer.Layer<RpcSerialization> = Layer.succeed(RpcSerialization, msgPack)
diff --git a/src/RpcServer.ts b/src/RpcServer.ts
new file mode 100644
index 0000000000000000000000000000000000000000..fb310ee7922aef6469d038b774488f7a914221da
--- /dev/null
+++ b/src/RpcServer.ts
@@ -0,0 +1,1234 @@
+/**
+ * @since 1.0.0
+ */
+import * as Headers from "@effect/platform/Headers"
+import * as HttpApp from "@effect/platform/HttpApp"
+import * as HttpRouter from "@effect/platform/HttpRouter"
+import * as HttpServerRequest from "@effect/platform/HttpServerRequest"
+import * as HttpServerResponse from "@effect/platform/HttpServerResponse"
+import type * as Socket from "@effect/platform/Socket"
+import * as SocketServer from "@effect/platform/SocketServer"
+import * as Transferable from "@effect/platform/Transferable"
+import type { WorkerError } from "@effect/platform/WorkerError"
+import * as WorkerRunner from "@effect/platform/WorkerRunner"
+import type { NonEmptyReadonlyArray } from "effect/Array"
+import * as Arr from "effect/Array"
+import * as Cause from "effect/Cause"
+import * as Chunk from "effect/Chunk"
+import * as Context from "effect/Context"
+import * as Deferred from "effect/Deferred"
+import * as Effect from "effect/Effect"
+import * as Exit from "effect/Exit"
+import * as Fiber from "effect/Fiber"
+import * as FiberId from "effect/FiberId"
+import * as FiberSet from "effect/FiberSet"
+import { constant, constTrue, constVoid, identity } from "effect/Function"
+import * as Layer from "effect/Layer"
+import * as Mailbox from "effect/Mailbox"
+import * as ManagedRuntime from "effect/ManagedRuntime"
+import * as Option from "effect/Option"
+import { ArrayFormatter, type ParseError } from "effect/ParseResult"
+import * as Predicate from "effect/Predicate"
+import * as Runtime from "effect/Runtime"
+import * as Schema from "effect/Schema"
+import * as Scope from "effect/Scope"
+import * as Stream from "effect/Stream"
+import * as Tracer from "effect/Tracer"
+import { withRun } from "./internal/utils.js"
+import * as Rpc from "./Rpc.js"
+import type * as RpcGroup from "./RpcGroup.js"
+import {
+  constEof,
+  constPong,
+  type FromClient,
+  type FromClientEncoded,
+  type FromServer,
+  type FromServerEncoded,
+  type Request,
+  RequestId,
+  ResponseDefectEncoded
+} from "./RpcMessage.js"
+import * as RpcSchema from "./RpcSchema.js"
+import * as RpcSerialization from "./RpcSerialization.js"
+import type { InitialMessage } from "./RpcWorker.js"
+
+/**
+ * @since 1.0.0
+ * @category server
+ */
+export interface RpcServer<A extends Rpc.Any> {
+  readonly write: (clientId: number, message: FromClient<A>) => Effect.Effect<void>
+  readonly disconnect: (clientId: number) => Effect.Effect<void>
+}
+
+/**
+ * @since 1.0.0
+ * @category server
+ */
+export const makeNoSerialization: <Rpcs extends Rpc.Any>(
+  group: RpcGroup.RpcGroup<Rpcs>,
+  options: {
+    readonly onFromServer: (response: FromServer<Rpcs>) => Effect.Effect<void>
+    readonly disableTracing?: boolean | undefined
+    readonly disableSpanPropagation?: boolean | undefined
+    readonly spanPrefix?: string | undefined
+    readonly disableClientAcks?: boolean | undefined
+    readonly concurrency?: number | "unbounded" | undefined
+  }
+) => Effect.Effect<
+  RpcServer<Rpcs>,
+  never,
+  Rpc.ToHandler<Rpcs> | Rpc.Middleware<Rpcs> | Scope.Scope
+> = Effect.fnUntraced(function*<Rpcs extends Rpc.Any>(
+  group: RpcGroup.RpcGroup<Rpcs>,
+  options: {
+    readonly onFromServer: (response: FromServer<Rpcs>) => Effect.Effect<void>
+    readonly disableTracing?: boolean | undefined
+    readonly disableSpanPropagation?: boolean | undefined
+    readonly spanPrefix?: string | undefined
+    readonly disableClientAcks?: boolean | undefined
+    readonly concurrency?: number | "unbounded" | undefined
+  }
+) {
+  const enableTracing = options.disableTracing !== true
+  const enableSpanPropagation = options.disableSpanPropagation !== true
+  const supportsAck = options.disableClientAcks !== true
+  const spanPrefix = options.spanPrefix ?? "RpcServer"
+  const concurrency = options.concurrency ?? "unbounded"
+  const context = yield* Effect.context<Rpc.ToHandler<Rpcs> | Scope.Scope>()
+  const scope = Context.get(context, Scope.Scope)
+  const fiberSet = yield* FiberSet.make()
+  const runFork = yield* FiberSet.runtime(fiberSet)().pipe(
+    Effect.interruptible
+  )
+  const concurrencySemaphore = concurrency === "unbounded"
+    ? undefined
+    : yield* Effect.makeSemaphore(concurrency)
+
+  type Client = {
+    readonly id: number
+    readonly latches: Map<RequestId, Effect.Latch>
+    readonly fibers: Map<RequestId, Fiber.RuntimeFiber<unknown, any>>
+    ended: boolean
+  }
+
+  const clients = new Map<number, Client>()
+  let isShutdown = false
+  const shutdownLatch = Effect.unsafeMakeLatch(false)
+  yield* Scope.addFinalizer(
+    scope,
+    Effect.fiberIdWith((fiberId) => {
+      isShutdown = true
+      for (const client of clients.values()) {
+        client.ended = true
+        if (client.fibers.size === 0) {
+          runFork(endClient(client))
+          continue
+        }
+        for (const fiber of client.fibers.values()) {
+          fiber.unsafeInterruptAsFork(fiberId)
+        }
+      }
+      if (clients.size === 0) {
+        return Effect.void
+      }
+      return shutdownLatch.await
+    })
+  )
+
+  const disconnect = (clientId: number) =>
+    Effect.fiberIdWith((fiberId) => {
+      const client = clients.get(clientId)
+      if (!client) return Effect.void
+      for (const fiber of client.fibers.values()) {
+        fiber.unsafeInterruptAsFork(fiberId)
+      }
+      clients.delete(clientId)
+      return Effect.void
+    })
+
+  const write = (clientId: number, message: FromClient<Rpcs>): Effect.Effect<void> =>
+    Effect.catchAllDefect(
+      Effect.withFiberRuntime((requestFiber) => {
+        if (isShutdown) return Effect.interrupt
+        let client = clients.get(clientId)
+        if (!client) {
+          client = {
+            id: clientId,
+            latches: new Map(),
+            fibers: new Map(),
+            ended: false
+          }
+          clients.set(clientId, client)
+        } else if (client.ended) {
+          return Effect.interrupt
+        }
+
+        switch (message._tag) {
+          case "Request": {
+            return handleRequest(requestFiber, client, message)
+          }
+          case "Ack": {
+            const latch = client.latches.get(message.requestId)
+            return latch ? latch.open : Effect.void
+          }
+          case "Interrupt": {
+            const fiber = client.fibers.get(message.requestId)
+            return fiber ? Fiber.interruptFork(fiber) : options.onFromServer({
+              _tag: "Exit",
+              clientId,
+              requestId: message.requestId,
+              exit: Exit.interrupt(FiberId.none)
+            })
+          }
+          case "Eof": {
+            client.ended = true
+            if (client.fibers.size > 0) return Effect.void
+            return endClient(client)
+          }
+          default: {
+            return sendDefect(client, `Unknown request tag: ${(message as any)._tag}`)
+          }
+        }
+      }),
+      (defect) => sendDefect(clients.get(clientId)!, defect)
+    )
+
+  const endClient = (client: Client) => {
+    clients.delete(client.id)
+    const write = options.onFromServer({
+      _tag: "ClientEnd",
+      clientId: client.id
+    })
+    if (isShutdown && clients.size === 0) {
+      return Effect.zipRight(write, shutdownLatch.open)
+    }
+    return write
+  }
+
+  const handleRequest = (
+    requestFiber: Fiber.RuntimeFiber<any, any>,
+    client: Client,
+    request: Request<Rpcs>
+  ): Effect.Effect<void> => {
+    if (client.fibers.has(request.id)) {
+      return Effect.interrupt
+    }
+    const rpc = group.requests.get(request.tag) as any as Rpc.AnyWithProps
+    const entry = context.unsafeMap.get(rpc?.key) as Rpc.Handler<Rpcs["_tag"]>
+    if (!rpc || !entry) {
+      const write = Effect.catchAllDefect(
+        options.onFromServer({
+          _tag: "Exit",
+          clientId: client.id,
+          requestId: request.id,
+          exit: Exit.die(`Unknown request tag: ${request.tag}`)
+        }),
+        (defect) => sendDefect(client, defect)
+      )
+      if (!client.ended || client.fibers.size > 0) return write
+      return Effect.zipRight(write, endClient(client))
+    }
+    const isStream = RpcSchema.isStreamSchema(rpc.successSchema)
+    const result = entry.handler(request.payload, request.headers)
+
+    // if the handler requested forking, then we skip the concurrency control
+    const isFork = Rpc.isFork(result)
+    // unwrap the fork data type
+    const streamOrEffect = isFork ? result.value : result
+
+    let responded = false
+    let effect = Effect.uninterruptible(Effect.matchCauseEffect(
+      Effect.interruptible(applyMiddleware(
+        rpc,
+        context,
+        request.payload,
+        request.headers,
+        isStream
+          ? streamEffect(client, request, streamOrEffect)
+          : streamOrEffect as Effect.Effect<any>
+      )),
+      {
+        onSuccess: (value) => {
+          responded = true
+          return options.onFromServer({
+            _tag: "Exit",
+            clientId: client.id,
+            requestId: request.id,
+            exit: Exit.succeed(value as any)
+          })
+        },
+        onFailure: (cause) => {
+          responded = true
+          return options.onFromServer({
+            _tag: "Exit",
+            clientId: client.id,
+            requestId: request.id,
+            exit: Exit.failCause(cause)
+          })
+        }
+      }
+    ))
+    if (enableTracing) {
+      const parentSpan = requestFiber.currentContext.unsafeMap.get(Tracer.ParentSpan.key) as Tracer.AnySpan | undefined
+      effect = Effect.withSpan(effect, `${spanPrefix}.${request.tag}`, {
+        captureStackTrace: false,
+        parent: enableSpanPropagation ?
+          {
+            _tag: "ExternalSpan",
+            traceId: request.traceId,
+            spanId: request.spanId,
+            sampled: request.sampled,
+            context: Context.empty()
+          } :
+          undefined,
+        links: enableSpanPropagation && parentSpan ?
+          [{
+            _tag: "SpanLink",
+            span: parentSpan,
+            attributes: {}
+          }] :
+          undefined
+      })
+    }
+    if (!isFork && concurrencySemaphore) {
+      effect = concurrencySemaphore.withPermits(1)(effect)
+    }
+    const runtime = Runtime.make({
+      context: Context.merge(entry.context, requestFiber.currentContext),
+      fiberRefs: requestFiber.getFiberRefs(),
+      runtimeFlags: Runtime.defaultRuntime.runtimeFlags
+    })
+    const fiber = Runtime.runFork(runtime, effect)
+    FiberSet.unsafeAdd(fiberSet, fiber)
+    client.fibers.set(request.id, fiber)
+    fiber.addObserver((exit) => {
+      if (!responded && exit._tag === "Failure") {
+        FiberSet.unsafeAdd(
+          fiberSet,
+          Runtime.runFork(
+            runtime,
+            options.onFromServer({
+              _tag: "Exit",
+              clientId: client.id,
+              requestId: request.id,
+              exit: Exit.interrupt(FiberId.none)
+            })
+          )
+        )
+      }
+      client.fibers.delete(request.id)
+      client.latches.delete(request.id)
+      if (client.ended && client.fibers.size === 0) {
+        FiberSet.unsafeAdd(
+          fiberSet,
+          Runtime.runFork(runtime, endClient(client))
+        )
+      }
+    })
+    return Effect.void
+  }
+
+  const streamEffect = (
+    client: Client,
+    request: Request<Rpcs>,
+    stream: Stream.Stream<any, any> | Effect.Effect<Mailbox.ReadonlyMailbox<any, any>, any, Scope.Scope>
+  ) => {
+    let latch = client.latches.get(request.id)
+    if (supportsAck && !latch) {
+      latch = Effect.unsafeMakeLatch(false)
+      client.latches.set(request.id, latch)
+    }
+    if (Effect.isEffect(stream)) {
+      let done = false
+      return stream.pipe(
+        Effect.flatMap((mailbox) =>
+          Effect.whileLoop({
+            while: () => !done,
+            body: constant(Effect.flatMap(mailbox.takeAll, ([chunk, done_]) => {
+              done = done_
+              if (!Chunk.isNonEmpty(chunk)) return Effect.void
+              const write = options.onFromServer({
+                _tag: "Chunk",
+                clientId: client.id,
+                requestId: request.id,
+                values: Chunk.toReadonlyArray(chunk)
+              })
+              if (!latch) return write
+              latch.unsafeClose()
+              return Effect.zipRight(write, latch.await)
+            })),
+            step: constVoid
+          })
+        ),
+        Effect.scoped
+      )
+    }
+    return Stream.runForEachChunk(stream, (chunk) => {
+      if (!Chunk.isNonEmpty(chunk)) return Effect.void
+      const write = options.onFromServer({
+        _tag: "Chunk",
+        clientId: client.id,
+        requestId: request.id,
+        values: Chunk.toReadonlyArray(chunk)
+      })
+      if (!latch) return write
+      latch.unsafeClose()
+      return Effect.zipRight(write, latch.await)
+    })
+  }
+
+  const sendDefect = (client: Client, defect: unknown) =>
+    Effect.suspend(() => {
+      const shouldEnd = client.ended && client.fibers.size === 0
+      const write = options.onFromServer({
+        _tag: "Defect",
+        clientId: client.id,
+        defect
+      })
+      if (!shouldEnd) return write
+      return Effect.zipRight(write, endClient(client))
+    })
+
+  return identity<RpcServer<Rpcs>>({
+    write,
+    disconnect
+  })
+})
+
+const applyMiddleware = <A, E, R>(
+  rpc: Rpc.AnyWithProps,
+  context: Context.Context<never>,
+  payload: A,
+  headers: Headers.Headers,
+  handler: Effect.Effect<A, E, R>
+) => {
+  if (rpc.middlewares.size === 0) {
+    return handler
+  }
+
+  const options = {
+    rpc,
+    payload,
+    headers
+  }
+
+  for (const tag of rpc.middlewares) {
+    const middleware = Context.unsafeGet(context, tag)
+    if (tag.optional) {
+      const previous = handler
+      handler = Effect.matchEffect(middleware(options), {
+        onFailure: () => previous,
+        onSuccess: tag.provides !== undefined
+          ? (value) => Effect.provideService(previous, tag.provides as any, value)
+          : (_) => previous
+      })
+    } else {
+      handler = tag.provides !== undefined
+        ? Effect.provideServiceEffect(handler, tag.provides as any, middleware(options))
+        : Effect.zipRight(middleware(options), handler)
+    }
+  }
+
+  return handler
+}
+
+/**
+ * @since 1.0.0
+ * @category server
+ */
+export const make: <Rpcs extends Rpc.Any>(
+  group: RpcGroup.RpcGroup<Rpcs>,
+  options?:
+    | {
+      readonly disableTracing?: boolean | undefined
+      readonly spanPrefix?: string | undefined
+      readonly concurrency?: number | "unbounded" | undefined
+    }
+    | undefined
+) => Effect.Effect<
+  never,
+  never,
+  Protocol | Rpc.ToHandler<Rpcs> | Rpc.Middleware<Rpcs>
+> = Effect.fnUntraced(function*<Rpcs extends Rpc.Any>(
+  group: RpcGroup.RpcGroup<Rpcs>,
+  options?: {
+    readonly disableTracing?: boolean | undefined
+    readonly spanPrefix?: string | undefined
+    readonly concurrency?: number | "unbounded" | undefined
+  }
+) {
+  const { disconnects, end, run, send, supportsAck, supportsSpanPropagation, supportsTransferables } = yield* Protocol
+  const context = yield* Effect.context<Rpc.ToHandler<Rpcs> | Rpc.Middleware<Rpcs>>()
+  const scope = yield* Scope.make()
+
+  const server = yield* makeNoSerialization(group, {
+    ...options,
+    disableClientAcks: !supportsAck,
+    disableSpanPropagation: !supportsSpanPropagation,
+    onFromServer(response): Effect.Effect<void> {
+      const client = clients.get(response.clientId)
+      if (!client) return Effect.void
+      switch (response._tag) {
+        case "Chunk": {
+          const schemas = client.schemas.get(response.requestId)
+          if (!schemas) return Effect.void
+          return handleEncode(
+            client,
+            response.requestId,
+            schemas.collector,
+            Effect.provide(schemas.encodeChunk(response.values), schemas.context),
+            (values) => ({ _tag: "Chunk", requestId: response.requestId, values })
+          )
+        }
+        case "Exit": {
+          const schemas = client.schemas.get(response.requestId)
+          if (!schemas) return Effect.void
+          client.schemas.delete(response.requestId)
+          return handleEncode(
+            client,
+            response.requestId,
+            schemas.collector,
+            Effect.provide(schemas.encodeExit(response.exit), schemas.context),
+            (exit) => ({ _tag: "Exit", requestId: response.requestId, exit })
+          )
+        }
+        case "Defect": {
+          return sendDefect(client, response.defect)
+        }
+        case "ClientEnd": {
+          clients.delete(response.clientId)
+          return end(response.clientId)
+        }
+      }
+    }
+  }).pipe(Scope.extend(scope))
+
+  // handle disconnects
+  yield* Effect.fork(Effect.interruptible(Effect.whileLoop({
+    while: constTrue,
+    body: constant(Effect.flatMap(disconnects.take, (clientId) => {
+      clients.delete(clientId)
+      return server.disconnect(clientId)
+    })),
+    step: constVoid
+  })))
+
+  type Schemas = {
+    readonly decode: (u: unknown) => Effect.Effect<Rpc.Payload<Rpcs>, ParseError>
+    readonly encodeChunk: (u: ReadonlyArray<unknown>) => Effect.Effect<NonEmptyReadonlyArray<unknown>, ParseError>
+    readonly encodeExit: (u: unknown) => Effect.Effect<Schema.ExitEncoded<unknown, unknown, unknown>, ParseError>
+    readonly context: Context.Context<never>
+    readonly collector?: Transferable.CollectorService | undefined
+  }
+
+  const schemasCache = new WeakMap<any, Schemas>()
+  const getSchemas = (rpc: Rpc.AnyWithProps) => {
+    let schemas = schemasCache.get(rpc)
+    if (!schemas) {
+      const entry = context.unsafeMap.get(rpc.key) as Rpc.Handler<Rpcs["_tag"]>
+      const streamSchemas = RpcSchema.getStreamSchemas(rpc.successSchema.ast)
+      const failures = new Set([rpc.errorSchema])
+      if (Option.isSome(streamSchemas)) {
+        failures.add(streamSchemas.value.failure)
+      }
+      for (const middleware of rpc.middlewares) {
+        failures.add(middleware.failure)
+      }
+      schemas = {
+        decode: Schema.decodeUnknown(rpc.payloadSchema as any),
+        encodeChunk: Schema.encodeUnknown(
+          Schema.Array(Option.isSome(streamSchemas) ? streamSchemas.value.success : Schema.Any)
+        ) as any,
+        encodeExit: Schema.encodeUnknown(Rpc.exitSchema(rpc as any)) as any,
+        context: entry.context
+      }
+      schemasCache.set(rpc, schemas)
+    }
+    return schemas
+  }
+
+  type Client = {
+    readonly id: number
+    readonly schemas: Map<RequestId, Schemas>
+  }
+  const clients = new Map<number, Client>()
+
+  const handleEncode = <A, R>(
+    client: Client,
+    requestId: RequestId,
+    collector: Transferable.CollectorService | undefined,
+    effect: Effect.Effect<A, ParseError, R>,
+    onSuccess: (a: A) => FromServerEncoded
+  ) =>
+    (collector ? Effect.provideService(effect, Transferable.Collector, collector) : effect).pipe(
+      Effect.flatMap((a) => send(client.id, onSuccess(a), collector && collector.unsafeClear())),
+      Effect.catchAllCause((cause) => {
+        client.schemas.delete(requestId)
+        const defect = Cause.squash(Cause.map(cause, ArrayFormatter.formatErrorSync))
+        return Effect.zipRight(
+          server.write(client.id, { _tag: "Interrupt", requestId, interruptors: [] }),
+          sendRequestDefect(client, requestId, defect)
+        )
+      })
+    )
+
+  const sendRequestDefect = (client: Client, requestId: RequestId, defect: unknown) =>
+    Effect.catchAllCause(
+      send(client.id, {
+        _tag: "Exit",
+        requestId,
+        exit: {
+          _tag: "Failure",
+          cause: {
+            _tag: "Die",
+            defect
+          }
+        }
+      }),
+      (cause) => sendDefect(client, Cause.squash(cause))
+    )
+
+  const sendDefect = (client: Client, defect: unknown) =>
+    Effect.catchAllCause(
+      send(client.id, { _tag: "Defect", defect }),
+      (cause) =>
+        Effect.annotateLogs(Effect.logDebug(cause), {
+          module: "RpcServer",
+          method: "sendDefect"
+        })
+    )
+
+  // main server loop
+  return yield* run((clientId, request) => {
+    let client = clients.get(clientId)
+    if (!client) {
+      client = {
+        id: clientId,
+        schemas: new Map()
+      }
+      clients.set(clientId, client)
+    }
+
+    switch (request._tag) {
+      case "Request": {
+        const tag = Predicate.hasProperty(request, "tag") ? request.tag as string : ""
+        const rpc = group.requests.get(tag)
+        if (!rpc) {
+          return sendDefect(client, `Unknown request tag: ${tag}`)
+        }
+        let requestId: RequestId
+        switch (typeof request.id) {
+          case "bigint":
+          case "string": {
+            requestId = RequestId(request.id)
+            break
+          }
+          default: {
+            return sendDefect(client, `Invalid request id: ${request.id}`)
+          }
+        }
+        const schemas = getSchemas(rpc as any)
+        return Effect.matchEffect(
+          Effect.provide(schemas.decode(request.payload), schemas.context),
+          {
+            onFailure: (error) => sendRequestDefect(client, requestId, ArrayFormatter.formatErrorSync(error)),
+            onSuccess: (payload) => {
+              client.schemas.set(
+                requestId,
+                supportsTransferables ?
+                  {
+                    ...schemas,
+                    collector: Transferable.unsafeMakeCollector()
+                  } :
+                  schemas
+              )
+              return server.write(clientId, {
+                ...request,
+                id: requestId,
+                payload,
+                headers: Headers.fromInput(request.headers)
+              } as any)
+            }
+          }
+        )
+      }
+      case "Ping": {
+        return Effect.catchAllCause(
+          send(client.id, constPong),
+          (cause) => sendDefect(client, Cause.squash(cause))
+        )
+      }
+      case "Ack":
+      case "Eof":
+      case "Interrupt": {
+        if ("requestId" in request && typeof request.requestId === "string") {
+          ;(request as any).requestId = BigInt(request.requestId)
+        }
+        return server.write(
+          clientId,
+          request._tag === "Interrupt" ?
+            {
+              ...request,
+              interruptors: []
+            } :
+            request
+        )
+      }
+      default: {
+        return sendDefect(client, `Unknown request tag: ${(request as any)._tag}`)
+      }
+    }
+  }).pipe(
+    Effect.interruptible,
+    Effect.tapErrorCause((cause) => Effect.logFatal("BUG: RpcServer protocol crashed", cause)),
+    Effect.onExit((exit) => Scope.close(scope, exit))
+  )
+})
+
+/**
+ * @since 1.0.0
+ * @category server
+ */
+export const layer = <Rpcs extends Rpc.Any>(
+  group: RpcGroup.RpcGroup<Rpcs>,
+  options?: {
+    readonly disableTracing?: boolean | undefined
+    readonly spanPrefix?: string | undefined
+    readonly concurrency?: number | "unbounded" | undefined
+  }
+): Layer.Layer<
+  never,
+  never,
+  | Protocol
+  | Rpc.ToHandler<Rpcs>
+  | Rpc.Middleware<Rpcs>
+> => Layer.scopedDiscard(Effect.forkScoped(Effect.interruptible(make(group, options))))
+
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+export class Protocol extends Context.Tag("@effect/rpc/RpcServer/Protocol")<Protocol, {
+  readonly run: (
+    f: (clientId: number, data: FromClientEncoded) => Effect.Effect<void>
+  ) => Effect.Effect<never>
+  readonly disconnects: Mailbox.ReadonlyMailbox<number>
+  readonly send: (
+    clientId: number,
+    response: FromServerEncoded,
+    transferables?: ReadonlyArray<globalThis.Transferable>
+  ) => Effect.Effect<void>
+  readonly end: (clientId: number) => Effect.Effect<void>
+  readonly initialMessage: Effect.Effect<Option.Option<unknown>>
+  readonly supportsAck: boolean
+  readonly supportsTransferables: boolean
+  readonly supportsSpanPropagation: boolean
+}>() {
+  /**
+   * @since 1.0.0
+   */
+  static make = withRun<Protocol["Type"]>()
+}
+
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+export const makeProtocolSocketServer = Effect.gen(function*() {
+  const server = yield* SocketServer.SocketServer
+  const { onSocket, protocol } = yield* makeSocketProtocol
+  yield* Effect.forkScoped(Effect.interruptible(
+    server.run(Effect.fnUntraced(onSocket, Effect.scoped))
+  ))
+  return protocol
+})
+
+/**
+ * A rpc protocol that uses `SocketServer` for communication.
+ *
+ * @since 1.0.0
+ * @category protocol
+ */
+export const layerProtocolSocketServer: Layer.Layer<
+  Protocol,
+  never,
+  RpcSerialization.RpcSerialization | SocketServer.SocketServer
+> = Layer.scoped(Protocol, makeProtocolSocketServer)
+
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+export const makeProtocolWithHttpAppWebsocket: Effect.Effect<
+  {
+    readonly protocol: Protocol["Type"]
+    readonly httpApp: HttpApp.Default<never, Scope.Scope>
+  },
+  never,
+  RpcSerialization.RpcSerialization
+> = Effect.gen(function*() {
+  const { onSocket, protocol } = yield* makeSocketProtocol
+
+  const httpApp: HttpApp.Default<never, Scope.Scope> = Effect.gen(function*() {
+    const request = yield* HttpServerRequest.HttpServerRequest
+    const socket = yield* Effect.orDie(request.upgrade)
+    yield* onSocket(socket)
+    return HttpServerResponse.empty()
+  })
+
+  return { protocol, httpApp } as const
+})
+
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+export const makeProtocolWebsocket: <I = HttpRouter.Default>(
+  options: {
+    readonly path: HttpRouter.PathInput
+    readonly routerTag?: Context.Tag<I, HttpRouter.HttpRouter.Service<any, any>>
+  }
+) => Effect.Effect<
+  Protocol["Type"],
+  never,
+  RpcSerialization.RpcSerialization | I
+> = Effect.fnUntraced(function*<I = HttpRouter.Default>(options: {
+  readonly path: HttpRouter.PathInput
+  readonly routerTag?: Context.Tag<I, HttpRouter.HttpRouter.Service<any, any>>
+}) {
+  const { httpApp, protocol } = yield* makeProtocolWithHttpAppWebsocket
+  const router =
+    yield* (options.routerTag ?? HttpRouter.Default as any as Context.Tag<I, HttpRouter.HttpRouter.Service<any, any>>)
+  yield* router.get(options.path, httpApp)
+  return protocol
+})
+
+/**
+ * A rpc protocol that uses websockets for communication.
+ *
+ * @since 1.0.0
+ * @category protocol
+ */
+export const layerProtocolWebsocket = <I = HttpRouter.Default>(options: {
+  readonly path: HttpRouter.PathInput
+  readonly routerTag?: HttpRouter.HttpRouter.TagClass<I, string, any, any>
+}): Layer.Layer<Protocol, never, RpcSerialization.RpcSerialization> => {
+  const routerTag = options.routerTag ??
+    HttpRouter.Default as any as HttpRouter.HttpRouter.TagClass<I, string, any, any>
+  return Layer.effect(Protocol, makeProtocolWebsocket(options)).pipe(
+    Layer.provide(routerTag.Live)
+  )
+}
+
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+export const makeProtocolWithHttpApp: Effect.Effect<
+  {
+    readonly protocol: Protocol["Type"]
+    readonly httpApp: HttpApp.Default<never, Scope.Scope>
+  },
+  never,
+  RpcSerialization.RpcSerialization
+> = Effect.gen(function*() {
+  const serialization = yield* RpcSerialization.RpcSerialization
+  const isJson = serialization.contentType === "application/json"
+
+  const disconnects = yield* Mailbox.make<number>()
+  let writeRequest!: (clientId: number, message: FromClientEncoded) => Effect.Effect<void>
+
+  let clientId = 0
+
+  const clients = new Map<number, {
+    readonly write: (bytes: FromServerEncoded) => Effect.Effect<void>
+    readonly end: Effect.Effect<void>
+  }>()
+
+  const httpApp: HttpApp.Default<never, Scope.Scope> = Effect.gen(function*() {
+    const request = yield* HttpServerRequest.HttpServerRequest
+    const data = yield* Effect.orDie(request.arrayBuffer)
+    const id = clientId++
+    const mailbox = yield* Mailbox.make<Uint8Array | FromServerEncoded>()
+    const parser = serialization.unsafeMake()
+    const encoder = new TextEncoder()
+
+    const offer = (data: Uint8Array | string) =>
+      typeof data === "string" ? mailbox.offer(encoder.encode(data)) : mailbox.offer(data)
+
+    clients.set(id, {
+      write: (response) => {
+        try {
+          if (!serialization.supportsBigInt) {
+            transformBigInt(response)
+          }
+          return isJson ? mailbox.offer(response) : offer(parser.encode(response))
+        } catch (cause) {
+          return isJson
+            ? mailbox.offer(ResponseDefectEncoded(cause))
+            : offer(parser.encode(ResponseDefectEncoded(cause)))
+        }
+      },
+      end: mailbox.end
+    })
+
+    const requestIds: Array<RequestId> = []
+
+    try {
+      const decoded = parser.decode(new Uint8Array(data)) as ReadonlyArray<FromClientEncoded>
+      for (const message of decoded) {
+        if (message._tag === "Request") {
+          requestIds.push(RequestId(message.id))
+        }
+        yield* writeRequest(id, message)
+      }
+    } catch (cause) {
+      yield* offer(parser.encode(ResponseDefectEncoded(cause)))
+    }
+
+    yield* writeRequest(id, constEof)
+
+    if (isJson) {
+      let done = false
+      yield* Effect.addFinalizer(() => {
+        clients.delete(id)
+        disconnects.unsafeOffer(id)
+        if (done) return Effect.void
+        return Effect.forEach(
+          requestIds,
+          (requestId) => writeRequest(id, { _tag: "Interrupt", requestId }),
+          { discard: true }
+        )
+      })
+      const responses = Arr.empty<FromServerEncoded>()
+      while (true) {
+        const [items, done] = yield* mailbox.takeAll
+        // eslint-disable-next-line no-restricted-syntax
+        responses.push(...items as any)
+        if (done) break
+      }
+      done = true
+      return HttpServerResponse.unsafeJson(responses)
+    }
+
+    return HttpServerResponse.stream(
+      Stream.ensuringWith(Mailbox.toStream(mailbox as Mailbox.ReadonlyMailbox<Uint8Array>), (exit) => {
+        clients.delete(id)
+        disconnects.unsafeOffer(id)
+        if (!Exit.isInterrupted(exit)) return Effect.void
+        return Effect.forEach(
+          requestIds,
+          (requestId) => writeRequest(id, { _tag: "Interrupt", requestId }),
+          { discard: true }
+        )
+      }),
+      { contentType: serialization.contentType }
+    )
+  }).pipe(Effect.interruptible)
+
+  const protocol = yield* Protocol.make((writeRequest_) => {
+    writeRequest = writeRequest_
+    return Effect.succeed({
+      disconnects,
+      send: (clientId, response) => {
+        const client = clients.get(clientId)
+        if (!client) return Effect.void
+        return client.write(response)
+      },
+      end(clientId) {
+        const client = clients.get(clientId)
+        if (!client) return Effect.void
+        return client.end
+      },
+      initialMessage: Effect.succeedNone,
+      supportsAck: false,
+      supportsTransferables: false,
+      supportsSpanPropagation: false
+    })
+  })
+
+  return { protocol, httpApp } as const
+})
+
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+export const makeProtocolHttp = Effect.fnUntraced(function*<I = HttpRouter.Default>(options: {
+  readonly path: HttpRouter.PathInput
+  readonly routerTag?: HttpRouter.HttpRouter.TagClass<I, string, any, any>
+}) {
+  const { httpApp, protocol } = yield* makeProtocolWithHttpApp
+  const router =
+    yield* (options.routerTag ?? HttpRouter.Default as any as HttpRouter.HttpRouter.TagClass<I, string, any, any>)
+  yield* router.post(options.path, httpApp)
+  return protocol
+})
+
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+export const makeProtocolWorkerRunner: Effect.Effect<
+  Protocol["Type"],
+  WorkerError,
+  WorkerRunner.PlatformRunner | Scope.Scope
+> = Protocol.make(Effect.fnUntraced(function*(writeRequest) {
+  const fiber = yield* Effect.withFiberRuntime<Fiber.RuntimeFiber<void>>(Effect.succeed as any)
+  const runner = yield* WorkerRunner.PlatformRunner
+  const closeLatch = yield* WorkerRunner.CloseLatch
+  const backing = yield* runner.start<FromClientEncoded | InitialMessage.Encoded, FromServerEncoded>(closeLatch)
+  const initialMessage = yield* Deferred.make<unknown>()
+
+  yield* Deferred.await(closeLatch).pipe(
+    Effect.onExit(() => {
+      fiber.currentScheduler.scheduleTask(() => fiber.unsafeInterruptAsFork(fiber.id()), 0)
+      return Effect.void
+    }),
+    Effect.forkScoped
+  )
+
+  yield* backing.run((clientId, message) => {
+    if (message._tag === "InitialMessage") {
+      return Deferred.succeed(initialMessage, message.value)
+    }
+    return writeRequest(clientId, message)
+  })
+
+  return {
+    disconnects: backing.disconnects ?? (yield* Mailbox.make<number>()),
+    send: backing.send,
+    end(_clientId) {
+      return Effect.void
+    },
+    initialMessage: Effect.asSome(Deferred.await(initialMessage)),
+    supportsAck: true,
+    supportsTransferables: true,
+    supportsSpanPropagation: true
+  }
+}))
+
+/**
+ * @since 1.0.0
+ * @category protocol
+ */
+export const layerProtocolWorkerRunner: Layer.Layer<
+  Protocol,
+  WorkerError,
+  WorkerRunner.PlatformRunner
+> = Layer.scoped(Protocol, makeProtocolWorkerRunner)
+
+/**
+ * A rpc protocol that uses streaming http for communication.
+ *
+ * @since 1.0.0
+ * @category protocol
+ */
+export const layerProtocolHttp = <I = HttpRouter.Default>(options: {
+  readonly path: HttpRouter.PathInput
+  readonly routerTag?: HttpRouter.HttpRouter.TagClass<I, string, any, any>
+}): Layer.Layer<Protocol, never, RpcSerialization.RpcSerialization> => {
+  const routerTag = options.routerTag ??
+    HttpRouter.Default as any as HttpRouter.HttpRouter.TagClass<I, string, any, any>
+  return Layer.effect(Protocol, makeProtocolHttp(options)).pipe(
+    Layer.provide(routerTag.Live)
+  )
+}
+
+/**
+ * @since 1.0.0
+ * @category http app
+ */
+export const toHttpApp: <Rpcs extends Rpc.Any>(
+  group: RpcGroup.RpcGroup<Rpcs>,
+  options?: {
+    readonly disableTracing?: boolean | undefined
+    readonly spanPrefix?: string | undefined
+  } | undefined
+) => Effect.Effect<
+  HttpApp.Default<never, Scope.Scope>,
+  never,
+  | Scope.Scope
+  | RpcSerialization.RpcSerialization
+  | Rpc.ToHandler<Rpcs>
+  | Rpc.Middleware<Rpcs>
+> = Effect.fnUntraced(function*<Rpcs extends Rpc.Any>(
+  group: RpcGroup.RpcGroup<Rpcs>,
+  options?: {
+    readonly disableTracing?: boolean | undefined
+    readonly spanPrefix?: string | undefined
+  }
+) {
+  const { httpApp, protocol } = yield* makeProtocolWithHttpApp
+  yield* make(group, options).pipe(
+    Effect.provideService(Protocol, protocol),
+    Effect.interruptible,
+    Effect.forkScoped
+  )
+  return httpApp
+})
+
+/**
+ * @since 1.0.0
+ * @category http app
+ */
+export const toHttpAppWebsocket: <Rpcs extends Rpc.Any>(
+  group: RpcGroup.RpcGroup<Rpcs>,
+  options?: {
+    readonly disableTracing?: boolean | undefined
+    readonly spanPrefix?: string | undefined
+  } | undefined
+) => Effect.Effect<
+  HttpApp.Default<never, Scope.Scope>,
+  never,
+  | Scope.Scope
+  | RpcSerialization.RpcSerialization
+  | Rpc.ToHandler<Rpcs>
+  | Rpc.Middleware<Rpcs>
+> = Effect.fnUntraced(function*<Rpcs extends Rpc.Any>(
+  group: RpcGroup.RpcGroup<Rpcs>,
+  options?: {
+    readonly disableTracing?: boolean | undefined
+    readonly spanPrefix?: string | undefined
+  }
+) {
+  const { httpApp, protocol } = yield* makeProtocolWithHttpAppWebsocket
+  yield* make(group, options).pipe(
+    Effect.provideService(Protocol, protocol),
+    Effect.interruptible,
+    Effect.forkScoped
+  )
+  return httpApp
+})
+
+/**
+ * Construct an http web handler from an `RpcGroup`.
+ *
+ * @since 1.0.0
+ * @category constructors
+ */
+export const toWebHandler = <Rpcs extends Rpc.Any, LE>(
+  group: RpcGroup.RpcGroup<Rpcs>,
+  options: {
+    readonly layer: Layer.Layer<
+      | Rpc.ToHandler<Rpcs>
+      | Rpc.Middleware<Rpcs>
+      | RpcSerialization.RpcSerialization
+      | HttpRouter.HttpRouter.DefaultServices,
+      LE
+    >
+    readonly disableTracing?: boolean | undefined
+    readonly spanPrefix?: string | undefined
+    readonly middleware?: (
+      httpApp: HttpApp.Default
+    ) => HttpApp.Default<
+      never,
+      HttpRouter.HttpRouter.DefaultServices
+    >
+    readonly memoMap?: Layer.MemoMap
+  }
+): {
+  readonly handler: (request: globalThis.Request, context?: Context.Context<never> | undefined) => Promise<Response>
+  readonly dispose: () => Promise<void>
+} => {
+  const runtime = ManagedRuntime.make(Layer.mergeAll(options.layer, Layer.scope), options?.memoMap)
+  let handlerCached:
+    | ((request: globalThis.Request, context?: Context.Context<never> | undefined) => Promise<Response>)
+    | undefined
+  const handlerPromise = Effect.gen(function*() {
+    const app = yield* toHttpApp(group, options)
+    const rt = yield* runtime.runtimeEffect
+    const handler = HttpApp.toWebHandlerRuntime(rt)(options?.middleware ? options.middleware(app as any) as any : app)
+    handlerCached = handler
+    return handler
+  }).pipe(runtime.runPromise)
+  function handler(request: globalThis.Request, context?: Context.Context<never> | undefined): Promise<Response> {
+    if (handlerCached !== undefined) {
+      return handlerCached(request, context)
+    }
+    return handlerPromise.then((handler) => handler(request, context))
+  }
+  return { handler, dispose: runtime.dispose } as const
+}
+
+// internal
+
+const makeSocketProtocol = Effect.gen(function*() {
+  const serialization = yield* RpcSerialization.RpcSerialization
+  const disconnects = yield* Mailbox.make<number>()
+
+  let clientId = 0
+  const clients = new Map<number, {
+    readonly write: (bytes: FromServerEncoded) => Effect.Effect<void>
+  }>()
+
+  let writeRequest!: (clientId: number, message: FromClientEncoded) => Effect.Effect<void>
+
+  const onSocket = function*(socket: Socket.Socket) {
+    const scope = yield* Effect.scope
+    const parser = serialization.unsafeMake()
+    const id = clientId++
+    yield* Scope.addFinalizerExit(scope, () => {
+      clients.delete(id)
+      return disconnects.offer(id)
+    })
+
+    const writeRaw = yield* socket.writer
+    const write = (response: FromServerEncoded) => {
+      try {
+        if (!serialization.supportsBigInt) {
+          transformBigInt(response)
+        }
+        return Effect.orDie(writeRaw(parser.encode(response)))
+      } catch (cause) {
+        return Effect.orDie(
+          writeRaw(parser.encode(ResponseDefectEncoded(cause)))
+        )
+      }
+    }
+    clients.set(id, { write })
+
+    yield* Effect.orDie(Effect.interruptible(socket.runRaw((data) => {
+      try {
+        const decoded = parser.decode(data) as ReadonlyArray<FromClientEncoded>
+        if (decoded.length === 0) return Effect.void
+        let i = 0
+        return Effect.whileLoop({
+          while: () => i < decoded.length,
+          body: () => writeRequest(id, decoded[i++]),
+          step: constVoid
+        })
+      } catch (cause) {
+        return writeRaw(parser.encode(ResponseDefectEncoded(cause)))
+      }
+    })))
+  }
+
+  const protocol = yield* Protocol.make((writeRequest_) => {
+    writeRequest = writeRequest_
+    return Effect.succeed({
+      disconnects,
+      send: (clientId, response) => {
+        const client = clients.get(clientId)
+        if (!client) return Effect.void
+        return Effect.orDie(client.write(response))
+      },
+      end(_clientId) {
+        return Effect.void
+      },
+      initialMessage: Effect.succeedNone,
+      supportsAck: true,
+      supportsTransferables: false,
+      supportsSpanPropagation: true
+    })
+  })
+
+  return { protocol, onSocket } as const
+})
+
+const transformBigInt = (response: FromServerEncoded) => {
+  if ("requestId" in response) {
+    ;(response as any).requestId = response.requestId.toString()
+  }
+}
diff --git a/src/RpcTest.ts b/src/RpcTest.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a4e6bca0a87be91706156562ff18b6a4c678b487
--- /dev/null
+++ b/src/RpcTest.ts
@@ -0,0 +1,38 @@
+/**
+ * @since 1.0.0
+ */
+import * as Effect from "effect/Effect"
+import type * as Scope from "effect/Scope"
+import type * as Rpc from "./Rpc.js"
+import * as RpcClient from "./RpcClient.js"
+import type * as RpcGroup from "./RpcGroup.js"
+import * as RpcServer from "./RpcServer.js"
+
+/**
+ * @since 1.0.0
+ * @category constructors
+ */
+export const makeClient: <Rpcs extends Rpc.Any>(
+  group: RpcGroup.RpcGroup<Rpcs>
+) => Effect.Effect<
+  RpcClient.RpcClient<Rpcs>,
+  never,
+  Scope.Scope | Rpc.ToHandler<Rpcs> | Rpc.Middleware<Rpcs> | Rpc.MiddlewareClient<Rpcs>
+> = Effect.fnUntraced(function*<Rpcs extends Rpc.Any>(
+  group: RpcGroup.RpcGroup<Rpcs>
+) {
+  // eslint-disable-next-line prefer-const
+  let client!: Effect.Effect.Success<ReturnType<typeof RpcClient.makeNoSerialization<Rpcs, never>>>
+  const server = yield* RpcServer.makeNoSerialization(group, {
+    onFromServer(response) {
+      return client.write(response)
+    }
+  })
+  client = yield* RpcClient.makeNoSerialization(group, {
+    supportsAck: true,
+    onFromClient({ message }) {
+      return server.write(0, message)
+    }
+  })
+  return client.client
+})
diff --git a/src/RpcWorker.ts b/src/RpcWorker.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ec08fa8bedff995112dbf3cef3237e136701eb6d
--- /dev/null
+++ b/src/RpcWorker.ts
@@ -0,0 +1,90 @@
+/**
+ * @since 1.0.0
+ */
+import * as Transferable from "@effect/platform/Transferable"
+import type { NoSuchElementException } from "effect/Cause"
+import * as Context from "effect/Context"
+import * as Effect from "effect/Effect"
+import * as Layer from "effect/Layer"
+import type { ParseError } from "effect/ParseResult"
+import * as Schema from "effect/Schema"
+import type { Protocol } from "./RpcServer.js"
+
+/**
+ * @since 1.0.0
+ * @category initial message
+ */
+export class InitialMessage extends Context.Tag("@effect/rpc/RpcWorker/InitialMessage")<
+  InitialMessage,
+  Effect.Effect<
+    readonly [
+      data: unknown,
+      transfers: ReadonlyArray<Transferable>
+    ]
+  >
+>() {}
+
+/**
+ * @since 1.0.0
+ * @category initial message
+ */
+export declare namespace InitialMessage {
+  /**
+   * @since 1.0.0
+   * @category initial message
+   */
+  export interface Encoded {
+    readonly _tag: "InitialMessage"
+    readonly value: unknown
+  }
+}
+
+const ProtocolTag: typeof Protocol = Context.GenericTag("@effect/rpc/RpcServer/Protocol") as any
+
+/**
+ * @since 1.0.0
+ * @category initial message
+ */
+export const makeInitialMessage = <A, I, R, E, R2>(
+  schema: Schema.Schema<A, I, R>,
+  effect: Effect.Effect<A, E, R2>
+): Effect.Effect<
+  readonly [data: unknown, transferables: ReadonlyArray<globalThis.Transferable>],
+  E | ParseError,
+  R | R2
+> =>
+  Effect.flatMap(effect, (value) => {
+    const collector = Transferable.unsafeMakeCollector()
+    return Schema.encode(schema)(value).pipe(
+      Effect.provideService(Transferable.Collector, collector),
+      Effect.map((encoded) => [encoded, collector.unsafeClear()] as const)
+    )
+  })
+
+/**
+ * @since 1.0.0
+ * @category initial message
+ */
+export const layerInitialMessage = <A, I, R, R2>(
+  schema: Schema.Schema<A, I, R>,
+  build: Effect.Effect<A, never, R2>
+): Layer.Layer<InitialMessage, never, R | R2> =>
+  Layer.effect(
+    InitialMessage,
+    Effect.contextWith((context: Context.Context<R | R2>) =>
+      Effect.provide(Effect.orDie(makeInitialMessage(schema, build)), context)
+    )
+  )
+
+/**
+ * @since 1.0.0
+ * @category initial message
+ */
+export const initialMessage = <A, I, R>(
+  schema: Schema.Schema<A, I, R>
+): Effect.Effect<A, NoSuchElementException | ParseError, Protocol | R> =>
+  ProtocolTag.pipe(
+    Effect.flatMap((protocol) => protocol.initialMessage),
+    Effect.flatten,
+    Effect.flatMap(Schema.decodeUnknown(schema))
+  )
diff --git a/src/index.ts b/src/index.ts
index 56a86163a9db7f267c019959b7d1e5b186d7294a..3b352e71a7b94b8308b04a76113cc09575f412a9 100644
--- a/src/index.ts
+++ b/src/index.ts
@@ -6,14 +6,44 @@ export * as Rpc from "./Rpc.js"
 /**
  * @since 1.0.0
  */
-export * as RpcResolver from "./RpcResolver.js"
+export * as RpcClient from "./RpcClient.js"
 
 /**
  * @since 1.0.0
  */
-export * as RpcResolverNoStream from "./RpcResolverNoStream.js"
+export * as RpcGroup from "./RpcGroup.js"
 
 /**
  * @since 1.0.0
  */
-export * as RpcRouter from "./RpcRouter.js"
+export * as RpcMessage from "./RpcMessage.js"
+
+/**
+ * @since 1.0.0
+ */
+export * as RpcMiddleware from "./RpcMiddleware.js"
+
+/**
+ * @since 1.0.0
+ */
+export * as RpcSchema from "./RpcSchema.js"
+
+/**
+ * @since 1.0.0
+ */
+export * as RpcSerialization from "./RpcSerialization.js"
+
+/**
+ * @since 1.0.0
+ */
+export * as RpcServer from "./RpcServer.js"
+
+/**
+ * @since 1.0.0
+ */
+export * as RpcTest from "./RpcTest.js"
+
+/**
+ * @since 1.0.0
+ */
+export * as RpcWorker from "./RpcWorker.js"
diff --git a/src/internal/utils.ts b/src/internal/utils.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7ce829c25b404766a068047c5189babcb0d4530f
--- /dev/null
+++ b/src/internal/utils.ts
@@ -0,0 +1,37 @@
+import type * as Context from "effect/Context"
+import * as Effect from "effect/Effect"
+
+/** @internal */
+export const withRun = <
+  A extends {
+    readonly run: (f: (...args: Array<any>) => Effect.Effect<void>) => Effect.Effect<never>
+  }
+>() =>
+<EX, RX>(f: (write: Parameters<A["run"]>[0]) => Effect.Effect<Omit<A, "run">, EX, RX>): Effect.Effect<A, EX, RX> =>
+  Effect.suspend(() => {
+    const semaphore = Effect.unsafeMakeSemaphore(1)
+    let buffer: Array<[Array<any>, Context.Context<never>]> = []
+    let write = (...args: Array<any>): Effect.Effect<void> =>
+      Effect.contextWith((context) => {
+        buffer.push([args, context])
+      })
+    return Effect.map(f((...args) => write(...args)), (a) => ({
+      ...a,
+      run(f) {
+        return semaphore.withPermits(1)(Effect.gen(function*() {
+          const prev = write
+          write = f
+
+          for (const [args, context] of buffer) {
+            yield* Effect.provide(write(...args), context)
+          }
+          buffer = []
+
+          return yield* Effect.onExit(Effect.never, () => {
+            write = prev
+            return Effect.void
+          })
+        }))
+      }
+    } as A))
+  })
