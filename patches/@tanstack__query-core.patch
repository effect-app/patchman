diff --git a/build/legacy/hydration-CdBkFt9i.d.cts b/build/legacy/hydration-Dv1t2VQO.d.cts
similarity index 99%
rename from build/legacy/hydration-CdBkFt9i.d.cts
rename to build/legacy/hydration-Dv1t2VQO.d.cts
index f76324f5b7145d4431d088092ae98a1ba2e4c49a..9486d3b175979caaedc9e8e03ae9d22b222bd654 100644
--- a/build/legacy/hydration-CdBkFt9i.d.cts
+++ b/build/legacy/hydration-Dv1t2VQO.d.cts
@@ -73,6 +73,7 @@ interface FetchOptions<TData = unknown> {
     cancelRefetch?: boolean;
     meta?: FetchMeta;
     initialPromise?: Promise<TData>;
+    updateMeta?: Record<string, unknown>;
 }
 interface FailedAction$1<TError> {
     type: 'failed';
@@ -775,6 +776,7 @@ interface RefetchOptions extends ResultOptions {
      * Defaults to `true`.
      */
     cancelRefetch?: boolean;
+    updateMeta?: Record<string, unknown>;
 }
 interface InvalidateQueryFilters<TQueryKey extends QueryKey = QueryKey> extends QueryFilters<TQueryKey> {
     refetchType?: QueryTypeFilter | 'none';
diff --git a/build/legacy/hydration-Cr-4Kky1.d.ts b/build/legacy/hydration-Dwnp99qT.d.ts
similarity index 99%
rename from build/legacy/hydration-Cr-4Kky1.d.ts
rename to build/legacy/hydration-Dwnp99qT.d.ts
index 588271203cacd383b4c706099683ce06fd08baa4..1f9fc5a22873edd4dde56e17568ce3810113f928 100644
--- a/build/legacy/hydration-Cr-4Kky1.d.ts
+++ b/build/legacy/hydration-Dwnp99qT.d.ts
@@ -73,6 +73,7 @@ interface FetchOptions<TData = unknown> {
     cancelRefetch?: boolean;
     meta?: FetchMeta;
     initialPromise?: Promise<TData>;
+    updateMeta?: Record<string, unknown>;
 }
 interface FailedAction$1<TError> {
     type: 'failed';
@@ -775,6 +776,7 @@ interface RefetchOptions extends ResultOptions {
      * Defaults to `true`.
      */
     cancelRefetch?: boolean;
+    updateMeta?: Record<string, unknown>;
 }
 interface InvalidateQueryFilters<TQueryKey extends QueryKey = QueryKey> extends QueryFilters<TQueryKey> {
     refetchType?: QueryTypeFilter | 'none';
diff --git a/build/legacy/hydration.d.cts b/build/legacy/hydration.d.cts
index 2c42c5f493852f161b80bc31c6dbd5d409727df1..27fe7f6e3cd6e8f116e390da439f969a491c8385 100644
--- a/build/legacy/hydration.d.cts
+++ b/build/legacy/hydration.d.cts
@@ -1,3 +1,3 @@
-export { D as DehydrateOptions, A as DehydratedState, H as HydrateOptions, v as defaultShouldDehydrateMutation, u as defaultShouldDehydrateQuery, q as dehydrate, t as hydrate } from './hydration-CdBkFt9i.cjs';
+export { D as DehydrateOptions, A as DehydratedState, H as HydrateOptions, v as defaultShouldDehydrateMutation, u as defaultShouldDehydrateQuery, q as dehydrate, t as hydrate } from './hydration-Dv1t2VQO.cjs';
 import './removable.cjs';
 import './subscribable.cjs';
diff --git a/build/legacy/hydration.d.ts b/build/legacy/hydration.d.ts
index 44e824db5f0a3d9af2f52bc8c49baa1a7789388d..6b9eed88f845f9d8f997e7c4d5c53416b1432a0b 100644
--- a/build/legacy/hydration.d.ts
+++ b/build/legacy/hydration.d.ts
@@ -1,3 +1,3 @@
-export { D as DehydrateOptions, A as DehydratedState, H as HydrateOptions, v as defaultShouldDehydrateMutation, u as defaultShouldDehydrateQuery, q as dehydrate, t as hydrate } from './hydration-Cr-4Kky1.js';
+export { D as DehydrateOptions, A as DehydratedState, H as HydrateOptions, v as defaultShouldDehydrateMutation, u as defaultShouldDehydrateQuery, q as dehydrate, t as hydrate } from './hydration-Dwnp99qT.js';
 import './removable.js';
 import './subscribable.js';
diff --git a/build/legacy/index.d.cts b/build/legacy/index.d.cts
index 0353f72e9c2210286ebfc9d4ce52b4601a13f7de..a308c0a3a4484c26ab7e64239394609425dec10e 100644
--- a/build/legacy/index.d.cts
+++ b/build/legacy/index.d.cts
@@ -1,4 +1,4 @@
-export { T as AnyDataTag, b6 as CancelOptions, C as CancelledError, V as DataTag, G as DefaultError, b5 as DefaultOptions, ak as DefaultedInfiniteQueryObserverOptions, ai as DefaultedQueryObserverOptions, aP as DefinedInfiniteQueryObserverResult, aG as DefinedQueryObserverResult, D as DehydrateOptions, A as DehydratedState, B as DistributiveOmit, $ as Enabled, an as EnsureInfiniteQueryDataOptions, am as EnsureQueryDataOptions, ao as FetchInfiniteQueryOptions, av as FetchNextPageOptions, aw as FetchPreviousPageOptions, al as FetchQueryOptions, ay as FetchStatus, a7 as GetNextPageParamFunction, a6 as GetPreviousPageParamFunction, H as HydrateOptions, W as InferDataFromTag, X as InferErrorFromTag, a8 as InfiniteData, aI as InfiniteQueryObserverBaseResult, aL as InfiniteQueryObserverLoadingErrorResult, aK as InfiniteQueryObserverLoadingResult, aj as InfiniteQueryObserverOptions, aJ as InfiniteQueryObserverPendingResult, aO as InfiniteQueryObserverPlaceholderResult, aM as InfiniteQueryObserverRefetchErrorResult, aQ as InfiniteQueryObserverResult, aN as InfiniteQueryObserverSuccessResult, ae as InfiniteQueryPageParamsOptions, a2 as InitialDataFunction, ad as InitialPageParam, at as InvalidateOptions, ar as InvalidateQueryFilters, aZ as MutateFunction, aY as MutateOptions, z as Mutation, M as MutationCache, d as MutationCacheNotifyEvent, j as MutationFilters, aV as MutationFunction, aR as MutationKey, aU as MutationMeta, e as MutationObserver, a_ as MutationObserverBaseResult, b1 as MutationObserverErrorResult, a$ as MutationObserverIdleResult, b0 as MutationObserverLoadingResult, aX as MutationObserverOptions, b3 as MutationObserverResult, b2 as MutationObserverSuccessResult, aW as MutationOptions, aT as MutationScope, y as MutationState, aS as MutationStatus, aa as NetworkMode, F as NoInfer, N as NonUndefinedGuard, b9 as NotifyEvent, b8 as NotifyEventType, ab as NotifyOnChangeProps, O as OmitKeyof, E as Override, a3 as PlaceholderDataFunction, a4 as QueriesPlaceholderDataFunction, x as Query, Q as QueryCache, a as QueryCacheNotifyEvent, b as QueryClient, b4 as QueryClientConfig, l as QueryFilters, Y as QueryFunction, a1 as QueryFunctionContext, I as QueryKey, a5 as QueryKeyHashFunction, a9 as QueryMeta, c as QueryObserver, az as QueryObserverBaseResult, aC as QueryObserverLoadingErrorResult, aB as QueryObserverLoadingResult, ag as QueryObserverOptions, aA as QueryObserverPendingResult, aF as QueryObserverPlaceholderResult, aD as QueryObserverRefetchErrorResult, aH as QueryObserverResult, aE as QueryObserverSuccessResult, ac as QueryOptions, a0 as QueryPersister, w as QueryState, ax as QueryStatus, aq as RefetchOptions, as as RefetchQueryFilters, R as Register, au as ResetOptions, ap as ResultOptions, b7 as SetDataOptions, S as SkipToken, Z as StaleTime, _ as StaleTimeFunction, af as ThrowOnError, P as UnsetMarker, U as Updater, ah as WithRequired, K as dataTagErrorSymbol, J as dataTagSymbol, v as defaultShouldDehydrateMutation, u as defaultShouldDehydrateQuery, q as dehydrate, h as hashKey, t as hydrate, o as isCancelledError, i as isServer, k as keepPreviousData, f as matchMutation, m as matchQuery, n as noop, p as partialMatchKey, r as replaceEqualDeep, g as shouldThrowError, s as skipToken, L as unsetMarker } from './hydration-CdBkFt9i.cjs';
+export { T as AnyDataTag, b6 as CancelOptions, C as CancelledError, V as DataTag, G as DefaultError, b5 as DefaultOptions, ak as DefaultedInfiniteQueryObserverOptions, ai as DefaultedQueryObserverOptions, aP as DefinedInfiniteQueryObserverResult, aG as DefinedQueryObserverResult, D as DehydrateOptions, A as DehydratedState, B as DistributiveOmit, $ as Enabled, an as EnsureInfiniteQueryDataOptions, am as EnsureQueryDataOptions, ao as FetchInfiniteQueryOptions, av as FetchNextPageOptions, aw as FetchPreviousPageOptions, al as FetchQueryOptions, ay as FetchStatus, a7 as GetNextPageParamFunction, a6 as GetPreviousPageParamFunction, H as HydrateOptions, W as InferDataFromTag, X as InferErrorFromTag, a8 as InfiniteData, aI as InfiniteQueryObserverBaseResult, aL as InfiniteQueryObserverLoadingErrorResult, aK as InfiniteQueryObserverLoadingResult, aj as InfiniteQueryObserverOptions, aJ as InfiniteQueryObserverPendingResult, aO as InfiniteQueryObserverPlaceholderResult, aM as InfiniteQueryObserverRefetchErrorResult, aQ as InfiniteQueryObserverResult, aN as InfiniteQueryObserverSuccessResult, ae as InfiniteQueryPageParamsOptions, a2 as InitialDataFunction, ad as InitialPageParam, at as InvalidateOptions, ar as InvalidateQueryFilters, aZ as MutateFunction, aY as MutateOptions, z as Mutation, M as MutationCache, d as MutationCacheNotifyEvent, j as MutationFilters, aV as MutationFunction, aR as MutationKey, aU as MutationMeta, e as MutationObserver, a_ as MutationObserverBaseResult, b1 as MutationObserverErrorResult, a$ as MutationObserverIdleResult, b0 as MutationObserverLoadingResult, aX as MutationObserverOptions, b3 as MutationObserverResult, b2 as MutationObserverSuccessResult, aW as MutationOptions, aT as MutationScope, y as MutationState, aS as MutationStatus, aa as NetworkMode, F as NoInfer, N as NonUndefinedGuard, b9 as NotifyEvent, b8 as NotifyEventType, ab as NotifyOnChangeProps, O as OmitKeyof, E as Override, a3 as PlaceholderDataFunction, a4 as QueriesPlaceholderDataFunction, x as Query, Q as QueryCache, a as QueryCacheNotifyEvent, b as QueryClient, b4 as QueryClientConfig, l as QueryFilters, Y as QueryFunction, a1 as QueryFunctionContext, I as QueryKey, a5 as QueryKeyHashFunction, a9 as QueryMeta, c as QueryObserver, az as QueryObserverBaseResult, aC as QueryObserverLoadingErrorResult, aB as QueryObserverLoadingResult, ag as QueryObserverOptions, aA as QueryObserverPendingResult, aF as QueryObserverPlaceholderResult, aD as QueryObserverRefetchErrorResult, aH as QueryObserverResult, aE as QueryObserverSuccessResult, ac as QueryOptions, a0 as QueryPersister, w as QueryState, ax as QueryStatus, aq as RefetchOptions, as as RefetchQueryFilters, R as Register, au as ResetOptions, ap as ResultOptions, b7 as SetDataOptions, S as SkipToken, Z as StaleTime, _ as StaleTimeFunction, af as ThrowOnError, P as UnsetMarker, U as Updater, ah as WithRequired, K as dataTagErrorSymbol, J as dataTagSymbol, v as defaultShouldDehydrateMutation, u as defaultShouldDehydrateQuery, q as dehydrate, h as hashKey, t as hydrate, o as isCancelledError, i as isServer, k as keepPreviousData, f as matchMutation, m as matchQuery, n as noop, p as partialMatchKey, r as replaceEqualDeep, g as shouldThrowError, s as skipToken, L as unsetMarker } from './hydration-Dv1t2VQO.cjs';
 export { QueriesObserver, QueriesObserverOptions } from './queriesObserver.cjs';
 export { InfiniteQueryObserver } from './infiniteQueryObserver.cjs';
 export { defaultScheduler, notifyManager } from './notifyManager.cjs';
diff --git a/build/legacy/index.d.ts b/build/legacy/index.d.ts
index 3eacee662d9884fd70e56b107415b6a8190dfa2a..5bdd7bf2642601f1e8a2c5505fd2a3ad68739dd6 100644
--- a/build/legacy/index.d.ts
+++ b/build/legacy/index.d.ts
@@ -1,4 +1,4 @@
-export { T as AnyDataTag, b6 as CancelOptions, C as CancelledError, V as DataTag, G as DefaultError, b5 as DefaultOptions, ak as DefaultedInfiniteQueryObserverOptions, ai as DefaultedQueryObserverOptions, aP as DefinedInfiniteQueryObserverResult, aG as DefinedQueryObserverResult, D as DehydrateOptions, A as DehydratedState, B as DistributiveOmit, $ as Enabled, an as EnsureInfiniteQueryDataOptions, am as EnsureQueryDataOptions, ao as FetchInfiniteQueryOptions, av as FetchNextPageOptions, aw as FetchPreviousPageOptions, al as FetchQueryOptions, ay as FetchStatus, a7 as GetNextPageParamFunction, a6 as GetPreviousPageParamFunction, H as HydrateOptions, W as InferDataFromTag, X as InferErrorFromTag, a8 as InfiniteData, aI as InfiniteQueryObserverBaseResult, aL as InfiniteQueryObserverLoadingErrorResult, aK as InfiniteQueryObserverLoadingResult, aj as InfiniteQueryObserverOptions, aJ as InfiniteQueryObserverPendingResult, aO as InfiniteQueryObserverPlaceholderResult, aM as InfiniteQueryObserverRefetchErrorResult, aQ as InfiniteQueryObserverResult, aN as InfiniteQueryObserverSuccessResult, ae as InfiniteQueryPageParamsOptions, a2 as InitialDataFunction, ad as InitialPageParam, at as InvalidateOptions, ar as InvalidateQueryFilters, aZ as MutateFunction, aY as MutateOptions, z as Mutation, M as MutationCache, d as MutationCacheNotifyEvent, j as MutationFilters, aV as MutationFunction, aR as MutationKey, aU as MutationMeta, e as MutationObserver, a_ as MutationObserverBaseResult, b1 as MutationObserverErrorResult, a$ as MutationObserverIdleResult, b0 as MutationObserverLoadingResult, aX as MutationObserverOptions, b3 as MutationObserverResult, b2 as MutationObserverSuccessResult, aW as MutationOptions, aT as MutationScope, y as MutationState, aS as MutationStatus, aa as NetworkMode, F as NoInfer, N as NonUndefinedGuard, b9 as NotifyEvent, b8 as NotifyEventType, ab as NotifyOnChangeProps, O as OmitKeyof, E as Override, a3 as PlaceholderDataFunction, a4 as QueriesPlaceholderDataFunction, x as Query, Q as QueryCache, a as QueryCacheNotifyEvent, b as QueryClient, b4 as QueryClientConfig, l as QueryFilters, Y as QueryFunction, a1 as QueryFunctionContext, I as QueryKey, a5 as QueryKeyHashFunction, a9 as QueryMeta, c as QueryObserver, az as QueryObserverBaseResult, aC as QueryObserverLoadingErrorResult, aB as QueryObserverLoadingResult, ag as QueryObserverOptions, aA as QueryObserverPendingResult, aF as QueryObserverPlaceholderResult, aD as QueryObserverRefetchErrorResult, aH as QueryObserverResult, aE as QueryObserverSuccessResult, ac as QueryOptions, a0 as QueryPersister, w as QueryState, ax as QueryStatus, aq as RefetchOptions, as as RefetchQueryFilters, R as Register, au as ResetOptions, ap as ResultOptions, b7 as SetDataOptions, S as SkipToken, Z as StaleTime, _ as StaleTimeFunction, af as ThrowOnError, P as UnsetMarker, U as Updater, ah as WithRequired, K as dataTagErrorSymbol, J as dataTagSymbol, v as defaultShouldDehydrateMutation, u as defaultShouldDehydrateQuery, q as dehydrate, h as hashKey, t as hydrate, o as isCancelledError, i as isServer, k as keepPreviousData, f as matchMutation, m as matchQuery, n as noop, p as partialMatchKey, r as replaceEqualDeep, g as shouldThrowError, s as skipToken, L as unsetMarker } from './hydration-Cr-4Kky1.js';
+export { T as AnyDataTag, b6 as CancelOptions, C as CancelledError, V as DataTag, G as DefaultError, b5 as DefaultOptions, ak as DefaultedInfiniteQueryObserverOptions, ai as DefaultedQueryObserverOptions, aP as DefinedInfiniteQueryObserverResult, aG as DefinedQueryObserverResult, D as DehydrateOptions, A as DehydratedState, B as DistributiveOmit, $ as Enabled, an as EnsureInfiniteQueryDataOptions, am as EnsureQueryDataOptions, ao as FetchInfiniteQueryOptions, av as FetchNextPageOptions, aw as FetchPreviousPageOptions, al as FetchQueryOptions, ay as FetchStatus, a7 as GetNextPageParamFunction, a6 as GetPreviousPageParamFunction, H as HydrateOptions, W as InferDataFromTag, X as InferErrorFromTag, a8 as InfiniteData, aI as InfiniteQueryObserverBaseResult, aL as InfiniteQueryObserverLoadingErrorResult, aK as InfiniteQueryObserverLoadingResult, aj as InfiniteQueryObserverOptions, aJ as InfiniteQueryObserverPendingResult, aO as InfiniteQueryObserverPlaceholderResult, aM as InfiniteQueryObserverRefetchErrorResult, aQ as InfiniteQueryObserverResult, aN as InfiniteQueryObserverSuccessResult, ae as InfiniteQueryPageParamsOptions, a2 as InitialDataFunction, ad as InitialPageParam, at as InvalidateOptions, ar as InvalidateQueryFilters, aZ as MutateFunction, aY as MutateOptions, z as Mutation, M as MutationCache, d as MutationCacheNotifyEvent, j as MutationFilters, aV as MutationFunction, aR as MutationKey, aU as MutationMeta, e as MutationObserver, a_ as MutationObserverBaseResult, b1 as MutationObserverErrorResult, a$ as MutationObserverIdleResult, b0 as MutationObserverLoadingResult, aX as MutationObserverOptions, b3 as MutationObserverResult, b2 as MutationObserverSuccessResult, aW as MutationOptions, aT as MutationScope, y as MutationState, aS as MutationStatus, aa as NetworkMode, F as NoInfer, N as NonUndefinedGuard, b9 as NotifyEvent, b8 as NotifyEventType, ab as NotifyOnChangeProps, O as OmitKeyof, E as Override, a3 as PlaceholderDataFunction, a4 as QueriesPlaceholderDataFunction, x as Query, Q as QueryCache, a as QueryCacheNotifyEvent, b as QueryClient, b4 as QueryClientConfig, l as QueryFilters, Y as QueryFunction, a1 as QueryFunctionContext, I as QueryKey, a5 as QueryKeyHashFunction, a9 as QueryMeta, c as QueryObserver, az as QueryObserverBaseResult, aC as QueryObserverLoadingErrorResult, aB as QueryObserverLoadingResult, ag as QueryObserverOptions, aA as QueryObserverPendingResult, aF as QueryObserverPlaceholderResult, aD as QueryObserverRefetchErrorResult, aH as QueryObserverResult, aE as QueryObserverSuccessResult, ac as QueryOptions, a0 as QueryPersister, w as QueryState, ax as QueryStatus, aq as RefetchOptions, as as RefetchQueryFilters, R as Register, au as ResetOptions, ap as ResultOptions, b7 as SetDataOptions, S as SkipToken, Z as StaleTime, _ as StaleTimeFunction, af as ThrowOnError, P as UnsetMarker, U as Updater, ah as WithRequired, K as dataTagErrorSymbol, J as dataTagSymbol, v as defaultShouldDehydrateMutation, u as defaultShouldDehydrateQuery, q as dehydrate, h as hashKey, t as hydrate, o as isCancelledError, i as isServer, k as keepPreviousData, f as matchMutation, m as matchQuery, n as noop, p as partialMatchKey, r as replaceEqualDeep, g as shouldThrowError, s as skipToken, L as unsetMarker } from './hydration-Dwnp99qT.js';
 export { QueriesObserver, QueriesObserverOptions } from './queriesObserver.js';
 export { InfiniteQueryObserver } from './infiniteQueryObserver.js';
 export { defaultScheduler, notifyManager } from './notifyManager.js';
diff --git a/build/legacy/infiniteQueryBehavior.d.cts b/build/legacy/infiniteQueryBehavior.d.cts
index dc431640774bd6ee0f8b6c38a7abf9afc1fe9a4f..2fb3508a04ce42f4a4dbd145b6b66ab9bdedfd80 100644
--- a/build/legacy/infiniteQueryBehavior.d.cts
+++ b/build/legacy/infiniteQueryBehavior.d.cts
@@ -1,4 +1,4 @@
-import { ba as QueryBehavior, a8 as InfiniteData, ae as InfiniteQueryPageParamsOptions } from './hydration-CdBkFt9i.cjs';
+import { ba as QueryBehavior, a8 as InfiniteData, ae as InfiniteQueryPageParamsOptions } from './hydration-Dv1t2VQO.cjs';
 import './removable.cjs';
 import './subscribable.cjs';
 
diff --git a/build/legacy/infiniteQueryBehavior.d.ts b/build/legacy/infiniteQueryBehavior.d.ts
index d101b7141e9ec1a7a963765a6e82b88dc788252f..b837c7b3ae5f5eee9c2a6e049db6ebd459707692 100644
--- a/build/legacy/infiniteQueryBehavior.d.ts
+++ b/build/legacy/infiniteQueryBehavior.d.ts
@@ -1,4 +1,4 @@
-import { ba as QueryBehavior, a8 as InfiniteData, ae as InfiniteQueryPageParamsOptions } from './hydration-Cr-4Kky1.js';
+import { ba as QueryBehavior, a8 as InfiniteData, ae as InfiniteQueryPageParamsOptions } from './hydration-Dwnp99qT.js';
 import './removable.js';
 import './subscribable.js';
 
diff --git a/build/legacy/infiniteQueryObserver.d.cts b/build/legacy/infiniteQueryObserver.d.cts
index fd5bc8a8ddfa244b2573d895a6eea2ed9f4a5b8e..8ee52ac9e2f6d8d2145866560a352cc3d372db55 100644
--- a/build/legacy/infiniteQueryObserver.d.cts
+++ b/build/legacy/infiniteQueryObserver.d.cts
@@ -1,4 +1,4 @@
-import { G as DefaultError, a8 as InfiniteData, I as QueryKey, c as QueryObserver, aQ as InfiniteQueryObserverResult, b as QueryClient, aj as InfiniteQueryObserverOptions, ak as DefaultedInfiniteQueryObserverOptions, av as FetchNextPageOptions, aw as FetchPreviousPageOptions, x as Query } from './hydration-CdBkFt9i.cjs';
+import { G as DefaultError, a8 as InfiniteData, I as QueryKey, c as QueryObserver, aQ as InfiniteQueryObserverResult, b as QueryClient, aj as InfiniteQueryObserverOptions, ak as DefaultedInfiniteQueryObserverOptions, av as FetchNextPageOptions, aw as FetchPreviousPageOptions, x as Query } from './hydration-Dv1t2VQO.cjs';
 import { Subscribable } from './subscribable.cjs';
 import './removable.cjs';
 
diff --git a/build/legacy/infiniteQueryObserver.d.ts b/build/legacy/infiniteQueryObserver.d.ts
index 88fff903875a31a48e0cc4d8bc101a9ad9e580f7..c49b3653191dd05cae8483611134c0a7691051e9 100644
--- a/build/legacy/infiniteQueryObserver.d.ts
+++ b/build/legacy/infiniteQueryObserver.d.ts
@@ -1,4 +1,4 @@
-import { G as DefaultError, a8 as InfiniteData, I as QueryKey, c as QueryObserver, aQ as InfiniteQueryObserverResult, b as QueryClient, aj as InfiniteQueryObserverOptions, ak as DefaultedInfiniteQueryObserverOptions, av as FetchNextPageOptions, aw as FetchPreviousPageOptions, x as Query } from './hydration-Cr-4Kky1.js';
+import { G as DefaultError, a8 as InfiniteData, I as QueryKey, c as QueryObserver, aQ as InfiniteQueryObserverResult, b as QueryClient, aj as InfiniteQueryObserverOptions, ak as DefaultedInfiniteQueryObserverOptions, av as FetchNextPageOptions, aw as FetchPreviousPageOptions, x as Query } from './hydration-Dwnp99qT.js';
 import { Subscribable } from './subscribable.js';
 import './removable.js';
 
diff --git a/build/legacy/mutation.d.cts b/build/legacy/mutation.d.cts
index a389982d2535be6422cf026b793653f16dbc2d06..b603e777bdb4850412e1b87c369fef1b47e3ae88 100644
--- a/build/legacy/mutation.d.cts
+++ b/build/legacy/mutation.d.cts
@@ -1,3 +1,3 @@
 import './removable.cjs';
-export { bi as Action, z as Mutation, y as MutationState, bj as getDefaultState } from './hydration-CdBkFt9i.cjs';
+export { bi as Action, z as Mutation, y as MutationState, bj as getDefaultState } from './hydration-Dv1t2VQO.cjs';
 import './subscribable.cjs';
diff --git a/build/legacy/mutation.d.ts b/build/legacy/mutation.d.ts
index dde7d7dfb71e8d32061bc1635e0e5318a561f3ac..c9e0754240c16882dd346345c0665ddc95f8ddbd 100644
--- a/build/legacy/mutation.d.ts
+++ b/build/legacy/mutation.d.ts
@@ -1,3 +1,3 @@
 import './removable.js';
-export { bi as Action, z as Mutation, y as MutationState, bj as getDefaultState } from './hydration-Cr-4Kky1.js';
+export { bi as Action, z as Mutation, y as MutationState, bj as getDefaultState } from './hydration-Dwnp99qT.js';
 import './subscribable.js';
diff --git a/build/legacy/mutationCache.d.cts b/build/legacy/mutationCache.d.cts
index cdf5fa04605fbe176955a33066dcea9d686ab2d3..103612e98a644c6a1fb8febfe8aa2aaaf63a1184 100644
--- a/build/legacy/mutationCache.d.cts
+++ b/build/legacy/mutationCache.d.cts
@@ -1,3 +1,3 @@
-export { M as MutationCache, d as MutationCacheNotifyEvent } from './hydration-CdBkFt9i.cjs';
+export { M as MutationCache, d as MutationCacheNotifyEvent } from './hydration-Dv1t2VQO.cjs';
 import './subscribable.cjs';
 import './removable.cjs';
diff --git a/build/legacy/mutationCache.d.ts b/build/legacy/mutationCache.d.ts
index 83e89ed128dd4ef9de638b4bee5a522467296a46..488b1ee5abe1bbe68ccb2cc4216ef7f004d59ec2 100644
--- a/build/legacy/mutationCache.d.ts
+++ b/build/legacy/mutationCache.d.ts
@@ -1,3 +1,3 @@
-export { M as MutationCache, d as MutationCacheNotifyEvent } from './hydration-Cr-4Kky1.js';
+export { M as MutationCache, d as MutationCacheNotifyEvent } from './hydration-Dwnp99qT.js';
 import './subscribable.js';
 import './removable.js';
diff --git a/build/legacy/mutationObserver.d.cts b/build/legacy/mutationObserver.d.cts
index 434d57afc47b6ba50c986e5912dfcc73e5e33518..2f1b51610ca0df15145e626bc7251ade5dd634f4 100644
--- a/build/legacy/mutationObserver.d.cts
+++ b/build/legacy/mutationObserver.d.cts
@@ -1,3 +1,3 @@
 import './subscribable.cjs';
-export { e as MutationObserver } from './hydration-CdBkFt9i.cjs';
+export { e as MutationObserver } from './hydration-Dv1t2VQO.cjs';
 import './removable.cjs';
diff --git a/build/legacy/mutationObserver.d.ts b/build/legacy/mutationObserver.d.ts
index 30812b79b3cf4b4ce01ec52d5301cabdcb47eba6..198ffa3584641b6b0ef4bfc90ca5fdbc56ede2c1 100644
--- a/build/legacy/mutationObserver.d.ts
+++ b/build/legacy/mutationObserver.d.ts
@@ -1,3 +1,3 @@
 import './subscribable.js';
-export { e as MutationObserver } from './hydration-Cr-4Kky1.js';
+export { e as MutationObserver } from './hydration-Dwnp99qT.js';
 import './removable.js';
diff --git a/build/legacy/queriesObserver.d.cts b/build/legacy/queriesObserver.d.cts
index 1fc8ee0fad7439f1ae1dbd04968fdde4fdf14e81..19cb98368ddc6f44696c883e9170cc45e6e3934d 100644
--- a/build/legacy/queriesObserver.d.cts
+++ b/build/legacy/queriesObserver.d.cts
@@ -1,4 +1,4 @@
-import { aH as QueryObserverResult, b as QueryClient, ag as QueryObserverOptions, x as Query, c as QueryObserver } from './hydration-CdBkFt9i.cjs';
+import { aH as QueryObserverResult, b as QueryClient, ag as QueryObserverOptions, x as Query, c as QueryObserver } from './hydration-Dv1t2VQO.cjs';
 import { Subscribable } from './subscribable.cjs';
 import './removable.cjs';
 
diff --git a/build/legacy/queriesObserver.d.ts b/build/legacy/queriesObserver.d.ts
index f58d4aa0cae947004220be2dd2f4fbede04b7bfe..3e2170cbdaf4fa8f4d65bb5cfb9fab3cf4e1e628 100644
--- a/build/legacy/queriesObserver.d.ts
+++ b/build/legacy/queriesObserver.d.ts
@@ -1,4 +1,4 @@
-import { aH as QueryObserverResult, b as QueryClient, ag as QueryObserverOptions, x as Query, c as QueryObserver } from './hydration-Cr-4Kky1.js';
+import { aH as QueryObserverResult, b as QueryClient, ag as QueryObserverOptions, x as Query, c as QueryObserver } from './hydration-Dwnp99qT.js';
 import { Subscribable } from './subscribable.js';
 import './removable.js';
 
diff --git a/build/legacy/query.cjs b/build/legacy/query.cjs
index d832d84525b93f73477ed91da0be3004c2a77d1f..432dd621eb97797940874dab34746b09a701fc37 100644
--- a/build/legacy/query.cjs
+++ b/build/legacy/query.cjs
@@ -227,7 +227,7 @@ var Query = class extends import_removable.Removable {
         const queryFnContext2 = {
           client: __privateGet(this, _client),
           queryKey: this.queryKey,
-          meta: this.meta
+          meta: (fetchOptions == null ? void 0 : fetchOptions.updateMeta) ? { ...this.meta, ...fetchOptions.updateMeta } : this.meta
         };
         addSignalProperty(queryFnContext2);
         return queryFnContext2;
diff --git a/build/legacy/query.cjs.map b/build/legacy/query.cjs.map
index 6c47e0d4524a68ad01f83254e6c466a49b9a9c6a..ba250e80b7fbad8911b98b45a0b2c344cf6bf7b9 100644
--- a/build/legacy/query.cjs.map
+++ b/build/legacy/query.cjs.map
@@ -1 +1 @@
-{"version":3,"sources":["../../src/query.ts"],"sourcesContent":["import {\n  ensureQueryFn,\n  noop,\n  replaceData,\n  resolveEnabled,\n  resolveStaleTime,\n  skipToken,\n  timeUntilStale,\n} from './utils'\nimport { notifyManager } from './notifyManager'\nimport { canFetch, createRetryer, isCancelledError } from './retryer'\nimport { Removable } from './removable'\nimport type { QueryCache } from './queryCache'\nimport type { QueryClient } from './queryClient'\nimport type {\n  CancelOptions,\n  DefaultError,\n  FetchStatus,\n  InitialDataFunction,\n  OmitKeyof,\n  QueryFunctionContext,\n  QueryKey,\n  QueryMeta,\n  QueryOptions,\n  QueryStatus,\n  SetDataOptions,\n  StaleTime,\n} from './types'\nimport type { QueryObserver } from './queryObserver'\nimport type { Retryer } from './retryer'\n\n// TYPES\n\ninterface QueryConfig<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  client: QueryClient\n  queryKey: TQueryKey\n  queryHash: string\n  options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  state?: QueryState<TData, TError>\n}\n\nexport interface QueryState<TData = unknown, TError = DefaultError> {\n  data: TData | undefined\n  dataUpdateCount: number\n  dataUpdatedAt: number\n  error: TError | null\n  errorUpdateCount: number\n  errorUpdatedAt: number\n  fetchFailureCount: number\n  fetchFailureReason: TError | null\n  fetchMeta: FetchMeta | null\n  isInvalidated: boolean\n  status: QueryStatus\n  fetchStatus: FetchStatus\n}\n\nexport interface FetchContext<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  fetchFn: () => unknown | Promise<unknown>\n  fetchOptions?: FetchOptions\n  signal: AbortSignal\n  options: QueryOptions<TQueryFnData, TError, TData, any>\n  client: QueryClient\n  queryKey: TQueryKey\n  state: QueryState<TData, TError>\n}\n\nexport interface QueryBehavior<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  onFetch: (\n    context: FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n    query: Query,\n  ) => void\n}\n\nexport type FetchDirection = 'forward' | 'backward'\n\nexport interface FetchMeta {\n  fetchMore?: { direction: FetchDirection }\n}\n\nexport interface FetchOptions<TData = unknown> {\n  cancelRefetch?: boolean\n  meta?: FetchMeta\n  initialPromise?: Promise<TData>\n}\n\ninterface FailedAction<TError> {\n  type: 'failed'\n  failureCount: number\n  error: TError\n}\n\ninterface FetchAction {\n  type: 'fetch'\n  meta?: FetchMeta\n}\n\ninterface SuccessAction<TData> {\n  data: TData | undefined\n  type: 'success'\n  dataUpdatedAt?: number\n  manual?: boolean\n}\n\ninterface ErrorAction<TError> {\n  type: 'error'\n  error: TError\n}\n\ninterface InvalidateAction {\n  type: 'invalidate'\n}\n\ninterface PauseAction {\n  type: 'pause'\n}\n\ninterface ContinueAction {\n  type: 'continue'\n}\n\ninterface SetStateAction<TData, TError> {\n  type: 'setState'\n  state: Partial<QueryState<TData, TError>>\n  setStateOptions?: SetStateOptions\n}\n\nexport type Action<TData, TError> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction<TError>\n  | FetchAction\n  | InvalidateAction\n  | PauseAction\n  | SetStateAction<TData, TError>\n  | SuccessAction<TData>\n\nexport interface SetStateOptions {\n  meta?: any\n}\n\n// CLASS\n\nexport class Query<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Removable {\n  queryKey: TQueryKey\n  queryHash: string\n  options!: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  state: QueryState<TData, TError>\n\n  #initialState: QueryState<TData, TError>\n  #revertState?: QueryState<TData, TError>\n  #cache: QueryCache\n  #client: QueryClient\n  #retryer?: Retryer<TData>\n  observers: Array<QueryObserver<any, any, any, any, any>>\n  #defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  #abortSignalConsumed: boolean\n\n  constructor(config: QueryConfig<TQueryFnData, TError, TData, TQueryKey>) {\n    super()\n\n    this.#abortSignalConsumed = false\n    this.#defaultOptions = config.defaultOptions\n    this.setOptions(config.options)\n    this.observers = []\n    this.#client = config.client\n    this.#cache = this.#client.getQueryCache()\n    this.queryKey = config.queryKey\n    this.queryHash = config.queryHash\n    this.#initialState = getDefaultState(this.options)\n    this.state = config.state ?? this.#initialState\n    this.scheduleGc()\n  }\n  get meta(): QueryMeta | undefined {\n    return this.options.meta\n  }\n\n  get promise(): Promise<TData> | undefined {\n    return this.#retryer?.promise\n  }\n\n  setOptions(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): void {\n    this.options = { ...this.#defaultOptions, ...options }\n\n    this.updateGcTime(this.options.gcTime)\n  }\n\n  protected optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === 'idle') {\n      this.#cache.remove(this)\n    }\n  }\n\n  setData(\n    newData: TData,\n    options?: SetDataOptions & { manual: boolean },\n  ): TData {\n    const data = replaceData(this.state.data, newData, this.options)\n\n    // Set data and mark it as cached\n    this.#dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options?.updatedAt,\n      manual: options?.manual,\n    })\n\n    return data\n  }\n\n  setState(\n    state: Partial<QueryState<TData, TError>>,\n    setStateOptions?: SetStateOptions,\n  ): void {\n    this.#dispatch({ type: 'setState', state, setStateOptions })\n  }\n\n  cancel(options?: CancelOptions): Promise<void> {\n    const promise = this.#retryer?.promise\n    this.#retryer?.cancel(options)\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve()\n  }\n\n  destroy(): void {\n    super.destroy()\n\n    this.cancel({ silent: true })\n  }\n\n  reset(): void {\n    this.destroy()\n    this.setState(this.#initialState)\n  }\n\n  isActive(): boolean {\n    return this.observers.some(\n      (observer) => resolveEnabled(observer.options.enabled, this) !== false,\n    )\n  }\n\n  isDisabled(): boolean {\n    if (this.getObserversCount() > 0) {\n      return !this.isActive()\n    }\n    // if a query has no observers, it should still be considered disabled if it never attempted a fetch\n    return (\n      this.options.queryFn === skipToken ||\n      this.state.dataUpdateCount + this.state.errorUpdateCount === 0\n    )\n  }\n\n  isStatic(): boolean {\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(\n        (observer) =>\n          resolveStaleTime(observer.options.staleTime, this) === 'static',\n      )\n    }\n\n    return false\n  }\n\n  isStale(): boolean {\n    // check observers first, their `isStale` has the source of truth\n    // calculated with `isStaleByTime` and it takes `enabled` into account\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(\n        (observer) => observer.getCurrentResult().isStale,\n      )\n    }\n\n    return this.state.data === undefined || this.state.isInvalidated\n  }\n\n  isStaleByTime(staleTime: StaleTime = 0): boolean {\n    // no data is always stale\n    if (this.state.data === undefined) {\n      return true\n    }\n    // static is never stale\n    if (staleTime === 'static') {\n      return false\n    }\n    // if the query is invalidated, it is stale\n    if (this.state.isInvalidated) {\n      return true\n    }\n\n    return !timeUntilStale(this.state.dataUpdatedAt, staleTime)\n  }\n\n  onFocus(): void {\n    const observer = this.observers.find((x) => x.shouldFetchOnWindowFocus())\n\n    observer?.refetch({ cancelRefetch: false })\n\n    // Continue fetch if currently paused\n    this.#retryer?.continue()\n  }\n\n  onOnline(): void {\n    const observer = this.observers.find((x) => x.shouldFetchOnReconnect())\n\n    observer?.refetch({ cancelRefetch: false })\n\n    // Continue fetch if currently paused\n    this.#retryer?.continue()\n  }\n\n  addObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer)\n\n      // Stop the query from being garbage collected\n      this.clearGcTimeout()\n\n      this.#cache.notify({ type: 'observerAdded', query: this, observer })\n    }\n  }\n\n  removeObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (this.observers.includes(observer)) {\n      this.observers = this.observers.filter((x) => x !== observer)\n\n      if (!this.observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.#retryer) {\n          if (this.#abortSignalConsumed) {\n            this.#retryer.cancel({ revert: true })\n          } else {\n            this.#retryer.cancelRetry()\n          }\n        }\n\n        this.scheduleGc()\n      }\n\n      this.#cache.notify({ type: 'observerRemoved', query: this, observer })\n    }\n  }\n\n  getObserversCount(): number {\n    return this.observers.length\n  }\n\n  invalidate(): void {\n    if (!this.state.isInvalidated) {\n      this.#dispatch({ type: 'invalidate' })\n    }\n  }\n\n  fetch(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    fetchOptions?: FetchOptions<TQueryFnData>,\n  ): Promise<TData> {\n    if (this.state.fetchStatus !== 'idle') {\n      if (this.state.data !== undefined && fetchOptions?.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetch\n        this.cancel({ silent: true })\n      } else if (this.#retryer) {\n        // make sure that retries that were potentially cancelled due to unmounts can continue\n        this.#retryer.continueRetry()\n        // Return current promise if we are already fetching\n        return this.#retryer.promise\n      }\n    }\n\n    // Update config if passed, otherwise the config from the last execution is used\n    if (options) {\n      this.setOptions(options)\n    }\n\n    // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n    if (!this.options.queryFn) {\n      const observer = this.observers.find((x) => x.options.queryFn)\n      if (observer) {\n        this.setOptions(observer.options)\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!Array.isArray(this.options.queryKey)) {\n        console.error(\n          `As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`,\n        )\n      }\n    }\n\n    const abortController = new AbortController()\n\n    // Adds an enumerable signal property to the object that\n    // which sets abortSignalConsumed to true when the signal\n    // is read.\n    const addSignalProperty = (object: unknown) => {\n      Object.defineProperty(object, 'signal', {\n        enumerable: true,\n        get: () => {\n          this.#abortSignalConsumed = true\n          return abortController.signal\n        },\n      })\n    }\n\n    // Create fetch function\n    const fetchFn = () => {\n      const queryFn = ensureQueryFn(this.options, fetchOptions)\n\n      // Create query function context\n      const createQueryFnContext = (): QueryFunctionContext<TQueryKey> => {\n        const queryFnContext: OmitKeyof<\n          QueryFunctionContext<TQueryKey>,\n          'signal'\n        > = {\n          client: this.#client,\n          queryKey: this.queryKey,\n          meta: this.meta,\n        }\n        addSignalProperty(queryFnContext)\n        return queryFnContext as QueryFunctionContext<TQueryKey>\n      }\n\n      const queryFnContext = createQueryFnContext()\n\n      this.#abortSignalConsumed = false\n      if (this.options.persister) {\n        return this.options.persister(\n          queryFn,\n          queryFnContext,\n          this as unknown as Query,\n        )\n      }\n\n      return queryFn(queryFnContext)\n    }\n\n    // Trigger behavior hook\n    const createFetchContext = (): FetchContext<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey\n    > => {\n      const context: OmitKeyof<\n        FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n        'signal'\n      > = {\n        fetchOptions,\n        options: this.options,\n        queryKey: this.queryKey,\n        client: this.#client,\n        state: this.state,\n        fetchFn,\n      }\n\n      addSignalProperty(context)\n      return context as FetchContext<TQueryFnData, TError, TData, TQueryKey>\n    }\n\n    const context = createFetchContext()\n\n    this.options.behavior?.onFetch(context, this as unknown as Query)\n\n    // Store state in case the current fetch needs to be reverted\n    this.#revertState = this.state\n\n    // Set to fetching state if not already in it\n    if (\n      this.state.fetchStatus === 'idle' ||\n      this.state.fetchMeta !== context.fetchOptions?.meta\n    ) {\n      this.#dispatch({ type: 'fetch', meta: context.fetchOptions?.meta })\n    }\n\n    const onError = (error: TError | { silent?: boolean }) => {\n      // Optimistically update state if needed\n      if (!(isCancelledError(error) && error.silent)) {\n        this.#dispatch({\n          type: 'error',\n          error: error as TError,\n        })\n      }\n\n      if (!isCancelledError(error)) {\n        // Notify cache callback\n        this.#cache.config.onError?.(\n          error as any,\n          this as Query<any, any, any, any>,\n        )\n        this.#cache.config.onSettled?.(\n          this.state.data,\n          error as any,\n          this as Query<any, any, any, any>,\n        )\n      }\n\n      // Schedule query gc after fetching\n      this.scheduleGc()\n    }\n\n    // Try to fetch the data\n    this.#retryer = createRetryer({\n      initialPromise: fetchOptions?.initialPromise as\n        | Promise<TData>\n        | undefined,\n      fn: context.fetchFn as () => Promise<TData>,\n      abort: abortController.abort.bind(abortController),\n      onSuccess: (data) => {\n        if (data === undefined) {\n          if (process.env.NODE_ENV !== 'production') {\n            console.error(\n              `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`,\n            )\n          }\n          onError(new Error(`${this.queryHash} data is undefined`) as any)\n          return\n        }\n\n        try {\n          this.setData(data)\n        } catch (error) {\n          onError(error as TError)\n          return\n        }\n\n        // Notify cache callback\n        this.#cache.config.onSuccess?.(data, this as Query<any, any, any, any>)\n        this.#cache.config.onSettled?.(\n          data,\n          this.state.error as any,\n          this as Query<any, any, any, any>,\n        )\n\n        // Schedule query gc after fetching\n        this.scheduleGc()\n      },\n      onError,\n      onFail: (failureCount, error) => {\n        this.#dispatch({ type: 'failed', failureCount, error })\n      },\n      onPause: () => {\n        this.#dispatch({ type: 'pause' })\n      },\n      onContinue: () => {\n        this.#dispatch({ type: 'continue' })\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode,\n      canRun: () => true,\n    })\n\n    return this.#retryer.start()\n  }\n\n  #dispatch(action: Action<TData, TError>): void {\n    const reducer = (\n      state: QueryState<TData, TError>,\n    ): QueryState<TData, TError> => {\n      switch (action.type) {\n        case 'failed':\n          return {\n            ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error,\n          }\n        case 'pause':\n          return {\n            ...state,\n            fetchStatus: 'paused',\n          }\n        case 'continue':\n          return {\n            ...state,\n            fetchStatus: 'fetching',\n          }\n        case 'fetch':\n          return {\n            ...state,\n            ...fetchState(state.data, this.options),\n            fetchMeta: action.meta ?? null,\n          }\n        case 'success':\n          // If fetching ends successfully, we don't need revertState as a fallback anymore.\n          this.#revertState = undefined\n          return {\n            ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: 'success',\n            ...(!action.manual && {\n              fetchStatus: 'idle',\n              fetchFailureCount: 0,\n              fetchFailureReason: null,\n            }),\n          }\n        case 'error':\n          const error = action.error\n\n          if (isCancelledError(error) && error.revert && this.#revertState) {\n            return { ...this.#revertState, fetchStatus: 'idle' }\n          }\n\n          return {\n            ...state,\n            error,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error,\n            fetchStatus: 'idle',\n            status: 'error',\n          }\n        case 'invalidate':\n          return {\n            ...state,\n            isInvalidated: true,\n          }\n        case 'setState':\n          return {\n            ...state,\n            ...action.state,\n          }\n      }\n    }\n\n    this.state = reducer(this.state)\n\n    notifyManager.batch(() => {\n      this.observers.forEach((observer) => {\n        observer.onQueryUpdate()\n      })\n\n      this.#cache.notify({ query: this, type: 'updated', action })\n    })\n  }\n}\n\nexport function fetchState<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey,\n>(\n  data: TData | undefined,\n  options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n) {\n  return {\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchStatus: canFetch(options.networkMode) ? 'fetching' : 'paused',\n    ...(data === undefined &&\n      ({\n        error: null,\n        status: 'pending',\n      } as const)),\n  } as const\n}\n\nfunction getDefaultState<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey,\n>(\n  options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): QueryState<TData, TError> {\n  const data =\n    typeof options.initialData === 'function'\n      ? (options.initialData as InitialDataFunction<TData>)()\n      : options.initialData\n\n  const hasData = data !== undefined\n\n  const initialDataUpdatedAt = hasData\n    ? typeof options.initialDataUpdatedAt === 'function'\n      ? (options.initialDataUpdatedAt as () => number | undefined)()\n      : options.initialDataUpdatedAt\n    : 0\n\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? (initialDataUpdatedAt ?? Date.now()) : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'pending',\n    fetchStatus: 'idle',\n  }\n}\n"],"mappings":"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","names":["queryFnContext","context","_a","_b","_c"]}
\ No newline at end of file
+{"version":3,"sources":["../../src/query.ts"],"sourcesContent":["import {\n  ensureQueryFn,\n  noop,\n  replaceData,\n  resolveEnabled,\n  resolveStaleTime,\n  skipToken,\n  timeUntilStale,\n} from './utils'\nimport { notifyManager } from './notifyManager'\nimport { canFetch, createRetryer, isCancelledError } from './retryer'\nimport { Removable } from './removable'\nimport type { QueryCache } from './queryCache'\nimport type { QueryClient } from './queryClient'\nimport type {\n  CancelOptions,\n  DefaultError,\n  FetchStatus,\n  InitialDataFunction,\n  OmitKeyof,\n  QueryFunctionContext,\n  QueryKey,\n  QueryMeta,\n  QueryOptions,\n  QueryStatus,\n  SetDataOptions,\n  StaleTime,\n} from './types'\nimport type { QueryObserver } from './queryObserver'\nimport type { Retryer } from './retryer'\n\n// TYPES\n\ninterface QueryConfig<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  client: QueryClient\n  queryKey: TQueryKey\n  queryHash: string\n  options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  state?: QueryState<TData, TError>\n}\n\nexport interface QueryState<TData = unknown, TError = DefaultError> {\n  data: TData | undefined\n  dataUpdateCount: number\n  dataUpdatedAt: number\n  error: TError | null\n  errorUpdateCount: number\n  errorUpdatedAt: number\n  fetchFailureCount: number\n  fetchFailureReason: TError | null\n  fetchMeta: FetchMeta | null\n  isInvalidated: boolean\n  status: QueryStatus\n  fetchStatus: FetchStatus\n}\n\nexport interface FetchContext<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  fetchFn: () => unknown | Promise<unknown>\n  fetchOptions?: FetchOptions\n  signal: AbortSignal\n  options: QueryOptions<TQueryFnData, TError, TData, any>\n  client: QueryClient\n  queryKey: TQueryKey\n  state: QueryState<TData, TError>\n}\n\nexport interface QueryBehavior<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  onFetch: (\n    context: FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n    query: Query,\n  ) => void\n}\n\nexport type FetchDirection = 'forward' | 'backward'\n\nexport interface FetchMeta {\n  fetchMore?: { direction: FetchDirection }\n}\n\nexport interface FetchOptions<TData = unknown> {\n  cancelRefetch?: boolean\n  meta?: FetchMeta\n  initialPromise?: Promise<TData>\n  updateMeta?: Record<string, unknown>\n}\n\ninterface FailedAction<TError> {\n  type: 'failed'\n  failureCount: number\n  error: TError\n}\n\ninterface FetchAction {\n  type: 'fetch'\n  meta?: FetchMeta\n}\n\ninterface SuccessAction<TData> {\n  data: TData | undefined\n  type: 'success'\n  dataUpdatedAt?: number\n  manual?: boolean\n}\n\ninterface ErrorAction<TError> {\n  type: 'error'\n  error: TError\n}\n\ninterface InvalidateAction {\n  type: 'invalidate'\n}\n\ninterface PauseAction {\n  type: 'pause'\n}\n\ninterface ContinueAction {\n  type: 'continue'\n}\n\ninterface SetStateAction<TData, TError> {\n  type: 'setState'\n  state: Partial<QueryState<TData, TError>>\n  setStateOptions?: SetStateOptions\n}\n\nexport type Action<TData, TError> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction<TError>\n  | FetchAction\n  | InvalidateAction\n  | PauseAction\n  | SetStateAction<TData, TError>\n  | SuccessAction<TData>\n\nexport interface SetStateOptions {\n  meta?: any\n}\n\n// CLASS\n\nexport class Query<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Removable {\n  queryKey: TQueryKey\n  queryHash: string\n  options!: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  state: QueryState<TData, TError>\n\n  #initialState: QueryState<TData, TError>\n  #revertState?: QueryState<TData, TError>\n  #cache: QueryCache\n  #client: QueryClient\n  #retryer?: Retryer<TData>\n  observers: Array<QueryObserver<any, any, any, any, any>>\n  #defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  #abortSignalConsumed: boolean\n\n  constructor(config: QueryConfig<TQueryFnData, TError, TData, TQueryKey>) {\n    super()\n\n    this.#abortSignalConsumed = false\n    this.#defaultOptions = config.defaultOptions\n    this.setOptions(config.options)\n    this.observers = []\n    this.#client = config.client\n    this.#cache = this.#client.getQueryCache()\n    this.queryKey = config.queryKey\n    this.queryHash = config.queryHash\n    this.#initialState = getDefaultState(this.options)\n    this.state = config.state ?? this.#initialState\n    this.scheduleGc()\n  }\n  get meta(): QueryMeta | undefined {\n    return this.options.meta\n  }\n\n  get promise(): Promise<TData> | undefined {\n    return this.#retryer?.promise\n  }\n\n  setOptions(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): void {\n    this.options = { ...this.#defaultOptions, ...options }\n\n    this.updateGcTime(this.options.gcTime)\n  }\n\n  protected optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === 'idle') {\n      this.#cache.remove(this)\n    }\n  }\n\n  setData(\n    newData: TData,\n    options?: SetDataOptions & { manual: boolean },\n  ): TData {\n    const data = replaceData(this.state.data, newData, this.options)\n\n    // Set data and mark it as cached\n    this.#dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options?.updatedAt,\n      manual: options?.manual,\n    })\n\n    return data\n  }\n\n  setState(\n    state: Partial<QueryState<TData, TError>>,\n    setStateOptions?: SetStateOptions,\n  ): void {\n    this.#dispatch({ type: 'setState', state, setStateOptions })\n  }\n\n  cancel(options?: CancelOptions): Promise<void> {\n    const promise = this.#retryer?.promise\n    this.#retryer?.cancel(options)\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve()\n  }\n\n  destroy(): void {\n    super.destroy()\n\n    this.cancel({ silent: true })\n  }\n\n  reset(): void {\n    this.destroy()\n    this.setState(this.#initialState)\n  }\n\n  isActive(): boolean {\n    return this.observers.some(\n      (observer) => resolveEnabled(observer.options.enabled, this) !== false,\n    )\n  }\n\n  isDisabled(): boolean {\n    if (this.getObserversCount() > 0) {\n      return !this.isActive()\n    }\n    // if a query has no observers, it should still be considered disabled if it never attempted a fetch\n    return (\n      this.options.queryFn === skipToken ||\n      this.state.dataUpdateCount + this.state.errorUpdateCount === 0\n    )\n  }\n\n  isStatic(): boolean {\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(\n        (observer) =>\n          resolveStaleTime(observer.options.staleTime, this) === 'static',\n      )\n    }\n\n    return false\n  }\n\n  isStale(): boolean {\n    // check observers first, their `isStale` has the source of truth\n    // calculated with `isStaleByTime` and it takes `enabled` into account\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(\n        (observer) => observer.getCurrentResult().isStale,\n      )\n    }\n\n    return this.state.data === undefined || this.state.isInvalidated\n  }\n\n  isStaleByTime(staleTime: StaleTime = 0): boolean {\n    // no data is always stale\n    if (this.state.data === undefined) {\n      return true\n    }\n    // static is never stale\n    if (staleTime === 'static') {\n      return false\n    }\n    // if the query is invalidated, it is stale\n    if (this.state.isInvalidated) {\n      return true\n    }\n\n    return !timeUntilStale(this.state.dataUpdatedAt, staleTime)\n  }\n\n  onFocus(): void {\n    const observer = this.observers.find((x) => x.shouldFetchOnWindowFocus())\n\n    observer?.refetch({ cancelRefetch: false })\n\n    // Continue fetch if currently paused\n    this.#retryer?.continue()\n  }\n\n  onOnline(): void {\n    const observer = this.observers.find((x) => x.shouldFetchOnReconnect())\n\n    observer?.refetch({ cancelRefetch: false })\n\n    // Continue fetch if currently paused\n    this.#retryer?.continue()\n  }\n\n  addObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer)\n\n      // Stop the query from being garbage collected\n      this.clearGcTimeout()\n\n      this.#cache.notify({ type: 'observerAdded', query: this, observer })\n    }\n  }\n\n  removeObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (this.observers.includes(observer)) {\n      this.observers = this.observers.filter((x) => x !== observer)\n\n      if (!this.observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.#retryer) {\n          if (this.#abortSignalConsumed) {\n            this.#retryer.cancel({ revert: true })\n          } else {\n            this.#retryer.cancelRetry()\n          }\n        }\n\n        this.scheduleGc()\n      }\n\n      this.#cache.notify({ type: 'observerRemoved', query: this, observer })\n    }\n  }\n\n  getObserversCount(): number {\n    return this.observers.length\n  }\n\n  invalidate(): void {\n    if (!this.state.isInvalidated) {\n      this.#dispatch({ type: 'invalidate' })\n    }\n  }\n\n  fetch(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    fetchOptions?: FetchOptions<TQueryFnData>,\n  ): Promise<TData> {\n    if (this.state.fetchStatus !== 'idle') {\n      if (this.state.data !== undefined && fetchOptions?.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetch\n        this.cancel({ silent: true })\n      } else if (this.#retryer) {\n        // make sure that retries that were potentially cancelled due to unmounts can continue\n        this.#retryer.continueRetry()\n        // Return current promise if we are already fetching\n        return this.#retryer.promise\n      }\n    }\n\n    // Update config if passed, otherwise the config from the last execution is used\n    if (options) {\n      this.setOptions(options)\n    }\n\n    // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n    if (!this.options.queryFn) {\n      const observer = this.observers.find((x) => x.options.queryFn)\n      if (observer) {\n        this.setOptions(observer.options)\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!Array.isArray(this.options.queryKey)) {\n        console.error(\n          `As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`,\n        )\n      }\n    }\n\n    const abortController = new AbortController()\n\n    // Adds an enumerable signal property to the object that\n    // which sets abortSignalConsumed to true when the signal\n    // is read.\n    const addSignalProperty = (object: unknown) => {\n      Object.defineProperty(object, 'signal', {\n        enumerable: true,\n        get: () => {\n          this.#abortSignalConsumed = true\n          return abortController.signal\n        },\n      })\n    }\n\n    // Create fetch function\n    const fetchFn = () => {\n      const queryFn = ensureQueryFn(this.options, fetchOptions)\n\n      // Create query function context\n      const createQueryFnContext = (): QueryFunctionContext<TQueryKey> => {\n        const queryFnContext: OmitKeyof<\n          QueryFunctionContext<TQueryKey>,\n          'signal'\n        > = {\n          client: this.#client,\n          queryKey: this.queryKey,\n          meta: fetchOptions?.updateMeta ? {...this.meta, ...fetchOptions.updateMeta } : this.meta,\n        }\n        addSignalProperty(queryFnContext)\n        return queryFnContext as QueryFunctionContext<TQueryKey>\n      }\n\n      const queryFnContext = createQueryFnContext()\n\n      this.#abortSignalConsumed = false\n      if (this.options.persister) {\n        return this.options.persister(\n          queryFn,\n          queryFnContext,\n          this as unknown as Query,\n        )\n      }\n\n      return queryFn(queryFnContext)\n    }\n\n    // Trigger behavior hook\n    const createFetchContext = (): FetchContext<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey\n    > => {\n      const context: OmitKeyof<\n        FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n        'signal'\n      > = {\n        fetchOptions,\n        options: this.options,\n        queryKey: this.queryKey,\n        client: this.#client,\n        state: this.state,\n        fetchFn,\n      }\n\n      addSignalProperty(context)\n      return context as FetchContext<TQueryFnData, TError, TData, TQueryKey>\n    }\n\n    const context = createFetchContext()\n\n    this.options.behavior?.onFetch(context, this as unknown as Query)\n\n    // Store state in case the current fetch needs to be reverted\n    this.#revertState = this.state\n\n    // Set to fetching state if not already in it\n    if (\n      this.state.fetchStatus === 'idle' ||\n      this.state.fetchMeta !== context.fetchOptions?.meta\n    ) {\n      this.#dispatch({ type: 'fetch', meta: context.fetchOptions?.meta })\n    }\n\n    const onError = (error: TError | { silent?: boolean }) => {\n      // Optimistically update state if needed\n      if (!(isCancelledError(error) && error.silent)) {\n        this.#dispatch({\n          type: 'error',\n          error: error as TError,\n        })\n      }\n\n      if (!isCancelledError(error)) {\n        // Notify cache callback\n        this.#cache.config.onError?.(\n          error as any,\n          this as Query<any, any, any, any>,\n        )\n        this.#cache.config.onSettled?.(\n          this.state.data,\n          error as any,\n          this as Query<any, any, any, any>,\n        )\n      }\n\n      // Schedule query gc after fetching\n      this.scheduleGc()\n    }\n\n    // Try to fetch the data\n    this.#retryer = createRetryer({\n      initialPromise: fetchOptions?.initialPromise as\n        | Promise<TData>\n        | undefined,\n      fn: context.fetchFn as () => Promise<TData>,\n      abort: abortController.abort.bind(abortController),\n      onSuccess: (data) => {\n        if (data === undefined) {\n          if (process.env.NODE_ENV !== 'production') {\n            console.error(\n              `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`,\n            )\n          }\n          onError(new Error(`${this.queryHash} data is undefined`) as any)\n          return\n        }\n\n        try {\n          this.setData(data)\n        } catch (error) {\n          onError(error as TError)\n          return\n        }\n\n        // Notify cache callback\n        this.#cache.config.onSuccess?.(data, this as Query<any, any, any, any>)\n        this.#cache.config.onSettled?.(\n          data,\n          this.state.error as any,\n          this as Query<any, any, any, any>,\n        )\n\n        // Schedule query gc after fetching\n        this.scheduleGc()\n      },\n      onError,\n      onFail: (failureCount, error) => {\n        this.#dispatch({ type: 'failed', failureCount, error })\n      },\n      onPause: () => {\n        this.#dispatch({ type: 'pause' })\n      },\n      onContinue: () => {\n        this.#dispatch({ type: 'continue' })\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode,\n      canRun: () => true,\n    })\n\n    return this.#retryer.start()\n  }\n\n  #dispatch(action: Action<TData, TError>): void {\n    const reducer = (\n      state: QueryState<TData, TError>,\n    ): QueryState<TData, TError> => {\n      switch (action.type) {\n        case 'failed':\n          return {\n            ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error,\n          }\n        case 'pause':\n          return {\n            ...state,\n            fetchStatus: 'paused',\n          }\n        case 'continue':\n          return {\n            ...state,\n            fetchStatus: 'fetching',\n          }\n        case 'fetch':\n          return {\n            ...state,\n            ...fetchState(state.data, this.options),\n            fetchMeta: action.meta ?? null,\n          }\n        case 'success':\n          // If fetching ends successfully, we don't need revertState as a fallback anymore.\n          this.#revertState = undefined\n          return {\n            ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: 'success',\n            ...(!action.manual && {\n              fetchStatus: 'idle',\n              fetchFailureCount: 0,\n              fetchFailureReason: null,\n            }),\n          }\n        case 'error':\n          const error = action.error\n\n          if (isCancelledError(error) && error.revert && this.#revertState) {\n            return { ...this.#revertState, fetchStatus: 'idle' }\n          }\n\n          return {\n            ...state,\n            error,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error,\n            fetchStatus: 'idle',\n            status: 'error',\n          }\n        case 'invalidate':\n          return {\n            ...state,\n            isInvalidated: true,\n          }\n        case 'setState':\n          return {\n            ...state,\n            ...action.state,\n          }\n      }\n    }\n\n    this.state = reducer(this.state)\n\n    notifyManager.batch(() => {\n      this.observers.forEach((observer) => {\n        observer.onQueryUpdate()\n      })\n\n      this.#cache.notify({ query: this, type: 'updated', action })\n    })\n  }\n}\n\nexport function fetchState<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey,\n>(\n  data: TData | undefined,\n  options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n) {\n  return {\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchStatus: canFetch(options.networkMode) ? 'fetching' : 'paused',\n    ...(data === undefined &&\n      ({\n        error: null,\n        status: 'pending',\n      } as const)),\n  } as const\n}\n\nfunction getDefaultState<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey,\n>(\n  options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): QueryState<TData, TError> {\n  const data =\n    typeof options.initialData === 'function'\n      ? (options.initialData as InitialDataFunction<TData>)()\n      : options.initialData\n\n  const hasData = data !== undefined\n\n  const initialDataUpdatedAt = hasData\n    ? typeof options.initialDataUpdatedAt === 'function'\n      ? (options.initialDataUpdatedAt as () => number | undefined)()\n      : options.initialDataUpdatedAt\n    : 0\n\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? (initialDataUpdatedAt ?? Date.now()) : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'pending',\n    fetchStatus: 'idle',\n  }\n}\n"],"mappings":"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","names":["queryFnContext","context","_a","_b","_c"]}
\ No newline at end of file
diff --git a/build/legacy/query.d.cts b/build/legacy/query.d.cts
index 7102ddc2ee879ad195bbc42a5738357fe2302ab5..a74691fc23490e48760c1c3ee2f4dde1b371291e 100644
--- a/build/legacy/query.d.cts
+++ b/build/legacy/query.d.cts
@@ -1,3 +1,3 @@
 import './removable.cjs';
-export { bf as Action, bb as FetchContext, bc as FetchDirection, bd as FetchMeta, be as FetchOptions, x as Query, ba as QueryBehavior, w as QueryState, bg as SetStateOptions, bh as fetchState } from './hydration-CdBkFt9i.cjs';
+export { bf as Action, bb as FetchContext, bc as FetchDirection, bd as FetchMeta, be as FetchOptions, x as Query, ba as QueryBehavior, w as QueryState, bg as SetStateOptions, bh as fetchState } from './hydration-Dv1t2VQO.cjs';
 import './subscribable.cjs';
diff --git a/build/legacy/query.d.ts b/build/legacy/query.d.ts
index 99185759a513502a7449346065d0a9f79e199e0e..7775da43ddaa6eccc111ba60c644a1fac1e21fef 100644
--- a/build/legacy/query.d.ts
+++ b/build/legacy/query.d.ts
@@ -1,3 +1,3 @@
 import './removable.js';
-export { bf as Action, bb as FetchContext, bc as FetchDirection, bd as FetchMeta, be as FetchOptions, x as Query, ba as QueryBehavior, w as QueryState, bg as SetStateOptions, bh as fetchState } from './hydration-Cr-4Kky1.js';
+export { bf as Action, bb as FetchContext, bc as FetchDirection, bd as FetchMeta, be as FetchOptions, x as Query, ba as QueryBehavior, w as QueryState, bg as SetStateOptions, bh as fetchState } from './hydration-Dwnp99qT.js';
 import './subscribable.js';
diff --git a/build/legacy/query.js b/build/legacy/query.js
index c1112895d24ce7e1eae0cbebc2bb213e0115e99a..7be5ca82522585c475f2ca7950d821dbb1ff1a63 100644
--- a/build/legacy/query.js
+++ b/build/legacy/query.js
@@ -209,7 +209,7 @@ var Query = class extends Removable {
         const queryFnContext2 = {
           client: __privateGet(this, _client),
           queryKey: this.queryKey,
-          meta: this.meta
+          meta: (fetchOptions == null ? void 0 : fetchOptions.updateMeta) ? { ...this.meta, ...fetchOptions.updateMeta } : this.meta
         };
         addSignalProperty(queryFnContext2);
         return queryFnContext2;
diff --git a/build/legacy/query.js.map b/build/legacy/query.js.map
index 08bcabc91fc2e0b472d768fb2aa52b7fc27cfd25..cf6f7c852b2c7ae294755a202348068e60642d3b 100644
--- a/build/legacy/query.js.map
+++ b/build/legacy/query.js.map
@@ -1 +1 @@
-{"version":3,"sources":["../../src/query.ts"],"sourcesContent":["import {\n  ensureQueryFn,\n  noop,\n  replaceData,\n  resolveEnabled,\n  resolveStaleTime,\n  skipToken,\n  timeUntilStale,\n} from './utils'\nimport { notifyManager } from './notifyManager'\nimport { canFetch, createRetryer, isCancelledError } from './retryer'\nimport { Removable } from './removable'\nimport type { QueryCache } from './queryCache'\nimport type { QueryClient } from './queryClient'\nimport type {\n  CancelOptions,\n  DefaultError,\n  FetchStatus,\n  InitialDataFunction,\n  OmitKeyof,\n  QueryFunctionContext,\n  QueryKey,\n  QueryMeta,\n  QueryOptions,\n  QueryStatus,\n  SetDataOptions,\n  StaleTime,\n} from './types'\nimport type { QueryObserver } from './queryObserver'\nimport type { Retryer } from './retryer'\n\n// TYPES\n\ninterface QueryConfig<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  client: QueryClient\n  queryKey: TQueryKey\n  queryHash: string\n  options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  state?: QueryState<TData, TError>\n}\n\nexport interface QueryState<TData = unknown, TError = DefaultError> {\n  data: TData | undefined\n  dataUpdateCount: number\n  dataUpdatedAt: number\n  error: TError | null\n  errorUpdateCount: number\n  errorUpdatedAt: number\n  fetchFailureCount: number\n  fetchFailureReason: TError | null\n  fetchMeta: FetchMeta | null\n  isInvalidated: boolean\n  status: QueryStatus\n  fetchStatus: FetchStatus\n}\n\nexport interface FetchContext<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  fetchFn: () => unknown | Promise<unknown>\n  fetchOptions?: FetchOptions\n  signal: AbortSignal\n  options: QueryOptions<TQueryFnData, TError, TData, any>\n  client: QueryClient\n  queryKey: TQueryKey\n  state: QueryState<TData, TError>\n}\n\nexport interface QueryBehavior<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  onFetch: (\n    context: FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n    query: Query,\n  ) => void\n}\n\nexport type FetchDirection = 'forward' | 'backward'\n\nexport interface FetchMeta {\n  fetchMore?: { direction: FetchDirection }\n}\n\nexport interface FetchOptions<TData = unknown> {\n  cancelRefetch?: boolean\n  meta?: FetchMeta\n  initialPromise?: Promise<TData>\n}\n\ninterface FailedAction<TError> {\n  type: 'failed'\n  failureCount: number\n  error: TError\n}\n\ninterface FetchAction {\n  type: 'fetch'\n  meta?: FetchMeta\n}\n\ninterface SuccessAction<TData> {\n  data: TData | undefined\n  type: 'success'\n  dataUpdatedAt?: number\n  manual?: boolean\n}\n\ninterface ErrorAction<TError> {\n  type: 'error'\n  error: TError\n}\n\ninterface InvalidateAction {\n  type: 'invalidate'\n}\n\ninterface PauseAction {\n  type: 'pause'\n}\n\ninterface ContinueAction {\n  type: 'continue'\n}\n\ninterface SetStateAction<TData, TError> {\n  type: 'setState'\n  state: Partial<QueryState<TData, TError>>\n  setStateOptions?: SetStateOptions\n}\n\nexport type Action<TData, TError> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction<TError>\n  | FetchAction\n  | InvalidateAction\n  | PauseAction\n  | SetStateAction<TData, TError>\n  | SuccessAction<TData>\n\nexport interface SetStateOptions {\n  meta?: any\n}\n\n// CLASS\n\nexport class Query<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Removable {\n  queryKey: TQueryKey\n  queryHash: string\n  options!: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  state: QueryState<TData, TError>\n\n  #initialState: QueryState<TData, TError>\n  #revertState?: QueryState<TData, TError>\n  #cache: QueryCache\n  #client: QueryClient\n  #retryer?: Retryer<TData>\n  observers: Array<QueryObserver<any, any, any, any, any>>\n  #defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  #abortSignalConsumed: boolean\n\n  constructor(config: QueryConfig<TQueryFnData, TError, TData, TQueryKey>) {\n    super()\n\n    this.#abortSignalConsumed = false\n    this.#defaultOptions = config.defaultOptions\n    this.setOptions(config.options)\n    this.observers = []\n    this.#client = config.client\n    this.#cache = this.#client.getQueryCache()\n    this.queryKey = config.queryKey\n    this.queryHash = config.queryHash\n    this.#initialState = getDefaultState(this.options)\n    this.state = config.state ?? this.#initialState\n    this.scheduleGc()\n  }\n  get meta(): QueryMeta | undefined {\n    return this.options.meta\n  }\n\n  get promise(): Promise<TData> | undefined {\n    return this.#retryer?.promise\n  }\n\n  setOptions(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): void {\n    this.options = { ...this.#defaultOptions, ...options }\n\n    this.updateGcTime(this.options.gcTime)\n  }\n\n  protected optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === 'idle') {\n      this.#cache.remove(this)\n    }\n  }\n\n  setData(\n    newData: TData,\n    options?: SetDataOptions & { manual: boolean },\n  ): TData {\n    const data = replaceData(this.state.data, newData, this.options)\n\n    // Set data and mark it as cached\n    this.#dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options?.updatedAt,\n      manual: options?.manual,\n    })\n\n    return data\n  }\n\n  setState(\n    state: Partial<QueryState<TData, TError>>,\n    setStateOptions?: SetStateOptions,\n  ): void {\n    this.#dispatch({ type: 'setState', state, setStateOptions })\n  }\n\n  cancel(options?: CancelOptions): Promise<void> {\n    const promise = this.#retryer?.promise\n    this.#retryer?.cancel(options)\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve()\n  }\n\n  destroy(): void {\n    super.destroy()\n\n    this.cancel({ silent: true })\n  }\n\n  reset(): void {\n    this.destroy()\n    this.setState(this.#initialState)\n  }\n\n  isActive(): boolean {\n    return this.observers.some(\n      (observer) => resolveEnabled(observer.options.enabled, this) !== false,\n    )\n  }\n\n  isDisabled(): boolean {\n    if (this.getObserversCount() > 0) {\n      return !this.isActive()\n    }\n    // if a query has no observers, it should still be considered disabled if it never attempted a fetch\n    return (\n      this.options.queryFn === skipToken ||\n      this.state.dataUpdateCount + this.state.errorUpdateCount === 0\n    )\n  }\n\n  isStatic(): boolean {\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(\n        (observer) =>\n          resolveStaleTime(observer.options.staleTime, this) === 'static',\n      )\n    }\n\n    return false\n  }\n\n  isStale(): boolean {\n    // check observers first, their `isStale` has the source of truth\n    // calculated with `isStaleByTime` and it takes `enabled` into account\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(\n        (observer) => observer.getCurrentResult().isStale,\n      )\n    }\n\n    return this.state.data === undefined || this.state.isInvalidated\n  }\n\n  isStaleByTime(staleTime: StaleTime = 0): boolean {\n    // no data is always stale\n    if (this.state.data === undefined) {\n      return true\n    }\n    // static is never stale\n    if (staleTime === 'static') {\n      return false\n    }\n    // if the query is invalidated, it is stale\n    if (this.state.isInvalidated) {\n      return true\n    }\n\n    return !timeUntilStale(this.state.dataUpdatedAt, staleTime)\n  }\n\n  onFocus(): void {\n    const observer = this.observers.find((x) => x.shouldFetchOnWindowFocus())\n\n    observer?.refetch({ cancelRefetch: false })\n\n    // Continue fetch if currently paused\n    this.#retryer?.continue()\n  }\n\n  onOnline(): void {\n    const observer = this.observers.find((x) => x.shouldFetchOnReconnect())\n\n    observer?.refetch({ cancelRefetch: false })\n\n    // Continue fetch if currently paused\n    this.#retryer?.continue()\n  }\n\n  addObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer)\n\n      // Stop the query from being garbage collected\n      this.clearGcTimeout()\n\n      this.#cache.notify({ type: 'observerAdded', query: this, observer })\n    }\n  }\n\n  removeObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (this.observers.includes(observer)) {\n      this.observers = this.observers.filter((x) => x !== observer)\n\n      if (!this.observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.#retryer) {\n          if (this.#abortSignalConsumed) {\n            this.#retryer.cancel({ revert: true })\n          } else {\n            this.#retryer.cancelRetry()\n          }\n        }\n\n        this.scheduleGc()\n      }\n\n      this.#cache.notify({ type: 'observerRemoved', query: this, observer })\n    }\n  }\n\n  getObserversCount(): number {\n    return this.observers.length\n  }\n\n  invalidate(): void {\n    if (!this.state.isInvalidated) {\n      this.#dispatch({ type: 'invalidate' })\n    }\n  }\n\n  fetch(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    fetchOptions?: FetchOptions<TQueryFnData>,\n  ): Promise<TData> {\n    if (this.state.fetchStatus !== 'idle') {\n      if (this.state.data !== undefined && fetchOptions?.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetch\n        this.cancel({ silent: true })\n      } else if (this.#retryer) {\n        // make sure that retries that were potentially cancelled due to unmounts can continue\n        this.#retryer.continueRetry()\n        // Return current promise if we are already fetching\n        return this.#retryer.promise\n      }\n    }\n\n    // Update config if passed, otherwise the config from the last execution is used\n    if (options) {\n      this.setOptions(options)\n    }\n\n    // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n    if (!this.options.queryFn) {\n      const observer = this.observers.find((x) => x.options.queryFn)\n      if (observer) {\n        this.setOptions(observer.options)\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!Array.isArray(this.options.queryKey)) {\n        console.error(\n          `As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`,\n        )\n      }\n    }\n\n    const abortController = new AbortController()\n\n    // Adds an enumerable signal property to the object that\n    // which sets abortSignalConsumed to true when the signal\n    // is read.\n    const addSignalProperty = (object: unknown) => {\n      Object.defineProperty(object, 'signal', {\n        enumerable: true,\n        get: () => {\n          this.#abortSignalConsumed = true\n          return abortController.signal\n        },\n      })\n    }\n\n    // Create fetch function\n    const fetchFn = () => {\n      const queryFn = ensureQueryFn(this.options, fetchOptions)\n\n      // Create query function context\n      const createQueryFnContext = (): QueryFunctionContext<TQueryKey> => {\n        const queryFnContext: OmitKeyof<\n          QueryFunctionContext<TQueryKey>,\n          'signal'\n        > = {\n          client: this.#client,\n          queryKey: this.queryKey,\n          meta: this.meta,\n        }\n        addSignalProperty(queryFnContext)\n        return queryFnContext as QueryFunctionContext<TQueryKey>\n      }\n\n      const queryFnContext = createQueryFnContext()\n\n      this.#abortSignalConsumed = false\n      if (this.options.persister) {\n        return this.options.persister(\n          queryFn,\n          queryFnContext,\n          this as unknown as Query,\n        )\n      }\n\n      return queryFn(queryFnContext)\n    }\n\n    // Trigger behavior hook\n    const createFetchContext = (): FetchContext<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey\n    > => {\n      const context: OmitKeyof<\n        FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n        'signal'\n      > = {\n        fetchOptions,\n        options: this.options,\n        queryKey: this.queryKey,\n        client: this.#client,\n        state: this.state,\n        fetchFn,\n      }\n\n      addSignalProperty(context)\n      return context as FetchContext<TQueryFnData, TError, TData, TQueryKey>\n    }\n\n    const context = createFetchContext()\n\n    this.options.behavior?.onFetch(context, this as unknown as Query)\n\n    // Store state in case the current fetch needs to be reverted\n    this.#revertState = this.state\n\n    // Set to fetching state if not already in it\n    if (\n      this.state.fetchStatus === 'idle' ||\n      this.state.fetchMeta !== context.fetchOptions?.meta\n    ) {\n      this.#dispatch({ type: 'fetch', meta: context.fetchOptions?.meta })\n    }\n\n    const onError = (error: TError | { silent?: boolean }) => {\n      // Optimistically update state if needed\n      if (!(isCancelledError(error) && error.silent)) {\n        this.#dispatch({\n          type: 'error',\n          error: error as TError,\n        })\n      }\n\n      if (!isCancelledError(error)) {\n        // Notify cache callback\n        this.#cache.config.onError?.(\n          error as any,\n          this as Query<any, any, any, any>,\n        )\n        this.#cache.config.onSettled?.(\n          this.state.data,\n          error as any,\n          this as Query<any, any, any, any>,\n        )\n      }\n\n      // Schedule query gc after fetching\n      this.scheduleGc()\n    }\n\n    // Try to fetch the data\n    this.#retryer = createRetryer({\n      initialPromise: fetchOptions?.initialPromise as\n        | Promise<TData>\n        | undefined,\n      fn: context.fetchFn as () => Promise<TData>,\n      abort: abortController.abort.bind(abortController),\n      onSuccess: (data) => {\n        if (data === undefined) {\n          if (process.env.NODE_ENV !== 'production') {\n            console.error(\n              `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`,\n            )\n          }\n          onError(new Error(`${this.queryHash} data is undefined`) as any)\n          return\n        }\n\n        try {\n          this.setData(data)\n        } catch (error) {\n          onError(error as TError)\n          return\n        }\n\n        // Notify cache callback\n        this.#cache.config.onSuccess?.(data, this as Query<any, any, any, any>)\n        this.#cache.config.onSettled?.(\n          data,\n          this.state.error as any,\n          this as Query<any, any, any, any>,\n        )\n\n        // Schedule query gc after fetching\n        this.scheduleGc()\n      },\n      onError,\n      onFail: (failureCount, error) => {\n        this.#dispatch({ type: 'failed', failureCount, error })\n      },\n      onPause: () => {\n        this.#dispatch({ type: 'pause' })\n      },\n      onContinue: () => {\n        this.#dispatch({ type: 'continue' })\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode,\n      canRun: () => true,\n    })\n\n    return this.#retryer.start()\n  }\n\n  #dispatch(action: Action<TData, TError>): void {\n    const reducer = (\n      state: QueryState<TData, TError>,\n    ): QueryState<TData, TError> => {\n      switch (action.type) {\n        case 'failed':\n          return {\n            ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error,\n          }\n        case 'pause':\n          return {\n            ...state,\n            fetchStatus: 'paused',\n          }\n        case 'continue':\n          return {\n            ...state,\n            fetchStatus: 'fetching',\n          }\n        case 'fetch':\n          return {\n            ...state,\n            ...fetchState(state.data, this.options),\n            fetchMeta: action.meta ?? null,\n          }\n        case 'success':\n          // If fetching ends successfully, we don't need revertState as a fallback anymore.\n          this.#revertState = undefined\n          return {\n            ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: 'success',\n            ...(!action.manual && {\n              fetchStatus: 'idle',\n              fetchFailureCount: 0,\n              fetchFailureReason: null,\n            }),\n          }\n        case 'error':\n          const error = action.error\n\n          if (isCancelledError(error) && error.revert && this.#revertState) {\n            return { ...this.#revertState, fetchStatus: 'idle' }\n          }\n\n          return {\n            ...state,\n            error,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error,\n            fetchStatus: 'idle',\n            status: 'error',\n          }\n        case 'invalidate':\n          return {\n            ...state,\n            isInvalidated: true,\n          }\n        case 'setState':\n          return {\n            ...state,\n            ...action.state,\n          }\n      }\n    }\n\n    this.state = reducer(this.state)\n\n    notifyManager.batch(() => {\n      this.observers.forEach((observer) => {\n        observer.onQueryUpdate()\n      })\n\n      this.#cache.notify({ query: this, type: 'updated', action })\n    })\n  }\n}\n\nexport function fetchState<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey,\n>(\n  data: TData | undefined,\n  options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n) {\n  return {\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchStatus: canFetch(options.networkMode) ? 'fetching' : 'paused',\n    ...(data === undefined &&\n      ({\n        error: null,\n        status: 'pending',\n      } as const)),\n  } as const\n}\n\nfunction getDefaultState<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey,\n>(\n  options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): QueryState<TData, TError> {\n  const data =\n    typeof options.initialData === 'function'\n      ? (options.initialData as InitialDataFunction<TData>)()\n      : options.initialData\n\n  const hasData = data !== undefined\n\n  const initialDataUpdatedAt = hasData\n    ? typeof options.initialDataUpdatedAt === 'function'\n      ? (options.initialDataUpdatedAt as () => number | undefined)()\n      : options.initialDataUpdatedAt\n    : 0\n\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? (initialDataUpdatedAt ?? Date.now()) : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'pending',\n    fetchStatus: 'idle',\n  }\n}\n"],"mappings":"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","names":["queryFnContext","context","_a","_b","_c"]}
\ No newline at end of file
+{"version":3,"sources":["../../src/query.ts"],"sourcesContent":["import {\n  ensureQueryFn,\n  noop,\n  replaceData,\n  resolveEnabled,\n  resolveStaleTime,\n  skipToken,\n  timeUntilStale,\n} from './utils'\nimport { notifyManager } from './notifyManager'\nimport { canFetch, createRetryer, isCancelledError } from './retryer'\nimport { Removable } from './removable'\nimport type { QueryCache } from './queryCache'\nimport type { QueryClient } from './queryClient'\nimport type {\n  CancelOptions,\n  DefaultError,\n  FetchStatus,\n  InitialDataFunction,\n  OmitKeyof,\n  QueryFunctionContext,\n  QueryKey,\n  QueryMeta,\n  QueryOptions,\n  QueryStatus,\n  SetDataOptions,\n  StaleTime,\n} from './types'\nimport type { QueryObserver } from './queryObserver'\nimport type { Retryer } from './retryer'\n\n// TYPES\n\ninterface QueryConfig<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  client: QueryClient\n  queryKey: TQueryKey\n  queryHash: string\n  options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  state?: QueryState<TData, TError>\n}\n\nexport interface QueryState<TData = unknown, TError = DefaultError> {\n  data: TData | undefined\n  dataUpdateCount: number\n  dataUpdatedAt: number\n  error: TError | null\n  errorUpdateCount: number\n  errorUpdatedAt: number\n  fetchFailureCount: number\n  fetchFailureReason: TError | null\n  fetchMeta: FetchMeta | null\n  isInvalidated: boolean\n  status: QueryStatus\n  fetchStatus: FetchStatus\n}\n\nexport interface FetchContext<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  fetchFn: () => unknown | Promise<unknown>\n  fetchOptions?: FetchOptions\n  signal: AbortSignal\n  options: QueryOptions<TQueryFnData, TError, TData, any>\n  client: QueryClient\n  queryKey: TQueryKey\n  state: QueryState<TData, TError>\n}\n\nexport interface QueryBehavior<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  onFetch: (\n    context: FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n    query: Query,\n  ) => void\n}\n\nexport type FetchDirection = 'forward' | 'backward'\n\nexport interface FetchMeta {\n  fetchMore?: { direction: FetchDirection }\n}\n\nexport interface FetchOptions<TData = unknown> {\n  cancelRefetch?: boolean\n  meta?: FetchMeta\n  initialPromise?: Promise<TData>\n  updateMeta?: Record<string, unknown>\n}\n\ninterface FailedAction<TError> {\n  type: 'failed'\n  failureCount: number\n  error: TError\n}\n\ninterface FetchAction {\n  type: 'fetch'\n  meta?: FetchMeta\n}\n\ninterface SuccessAction<TData> {\n  data: TData | undefined\n  type: 'success'\n  dataUpdatedAt?: number\n  manual?: boolean\n}\n\ninterface ErrorAction<TError> {\n  type: 'error'\n  error: TError\n}\n\ninterface InvalidateAction {\n  type: 'invalidate'\n}\n\ninterface PauseAction {\n  type: 'pause'\n}\n\ninterface ContinueAction {\n  type: 'continue'\n}\n\ninterface SetStateAction<TData, TError> {\n  type: 'setState'\n  state: Partial<QueryState<TData, TError>>\n  setStateOptions?: SetStateOptions\n}\n\nexport type Action<TData, TError> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction<TError>\n  | FetchAction\n  | InvalidateAction\n  | PauseAction\n  | SetStateAction<TData, TError>\n  | SuccessAction<TData>\n\nexport interface SetStateOptions {\n  meta?: any\n}\n\n// CLASS\n\nexport class Query<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Removable {\n  queryKey: TQueryKey\n  queryHash: string\n  options!: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  state: QueryState<TData, TError>\n\n  #initialState: QueryState<TData, TError>\n  #revertState?: QueryState<TData, TError>\n  #cache: QueryCache\n  #client: QueryClient\n  #retryer?: Retryer<TData>\n  observers: Array<QueryObserver<any, any, any, any, any>>\n  #defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  #abortSignalConsumed: boolean\n\n  constructor(config: QueryConfig<TQueryFnData, TError, TData, TQueryKey>) {\n    super()\n\n    this.#abortSignalConsumed = false\n    this.#defaultOptions = config.defaultOptions\n    this.setOptions(config.options)\n    this.observers = []\n    this.#client = config.client\n    this.#cache = this.#client.getQueryCache()\n    this.queryKey = config.queryKey\n    this.queryHash = config.queryHash\n    this.#initialState = getDefaultState(this.options)\n    this.state = config.state ?? this.#initialState\n    this.scheduleGc()\n  }\n  get meta(): QueryMeta | undefined {\n    return this.options.meta\n  }\n\n  get promise(): Promise<TData> | undefined {\n    return this.#retryer?.promise\n  }\n\n  setOptions(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): void {\n    this.options = { ...this.#defaultOptions, ...options }\n\n    this.updateGcTime(this.options.gcTime)\n  }\n\n  protected optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === 'idle') {\n      this.#cache.remove(this)\n    }\n  }\n\n  setData(\n    newData: TData,\n    options?: SetDataOptions & { manual: boolean },\n  ): TData {\n    const data = replaceData(this.state.data, newData, this.options)\n\n    // Set data and mark it as cached\n    this.#dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options?.updatedAt,\n      manual: options?.manual,\n    })\n\n    return data\n  }\n\n  setState(\n    state: Partial<QueryState<TData, TError>>,\n    setStateOptions?: SetStateOptions,\n  ): void {\n    this.#dispatch({ type: 'setState', state, setStateOptions })\n  }\n\n  cancel(options?: CancelOptions): Promise<void> {\n    const promise = this.#retryer?.promise\n    this.#retryer?.cancel(options)\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve()\n  }\n\n  destroy(): void {\n    super.destroy()\n\n    this.cancel({ silent: true })\n  }\n\n  reset(): void {\n    this.destroy()\n    this.setState(this.#initialState)\n  }\n\n  isActive(): boolean {\n    return this.observers.some(\n      (observer) => resolveEnabled(observer.options.enabled, this) !== false,\n    )\n  }\n\n  isDisabled(): boolean {\n    if (this.getObserversCount() > 0) {\n      return !this.isActive()\n    }\n    // if a query has no observers, it should still be considered disabled if it never attempted a fetch\n    return (\n      this.options.queryFn === skipToken ||\n      this.state.dataUpdateCount + this.state.errorUpdateCount === 0\n    )\n  }\n\n  isStatic(): boolean {\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(\n        (observer) =>\n          resolveStaleTime(observer.options.staleTime, this) === 'static',\n      )\n    }\n\n    return false\n  }\n\n  isStale(): boolean {\n    // check observers first, their `isStale` has the source of truth\n    // calculated with `isStaleByTime` and it takes `enabled` into account\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(\n        (observer) => observer.getCurrentResult().isStale,\n      )\n    }\n\n    return this.state.data === undefined || this.state.isInvalidated\n  }\n\n  isStaleByTime(staleTime: StaleTime = 0): boolean {\n    // no data is always stale\n    if (this.state.data === undefined) {\n      return true\n    }\n    // static is never stale\n    if (staleTime === 'static') {\n      return false\n    }\n    // if the query is invalidated, it is stale\n    if (this.state.isInvalidated) {\n      return true\n    }\n\n    return !timeUntilStale(this.state.dataUpdatedAt, staleTime)\n  }\n\n  onFocus(): void {\n    const observer = this.observers.find((x) => x.shouldFetchOnWindowFocus())\n\n    observer?.refetch({ cancelRefetch: false })\n\n    // Continue fetch if currently paused\n    this.#retryer?.continue()\n  }\n\n  onOnline(): void {\n    const observer = this.observers.find((x) => x.shouldFetchOnReconnect())\n\n    observer?.refetch({ cancelRefetch: false })\n\n    // Continue fetch if currently paused\n    this.#retryer?.continue()\n  }\n\n  addObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer)\n\n      // Stop the query from being garbage collected\n      this.clearGcTimeout()\n\n      this.#cache.notify({ type: 'observerAdded', query: this, observer })\n    }\n  }\n\n  removeObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (this.observers.includes(observer)) {\n      this.observers = this.observers.filter((x) => x !== observer)\n\n      if (!this.observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.#retryer) {\n          if (this.#abortSignalConsumed) {\n            this.#retryer.cancel({ revert: true })\n          } else {\n            this.#retryer.cancelRetry()\n          }\n        }\n\n        this.scheduleGc()\n      }\n\n      this.#cache.notify({ type: 'observerRemoved', query: this, observer })\n    }\n  }\n\n  getObserversCount(): number {\n    return this.observers.length\n  }\n\n  invalidate(): void {\n    if (!this.state.isInvalidated) {\n      this.#dispatch({ type: 'invalidate' })\n    }\n  }\n\n  fetch(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    fetchOptions?: FetchOptions<TQueryFnData>,\n  ): Promise<TData> {\n    if (this.state.fetchStatus !== 'idle') {\n      if (this.state.data !== undefined && fetchOptions?.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetch\n        this.cancel({ silent: true })\n      } else if (this.#retryer) {\n        // make sure that retries that were potentially cancelled due to unmounts can continue\n        this.#retryer.continueRetry()\n        // Return current promise if we are already fetching\n        return this.#retryer.promise\n      }\n    }\n\n    // Update config if passed, otherwise the config from the last execution is used\n    if (options) {\n      this.setOptions(options)\n    }\n\n    // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n    if (!this.options.queryFn) {\n      const observer = this.observers.find((x) => x.options.queryFn)\n      if (observer) {\n        this.setOptions(observer.options)\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!Array.isArray(this.options.queryKey)) {\n        console.error(\n          `As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`,\n        )\n      }\n    }\n\n    const abortController = new AbortController()\n\n    // Adds an enumerable signal property to the object that\n    // which sets abortSignalConsumed to true when the signal\n    // is read.\n    const addSignalProperty = (object: unknown) => {\n      Object.defineProperty(object, 'signal', {\n        enumerable: true,\n        get: () => {\n          this.#abortSignalConsumed = true\n          return abortController.signal\n        },\n      })\n    }\n\n    // Create fetch function\n    const fetchFn = () => {\n      const queryFn = ensureQueryFn(this.options, fetchOptions)\n\n      // Create query function context\n      const createQueryFnContext = (): QueryFunctionContext<TQueryKey> => {\n        const queryFnContext: OmitKeyof<\n          QueryFunctionContext<TQueryKey>,\n          'signal'\n        > = {\n          client: this.#client,\n          queryKey: this.queryKey,\n          meta: fetchOptions?.updateMeta ? {...this.meta, ...fetchOptions.updateMeta } : this.meta,\n        }\n        addSignalProperty(queryFnContext)\n        return queryFnContext as QueryFunctionContext<TQueryKey>\n      }\n\n      const queryFnContext = createQueryFnContext()\n\n      this.#abortSignalConsumed = false\n      if (this.options.persister) {\n        return this.options.persister(\n          queryFn,\n          queryFnContext,\n          this as unknown as Query,\n        )\n      }\n\n      return queryFn(queryFnContext)\n    }\n\n    // Trigger behavior hook\n    const createFetchContext = (): FetchContext<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey\n    > => {\n      const context: OmitKeyof<\n        FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n        'signal'\n      > = {\n        fetchOptions,\n        options: this.options,\n        queryKey: this.queryKey,\n        client: this.#client,\n        state: this.state,\n        fetchFn,\n      }\n\n      addSignalProperty(context)\n      return context as FetchContext<TQueryFnData, TError, TData, TQueryKey>\n    }\n\n    const context = createFetchContext()\n\n    this.options.behavior?.onFetch(context, this as unknown as Query)\n\n    // Store state in case the current fetch needs to be reverted\n    this.#revertState = this.state\n\n    // Set to fetching state if not already in it\n    if (\n      this.state.fetchStatus === 'idle' ||\n      this.state.fetchMeta !== context.fetchOptions?.meta\n    ) {\n      this.#dispatch({ type: 'fetch', meta: context.fetchOptions?.meta })\n    }\n\n    const onError = (error: TError | { silent?: boolean }) => {\n      // Optimistically update state if needed\n      if (!(isCancelledError(error) && error.silent)) {\n        this.#dispatch({\n          type: 'error',\n          error: error as TError,\n        })\n      }\n\n      if (!isCancelledError(error)) {\n        // Notify cache callback\n        this.#cache.config.onError?.(\n          error as any,\n          this as Query<any, any, any, any>,\n        )\n        this.#cache.config.onSettled?.(\n          this.state.data,\n          error as any,\n          this as Query<any, any, any, any>,\n        )\n      }\n\n      // Schedule query gc after fetching\n      this.scheduleGc()\n    }\n\n    // Try to fetch the data\n    this.#retryer = createRetryer({\n      initialPromise: fetchOptions?.initialPromise as\n        | Promise<TData>\n        | undefined,\n      fn: context.fetchFn as () => Promise<TData>,\n      abort: abortController.abort.bind(abortController),\n      onSuccess: (data) => {\n        if (data === undefined) {\n          if (process.env.NODE_ENV !== 'production') {\n            console.error(\n              `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`,\n            )\n          }\n          onError(new Error(`${this.queryHash} data is undefined`) as any)\n          return\n        }\n\n        try {\n          this.setData(data)\n        } catch (error) {\n          onError(error as TError)\n          return\n        }\n\n        // Notify cache callback\n        this.#cache.config.onSuccess?.(data, this as Query<any, any, any, any>)\n        this.#cache.config.onSettled?.(\n          data,\n          this.state.error as any,\n          this as Query<any, any, any, any>,\n        )\n\n        // Schedule query gc after fetching\n        this.scheduleGc()\n      },\n      onError,\n      onFail: (failureCount, error) => {\n        this.#dispatch({ type: 'failed', failureCount, error })\n      },\n      onPause: () => {\n        this.#dispatch({ type: 'pause' })\n      },\n      onContinue: () => {\n        this.#dispatch({ type: 'continue' })\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode,\n      canRun: () => true,\n    })\n\n    return this.#retryer.start()\n  }\n\n  #dispatch(action: Action<TData, TError>): void {\n    const reducer = (\n      state: QueryState<TData, TError>,\n    ): QueryState<TData, TError> => {\n      switch (action.type) {\n        case 'failed':\n          return {\n            ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error,\n          }\n        case 'pause':\n          return {\n            ...state,\n            fetchStatus: 'paused',\n          }\n        case 'continue':\n          return {\n            ...state,\n            fetchStatus: 'fetching',\n          }\n        case 'fetch':\n          return {\n            ...state,\n            ...fetchState(state.data, this.options),\n            fetchMeta: action.meta ?? null,\n          }\n        case 'success':\n          // If fetching ends successfully, we don't need revertState as a fallback anymore.\n          this.#revertState = undefined\n          return {\n            ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: 'success',\n            ...(!action.manual && {\n              fetchStatus: 'idle',\n              fetchFailureCount: 0,\n              fetchFailureReason: null,\n            }),\n          }\n        case 'error':\n          const error = action.error\n\n          if (isCancelledError(error) && error.revert && this.#revertState) {\n            return { ...this.#revertState, fetchStatus: 'idle' }\n          }\n\n          return {\n            ...state,\n            error,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error,\n            fetchStatus: 'idle',\n            status: 'error',\n          }\n        case 'invalidate':\n          return {\n            ...state,\n            isInvalidated: true,\n          }\n        case 'setState':\n          return {\n            ...state,\n            ...action.state,\n          }\n      }\n    }\n\n    this.state = reducer(this.state)\n\n    notifyManager.batch(() => {\n      this.observers.forEach((observer) => {\n        observer.onQueryUpdate()\n      })\n\n      this.#cache.notify({ query: this, type: 'updated', action })\n    })\n  }\n}\n\nexport function fetchState<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey,\n>(\n  data: TData | undefined,\n  options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n) {\n  return {\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchStatus: canFetch(options.networkMode) ? 'fetching' : 'paused',\n    ...(data === undefined &&\n      ({\n        error: null,\n        status: 'pending',\n      } as const)),\n  } as const\n}\n\nfunction getDefaultState<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey,\n>(\n  options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): QueryState<TData, TError> {\n  const data =\n    typeof options.initialData === 'function'\n      ? (options.initialData as InitialDataFunction<TData>)()\n      : options.initialData\n\n  const hasData = data !== undefined\n\n  const initialDataUpdatedAt = hasData\n    ? typeof options.initialDataUpdatedAt === 'function'\n      ? (options.initialDataUpdatedAt as () => number | undefined)()\n      : options.initialDataUpdatedAt\n    : 0\n\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? (initialDataUpdatedAt ?? Date.now()) : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'pending',\n    fetchStatus: 'idle',\n  }\n}\n"],"mappings":"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","names":["queryFnContext","context","_a","_b","_c"]}
\ No newline at end of file
diff --git a/build/legacy/queryCache.d.cts b/build/legacy/queryCache.d.cts
index 823298712f10fa64a988313a0a4630cc4ac81ab0..a2fa0d9259fba8f56225bdc614a39139fca49461 100644
--- a/build/legacy/queryCache.d.cts
+++ b/build/legacy/queryCache.d.cts
@@ -1,3 +1,3 @@
-export { Q as QueryCache, a as QueryCacheNotifyEvent, bz as QueryStore } from './hydration-CdBkFt9i.cjs';
+export { Q as QueryCache, a as QueryCacheNotifyEvent, bz as QueryStore } from './hydration-Dv1t2VQO.cjs';
 import './subscribable.cjs';
 import './removable.cjs';
diff --git a/build/legacy/queryCache.d.ts b/build/legacy/queryCache.d.ts
index 58f890ba020958c8a681915aad77562995b2f1b6..1a160be96bc664ed52603abea62242f46b83c1e2 100644
--- a/build/legacy/queryCache.d.ts
+++ b/build/legacy/queryCache.d.ts
@@ -1,3 +1,3 @@
-export { Q as QueryCache, a as QueryCacheNotifyEvent, bz as QueryStore } from './hydration-Cr-4Kky1.js';
+export { Q as QueryCache, a as QueryCacheNotifyEvent, bz as QueryStore } from './hydration-Dwnp99qT.js';
 import './subscribable.js';
 import './removable.js';
diff --git a/build/legacy/queryClient.d.cts b/build/legacy/queryClient.d.cts
index c84587345211e4493170f348049ef7e1ae3ad5b8..d830a1e8c688a0bd3dd86e2fb28f5bdb99b2ec23 100644
--- a/build/legacy/queryClient.d.cts
+++ b/build/legacy/queryClient.d.cts
@@ -1,3 +1,3 @@
-export { b as QueryClient } from './hydration-CdBkFt9i.cjs';
+export { b as QueryClient } from './hydration-Dv1t2VQO.cjs';
 import './removable.cjs';
 import './subscribable.cjs';
diff --git a/build/legacy/queryClient.d.ts b/build/legacy/queryClient.d.ts
index 29d11e06d176d3092342d06a929723fb8c80f1cf..a5043b5e12b0dc379f20fb3e8d68a3ac4dccc264 100644
--- a/build/legacy/queryClient.d.ts
+++ b/build/legacy/queryClient.d.ts
@@ -1,3 +1,3 @@
-export { b as QueryClient } from './hydration-Cr-4Kky1.js';
+export { b as QueryClient } from './hydration-Dwnp99qT.js';
 import './removable.js';
 import './subscribable.js';
diff --git a/build/legacy/queryObserver.d.cts b/build/legacy/queryObserver.d.cts
index 6a958249d002d99525971fbf1dd57919bc4e3dfa..978b4385cf6939a0899f68614d57fa54df04d964 100644
--- a/build/legacy/queryObserver.d.cts
+++ b/build/legacy/queryObserver.d.cts
@@ -1,3 +1,3 @@
 import './subscribable.cjs';
-export { c as QueryObserver } from './hydration-CdBkFt9i.cjs';
+export { c as QueryObserver } from './hydration-Dv1t2VQO.cjs';
 import './removable.cjs';
diff --git a/build/legacy/queryObserver.d.ts b/build/legacy/queryObserver.d.ts
index 00215003b69f69df7eae0814fdf6380fc021ed4e..7999c5d235a0b731642c88b58ef247650f5767c1 100644
--- a/build/legacy/queryObserver.d.ts
+++ b/build/legacy/queryObserver.d.ts
@@ -1,3 +1,3 @@
 import './subscribable.js';
-export { c as QueryObserver } from './hydration-Cr-4Kky1.js';
+export { c as QueryObserver } from './hydration-Dwnp99qT.js';
 import './removable.js';
diff --git a/build/legacy/retryer.d.cts b/build/legacy/retryer.d.cts
index bf1c56ede4f0807fbd0f7ca6e3f148dc50206c6e..0582d235973f50c2dc89e14a138640d7a0787ead 100644
--- a/build/legacy/retryer.d.cts
+++ b/build/legacy/retryer.d.cts
@@ -1,3 +1,3 @@
-export { C as CancelledError, bC as RetryDelayValue, bB as RetryValue, bA as Retryer, bD as canFetch, bE as createRetryer, o as isCancelledError } from './hydration-CdBkFt9i.cjs';
+export { C as CancelledError, bC as RetryDelayValue, bB as RetryValue, bA as Retryer, bD as canFetch, bE as createRetryer, o as isCancelledError } from './hydration-Dv1t2VQO.cjs';
 import './removable.cjs';
 import './subscribable.cjs';
diff --git a/build/legacy/retryer.d.ts b/build/legacy/retryer.d.ts
index 93331066282045b745031a331a2393332186f0f0..a670219d8a6c98808ed82f311f6e5052ccd4c076 100644
--- a/build/legacy/retryer.d.ts
+++ b/build/legacy/retryer.d.ts
@@ -1,3 +1,3 @@
-export { C as CancelledError, bC as RetryDelayValue, bB as RetryValue, bA as Retryer, bD as canFetch, bE as createRetryer, o as isCancelledError } from './hydration-Cr-4Kky1.js';
+export { C as CancelledError, bC as RetryDelayValue, bB as RetryValue, bA as Retryer, bD as canFetch, bE as createRetryer, o as isCancelledError } from './hydration-Dwnp99qT.js';
 import './removable.js';
 import './subscribable.js';
diff --git a/build/legacy/streamedQuery.d.cts b/build/legacy/streamedQuery.d.cts
index cfd2a5264343d8714671ed59b73614331896224b..58cfa5ad3a910519f1c7d2095f5432ae943ab58a 100644
--- a/build/legacy/streamedQuery.d.cts
+++ b/build/legacy/streamedQuery.d.cts
@@ -1,4 +1,4 @@
-import { I as QueryKey, a1 as QueryFunctionContext, Y as QueryFunction } from './hydration-CdBkFt9i.cjs';
+import { I as QueryKey, a1 as QueryFunctionContext, Y as QueryFunction } from './hydration-Dv1t2VQO.cjs';
 import './removable.cjs';
 import './subscribable.cjs';
 
diff --git a/build/legacy/streamedQuery.d.ts b/build/legacy/streamedQuery.d.ts
index 9eeb1770117c52d30d047778aa4cac4bbacefe23..e9329415b81976c730b401b3194d775b55f5ba79 100644
--- a/build/legacy/streamedQuery.d.ts
+++ b/build/legacy/streamedQuery.d.ts
@@ -1,4 +1,4 @@
-import { I as QueryKey, a1 as QueryFunctionContext, Y as QueryFunction } from './hydration-Cr-4Kky1.js';
+import { I as QueryKey, a1 as QueryFunctionContext, Y as QueryFunction } from './hydration-Dwnp99qT.js';
 import './removable.js';
 import './subscribable.js';
 
diff --git a/build/legacy/types.cjs.map b/build/legacy/types.cjs.map
index 3490d3eba61a49729da77d8b6e41a4bf38406275..f2378602a3e9473e47fc9a27d19d502382d03535 100644
--- a/build/legacy/types.cjs.map
+++ b/build/legacy/types.cjs.map
@@ -1 +1 @@
-{"version":3,"sources":["../../src/types.ts"],"sourcesContent":["/* istanbul ignore file */\n\nimport type { QueryClient } from './queryClient'\nimport type { DehydrateOptions, HydrateOptions } from './hydration'\nimport type { MutationState } from './mutation'\nimport type { FetchDirection, Query, QueryBehavior } from './query'\nimport type { RetryDelayValue, RetryValue } from './retryer'\nimport type { QueryFilters, QueryTypeFilter, SkipToken } from './utils'\nimport type { QueryCache } from './queryCache'\nimport type { MutationCache } from './mutationCache'\n\nexport type NonUndefinedGuard<T> = T extends undefined ? never : T\n\nexport type DistributiveOmit<\n  TObject,\n  TKey extends keyof TObject,\n> = TObject extends any ? Omit<TObject, TKey> : never\n\nexport type OmitKeyof<\n  TObject,\n  TKey extends TStrictly extends 'safely'\n    ?\n        | keyof TObject\n        | (string & Record<never, never>)\n        | (number & Record<never, never>)\n        | (symbol & Record<never, never>)\n    : keyof TObject,\n  TStrictly extends 'strictly' | 'safely' = 'strictly',\n> = Omit<TObject, TKey>\n\nexport type Override<TTargetA, TTargetB> = {\n  [AKey in keyof TTargetA]: AKey extends keyof TTargetB\n    ? TTargetB[AKey]\n    : TTargetA[AKey]\n}\n\nexport type NoInfer<T> = [T][T extends any ? 0 : never]\n\nexport interface Register {\n  // defaultError: Error\n  // queryMeta: Record<string, unknown>\n  // mutationMeta: Record<string, unknown>\n  // queryKey: ReadonlyArray<unknown>\n  // mutationKey: ReadonlyArray<unknown>\n}\n\nexport type DefaultError = Register extends {\n  defaultError: infer TError\n}\n  ? TError\n  : Error\n\nexport type QueryKey = Register extends {\n  queryKey: infer TQueryKey\n}\n  ? TQueryKey extends ReadonlyArray<unknown>\n    ? TQueryKey\n    : TQueryKey extends Array<unknown>\n      ? TQueryKey\n      : ReadonlyArray<unknown>\n  : ReadonlyArray<unknown>\n\nexport const dataTagSymbol = Symbol('dataTagSymbol')\nexport type dataTagSymbol = typeof dataTagSymbol\nexport const dataTagErrorSymbol = Symbol('dataTagErrorSymbol')\nexport type dataTagErrorSymbol = typeof dataTagErrorSymbol\nexport const unsetMarker = Symbol('unsetMarker')\nexport type UnsetMarker = typeof unsetMarker\nexport type AnyDataTag = {\n  [dataTagSymbol]: any\n  [dataTagErrorSymbol]: any\n}\nexport type DataTag<\n  TType,\n  TValue,\n  TError = UnsetMarker,\n> = TType extends AnyDataTag\n  ? TType\n  : TType & {\n      [dataTagSymbol]: TValue\n      [dataTagErrorSymbol]: TError\n    }\n\nexport type InferDataFromTag<TQueryFnData, TTaggedQueryKey extends QueryKey> =\n  TTaggedQueryKey extends DataTag<unknown, infer TaggedValue, unknown>\n    ? TaggedValue\n    : TQueryFnData\n\nexport type InferErrorFromTag<TError, TTaggedQueryKey extends QueryKey> =\n  TTaggedQueryKey extends DataTag<unknown, unknown, infer TaggedError>\n    ? TaggedError extends UnsetMarker\n      ? TError\n      : TaggedError\n    : TError\n\nexport type QueryFunction<\n  T = unknown,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> = (context: QueryFunctionContext<TQueryKey, TPageParam>) => T | Promise<T>\n\nexport type StaleTime = number | 'static'\n\nexport type StaleTimeFunction<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> =\n  | StaleTime\n  | ((query: Query<TQueryFnData, TError, TData, TQueryKey>) => StaleTime)\n\nexport type Enabled<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> =\n  | boolean\n  | ((query: Query<TQueryFnData, TError, TData, TQueryKey>) => boolean)\n\nexport type QueryPersister<\n  T = unknown,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> = [TPageParam] extends [never]\n  ? (\n      queryFn: QueryFunction<T, TQueryKey, never>,\n      context: QueryFunctionContext<TQueryKey>,\n      query: Query,\n    ) => T | Promise<T>\n  : (\n      queryFn: QueryFunction<T, TQueryKey, TPageParam>,\n      context: QueryFunctionContext<TQueryKey>,\n      query: Query,\n    ) => T | Promise<T>\n\nexport type QueryFunctionContext<\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> = [TPageParam] extends [never]\n  ? {\n      client: QueryClient\n      queryKey: TQueryKey\n      signal: AbortSignal\n      meta: QueryMeta | undefined\n      pageParam?: unknown\n      /**\n       * @deprecated\n       * if you want access to the direction, you can add it to the pageParam\n       */\n      direction?: unknown\n    }\n  : {\n      client: QueryClient\n      queryKey: TQueryKey\n      signal: AbortSignal\n      pageParam: TPageParam\n      /**\n       * @deprecated\n       * if you want access to the direction, you can add it to the pageParam\n       */\n      direction: FetchDirection\n      meta: QueryMeta | undefined\n    }\n\nexport type InitialDataFunction<T> = () => T | undefined\n\ntype NonFunctionGuard<T> = T extends Function ? never : T\n\nexport type PlaceholderDataFunction<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = (\n  previousData: TQueryData | undefined,\n  previousQuery: Query<TQueryFnData, TError, TQueryData, TQueryKey> | undefined,\n) => TQueryData | undefined\n\nexport type QueriesPlaceholderDataFunction<TQueryData> = (\n  previousData: undefined,\n  previousQuery: undefined,\n) => TQueryData | undefined\n\nexport type QueryKeyHashFunction<TQueryKey extends QueryKey> = (\n  queryKey: TQueryKey,\n) => string\n\nexport type GetPreviousPageParamFunction<TPageParam, TQueryFnData = unknown> = (\n  firstPage: TQueryFnData,\n  allPages: Array<TQueryFnData>,\n  firstPageParam: TPageParam,\n  allPageParams: Array<TPageParam>,\n) => TPageParam | undefined | null\n\nexport type GetNextPageParamFunction<TPageParam, TQueryFnData = unknown> = (\n  lastPage: TQueryFnData,\n  allPages: Array<TQueryFnData>,\n  lastPageParam: TPageParam,\n  allPageParams: Array<TPageParam>,\n) => TPageParam | undefined | null\n\nexport interface InfiniteData<TData, TPageParam = unknown> {\n  pages: Array<TData>\n  pageParams: Array<TPageParam>\n}\n\nexport type QueryMeta = Register extends {\n  queryMeta: infer TQueryMeta\n}\n  ? TQueryMeta extends Record<string, unknown>\n    ? TQueryMeta\n    : Record<string, unknown>\n  : Record<string, unknown>\n\nexport type NetworkMode = 'online' | 'always' | 'offlineFirst'\n\nexport type NotifyOnChangeProps =\n  | Array<keyof InfiniteQueryObserverResult>\n  | 'all'\n  | undefined\n  | (() => Array<keyof InfiniteQueryObserverResult> | 'all' | undefined)\n\nexport interface QueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> {\n  /**\n   * If `false`, failed queries will not retry by default.\n   * If `true`, failed queries will retry infinitely., failureCount: num\n   * If set to an integer number, e.g. 3, failed queries will retry until the failed query count meets that number.\n   * If set to a function `(failureCount, error) => boolean` failed queries will retry until the function returns false.\n   */\n  retry?: RetryValue<TError>\n  retryDelay?: RetryDelayValue<TError>\n  networkMode?: NetworkMode\n  /**\n   * The time in milliseconds that unused/inactive cache data remains in memory.\n   * When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration.\n   * When different garbage collection times are specified, the longest one will be used.\n   * Setting it to `Infinity` will disable garbage collection.\n   */\n  gcTime?: number\n  queryFn?: QueryFunction<TQueryFnData, TQueryKey, TPageParam> | SkipToken\n  persister?: QueryPersister<\n    NoInfer<TQueryFnData>,\n    NoInfer<TQueryKey>,\n    NoInfer<TPageParam>\n  >\n  queryHash?: string\n  queryKey?: TQueryKey\n  queryKeyHashFn?: QueryKeyHashFunction<TQueryKey>\n  initialData?: TData | InitialDataFunction<TData>\n  initialDataUpdatedAt?: number | (() => number | undefined)\n  behavior?: QueryBehavior<TQueryFnData, TError, TData, TQueryKey>\n  /**\n   * Set this to `false` to disable structural sharing between query results.\n   * Set this to a function which accepts the old and new data and returns resolved data of the same type to implement custom structural sharing logic.\n   * Defaults to `true`.\n   */\n  structuralSharing?:\n    | boolean\n    | ((oldData: unknown | undefined, newData: unknown) => unknown)\n  _defaulted?: boolean\n  /**\n   * Additional payload to be stored on each query.\n   * Use this property to pass information that can be used in other places.\n   */\n  meta?: QueryMeta\n  /**\n   * Maximum number of pages to store in the data of an infinite query.\n   */\n  maxPages?: number\n}\n\nexport interface InitialPageParam<TPageParam = unknown> {\n  initialPageParam: TPageParam\n}\n\nexport interface InfiniteQueryPageParamsOptions<\n  TQueryFnData = unknown,\n  TPageParam = unknown,\n> extends InitialPageParam<TPageParam> {\n  /**\n   * This function can be set to automatically get the previous cursor for infinite queries.\n   * The result will also be used to determine the value of `hasPreviousPage`.\n   */\n  getPreviousPageParam?: GetPreviousPageParamFunction<TPageParam, TQueryFnData>\n  /**\n   * This function can be set to automatically get the next cursor for infinite queries.\n   * The result will also be used to determine the value of `hasNextPage`.\n   */\n  getNextPageParam: GetNextPageParamFunction<TPageParam, TQueryFnData>\n}\n\nexport type ThrowOnError<\n  TQueryFnData,\n  TError,\n  TQueryData,\n  TQueryKey extends QueryKey,\n> =\n  | boolean\n  | ((\n      error: TError,\n      query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n    ) => boolean)\n\nexport interface QueryObserverOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> extends WithRequired<\n    QueryOptions<TQueryFnData, TError, TQueryData, TQueryKey, TPageParam>,\n    'queryKey'\n  > {\n  /**\n   * Set this to `false` or a function that returns `false` to disable automatic refetching when the query mounts or changes query keys.\n   * To refetch the query, use the `refetch` method returned from the `useQuery` instance.\n   * Accepts a boolean or function that returns a boolean.\n   * Defaults to `true`.\n   */\n  enabled?: Enabled<TQueryFnData, TError, TQueryData, TQueryKey>\n  /**\n   * The time in milliseconds after data is considered stale.\n   * If set to `Infinity`, the data will never be considered stale.\n   * If set to a function, the function will be executed with the query to compute a `staleTime`.\n   * Defaults to `0`.\n   */\n  staleTime?: StaleTimeFunction<TQueryFnData, TError, TQueryData, TQueryKey>\n  /**\n   * If set to a number, the query will continuously refetch at this frequency in milliseconds.\n   * If set to a function, the function will be executed with the latest data and query to compute a frequency\n   * Defaults to `false`.\n   */\n  refetchInterval?:\n    | number\n    | false\n    | ((\n        query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n      ) => number | false | undefined)\n  /**\n   * If set to `true`, the query will continue to refetch while their tab/window is in the background.\n   * Defaults to `false`.\n   */\n  refetchIntervalInBackground?: boolean\n  /**\n   * If set to `true`, the query will refetch on window focus if the data is stale.\n   * If set to `false`, the query will not refetch on window focus.\n   * If set to `'always'`, the query will always refetch on window focus.\n   * If set to a function, the function will be executed with the latest data and query to compute the value.\n   * Defaults to `true`.\n   */\n  refetchOnWindowFocus?:\n    | boolean\n    | 'always'\n    | ((\n        query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n      ) => boolean | 'always')\n  /**\n   * If set to `true`, the query will refetch on reconnect if the data is stale.\n   * If set to `false`, the query will not refetch on reconnect.\n   * If set to `'always'`, the query will always refetch on reconnect.\n   * If set to a function, the function will be executed with the latest data and query to compute the value.\n   * Defaults to the value of `networkOnline` (`true`)\n   */\n  refetchOnReconnect?:\n    | boolean\n    | 'always'\n    | ((\n        query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n      ) => boolean | 'always')\n  /**\n   * If set to `true`, the query will refetch on mount if the data is stale.\n   * If set to `false`, will disable additional instances of a query to trigger background refetch.\n   * If set to `'always'`, the query will always refetch on mount.\n   * If set to a function, the function will be executed with the latest data and query to compute the value\n   * Defaults to `true`.\n   */\n  refetchOnMount?:\n    | boolean\n    | 'always'\n    | ((\n        query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n      ) => boolean | 'always')\n  /**\n   * If set to `false`, the query will not be retried on mount if it contains an error.\n   * Defaults to `true`.\n   */\n  retryOnMount?: boolean\n  /**\n   * If set, the component will only re-render if any of the listed properties change.\n   * When set to `['data', 'error']`, the component will only re-render when the `data` or `error` properties change.\n   * When set to `'all'`, the component will re-render whenever a query is updated.\n   * When set to a function, the function will be executed to compute the list of properties.\n   * By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.\n   */\n  notifyOnChangeProps?: NotifyOnChangeProps\n  /**\n   * Whether errors should be thrown instead of setting the `error` property.\n   * If set to `true` or `suspense` is `true`, all errors will be thrown to the error boundary.\n   * If set to `false` and `suspense` is `false`, errors are returned as state.\n   * If set to a function, it will be passed the error and the query, and it should return a boolean indicating whether to show the error in an error boundary (`true`) or return the error as state (`false`).\n   * Defaults to `false`.\n   */\n  throwOnError?: ThrowOnError<TQueryFnData, TError, TQueryData, TQueryKey>\n  /**\n   * This option can be used to transform or select a part of the data returned by the query function.\n   */\n  select?: (data: TQueryData) => TData\n  /**\n   * If set to `true`, the query will suspend when `status === 'pending'`\n   * and throw errors when `status === 'error'`.\n   * Defaults to `false`.\n   */\n  suspense?: boolean\n  /**\n   * If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `loading` data and no initialData has been provided.\n   */\n  placeholderData?:\n    | NonFunctionGuard<TQueryData>\n    | PlaceholderDataFunction<\n        NonFunctionGuard<TQueryData>,\n        TError,\n        NonFunctionGuard<TQueryData>,\n        TQueryKey\n      >\n\n  _optimisticResults?: 'optimistic' | 'isRestoring'\n\n  /**\n   * Enable prefetching during rendering\n   */\n  experimental_prefetchInRender?: boolean\n}\n\nexport type WithRequired<TTarget, TKey extends keyof TTarget> = TTarget & {\n  [_ in TKey]: {}\n}\n\nexport type DefaultedQueryObserverOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = WithRequired<\n  QueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  'throwOnError' | 'refetchOnReconnect' | 'queryHash'\n>\n\nexport interface InfiniteQueryObserverOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> extends QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      InfiniteData<TQueryFnData, TPageParam>,\n      TQueryKey,\n      TPageParam\n    >,\n    InfiniteQueryPageParamsOptions<TQueryFnData, TPageParam> {}\n\nexport type DefaultedInfiniteQueryObserverOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> = WithRequired<\n  InfiniteQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  >,\n  'throwOnError' | 'refetchOnReconnect' | 'queryHash'\n>\n\nexport interface FetchQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> extends WithRequired<\n    QueryOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>,\n    'queryKey'\n  > {\n  initialPageParam?: never\n  /**\n   * The time in milliseconds after data is considered stale.\n   * If the data is fresh it will be returned from the cache.\n   */\n  staleTime?: StaleTimeFunction<TQueryFnData, TError, TData, TQueryKey>\n}\n\nexport interface EnsureQueryDataOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> extends FetchQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  > {\n  revalidateIfStale?: boolean\n}\n\nexport type EnsureInfiniteQueryDataOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> = FetchInfiniteQueryOptions<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey,\n  TPageParam\n> & {\n  revalidateIfStale?: boolean\n}\n\ntype FetchInfiniteQueryPages<TQueryFnData = unknown, TPageParam = unknown> =\n  | { pages?: never }\n  | {\n      pages: number\n      getNextPageParam: GetNextPageParamFunction<TPageParam, TQueryFnData>\n    }\n\nexport type FetchInfiniteQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> = Omit<\n  FetchQueryOptions<\n    TQueryFnData,\n    TError,\n    InfiniteData<TData, TPageParam>,\n    TQueryKey,\n    TPageParam\n  >,\n  'initialPageParam'\n> &\n  InitialPageParam<TPageParam> &\n  FetchInfiniteQueryPages<TQueryFnData, TPageParam>\n\nexport interface ResultOptions {\n  throwOnError?: boolean\n}\n\nexport interface RefetchOptions extends ResultOptions {\n  /**\n   * If set to `true`, a currently running request will be cancelled before a new request is made\n   *\n   * If set to `false`, no refetch will be made if there is already a request running.\n   *\n   * Defaults to `true`.\n   */\n  cancelRefetch?: boolean\n}\n\nexport interface InvalidateQueryFilters<TQueryKey extends QueryKey = QueryKey>\n  extends QueryFilters<TQueryKey> {\n  refetchType?: QueryTypeFilter | 'none'\n}\n\nexport interface RefetchQueryFilters<TQueryKey extends QueryKey = QueryKey>\n  extends QueryFilters<TQueryKey> {}\n\nexport interface InvalidateOptions extends RefetchOptions {}\nexport interface ResetOptions extends RefetchOptions {}\n\nexport interface FetchNextPageOptions extends ResultOptions {\n  /**\n   * If set to `true`, calling `fetchNextPage` repeatedly will invoke `queryFn` every time,\n   * whether the previous invocation has resolved or not. Also, the result from previous invocations will be ignored.\n   *\n   * If set to `false`, calling `fetchNextPage` repeatedly won't have any effect until the first invocation has resolved.\n   *\n   * Defaults to `true`.\n   */\n  cancelRefetch?: boolean\n}\n\nexport interface FetchPreviousPageOptions extends ResultOptions {\n  /**\n   * If set to `true`, calling `fetchPreviousPage` repeatedly will invoke `queryFn` every time,\n   * whether the previous invocation has resolved or not. Also, the result from previous invocations will be ignored.\n   *\n   * If set to `false`, calling `fetchPreviousPage` repeatedly won't have any effect until the first invocation has resolved.\n   *\n   * Defaults to `true`.\n   */\n  cancelRefetch?: boolean\n}\n\nexport type QueryStatus = 'pending' | 'error' | 'success'\nexport type FetchStatus = 'fetching' | 'paused' | 'idle'\n\nexport interface QueryObserverBaseResult<\n  TData = unknown,\n  TError = DefaultError,\n> {\n  /**\n   * The last successfully resolved data for the query.\n   */\n  data: TData | undefined\n  /**\n   * The timestamp for when the query most recently returned the `status` as `\"success\"`.\n   */\n  dataUpdatedAt: number\n  /**\n   * The error object for the query, if an error was thrown.\n   * - Defaults to `null`.\n   */\n  error: TError | null\n  /**\n   * The timestamp for when the query most recently returned the `status` as `\"error\"`.\n   */\n  errorUpdatedAt: number\n  /**\n   * The failure count for the query.\n   * - Incremented every time the query fails.\n   * - Reset to `0` when the query succeeds.\n   */\n  failureCount: number\n  /**\n   * The failure reason for the query retry.\n   * - Reset to `null` when the query succeeds.\n   */\n  failureReason: TError | null\n  /**\n   * The sum of all errors.\n   */\n  errorUpdateCount: number\n  /**\n   * A derived boolean from the `status` variable, provided for convenience.\n   * - `true` if the query attempt resulted in an error.\n   */\n  isError: boolean\n  /**\n   * Will be `true` if the query has been fetched.\n   */\n  isFetched: boolean\n  /**\n   * Will be `true` if the query has been fetched after the component mounted.\n   * - This property can be used to not show any previously cached data.\n   */\n  isFetchedAfterMount: boolean\n  /**\n   * A derived boolean from the `fetchStatus` variable, provided for convenience.\n   * - `true` whenever the `queryFn` is executing, which includes initial `pending` as well as background refetch.\n   */\n  isFetching: boolean\n  /**\n   * Is `true` whenever the first fetch for a query is in-flight.\n   * - Is the same as `isFetching && isPending`.\n   */\n  isLoading: boolean\n  /**\n   * Will be `pending` if there's no cached data and no query attempt was finished yet.\n   */\n  isPending: boolean\n  /**\n   * Will be `true` if the query failed while fetching for the first time.\n   */\n  isLoadingError: boolean\n  /**\n   * @deprecated `isInitialLoading` is being deprecated in favor of `isLoading`\n   * and will be removed in the next major version.\n   */\n  isInitialLoading: boolean\n  /**\n   * A derived boolean from the `fetchStatus` variable, provided for convenience.\n   * - The query wanted to fetch, but has been `paused`.\n   */\n  isPaused: boolean\n  /**\n   * Will be `true` if the data shown is the placeholder data.\n   */\n  isPlaceholderData: boolean\n  /**\n   * Will be `true` if the query failed while refetching.\n   */\n  isRefetchError: boolean\n  /**\n   * Is `true` whenever a background refetch is in-flight, which _does not_ include initial `pending`.\n   * - Is the same as `isFetching && !isPending`.\n   */\n  isRefetching: boolean\n  /**\n   * Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.\n   */\n  isStale: boolean\n  /**\n   * A derived boolean from the `status` variable, provided for convenience.\n   * - `true` if the query has received a response with no errors and is ready to display its data.\n   */\n  isSuccess: boolean\n  /**\n   * A function to manually refetch the query.\n   */\n  refetch: (\n    options?: RefetchOptions,\n  ) => Promise<QueryObserverResult<TData, TError>>\n  /**\n   * The status of the query.\n   * - Will be:\n   *   - `pending` if there's no cached data and no query attempt was finished yet.\n   *   - `error` if the query attempt resulted in an error.\n   *   - `success` if the query has received a response with no errors and is ready to display its data.\n   */\n  status: QueryStatus\n  /**\n   * The fetch status of the query.\n   * - `fetching`: Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetch.\n   * - `paused`: The query wanted to fetch, but has been `paused`.\n   * - `idle`: The query is not fetching.\n   * - See [Network Mode](https://tanstack.com/query/latest/docs/framework/react/guides/network-mode) for more information.\n   */\n  fetchStatus: FetchStatus\n  /**\n   * A stable promise that will be resolved with the data of the query.\n   * Requires the `experimental_prefetchInRender` feature flag to be enabled.\n   * @example\n   *\n   * ### Enabling the feature flag\n   * ```ts\n   * const client = new QueryClient({\n   *   defaultOptions: {\n   *     queries: {\n   *       experimental_prefetchInRender: true,\n   *     },\n   *   },\n   * })\n   * ```\n   *\n   * ### Usage\n   * ```tsx\n   * import { useQuery } from '@tanstack/react-query'\n   * import React from 'react'\n   * import { fetchTodos, type Todo } from './api'\n   *\n   * function TodoList({ query }: { query: UseQueryResult<Todo[], Error> }) {\n   *   const data = React.use(query.promise)\n   *\n   *   return (\n   *     <ul>\n   *       {data.map(todo => (\n   *         <li key={todo.id}>{todo.title}</li>\n   *       ))}\n   *     </ul>\n   *   )\n   * }\n   *\n   * export function App() {\n   *   const query = useQuery({ queryKey: ['todos'], queryFn: fetchTodos })\n   *\n   *   return (\n   *     <>\n   *       <h1>Todos</h1>\n   *       <React.Suspense fallback={<div>Loading...</div>}>\n   *         <TodoList query={query} />\n   *       </React.Suspense>\n   *     </>\n   *   )\n   * }\n   * ```\n   */\n  promise: Promise<TData>\n}\n\nexport interface QueryObserverPendingResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: null\n  isError: false\n  isPending: true\n  isLoadingError: false\n  isRefetchError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'pending'\n}\n\nexport interface QueryObserverLoadingResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: null\n  isError: false\n  isPending: true\n  isLoading: true\n  isLoadingError: false\n  isRefetchError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'pending'\n}\n\nexport interface QueryObserverLoadingErrorResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: TError\n  isError: true\n  isPending: false\n  isLoading: false\n  isLoadingError: true\n  isRefetchError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'error'\n}\n\nexport interface QueryObserverRefetchErrorResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: TData\n  error: TError\n  isError: true\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: true\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'error'\n}\n\nexport interface QueryObserverSuccessResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: TData\n  error: null\n  isError: false\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: false\n  isSuccess: true\n  isPlaceholderData: false\n  status: 'success'\n}\n\nexport interface QueryObserverPlaceholderResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: TData\n  isError: false\n  error: null\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: false\n  isSuccess: true\n  isPlaceholderData: true\n  status: 'success'\n}\n\nexport type DefinedQueryObserverResult<\n  TData = unknown,\n  TError = DefaultError,\n> =\n  | QueryObserverRefetchErrorResult<TData, TError>\n  | QueryObserverSuccessResult<TData, TError>\n\nexport type QueryObserverResult<TData = unknown, TError = DefaultError> =\n  | DefinedQueryObserverResult<TData, TError>\n  | QueryObserverLoadingErrorResult<TData, TError>\n  | QueryObserverLoadingResult<TData, TError>\n  | QueryObserverPendingResult<TData, TError>\n  | QueryObserverPlaceholderResult<TData, TError>\n\nexport interface InfiniteQueryObserverBaseResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  /**\n   * This function allows you to fetch the next \"page\" of results.\n   */\n  fetchNextPage: (\n    options?: FetchNextPageOptions,\n  ) => Promise<InfiniteQueryObserverResult<TData, TError>>\n  /**\n   * This function allows you to fetch the previous \"page\" of results.\n   */\n  fetchPreviousPage: (\n    options?: FetchPreviousPageOptions,\n  ) => Promise<InfiniteQueryObserverResult<TData, TError>>\n  /**\n   * Will be `true` if there is a next page to be fetched (known via the `getNextPageParam` option).\n   */\n  hasNextPage: boolean\n  /**\n   * Will be `true` if there is a previous page to be fetched (known via the `getPreviousPageParam` option).\n   */\n  hasPreviousPage: boolean\n  /**\n   * Will be `true` if the query failed while fetching the next page.\n   */\n  isFetchNextPageError: boolean\n  /**\n   * Will be `true` while fetching the next page with `fetchNextPage`.\n   */\n  isFetchingNextPage: boolean\n  /**\n   * Will be `true` if the query failed while fetching the previous page.\n   */\n  isFetchPreviousPageError: boolean\n  /**\n   * Will be `true` while fetching the previous page with `fetchPreviousPage`.\n   */\n  isFetchingPreviousPage: boolean\n}\n\nexport interface InfiniteQueryObserverPendingResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: null\n  isError: false\n  isPending: true\n  isLoadingError: false\n  isRefetchError: false\n  isFetchNextPageError: false\n  isFetchPreviousPageError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'pending'\n}\n\nexport interface InfiniteQueryObserverLoadingResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: null\n  isError: false\n  isPending: true\n  isLoading: true\n  isLoadingError: false\n  isRefetchError: false\n  isFetchNextPageError: false\n  isFetchPreviousPageError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'pending'\n}\n\nexport interface InfiniteQueryObserverLoadingErrorResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: TError\n  isError: true\n  isPending: false\n  isLoading: false\n  isLoadingError: true\n  isRefetchError: false\n  isFetchNextPageError: false\n  isFetchPreviousPageError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'error'\n}\n\nexport interface InfiniteQueryObserverRefetchErrorResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: TData\n  error: TError\n  isError: true\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: true\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'error'\n}\n\nexport interface InfiniteQueryObserverSuccessResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: TData\n  error: null\n  isError: false\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: false\n  isFetchNextPageError: false\n  isFetchPreviousPageError: false\n  isSuccess: true\n  isPlaceholderData: false\n  status: 'success'\n}\n\nexport interface InfiniteQueryObserverPlaceholderResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: TData\n  isError: false\n  error: null\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: false\n  isSuccess: true\n  isPlaceholderData: true\n  isFetchNextPageError: false\n  isFetchPreviousPageError: false\n  status: 'success'\n}\n\nexport type DefinedInfiniteQueryObserverResult<\n  TData = unknown,\n  TError = DefaultError,\n> =\n  | InfiniteQueryObserverRefetchErrorResult<TData, TError>\n  | InfiniteQueryObserverSuccessResult<TData, TError>\n\nexport type InfiniteQueryObserverResult<\n  TData = unknown,\n  TError = DefaultError,\n> =\n  | DefinedInfiniteQueryObserverResult<TData, TError>\n  | InfiniteQueryObserverLoadingErrorResult<TData, TError>\n  | InfiniteQueryObserverLoadingResult<TData, TError>\n  | InfiniteQueryObserverPendingResult<TData, TError>\n  | InfiniteQueryObserverPlaceholderResult<TData, TError>\n\nexport type MutationKey = Register extends {\n  mutationKey: infer TMutationKey\n}\n  ? TMutationKey extends Array<unknown>\n    ? TMutationKey\n    : TMutationKey extends Array<unknown>\n      ? TMutationKey\n      : ReadonlyArray<unknown>\n  : ReadonlyArray<unknown>\n\nexport type MutationStatus = 'idle' | 'pending' | 'success' | 'error'\n\nexport type MutationScope = {\n  id: string\n}\n\nexport type MutationMeta = Register extends {\n  mutationMeta: infer TMutationMeta\n}\n  ? TMutationMeta extends Record<string, unknown>\n    ? TMutationMeta\n    : Record<string, unknown>\n  : Record<string, unknown>\n\nexport type MutationFunction<TData = unknown, TVariables = unknown> = (\n  variables: TVariables,\n) => Promise<TData>\n\nexport interface MutationOptions<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> {\n  mutationFn?: MutationFunction<TData, TVariables>\n  mutationKey?: MutationKey\n  onMutate?: (\n    variables: TVariables,\n  ) => Promise<TContext | undefined> | TContext | undefined\n  onSuccess?: (\n    data: TData,\n    variables: TVariables,\n    context: TContext,\n  ) => Promise<unknown> | unknown\n  onError?: (\n    error: TError,\n    variables: TVariables,\n    context: TContext | undefined,\n  ) => Promise<unknown> | unknown\n  onSettled?: (\n    data: TData | undefined,\n    error: TError | null,\n    variables: TVariables,\n    context: TContext | undefined,\n  ) => Promise<unknown> | unknown\n  retry?: RetryValue<TError>\n  retryDelay?: RetryDelayValue<TError>\n  networkMode?: NetworkMode\n  gcTime?: number\n  _defaulted?: boolean\n  meta?: MutationMeta\n  scope?: MutationScope\n}\n\nexport interface MutationObserverOptions<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationOptions<TData, TError, TVariables, TContext> {\n  throwOnError?: boolean | ((error: TError) => boolean)\n}\n\nexport interface MutateOptions<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> {\n  onSuccess?: (data: TData, variables: TVariables, context: TContext) => void\n  onError?: (\n    error: TError,\n    variables: TVariables,\n    context: TContext | undefined,\n  ) => void\n  onSettled?: (\n    data: TData | undefined,\n    error: TError | null,\n    variables: TVariables,\n    context: TContext | undefined,\n  ) => void\n}\n\nexport type MutateFunction<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> = (\n  variables: TVariables,\n  options?: MutateOptions<TData, TError, TVariables, TContext>,\n) => Promise<TData>\n\nexport interface MutationObserverBaseResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationState<TData, TError, TVariables, TContext> {\n  /**\n   * The last successfully resolved data for the mutation.\n   */\n  data: TData | undefined\n  /**\n   * The variables object passed to the `mutationFn`.\n   */\n  variables: TVariables | undefined\n  /**\n   * The error object for the mutation, if an error was encountered.\n   * - Defaults to `null`.\n   */\n  error: TError | null\n  /**\n   * A boolean variable derived from `status`.\n   * - `true` if the last mutation attempt resulted in an error.\n   */\n  isError: boolean\n  /**\n   * A boolean variable derived from `status`.\n   * - `true` if the mutation is in its initial state prior to executing.\n   */\n  isIdle: boolean\n  /**\n   * A boolean variable derived from `status`.\n   * - `true` if the mutation is currently executing.\n   */\n  isPending: boolean\n  /**\n   * A boolean variable derived from `status`.\n   * - `true` if the last mutation attempt was successful.\n   */\n  isSuccess: boolean\n  /**\n   * The status of the mutation.\n   * - Will be:\n   *   - `idle` initial status prior to the mutation function executing.\n   *   - `pending` if the mutation is currently executing.\n   *   - `error` if the last mutation attempt resulted in an error.\n   *   - `success` if the last mutation attempt was successful.\n   */\n  status: MutationStatus\n  /**\n   * The mutation function you can call with variables to trigger the mutation and optionally hooks on additional callback options.\n   * @param variables - The variables object to pass to the `mutationFn`.\n   * @param options.onSuccess - This function will fire when the mutation is successful and will be passed the mutation's result.\n   * @param options.onError - This function will fire if the mutation encounters an error and will be passed the error.\n   * @param options.onSettled - This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error.\n   * @remarks\n   * - If you make multiple requests, `onSuccess` will fire only after the latest call you've made.\n   * - All the callback functions (`onSuccess`, `onError`, `onSettled`) are void functions, and the returned value will be ignored.\n   */\n  mutate: MutateFunction<TData, TError, TVariables, TContext>\n  /**\n   * A function to clean the mutation internal state (i.e., it resets the mutation to its initial state).\n   */\n  reset: () => void\n}\n\nexport interface MutationObserverIdleResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationObserverBaseResult<TData, TError, TVariables, TContext> {\n  data: undefined\n  variables: undefined\n  error: null\n  isError: false\n  isIdle: true\n  isPending: false\n  isSuccess: false\n  status: 'idle'\n}\n\nexport interface MutationObserverLoadingResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationObserverBaseResult<TData, TError, TVariables, TContext> {\n  data: undefined\n  variables: TVariables\n  error: null\n  isError: false\n  isIdle: false\n  isPending: true\n  isSuccess: false\n  status: 'pending'\n}\n\nexport interface MutationObserverErrorResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationObserverBaseResult<TData, TError, TVariables, TContext> {\n  data: undefined\n  error: TError\n  variables: TVariables\n  isError: true\n  isIdle: false\n  isPending: false\n  isSuccess: false\n  status: 'error'\n}\n\nexport interface MutationObserverSuccessResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationObserverBaseResult<TData, TError, TVariables, TContext> {\n  data: TData\n  error: null\n  variables: TVariables\n  isError: false\n  isIdle: false\n  isPending: false\n  isSuccess: true\n  status: 'success'\n}\n\nexport type MutationObserverResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> =\n  | MutationObserverIdleResult<TData, TError, TVariables, TContext>\n  | MutationObserverLoadingResult<TData, TError, TVariables, TContext>\n  | MutationObserverErrorResult<TData, TError, TVariables, TContext>\n  | MutationObserverSuccessResult<TData, TError, TVariables, TContext>\n\nexport interface QueryClientConfig {\n  queryCache?: QueryCache\n  mutationCache?: MutationCache\n  defaultOptions?: DefaultOptions\n}\n\nexport interface DefaultOptions<TError = DefaultError> {\n  queries?: OmitKeyof<\n    QueryObserverOptions<unknown, TError>,\n    'suspense' | 'queryKey'\n  >\n  mutations?: MutationObserverOptions<unknown, TError, unknown, unknown>\n  hydrate?: HydrateOptions['defaultOptions']\n  dehydrate?: DehydrateOptions\n}\n\nexport interface CancelOptions {\n  revert?: boolean\n  silent?: boolean\n}\n\nexport interface SetDataOptions {\n  updatedAt?: number\n}\n\nexport type NotifyEventType =\n  | 'added'\n  | 'removed'\n  | 'updated'\n  | 'observerAdded'\n  | 'observerRemoved'\n  | 'observerResultsUpdated'\n  | 'observerOptionsUpdated'\n\nexport interface NotifyEvent {\n  type: NotifyEventType\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA8DO,IAAM,gBAAgB,OAAO,eAAe;AAE5C,IAAM,qBAAqB,OAAO,oBAAoB;AAEtD,IAAM,cAAc,OAAO,aAAa;","names":[]}
\ No newline at end of file
+{"version":3,"sources":["../../src/types.ts"],"sourcesContent":["/* istanbul ignore file */\n\nimport type { QueryClient } from './queryClient'\nimport type { DehydrateOptions, HydrateOptions } from './hydration'\nimport type { MutationState } from './mutation'\nimport type { FetchDirection, Query, QueryBehavior } from './query'\nimport type { RetryDelayValue, RetryValue } from './retryer'\nimport type { QueryFilters, QueryTypeFilter, SkipToken } from './utils'\nimport type { QueryCache } from './queryCache'\nimport type { MutationCache } from './mutationCache'\n\nexport type NonUndefinedGuard<T> = T extends undefined ? never : T\n\nexport type DistributiveOmit<\n  TObject,\n  TKey extends keyof TObject,\n> = TObject extends any ? Omit<TObject, TKey> : never\n\nexport type OmitKeyof<\n  TObject,\n  TKey extends TStrictly extends 'safely'\n    ?\n        | keyof TObject\n        | (string & Record<never, never>)\n        | (number & Record<never, never>)\n        | (symbol & Record<never, never>)\n    : keyof TObject,\n  TStrictly extends 'strictly' | 'safely' = 'strictly',\n> = Omit<TObject, TKey>\n\nexport type Override<TTargetA, TTargetB> = {\n  [AKey in keyof TTargetA]: AKey extends keyof TTargetB\n    ? TTargetB[AKey]\n    : TTargetA[AKey]\n}\n\nexport type NoInfer<T> = [T][T extends any ? 0 : never]\n\nexport interface Register {\n  // defaultError: Error\n  // queryMeta: Record<string, unknown>\n  // mutationMeta: Record<string, unknown>\n  // queryKey: ReadonlyArray<unknown>\n  // mutationKey: ReadonlyArray<unknown>\n}\n\nexport type DefaultError = Register extends {\n  defaultError: infer TError\n}\n  ? TError\n  : Error\n\nexport type QueryKey = Register extends {\n  queryKey: infer TQueryKey\n}\n  ? TQueryKey extends ReadonlyArray<unknown>\n    ? TQueryKey\n    : TQueryKey extends Array<unknown>\n      ? TQueryKey\n      : ReadonlyArray<unknown>\n  : ReadonlyArray<unknown>\n\nexport const dataTagSymbol = Symbol('dataTagSymbol')\nexport type dataTagSymbol = typeof dataTagSymbol\nexport const dataTagErrorSymbol = Symbol('dataTagErrorSymbol')\nexport type dataTagErrorSymbol = typeof dataTagErrorSymbol\nexport const unsetMarker = Symbol('unsetMarker')\nexport type UnsetMarker = typeof unsetMarker\nexport type AnyDataTag = {\n  [dataTagSymbol]: any\n  [dataTagErrorSymbol]: any\n}\nexport type DataTag<\n  TType,\n  TValue,\n  TError = UnsetMarker,\n> = TType extends AnyDataTag\n  ? TType\n  : TType & {\n      [dataTagSymbol]: TValue\n      [dataTagErrorSymbol]: TError\n    }\n\nexport type InferDataFromTag<TQueryFnData, TTaggedQueryKey extends QueryKey> =\n  TTaggedQueryKey extends DataTag<unknown, infer TaggedValue, unknown>\n    ? TaggedValue\n    : TQueryFnData\n\nexport type InferErrorFromTag<TError, TTaggedQueryKey extends QueryKey> =\n  TTaggedQueryKey extends DataTag<unknown, unknown, infer TaggedError>\n    ? TaggedError extends UnsetMarker\n      ? TError\n      : TaggedError\n    : TError\n\nexport type QueryFunction<\n  T = unknown,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> = (context: QueryFunctionContext<TQueryKey, TPageParam>) => T | Promise<T>\n\nexport type StaleTime = number | 'static'\n\nexport type StaleTimeFunction<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> =\n  | StaleTime\n  | ((query: Query<TQueryFnData, TError, TData, TQueryKey>) => StaleTime)\n\nexport type Enabled<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> =\n  | boolean\n  | ((query: Query<TQueryFnData, TError, TData, TQueryKey>) => boolean)\n\nexport type QueryPersister<\n  T = unknown,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> = [TPageParam] extends [never]\n  ? (\n      queryFn: QueryFunction<T, TQueryKey, never>,\n      context: QueryFunctionContext<TQueryKey>,\n      query: Query,\n    ) => T | Promise<T>\n  : (\n      queryFn: QueryFunction<T, TQueryKey, TPageParam>,\n      context: QueryFunctionContext<TQueryKey>,\n      query: Query,\n    ) => T | Promise<T>\n\nexport type QueryFunctionContext<\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> = [TPageParam] extends [never]\n  ? {\n      client: QueryClient\n      queryKey: TQueryKey\n      signal: AbortSignal\n      meta: QueryMeta | undefined\n      pageParam?: unknown\n      /**\n       * @deprecated\n       * if you want access to the direction, you can add it to the pageParam\n       */\n      direction?: unknown\n    }\n  : {\n      client: QueryClient\n      queryKey: TQueryKey\n      signal: AbortSignal\n      pageParam: TPageParam\n      /**\n       * @deprecated\n       * if you want access to the direction, you can add it to the pageParam\n       */\n      direction: FetchDirection\n      meta: QueryMeta | undefined\n    }\n\nexport type InitialDataFunction<T> = () => T | undefined\n\ntype NonFunctionGuard<T> = T extends Function ? never : T\n\nexport type PlaceholderDataFunction<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = (\n  previousData: TQueryData | undefined,\n  previousQuery: Query<TQueryFnData, TError, TQueryData, TQueryKey> | undefined,\n) => TQueryData | undefined\n\nexport type QueriesPlaceholderDataFunction<TQueryData> = (\n  previousData: undefined,\n  previousQuery: undefined,\n) => TQueryData | undefined\n\nexport type QueryKeyHashFunction<TQueryKey extends QueryKey> = (\n  queryKey: TQueryKey,\n) => string\n\nexport type GetPreviousPageParamFunction<TPageParam, TQueryFnData = unknown> = (\n  firstPage: TQueryFnData,\n  allPages: Array<TQueryFnData>,\n  firstPageParam: TPageParam,\n  allPageParams: Array<TPageParam>,\n) => TPageParam | undefined | null\n\nexport type GetNextPageParamFunction<TPageParam, TQueryFnData = unknown> = (\n  lastPage: TQueryFnData,\n  allPages: Array<TQueryFnData>,\n  lastPageParam: TPageParam,\n  allPageParams: Array<TPageParam>,\n) => TPageParam | undefined | null\n\nexport interface InfiniteData<TData, TPageParam = unknown> {\n  pages: Array<TData>\n  pageParams: Array<TPageParam>\n}\n\nexport type QueryMeta = Register extends {\n  queryMeta: infer TQueryMeta\n}\n  ? TQueryMeta extends Record<string, unknown>\n    ? TQueryMeta\n    : Record<string, unknown>\n  : Record<string, unknown>\n\nexport type NetworkMode = 'online' | 'always' | 'offlineFirst'\n\nexport type NotifyOnChangeProps =\n  | Array<keyof InfiniteQueryObserverResult>\n  | 'all'\n  | undefined\n  | (() => Array<keyof InfiniteQueryObserverResult> | 'all' | undefined)\n\nexport interface QueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> {\n  /**\n   * If `false`, failed queries will not retry by default.\n   * If `true`, failed queries will retry infinitely., failureCount: num\n   * If set to an integer number, e.g. 3, failed queries will retry until the failed query count meets that number.\n   * If set to a function `(failureCount, error) => boolean` failed queries will retry until the function returns false.\n   */\n  retry?: RetryValue<TError>\n  retryDelay?: RetryDelayValue<TError>\n  networkMode?: NetworkMode\n  /**\n   * The time in milliseconds that unused/inactive cache data remains in memory.\n   * When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration.\n   * When different garbage collection times are specified, the longest one will be used.\n   * Setting it to `Infinity` will disable garbage collection.\n   */\n  gcTime?: number\n  queryFn?: QueryFunction<TQueryFnData, TQueryKey, TPageParam> | SkipToken\n  persister?: QueryPersister<\n    NoInfer<TQueryFnData>,\n    NoInfer<TQueryKey>,\n    NoInfer<TPageParam>\n  >\n  queryHash?: string\n  queryKey?: TQueryKey\n  queryKeyHashFn?: QueryKeyHashFunction<TQueryKey>\n  initialData?: TData | InitialDataFunction<TData>\n  initialDataUpdatedAt?: number | (() => number | undefined)\n  behavior?: QueryBehavior<TQueryFnData, TError, TData, TQueryKey>\n  /**\n   * Set this to `false` to disable structural sharing between query results.\n   * Set this to a function which accepts the old and new data and returns resolved data of the same type to implement custom structural sharing logic.\n   * Defaults to `true`.\n   */\n  structuralSharing?:\n    | boolean\n    | ((oldData: unknown | undefined, newData: unknown) => unknown)\n  _defaulted?: boolean\n  /**\n   * Additional payload to be stored on each query.\n   * Use this property to pass information that can be used in other places.\n   */\n  meta?: QueryMeta\n  /**\n   * Maximum number of pages to store in the data of an infinite query.\n   */\n  maxPages?: number\n}\n\nexport interface InitialPageParam<TPageParam = unknown> {\n  initialPageParam: TPageParam\n}\n\nexport interface InfiniteQueryPageParamsOptions<\n  TQueryFnData = unknown,\n  TPageParam = unknown,\n> extends InitialPageParam<TPageParam> {\n  /**\n   * This function can be set to automatically get the previous cursor for infinite queries.\n   * The result will also be used to determine the value of `hasPreviousPage`.\n   */\n  getPreviousPageParam?: GetPreviousPageParamFunction<TPageParam, TQueryFnData>\n  /**\n   * This function can be set to automatically get the next cursor for infinite queries.\n   * The result will also be used to determine the value of `hasNextPage`.\n   */\n  getNextPageParam: GetNextPageParamFunction<TPageParam, TQueryFnData>\n}\n\nexport type ThrowOnError<\n  TQueryFnData,\n  TError,\n  TQueryData,\n  TQueryKey extends QueryKey,\n> =\n  | boolean\n  | ((\n      error: TError,\n      query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n    ) => boolean)\n\nexport interface QueryObserverOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> extends WithRequired<\n    QueryOptions<TQueryFnData, TError, TQueryData, TQueryKey, TPageParam>,\n    'queryKey'\n  > {\n  /**\n   * Set this to `false` or a function that returns `false` to disable automatic refetching when the query mounts or changes query keys.\n   * To refetch the query, use the `refetch` method returned from the `useQuery` instance.\n   * Accepts a boolean or function that returns a boolean.\n   * Defaults to `true`.\n   */\n  enabled?: Enabled<TQueryFnData, TError, TQueryData, TQueryKey>\n  /**\n   * The time in milliseconds after data is considered stale.\n   * If set to `Infinity`, the data will never be considered stale.\n   * If set to a function, the function will be executed with the query to compute a `staleTime`.\n   * Defaults to `0`.\n   */\n  staleTime?: StaleTimeFunction<TQueryFnData, TError, TQueryData, TQueryKey>\n  /**\n   * If set to a number, the query will continuously refetch at this frequency in milliseconds.\n   * If set to a function, the function will be executed with the latest data and query to compute a frequency\n   * Defaults to `false`.\n   */\n  refetchInterval?:\n    | number\n    | false\n    | ((\n        query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n      ) => number | false | undefined)\n  /**\n   * If set to `true`, the query will continue to refetch while their tab/window is in the background.\n   * Defaults to `false`.\n   */\n  refetchIntervalInBackground?: boolean\n  /**\n   * If set to `true`, the query will refetch on window focus if the data is stale.\n   * If set to `false`, the query will not refetch on window focus.\n   * If set to `'always'`, the query will always refetch on window focus.\n   * If set to a function, the function will be executed with the latest data and query to compute the value.\n   * Defaults to `true`.\n   */\n  refetchOnWindowFocus?:\n    | boolean\n    | 'always'\n    | ((\n        query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n      ) => boolean | 'always')\n  /**\n   * If set to `true`, the query will refetch on reconnect if the data is stale.\n   * If set to `false`, the query will not refetch on reconnect.\n   * If set to `'always'`, the query will always refetch on reconnect.\n   * If set to a function, the function will be executed with the latest data and query to compute the value.\n   * Defaults to the value of `networkOnline` (`true`)\n   */\n  refetchOnReconnect?:\n    | boolean\n    | 'always'\n    | ((\n        query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n      ) => boolean | 'always')\n  /**\n   * If set to `true`, the query will refetch on mount if the data is stale.\n   * If set to `false`, will disable additional instances of a query to trigger background refetch.\n   * If set to `'always'`, the query will always refetch on mount.\n   * If set to a function, the function will be executed with the latest data and query to compute the value\n   * Defaults to `true`.\n   */\n  refetchOnMount?:\n    | boolean\n    | 'always'\n    | ((\n        query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n      ) => boolean | 'always')\n  /**\n   * If set to `false`, the query will not be retried on mount if it contains an error.\n   * Defaults to `true`.\n   */\n  retryOnMount?: boolean\n  /**\n   * If set, the component will only re-render if any of the listed properties change.\n   * When set to `['data', 'error']`, the component will only re-render when the `data` or `error` properties change.\n   * When set to `'all'`, the component will re-render whenever a query is updated.\n   * When set to a function, the function will be executed to compute the list of properties.\n   * By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.\n   */\n  notifyOnChangeProps?: NotifyOnChangeProps\n  /**\n   * Whether errors should be thrown instead of setting the `error` property.\n   * If set to `true` or `suspense` is `true`, all errors will be thrown to the error boundary.\n   * If set to `false` and `suspense` is `false`, errors are returned as state.\n   * If set to a function, it will be passed the error and the query, and it should return a boolean indicating whether to show the error in an error boundary (`true`) or return the error as state (`false`).\n   * Defaults to `false`.\n   */\n  throwOnError?: ThrowOnError<TQueryFnData, TError, TQueryData, TQueryKey>\n  /**\n   * This option can be used to transform or select a part of the data returned by the query function.\n   */\n  select?: (data: TQueryData) => TData\n  /**\n   * If set to `true`, the query will suspend when `status === 'pending'`\n   * and throw errors when `status === 'error'`.\n   * Defaults to `false`.\n   */\n  suspense?: boolean\n  /**\n   * If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `loading` data and no initialData has been provided.\n   */\n  placeholderData?:\n    | NonFunctionGuard<TQueryData>\n    | PlaceholderDataFunction<\n        NonFunctionGuard<TQueryData>,\n        TError,\n        NonFunctionGuard<TQueryData>,\n        TQueryKey\n      >\n\n  _optimisticResults?: 'optimistic' | 'isRestoring'\n\n  /**\n   * Enable prefetching during rendering\n   */\n  experimental_prefetchInRender?: boolean\n}\n\nexport type WithRequired<TTarget, TKey extends keyof TTarget> = TTarget & {\n  [_ in TKey]: {}\n}\n\nexport type DefaultedQueryObserverOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = WithRequired<\n  QueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  'throwOnError' | 'refetchOnReconnect' | 'queryHash'\n>\n\nexport interface InfiniteQueryObserverOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> extends QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      InfiniteData<TQueryFnData, TPageParam>,\n      TQueryKey,\n      TPageParam\n    >,\n    InfiniteQueryPageParamsOptions<TQueryFnData, TPageParam> {}\n\nexport type DefaultedInfiniteQueryObserverOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> = WithRequired<\n  InfiniteQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  >,\n  'throwOnError' | 'refetchOnReconnect' | 'queryHash'\n>\n\nexport interface FetchQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> extends WithRequired<\n    QueryOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>,\n    'queryKey'\n  > {\n  initialPageParam?: never\n  /**\n   * The time in milliseconds after data is considered stale.\n   * If the data is fresh it will be returned from the cache.\n   */\n  staleTime?: StaleTimeFunction<TQueryFnData, TError, TData, TQueryKey>\n}\n\nexport interface EnsureQueryDataOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> extends FetchQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  > {\n  revalidateIfStale?: boolean\n}\n\nexport type EnsureInfiniteQueryDataOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> = FetchInfiniteQueryOptions<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey,\n  TPageParam\n> & {\n  revalidateIfStale?: boolean\n}\n\ntype FetchInfiniteQueryPages<TQueryFnData = unknown, TPageParam = unknown> =\n  | { pages?: never }\n  | {\n      pages: number\n      getNextPageParam: GetNextPageParamFunction<TPageParam, TQueryFnData>\n    }\n\nexport type FetchInfiniteQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> = Omit<\n  FetchQueryOptions<\n    TQueryFnData,\n    TError,\n    InfiniteData<TData, TPageParam>,\n    TQueryKey,\n    TPageParam\n  >,\n  'initialPageParam'\n> &\n  InitialPageParam<TPageParam> &\n  FetchInfiniteQueryPages<TQueryFnData, TPageParam>\n\nexport interface ResultOptions {\n  throwOnError?: boolean\n}\n\nexport interface RefetchOptions extends ResultOptions {\n  /**\n   * If set to `true`, a currently running request will be cancelled before a new request is made\n   *\n   * If set to `false`, no refetch will be made if there is already a request running.\n   *\n   * Defaults to `true`.\n   */\n  cancelRefetch?: boolean\n\n  updateMeta?: Record<string, unknown>\n}\n\nexport interface InvalidateQueryFilters<TQueryKey extends QueryKey = QueryKey>\n  extends QueryFilters<TQueryKey> {\n  refetchType?: QueryTypeFilter | 'none'\n}\n\nexport interface RefetchQueryFilters<TQueryKey extends QueryKey = QueryKey>\n  extends QueryFilters<TQueryKey> {}\n\nexport interface InvalidateOptions extends RefetchOptions {}\nexport interface ResetOptions extends RefetchOptions {}\n\nexport interface FetchNextPageOptions extends ResultOptions {\n  /**\n   * If set to `true`, calling `fetchNextPage` repeatedly will invoke `queryFn` every time,\n   * whether the previous invocation has resolved or not. Also, the result from previous invocations will be ignored.\n   *\n   * If set to `false`, calling `fetchNextPage` repeatedly won't have any effect until the first invocation has resolved.\n   *\n   * Defaults to `true`.\n   */\n  cancelRefetch?: boolean\n}\n\nexport interface FetchPreviousPageOptions extends ResultOptions {\n  /**\n   * If set to `true`, calling `fetchPreviousPage` repeatedly will invoke `queryFn` every time,\n   * whether the previous invocation has resolved or not. Also, the result from previous invocations will be ignored.\n   *\n   * If set to `false`, calling `fetchPreviousPage` repeatedly won't have any effect until the first invocation has resolved.\n   *\n   * Defaults to `true`.\n   */\n  cancelRefetch?: boolean\n}\n\nexport type QueryStatus = 'pending' | 'error' | 'success'\nexport type FetchStatus = 'fetching' | 'paused' | 'idle'\n\nexport interface QueryObserverBaseResult<\n  TData = unknown,\n  TError = DefaultError,\n> {\n  /**\n   * The last successfully resolved data for the query.\n   */\n  data: TData | undefined\n  /**\n   * The timestamp for when the query most recently returned the `status` as `\"success\"`.\n   */\n  dataUpdatedAt: number\n  /**\n   * The error object for the query, if an error was thrown.\n   * - Defaults to `null`.\n   */\n  error: TError | null\n  /**\n   * The timestamp for when the query most recently returned the `status` as `\"error\"`.\n   */\n  errorUpdatedAt: number\n  /**\n   * The failure count for the query.\n   * - Incremented every time the query fails.\n   * - Reset to `0` when the query succeeds.\n   */\n  failureCount: number\n  /**\n   * The failure reason for the query retry.\n   * - Reset to `null` when the query succeeds.\n   */\n  failureReason: TError | null\n  /**\n   * The sum of all errors.\n   */\n  errorUpdateCount: number\n  /**\n   * A derived boolean from the `status` variable, provided for convenience.\n   * - `true` if the query attempt resulted in an error.\n   */\n  isError: boolean\n  /**\n   * Will be `true` if the query has been fetched.\n   */\n  isFetched: boolean\n  /**\n   * Will be `true` if the query has been fetched after the component mounted.\n   * - This property can be used to not show any previously cached data.\n   */\n  isFetchedAfterMount: boolean\n  /**\n   * A derived boolean from the `fetchStatus` variable, provided for convenience.\n   * - `true` whenever the `queryFn` is executing, which includes initial `pending` as well as background refetch.\n   */\n  isFetching: boolean\n  /**\n   * Is `true` whenever the first fetch for a query is in-flight.\n   * - Is the same as `isFetching && isPending`.\n   */\n  isLoading: boolean\n  /**\n   * Will be `pending` if there's no cached data and no query attempt was finished yet.\n   */\n  isPending: boolean\n  /**\n   * Will be `true` if the query failed while fetching for the first time.\n   */\n  isLoadingError: boolean\n  /**\n   * @deprecated `isInitialLoading` is being deprecated in favor of `isLoading`\n   * and will be removed in the next major version.\n   */\n  isInitialLoading: boolean\n  /**\n   * A derived boolean from the `fetchStatus` variable, provided for convenience.\n   * - The query wanted to fetch, but has been `paused`.\n   */\n  isPaused: boolean\n  /**\n   * Will be `true` if the data shown is the placeholder data.\n   */\n  isPlaceholderData: boolean\n  /**\n   * Will be `true` if the query failed while refetching.\n   */\n  isRefetchError: boolean\n  /**\n   * Is `true` whenever a background refetch is in-flight, which _does not_ include initial `pending`.\n   * - Is the same as `isFetching && !isPending`.\n   */\n  isRefetching: boolean\n  /**\n   * Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.\n   */\n  isStale: boolean\n  /**\n   * A derived boolean from the `status` variable, provided for convenience.\n   * - `true` if the query has received a response with no errors and is ready to display its data.\n   */\n  isSuccess: boolean\n  /**\n   * A function to manually refetch the query.\n   */\n  refetch: (\n    options?: RefetchOptions,\n  ) => Promise<QueryObserverResult<TData, TError>>\n  /**\n   * The status of the query.\n   * - Will be:\n   *   - `pending` if there's no cached data and no query attempt was finished yet.\n   *   - `error` if the query attempt resulted in an error.\n   *   - `success` if the query has received a response with no errors and is ready to display its data.\n   */\n  status: QueryStatus\n  /**\n   * The fetch status of the query.\n   * - `fetching`: Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetch.\n   * - `paused`: The query wanted to fetch, but has been `paused`.\n   * - `idle`: The query is not fetching.\n   * - See [Network Mode](https://tanstack.com/query/latest/docs/framework/react/guides/network-mode) for more information.\n   */\n  fetchStatus: FetchStatus\n  /**\n   * A stable promise that will be resolved with the data of the query.\n   * Requires the `experimental_prefetchInRender` feature flag to be enabled.\n   * @example\n   *\n   * ### Enabling the feature flag\n   * ```ts\n   * const client = new QueryClient({\n   *   defaultOptions: {\n   *     queries: {\n   *       experimental_prefetchInRender: true,\n   *     },\n   *   },\n   * })\n   * ```\n   *\n   * ### Usage\n   * ```tsx\n   * import { useQuery } from '@tanstack/react-query'\n   * import React from 'react'\n   * import { fetchTodos, type Todo } from './api'\n   *\n   * function TodoList({ query }: { query: UseQueryResult<Todo[], Error> }) {\n   *   const data = React.use(query.promise)\n   *\n   *   return (\n   *     <ul>\n   *       {data.map(todo => (\n   *         <li key={todo.id}>{todo.title}</li>\n   *       ))}\n   *     </ul>\n   *   )\n   * }\n   *\n   * export function App() {\n   *   const query = useQuery({ queryKey: ['todos'], queryFn: fetchTodos })\n   *\n   *   return (\n   *     <>\n   *       <h1>Todos</h1>\n   *       <React.Suspense fallback={<div>Loading...</div>}>\n   *         <TodoList query={query} />\n   *       </React.Suspense>\n   *     </>\n   *   )\n   * }\n   * ```\n   */\n  promise: Promise<TData>\n}\n\nexport interface QueryObserverPendingResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: null\n  isError: false\n  isPending: true\n  isLoadingError: false\n  isRefetchError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'pending'\n}\n\nexport interface QueryObserverLoadingResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: null\n  isError: false\n  isPending: true\n  isLoading: true\n  isLoadingError: false\n  isRefetchError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'pending'\n}\n\nexport interface QueryObserverLoadingErrorResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: TError\n  isError: true\n  isPending: false\n  isLoading: false\n  isLoadingError: true\n  isRefetchError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'error'\n}\n\nexport interface QueryObserverRefetchErrorResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: TData\n  error: TError\n  isError: true\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: true\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'error'\n}\n\nexport interface QueryObserverSuccessResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: TData\n  error: null\n  isError: false\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: false\n  isSuccess: true\n  isPlaceholderData: false\n  status: 'success'\n}\n\nexport interface QueryObserverPlaceholderResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: TData\n  isError: false\n  error: null\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: false\n  isSuccess: true\n  isPlaceholderData: true\n  status: 'success'\n}\n\nexport type DefinedQueryObserverResult<\n  TData = unknown,\n  TError = DefaultError,\n> =\n  | QueryObserverRefetchErrorResult<TData, TError>\n  | QueryObserverSuccessResult<TData, TError>\n\nexport type QueryObserverResult<TData = unknown, TError = DefaultError> =\n  | DefinedQueryObserverResult<TData, TError>\n  | QueryObserverLoadingErrorResult<TData, TError>\n  | QueryObserverLoadingResult<TData, TError>\n  | QueryObserverPendingResult<TData, TError>\n  | QueryObserverPlaceholderResult<TData, TError>\n\nexport interface InfiniteQueryObserverBaseResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  /**\n   * This function allows you to fetch the next \"page\" of results.\n   */\n  fetchNextPage: (\n    options?: FetchNextPageOptions,\n  ) => Promise<InfiniteQueryObserverResult<TData, TError>>\n  /**\n   * This function allows you to fetch the previous \"page\" of results.\n   */\n  fetchPreviousPage: (\n    options?: FetchPreviousPageOptions,\n  ) => Promise<InfiniteQueryObserverResult<TData, TError>>\n  /**\n   * Will be `true` if there is a next page to be fetched (known via the `getNextPageParam` option).\n   */\n  hasNextPage: boolean\n  /**\n   * Will be `true` if there is a previous page to be fetched (known via the `getPreviousPageParam` option).\n   */\n  hasPreviousPage: boolean\n  /**\n   * Will be `true` if the query failed while fetching the next page.\n   */\n  isFetchNextPageError: boolean\n  /**\n   * Will be `true` while fetching the next page with `fetchNextPage`.\n   */\n  isFetchingNextPage: boolean\n  /**\n   * Will be `true` if the query failed while fetching the previous page.\n   */\n  isFetchPreviousPageError: boolean\n  /**\n   * Will be `true` while fetching the previous page with `fetchPreviousPage`.\n   */\n  isFetchingPreviousPage: boolean\n}\n\nexport interface InfiniteQueryObserverPendingResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: null\n  isError: false\n  isPending: true\n  isLoadingError: false\n  isRefetchError: false\n  isFetchNextPageError: false\n  isFetchPreviousPageError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'pending'\n}\n\nexport interface InfiniteQueryObserverLoadingResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: null\n  isError: false\n  isPending: true\n  isLoading: true\n  isLoadingError: false\n  isRefetchError: false\n  isFetchNextPageError: false\n  isFetchPreviousPageError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'pending'\n}\n\nexport interface InfiniteQueryObserverLoadingErrorResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: TError\n  isError: true\n  isPending: false\n  isLoading: false\n  isLoadingError: true\n  isRefetchError: false\n  isFetchNextPageError: false\n  isFetchPreviousPageError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'error'\n}\n\nexport interface InfiniteQueryObserverRefetchErrorResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: TData\n  error: TError\n  isError: true\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: true\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'error'\n}\n\nexport interface InfiniteQueryObserverSuccessResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: TData\n  error: null\n  isError: false\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: false\n  isFetchNextPageError: false\n  isFetchPreviousPageError: false\n  isSuccess: true\n  isPlaceholderData: false\n  status: 'success'\n}\n\nexport interface InfiniteQueryObserverPlaceholderResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: TData\n  isError: false\n  error: null\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: false\n  isSuccess: true\n  isPlaceholderData: true\n  isFetchNextPageError: false\n  isFetchPreviousPageError: false\n  status: 'success'\n}\n\nexport type DefinedInfiniteQueryObserverResult<\n  TData = unknown,\n  TError = DefaultError,\n> =\n  | InfiniteQueryObserverRefetchErrorResult<TData, TError>\n  | InfiniteQueryObserverSuccessResult<TData, TError>\n\nexport type InfiniteQueryObserverResult<\n  TData = unknown,\n  TError = DefaultError,\n> =\n  | DefinedInfiniteQueryObserverResult<TData, TError>\n  | InfiniteQueryObserverLoadingErrorResult<TData, TError>\n  | InfiniteQueryObserverLoadingResult<TData, TError>\n  | InfiniteQueryObserverPendingResult<TData, TError>\n  | InfiniteQueryObserverPlaceholderResult<TData, TError>\n\nexport type MutationKey = Register extends {\n  mutationKey: infer TMutationKey\n}\n  ? TMutationKey extends Array<unknown>\n    ? TMutationKey\n    : TMutationKey extends Array<unknown>\n      ? TMutationKey\n      : ReadonlyArray<unknown>\n  : ReadonlyArray<unknown>\n\nexport type MutationStatus = 'idle' | 'pending' | 'success' | 'error'\n\nexport type MutationScope = {\n  id: string\n}\n\nexport type MutationMeta = Register extends {\n  mutationMeta: infer TMutationMeta\n}\n  ? TMutationMeta extends Record<string, unknown>\n    ? TMutationMeta\n    : Record<string, unknown>\n  : Record<string, unknown>\n\nexport type MutationFunction<TData = unknown, TVariables = unknown> = (\n  variables: TVariables,\n) => Promise<TData>\n\nexport interface MutationOptions<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> {\n  mutationFn?: MutationFunction<TData, TVariables>\n  mutationKey?: MutationKey\n  onMutate?: (\n    variables: TVariables,\n  ) => Promise<TContext | undefined> | TContext | undefined\n  onSuccess?: (\n    data: TData,\n    variables: TVariables,\n    context: TContext,\n  ) => Promise<unknown> | unknown\n  onError?: (\n    error: TError,\n    variables: TVariables,\n    context: TContext | undefined,\n  ) => Promise<unknown> | unknown\n  onSettled?: (\n    data: TData | undefined,\n    error: TError | null,\n    variables: TVariables,\n    context: TContext | undefined,\n  ) => Promise<unknown> | unknown\n  retry?: RetryValue<TError>\n  retryDelay?: RetryDelayValue<TError>\n  networkMode?: NetworkMode\n  gcTime?: number\n  _defaulted?: boolean\n  meta?: MutationMeta\n  scope?: MutationScope\n}\n\nexport interface MutationObserverOptions<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationOptions<TData, TError, TVariables, TContext> {\n  throwOnError?: boolean | ((error: TError) => boolean)\n}\n\nexport interface MutateOptions<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> {\n  onSuccess?: (data: TData, variables: TVariables, context: TContext) => void\n  onError?: (\n    error: TError,\n    variables: TVariables,\n    context: TContext | undefined,\n  ) => void\n  onSettled?: (\n    data: TData | undefined,\n    error: TError | null,\n    variables: TVariables,\n    context: TContext | undefined,\n  ) => void\n}\n\nexport type MutateFunction<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> = (\n  variables: TVariables,\n  options?: MutateOptions<TData, TError, TVariables, TContext>,\n) => Promise<TData>\n\nexport interface MutationObserverBaseResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationState<TData, TError, TVariables, TContext> {\n  /**\n   * The last successfully resolved data for the mutation.\n   */\n  data: TData | undefined\n  /**\n   * The variables object passed to the `mutationFn`.\n   */\n  variables: TVariables | undefined\n  /**\n   * The error object for the mutation, if an error was encountered.\n   * - Defaults to `null`.\n   */\n  error: TError | null\n  /**\n   * A boolean variable derived from `status`.\n   * - `true` if the last mutation attempt resulted in an error.\n   */\n  isError: boolean\n  /**\n   * A boolean variable derived from `status`.\n   * - `true` if the mutation is in its initial state prior to executing.\n   */\n  isIdle: boolean\n  /**\n   * A boolean variable derived from `status`.\n   * - `true` if the mutation is currently executing.\n   */\n  isPending: boolean\n  /**\n   * A boolean variable derived from `status`.\n   * - `true` if the last mutation attempt was successful.\n   */\n  isSuccess: boolean\n  /**\n   * The status of the mutation.\n   * - Will be:\n   *   - `idle` initial status prior to the mutation function executing.\n   *   - `pending` if the mutation is currently executing.\n   *   - `error` if the last mutation attempt resulted in an error.\n   *   - `success` if the last mutation attempt was successful.\n   */\n  status: MutationStatus\n  /**\n   * The mutation function you can call with variables to trigger the mutation and optionally hooks on additional callback options.\n   * @param variables - The variables object to pass to the `mutationFn`.\n   * @param options.onSuccess - This function will fire when the mutation is successful and will be passed the mutation's result.\n   * @param options.onError - This function will fire if the mutation encounters an error and will be passed the error.\n   * @param options.onSettled - This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error.\n   * @remarks\n   * - If you make multiple requests, `onSuccess` will fire only after the latest call you've made.\n   * - All the callback functions (`onSuccess`, `onError`, `onSettled`) are void functions, and the returned value will be ignored.\n   */\n  mutate: MutateFunction<TData, TError, TVariables, TContext>\n  /**\n   * A function to clean the mutation internal state (i.e., it resets the mutation to its initial state).\n   */\n  reset: () => void\n}\n\nexport interface MutationObserverIdleResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationObserverBaseResult<TData, TError, TVariables, TContext> {\n  data: undefined\n  variables: undefined\n  error: null\n  isError: false\n  isIdle: true\n  isPending: false\n  isSuccess: false\n  status: 'idle'\n}\n\nexport interface MutationObserverLoadingResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationObserverBaseResult<TData, TError, TVariables, TContext> {\n  data: undefined\n  variables: TVariables\n  error: null\n  isError: false\n  isIdle: false\n  isPending: true\n  isSuccess: false\n  status: 'pending'\n}\n\nexport interface MutationObserverErrorResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationObserverBaseResult<TData, TError, TVariables, TContext> {\n  data: undefined\n  error: TError\n  variables: TVariables\n  isError: true\n  isIdle: false\n  isPending: false\n  isSuccess: false\n  status: 'error'\n}\n\nexport interface MutationObserverSuccessResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationObserverBaseResult<TData, TError, TVariables, TContext> {\n  data: TData\n  error: null\n  variables: TVariables\n  isError: false\n  isIdle: false\n  isPending: false\n  isSuccess: true\n  status: 'success'\n}\n\nexport type MutationObserverResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> =\n  | MutationObserverIdleResult<TData, TError, TVariables, TContext>\n  | MutationObserverLoadingResult<TData, TError, TVariables, TContext>\n  | MutationObserverErrorResult<TData, TError, TVariables, TContext>\n  | MutationObserverSuccessResult<TData, TError, TVariables, TContext>\n\nexport interface QueryClientConfig {\n  queryCache?: QueryCache\n  mutationCache?: MutationCache\n  defaultOptions?: DefaultOptions\n}\n\nexport interface DefaultOptions<TError = DefaultError> {\n  queries?: OmitKeyof<\n    QueryObserverOptions<unknown, TError>,\n    'suspense' | 'queryKey'\n  >\n  mutations?: MutationObserverOptions<unknown, TError, unknown, unknown>\n  hydrate?: HydrateOptions['defaultOptions']\n  dehydrate?: DehydrateOptions\n}\n\nexport interface CancelOptions {\n  revert?: boolean\n  silent?: boolean\n}\n\nexport interface SetDataOptions {\n  updatedAt?: number\n}\n\nexport type NotifyEventType =\n  | 'added'\n  | 'removed'\n  | 'updated'\n  | 'observerAdded'\n  | 'observerRemoved'\n  | 'observerResultsUpdated'\n  | 'observerOptionsUpdated'\n\nexport interface NotifyEvent {\n  type: NotifyEventType\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA8DO,IAAM,gBAAgB,OAAO,eAAe;AAE5C,IAAM,qBAAqB,OAAO,oBAAoB;AAEtD,IAAM,cAAc,OAAO,aAAa;","names":[]}
\ No newline at end of file
diff --git a/build/legacy/types.d.cts b/build/legacy/types.d.cts
index 2a21e2164c6adabc963945a2c7a192de945cc476..8db71ac4606137e1524fe45ce11bbb254ebc7a60 100644
--- a/build/legacy/types.d.cts
+++ b/build/legacy/types.d.cts
@@ -1,3 +1,3 @@
-export { T as AnyDataTag, b6 as CancelOptions, V as DataTag, G as DefaultError, b5 as DefaultOptions, ak as DefaultedInfiniteQueryObserverOptions, ai as DefaultedQueryObserverOptions, aP as DefinedInfiniteQueryObserverResult, aG as DefinedQueryObserverResult, B as DistributiveOmit, $ as Enabled, an as EnsureInfiniteQueryDataOptions, am as EnsureQueryDataOptions, ao as FetchInfiniteQueryOptions, av as FetchNextPageOptions, aw as FetchPreviousPageOptions, al as FetchQueryOptions, ay as FetchStatus, a7 as GetNextPageParamFunction, a6 as GetPreviousPageParamFunction, W as InferDataFromTag, X as InferErrorFromTag, a8 as InfiniteData, aI as InfiniteQueryObserverBaseResult, aL as InfiniteQueryObserverLoadingErrorResult, aK as InfiniteQueryObserverLoadingResult, aj as InfiniteQueryObserverOptions, aJ as InfiniteQueryObserverPendingResult, aO as InfiniteQueryObserverPlaceholderResult, aM as InfiniteQueryObserverRefetchErrorResult, aQ as InfiniteQueryObserverResult, aN as InfiniteQueryObserverSuccessResult, ae as InfiniteQueryPageParamsOptions, a2 as InitialDataFunction, ad as InitialPageParam, at as InvalidateOptions, ar as InvalidateQueryFilters, aZ as MutateFunction, aY as MutateOptions, aV as MutationFunction, aR as MutationKey, aU as MutationMeta, a_ as MutationObserverBaseResult, b1 as MutationObserverErrorResult, a$ as MutationObserverIdleResult, b0 as MutationObserverLoadingResult, aX as MutationObserverOptions, b3 as MutationObserverResult, b2 as MutationObserverSuccessResult, aW as MutationOptions, aT as MutationScope, aS as MutationStatus, aa as NetworkMode, F as NoInfer, N as NonUndefinedGuard, b9 as NotifyEvent, b8 as NotifyEventType, ab as NotifyOnChangeProps, O as OmitKeyof, E as Override, a3 as PlaceholderDataFunction, a4 as QueriesPlaceholderDataFunction, b4 as QueryClientConfig, Y as QueryFunction, a1 as QueryFunctionContext, I as QueryKey, a5 as QueryKeyHashFunction, a9 as QueryMeta, az as QueryObserverBaseResult, aC as QueryObserverLoadingErrorResult, aB as QueryObserverLoadingResult, ag as QueryObserverOptions, aA as QueryObserverPendingResult, aF as QueryObserverPlaceholderResult, aD as QueryObserverRefetchErrorResult, aH as QueryObserverResult, aE as QueryObserverSuccessResult, ac as QueryOptions, a0 as QueryPersister, ax as QueryStatus, aq as RefetchOptions, as as RefetchQueryFilters, R as Register, au as ResetOptions, ap as ResultOptions, b7 as SetDataOptions, Z as StaleTime, _ as StaleTimeFunction, af as ThrowOnError, P as UnsetMarker, ah as WithRequired, K as dataTagErrorSymbol, J as dataTagSymbol, L as unsetMarker } from './hydration-CdBkFt9i.cjs';
+export { T as AnyDataTag, b6 as CancelOptions, V as DataTag, G as DefaultError, b5 as DefaultOptions, ak as DefaultedInfiniteQueryObserverOptions, ai as DefaultedQueryObserverOptions, aP as DefinedInfiniteQueryObserverResult, aG as DefinedQueryObserverResult, B as DistributiveOmit, $ as Enabled, an as EnsureInfiniteQueryDataOptions, am as EnsureQueryDataOptions, ao as FetchInfiniteQueryOptions, av as FetchNextPageOptions, aw as FetchPreviousPageOptions, al as FetchQueryOptions, ay as FetchStatus, a7 as GetNextPageParamFunction, a6 as GetPreviousPageParamFunction, W as InferDataFromTag, X as InferErrorFromTag, a8 as InfiniteData, aI as InfiniteQueryObserverBaseResult, aL as InfiniteQueryObserverLoadingErrorResult, aK as InfiniteQueryObserverLoadingResult, aj as InfiniteQueryObserverOptions, aJ as InfiniteQueryObserverPendingResult, aO as InfiniteQueryObserverPlaceholderResult, aM as InfiniteQueryObserverRefetchErrorResult, aQ as InfiniteQueryObserverResult, aN as InfiniteQueryObserverSuccessResult, ae as InfiniteQueryPageParamsOptions, a2 as InitialDataFunction, ad as InitialPageParam, at as InvalidateOptions, ar as InvalidateQueryFilters, aZ as MutateFunction, aY as MutateOptions, aV as MutationFunction, aR as MutationKey, aU as MutationMeta, a_ as MutationObserverBaseResult, b1 as MutationObserverErrorResult, a$ as MutationObserverIdleResult, b0 as MutationObserverLoadingResult, aX as MutationObserverOptions, b3 as MutationObserverResult, b2 as MutationObserverSuccessResult, aW as MutationOptions, aT as MutationScope, aS as MutationStatus, aa as NetworkMode, F as NoInfer, N as NonUndefinedGuard, b9 as NotifyEvent, b8 as NotifyEventType, ab as NotifyOnChangeProps, O as OmitKeyof, E as Override, a3 as PlaceholderDataFunction, a4 as QueriesPlaceholderDataFunction, b4 as QueryClientConfig, Y as QueryFunction, a1 as QueryFunctionContext, I as QueryKey, a5 as QueryKeyHashFunction, a9 as QueryMeta, az as QueryObserverBaseResult, aC as QueryObserverLoadingErrorResult, aB as QueryObserverLoadingResult, ag as QueryObserverOptions, aA as QueryObserverPendingResult, aF as QueryObserverPlaceholderResult, aD as QueryObserverRefetchErrorResult, aH as QueryObserverResult, aE as QueryObserverSuccessResult, ac as QueryOptions, a0 as QueryPersister, ax as QueryStatus, aq as RefetchOptions, as as RefetchQueryFilters, R as Register, au as ResetOptions, ap as ResultOptions, b7 as SetDataOptions, Z as StaleTime, _ as StaleTimeFunction, af as ThrowOnError, P as UnsetMarker, ah as WithRequired, K as dataTagErrorSymbol, J as dataTagSymbol, L as unsetMarker } from './hydration-Dv1t2VQO.cjs';
 import './removable.cjs';
 import './subscribable.cjs';
diff --git a/build/legacy/types.d.ts b/build/legacy/types.d.ts
index 2dbce3d23404ae403761c9724e9d1216e7482973..2e8efb08886d46461a529058f834605a08e2f938 100644
--- a/build/legacy/types.d.ts
+++ b/build/legacy/types.d.ts
@@ -1,3 +1,3 @@
-export { T as AnyDataTag, b6 as CancelOptions, V as DataTag, G as DefaultError, b5 as DefaultOptions, ak as DefaultedInfiniteQueryObserverOptions, ai as DefaultedQueryObserverOptions, aP as DefinedInfiniteQueryObserverResult, aG as DefinedQueryObserverResult, B as DistributiveOmit, $ as Enabled, an as EnsureInfiniteQueryDataOptions, am as EnsureQueryDataOptions, ao as FetchInfiniteQueryOptions, av as FetchNextPageOptions, aw as FetchPreviousPageOptions, al as FetchQueryOptions, ay as FetchStatus, a7 as GetNextPageParamFunction, a6 as GetPreviousPageParamFunction, W as InferDataFromTag, X as InferErrorFromTag, a8 as InfiniteData, aI as InfiniteQueryObserverBaseResult, aL as InfiniteQueryObserverLoadingErrorResult, aK as InfiniteQueryObserverLoadingResult, aj as InfiniteQueryObserverOptions, aJ as InfiniteQueryObserverPendingResult, aO as InfiniteQueryObserverPlaceholderResult, aM as InfiniteQueryObserverRefetchErrorResult, aQ as InfiniteQueryObserverResult, aN as InfiniteQueryObserverSuccessResult, ae as InfiniteQueryPageParamsOptions, a2 as InitialDataFunction, ad as InitialPageParam, at as InvalidateOptions, ar as InvalidateQueryFilters, aZ as MutateFunction, aY as MutateOptions, aV as MutationFunction, aR as MutationKey, aU as MutationMeta, a_ as MutationObserverBaseResult, b1 as MutationObserverErrorResult, a$ as MutationObserverIdleResult, b0 as MutationObserverLoadingResult, aX as MutationObserverOptions, b3 as MutationObserverResult, b2 as MutationObserverSuccessResult, aW as MutationOptions, aT as MutationScope, aS as MutationStatus, aa as NetworkMode, F as NoInfer, N as NonUndefinedGuard, b9 as NotifyEvent, b8 as NotifyEventType, ab as NotifyOnChangeProps, O as OmitKeyof, E as Override, a3 as PlaceholderDataFunction, a4 as QueriesPlaceholderDataFunction, b4 as QueryClientConfig, Y as QueryFunction, a1 as QueryFunctionContext, I as QueryKey, a5 as QueryKeyHashFunction, a9 as QueryMeta, az as QueryObserverBaseResult, aC as QueryObserverLoadingErrorResult, aB as QueryObserverLoadingResult, ag as QueryObserverOptions, aA as QueryObserverPendingResult, aF as QueryObserverPlaceholderResult, aD as QueryObserverRefetchErrorResult, aH as QueryObserverResult, aE as QueryObserverSuccessResult, ac as QueryOptions, a0 as QueryPersister, ax as QueryStatus, aq as RefetchOptions, as as RefetchQueryFilters, R as Register, au as ResetOptions, ap as ResultOptions, b7 as SetDataOptions, Z as StaleTime, _ as StaleTimeFunction, af as ThrowOnError, P as UnsetMarker, ah as WithRequired, K as dataTagErrorSymbol, J as dataTagSymbol, L as unsetMarker } from './hydration-Cr-4Kky1.js';
+export { T as AnyDataTag, b6 as CancelOptions, V as DataTag, G as DefaultError, b5 as DefaultOptions, ak as DefaultedInfiniteQueryObserverOptions, ai as DefaultedQueryObserverOptions, aP as DefinedInfiniteQueryObserverResult, aG as DefinedQueryObserverResult, B as DistributiveOmit, $ as Enabled, an as EnsureInfiniteQueryDataOptions, am as EnsureQueryDataOptions, ao as FetchInfiniteQueryOptions, av as FetchNextPageOptions, aw as FetchPreviousPageOptions, al as FetchQueryOptions, ay as FetchStatus, a7 as GetNextPageParamFunction, a6 as GetPreviousPageParamFunction, W as InferDataFromTag, X as InferErrorFromTag, a8 as InfiniteData, aI as InfiniteQueryObserverBaseResult, aL as InfiniteQueryObserverLoadingErrorResult, aK as InfiniteQueryObserverLoadingResult, aj as InfiniteQueryObserverOptions, aJ as InfiniteQueryObserverPendingResult, aO as InfiniteQueryObserverPlaceholderResult, aM as InfiniteQueryObserverRefetchErrorResult, aQ as InfiniteQueryObserverResult, aN as InfiniteQueryObserverSuccessResult, ae as InfiniteQueryPageParamsOptions, a2 as InitialDataFunction, ad as InitialPageParam, at as InvalidateOptions, ar as InvalidateQueryFilters, aZ as MutateFunction, aY as MutateOptions, aV as MutationFunction, aR as MutationKey, aU as MutationMeta, a_ as MutationObserverBaseResult, b1 as MutationObserverErrorResult, a$ as MutationObserverIdleResult, b0 as MutationObserverLoadingResult, aX as MutationObserverOptions, b3 as MutationObserverResult, b2 as MutationObserverSuccessResult, aW as MutationOptions, aT as MutationScope, aS as MutationStatus, aa as NetworkMode, F as NoInfer, N as NonUndefinedGuard, b9 as NotifyEvent, b8 as NotifyEventType, ab as NotifyOnChangeProps, O as OmitKeyof, E as Override, a3 as PlaceholderDataFunction, a4 as QueriesPlaceholderDataFunction, b4 as QueryClientConfig, Y as QueryFunction, a1 as QueryFunctionContext, I as QueryKey, a5 as QueryKeyHashFunction, a9 as QueryMeta, az as QueryObserverBaseResult, aC as QueryObserverLoadingErrorResult, aB as QueryObserverLoadingResult, ag as QueryObserverOptions, aA as QueryObserverPendingResult, aF as QueryObserverPlaceholderResult, aD as QueryObserverRefetchErrorResult, aH as QueryObserverResult, aE as QueryObserverSuccessResult, ac as QueryOptions, a0 as QueryPersister, ax as QueryStatus, aq as RefetchOptions, as as RefetchQueryFilters, R as Register, au as ResetOptions, ap as ResultOptions, b7 as SetDataOptions, Z as StaleTime, _ as StaleTimeFunction, af as ThrowOnError, P as UnsetMarker, ah as WithRequired, K as dataTagErrorSymbol, J as dataTagSymbol, L as unsetMarker } from './hydration-Dwnp99qT.js';
 import './removable.js';
 import './subscribable.js';
diff --git a/build/legacy/types.js.map b/build/legacy/types.js.map
index 77e4a7be6832dc873927a4173037d889560607d0..d31bade5093542e58311c145de5dbbd0267b89e5 100644
--- a/build/legacy/types.js.map
+++ b/build/legacy/types.js.map
@@ -1 +1 @@
-{"version":3,"sources":["../../src/types.ts"],"sourcesContent":["/* istanbul ignore file */\n\nimport type { QueryClient } from './queryClient'\nimport type { DehydrateOptions, HydrateOptions } from './hydration'\nimport type { MutationState } from './mutation'\nimport type { FetchDirection, Query, QueryBehavior } from './query'\nimport type { RetryDelayValue, RetryValue } from './retryer'\nimport type { QueryFilters, QueryTypeFilter, SkipToken } from './utils'\nimport type { QueryCache } from './queryCache'\nimport type { MutationCache } from './mutationCache'\n\nexport type NonUndefinedGuard<T> = T extends undefined ? never : T\n\nexport type DistributiveOmit<\n  TObject,\n  TKey extends keyof TObject,\n> = TObject extends any ? Omit<TObject, TKey> : never\n\nexport type OmitKeyof<\n  TObject,\n  TKey extends TStrictly extends 'safely'\n    ?\n        | keyof TObject\n        | (string & Record<never, never>)\n        | (number & Record<never, never>)\n        | (symbol & Record<never, never>)\n    : keyof TObject,\n  TStrictly extends 'strictly' | 'safely' = 'strictly',\n> = Omit<TObject, TKey>\n\nexport type Override<TTargetA, TTargetB> = {\n  [AKey in keyof TTargetA]: AKey extends keyof TTargetB\n    ? TTargetB[AKey]\n    : TTargetA[AKey]\n}\n\nexport type NoInfer<T> = [T][T extends any ? 0 : never]\n\nexport interface Register {\n  // defaultError: Error\n  // queryMeta: Record<string, unknown>\n  // mutationMeta: Record<string, unknown>\n  // queryKey: ReadonlyArray<unknown>\n  // mutationKey: ReadonlyArray<unknown>\n}\n\nexport type DefaultError = Register extends {\n  defaultError: infer TError\n}\n  ? TError\n  : Error\n\nexport type QueryKey = Register extends {\n  queryKey: infer TQueryKey\n}\n  ? TQueryKey extends ReadonlyArray<unknown>\n    ? TQueryKey\n    : TQueryKey extends Array<unknown>\n      ? TQueryKey\n      : ReadonlyArray<unknown>\n  : ReadonlyArray<unknown>\n\nexport const dataTagSymbol = Symbol('dataTagSymbol')\nexport type dataTagSymbol = typeof dataTagSymbol\nexport const dataTagErrorSymbol = Symbol('dataTagErrorSymbol')\nexport type dataTagErrorSymbol = typeof dataTagErrorSymbol\nexport const unsetMarker = Symbol('unsetMarker')\nexport type UnsetMarker = typeof unsetMarker\nexport type AnyDataTag = {\n  [dataTagSymbol]: any\n  [dataTagErrorSymbol]: any\n}\nexport type DataTag<\n  TType,\n  TValue,\n  TError = UnsetMarker,\n> = TType extends AnyDataTag\n  ? TType\n  : TType & {\n      [dataTagSymbol]: TValue\n      [dataTagErrorSymbol]: TError\n    }\n\nexport type InferDataFromTag<TQueryFnData, TTaggedQueryKey extends QueryKey> =\n  TTaggedQueryKey extends DataTag<unknown, infer TaggedValue, unknown>\n    ? TaggedValue\n    : TQueryFnData\n\nexport type InferErrorFromTag<TError, TTaggedQueryKey extends QueryKey> =\n  TTaggedQueryKey extends DataTag<unknown, unknown, infer TaggedError>\n    ? TaggedError extends UnsetMarker\n      ? TError\n      : TaggedError\n    : TError\n\nexport type QueryFunction<\n  T = unknown,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> = (context: QueryFunctionContext<TQueryKey, TPageParam>) => T | Promise<T>\n\nexport type StaleTime = number | 'static'\n\nexport type StaleTimeFunction<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> =\n  | StaleTime\n  | ((query: Query<TQueryFnData, TError, TData, TQueryKey>) => StaleTime)\n\nexport type Enabled<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> =\n  | boolean\n  | ((query: Query<TQueryFnData, TError, TData, TQueryKey>) => boolean)\n\nexport type QueryPersister<\n  T = unknown,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> = [TPageParam] extends [never]\n  ? (\n      queryFn: QueryFunction<T, TQueryKey, never>,\n      context: QueryFunctionContext<TQueryKey>,\n      query: Query,\n    ) => T | Promise<T>\n  : (\n      queryFn: QueryFunction<T, TQueryKey, TPageParam>,\n      context: QueryFunctionContext<TQueryKey>,\n      query: Query,\n    ) => T | Promise<T>\n\nexport type QueryFunctionContext<\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> = [TPageParam] extends [never]\n  ? {\n      client: QueryClient\n      queryKey: TQueryKey\n      signal: AbortSignal\n      meta: QueryMeta | undefined\n      pageParam?: unknown\n      /**\n       * @deprecated\n       * if you want access to the direction, you can add it to the pageParam\n       */\n      direction?: unknown\n    }\n  : {\n      client: QueryClient\n      queryKey: TQueryKey\n      signal: AbortSignal\n      pageParam: TPageParam\n      /**\n       * @deprecated\n       * if you want access to the direction, you can add it to the pageParam\n       */\n      direction: FetchDirection\n      meta: QueryMeta | undefined\n    }\n\nexport type InitialDataFunction<T> = () => T | undefined\n\ntype NonFunctionGuard<T> = T extends Function ? never : T\n\nexport type PlaceholderDataFunction<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = (\n  previousData: TQueryData | undefined,\n  previousQuery: Query<TQueryFnData, TError, TQueryData, TQueryKey> | undefined,\n) => TQueryData | undefined\n\nexport type QueriesPlaceholderDataFunction<TQueryData> = (\n  previousData: undefined,\n  previousQuery: undefined,\n) => TQueryData | undefined\n\nexport type QueryKeyHashFunction<TQueryKey extends QueryKey> = (\n  queryKey: TQueryKey,\n) => string\n\nexport type GetPreviousPageParamFunction<TPageParam, TQueryFnData = unknown> = (\n  firstPage: TQueryFnData,\n  allPages: Array<TQueryFnData>,\n  firstPageParam: TPageParam,\n  allPageParams: Array<TPageParam>,\n) => TPageParam | undefined | null\n\nexport type GetNextPageParamFunction<TPageParam, TQueryFnData = unknown> = (\n  lastPage: TQueryFnData,\n  allPages: Array<TQueryFnData>,\n  lastPageParam: TPageParam,\n  allPageParams: Array<TPageParam>,\n) => TPageParam | undefined | null\n\nexport interface InfiniteData<TData, TPageParam = unknown> {\n  pages: Array<TData>\n  pageParams: Array<TPageParam>\n}\n\nexport type QueryMeta = Register extends {\n  queryMeta: infer TQueryMeta\n}\n  ? TQueryMeta extends Record<string, unknown>\n    ? TQueryMeta\n    : Record<string, unknown>\n  : Record<string, unknown>\n\nexport type NetworkMode = 'online' | 'always' | 'offlineFirst'\n\nexport type NotifyOnChangeProps =\n  | Array<keyof InfiniteQueryObserverResult>\n  | 'all'\n  | undefined\n  | (() => Array<keyof InfiniteQueryObserverResult> | 'all' | undefined)\n\nexport interface QueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> {\n  /**\n   * If `false`, failed queries will not retry by default.\n   * If `true`, failed queries will retry infinitely., failureCount: num\n   * If set to an integer number, e.g. 3, failed queries will retry until the failed query count meets that number.\n   * If set to a function `(failureCount, error) => boolean` failed queries will retry until the function returns false.\n   */\n  retry?: RetryValue<TError>\n  retryDelay?: RetryDelayValue<TError>\n  networkMode?: NetworkMode\n  /**\n   * The time in milliseconds that unused/inactive cache data remains in memory.\n   * When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration.\n   * When different garbage collection times are specified, the longest one will be used.\n   * Setting it to `Infinity` will disable garbage collection.\n   */\n  gcTime?: number\n  queryFn?: QueryFunction<TQueryFnData, TQueryKey, TPageParam> | SkipToken\n  persister?: QueryPersister<\n    NoInfer<TQueryFnData>,\n    NoInfer<TQueryKey>,\n    NoInfer<TPageParam>\n  >\n  queryHash?: string\n  queryKey?: TQueryKey\n  queryKeyHashFn?: QueryKeyHashFunction<TQueryKey>\n  initialData?: TData | InitialDataFunction<TData>\n  initialDataUpdatedAt?: number | (() => number | undefined)\n  behavior?: QueryBehavior<TQueryFnData, TError, TData, TQueryKey>\n  /**\n   * Set this to `false` to disable structural sharing between query results.\n   * Set this to a function which accepts the old and new data and returns resolved data of the same type to implement custom structural sharing logic.\n   * Defaults to `true`.\n   */\n  structuralSharing?:\n    | boolean\n    | ((oldData: unknown | undefined, newData: unknown) => unknown)\n  _defaulted?: boolean\n  /**\n   * Additional payload to be stored on each query.\n   * Use this property to pass information that can be used in other places.\n   */\n  meta?: QueryMeta\n  /**\n   * Maximum number of pages to store in the data of an infinite query.\n   */\n  maxPages?: number\n}\n\nexport interface InitialPageParam<TPageParam = unknown> {\n  initialPageParam: TPageParam\n}\n\nexport interface InfiniteQueryPageParamsOptions<\n  TQueryFnData = unknown,\n  TPageParam = unknown,\n> extends InitialPageParam<TPageParam> {\n  /**\n   * This function can be set to automatically get the previous cursor for infinite queries.\n   * The result will also be used to determine the value of `hasPreviousPage`.\n   */\n  getPreviousPageParam?: GetPreviousPageParamFunction<TPageParam, TQueryFnData>\n  /**\n   * This function can be set to automatically get the next cursor for infinite queries.\n   * The result will also be used to determine the value of `hasNextPage`.\n   */\n  getNextPageParam: GetNextPageParamFunction<TPageParam, TQueryFnData>\n}\n\nexport type ThrowOnError<\n  TQueryFnData,\n  TError,\n  TQueryData,\n  TQueryKey extends QueryKey,\n> =\n  | boolean\n  | ((\n      error: TError,\n      query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n    ) => boolean)\n\nexport interface QueryObserverOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> extends WithRequired<\n    QueryOptions<TQueryFnData, TError, TQueryData, TQueryKey, TPageParam>,\n    'queryKey'\n  > {\n  /**\n   * Set this to `false` or a function that returns `false` to disable automatic refetching when the query mounts or changes query keys.\n   * To refetch the query, use the `refetch` method returned from the `useQuery` instance.\n   * Accepts a boolean or function that returns a boolean.\n   * Defaults to `true`.\n   */\n  enabled?: Enabled<TQueryFnData, TError, TQueryData, TQueryKey>\n  /**\n   * The time in milliseconds after data is considered stale.\n   * If set to `Infinity`, the data will never be considered stale.\n   * If set to a function, the function will be executed with the query to compute a `staleTime`.\n   * Defaults to `0`.\n   */\n  staleTime?: StaleTimeFunction<TQueryFnData, TError, TQueryData, TQueryKey>\n  /**\n   * If set to a number, the query will continuously refetch at this frequency in milliseconds.\n   * If set to a function, the function will be executed with the latest data and query to compute a frequency\n   * Defaults to `false`.\n   */\n  refetchInterval?:\n    | number\n    | false\n    | ((\n        query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n      ) => number | false | undefined)\n  /**\n   * If set to `true`, the query will continue to refetch while their tab/window is in the background.\n   * Defaults to `false`.\n   */\n  refetchIntervalInBackground?: boolean\n  /**\n   * If set to `true`, the query will refetch on window focus if the data is stale.\n   * If set to `false`, the query will not refetch on window focus.\n   * If set to `'always'`, the query will always refetch on window focus.\n   * If set to a function, the function will be executed with the latest data and query to compute the value.\n   * Defaults to `true`.\n   */\n  refetchOnWindowFocus?:\n    | boolean\n    | 'always'\n    | ((\n        query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n      ) => boolean | 'always')\n  /**\n   * If set to `true`, the query will refetch on reconnect if the data is stale.\n   * If set to `false`, the query will not refetch on reconnect.\n   * If set to `'always'`, the query will always refetch on reconnect.\n   * If set to a function, the function will be executed with the latest data and query to compute the value.\n   * Defaults to the value of `networkOnline` (`true`)\n   */\n  refetchOnReconnect?:\n    | boolean\n    | 'always'\n    | ((\n        query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n      ) => boolean | 'always')\n  /**\n   * If set to `true`, the query will refetch on mount if the data is stale.\n   * If set to `false`, will disable additional instances of a query to trigger background refetch.\n   * If set to `'always'`, the query will always refetch on mount.\n   * If set to a function, the function will be executed with the latest data and query to compute the value\n   * Defaults to `true`.\n   */\n  refetchOnMount?:\n    | boolean\n    | 'always'\n    | ((\n        query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n      ) => boolean | 'always')\n  /**\n   * If set to `false`, the query will not be retried on mount if it contains an error.\n   * Defaults to `true`.\n   */\n  retryOnMount?: boolean\n  /**\n   * If set, the component will only re-render if any of the listed properties change.\n   * When set to `['data', 'error']`, the component will only re-render when the `data` or `error` properties change.\n   * When set to `'all'`, the component will re-render whenever a query is updated.\n   * When set to a function, the function will be executed to compute the list of properties.\n   * By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.\n   */\n  notifyOnChangeProps?: NotifyOnChangeProps\n  /**\n   * Whether errors should be thrown instead of setting the `error` property.\n   * If set to `true` or `suspense` is `true`, all errors will be thrown to the error boundary.\n   * If set to `false` and `suspense` is `false`, errors are returned as state.\n   * If set to a function, it will be passed the error and the query, and it should return a boolean indicating whether to show the error in an error boundary (`true`) or return the error as state (`false`).\n   * Defaults to `false`.\n   */\n  throwOnError?: ThrowOnError<TQueryFnData, TError, TQueryData, TQueryKey>\n  /**\n   * This option can be used to transform or select a part of the data returned by the query function.\n   */\n  select?: (data: TQueryData) => TData\n  /**\n   * If set to `true`, the query will suspend when `status === 'pending'`\n   * and throw errors when `status === 'error'`.\n   * Defaults to `false`.\n   */\n  suspense?: boolean\n  /**\n   * If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `loading` data and no initialData has been provided.\n   */\n  placeholderData?:\n    | NonFunctionGuard<TQueryData>\n    | PlaceholderDataFunction<\n        NonFunctionGuard<TQueryData>,\n        TError,\n        NonFunctionGuard<TQueryData>,\n        TQueryKey\n      >\n\n  _optimisticResults?: 'optimistic' | 'isRestoring'\n\n  /**\n   * Enable prefetching during rendering\n   */\n  experimental_prefetchInRender?: boolean\n}\n\nexport type WithRequired<TTarget, TKey extends keyof TTarget> = TTarget & {\n  [_ in TKey]: {}\n}\n\nexport type DefaultedQueryObserverOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = WithRequired<\n  QueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  'throwOnError' | 'refetchOnReconnect' | 'queryHash'\n>\n\nexport interface InfiniteQueryObserverOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> extends QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      InfiniteData<TQueryFnData, TPageParam>,\n      TQueryKey,\n      TPageParam\n    >,\n    InfiniteQueryPageParamsOptions<TQueryFnData, TPageParam> {}\n\nexport type DefaultedInfiniteQueryObserverOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> = WithRequired<\n  InfiniteQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  >,\n  'throwOnError' | 'refetchOnReconnect' | 'queryHash'\n>\n\nexport interface FetchQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> extends WithRequired<\n    QueryOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>,\n    'queryKey'\n  > {\n  initialPageParam?: never\n  /**\n   * The time in milliseconds after data is considered stale.\n   * If the data is fresh it will be returned from the cache.\n   */\n  staleTime?: StaleTimeFunction<TQueryFnData, TError, TData, TQueryKey>\n}\n\nexport interface EnsureQueryDataOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> extends FetchQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  > {\n  revalidateIfStale?: boolean\n}\n\nexport type EnsureInfiniteQueryDataOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> = FetchInfiniteQueryOptions<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey,\n  TPageParam\n> & {\n  revalidateIfStale?: boolean\n}\n\ntype FetchInfiniteQueryPages<TQueryFnData = unknown, TPageParam = unknown> =\n  | { pages?: never }\n  | {\n      pages: number\n      getNextPageParam: GetNextPageParamFunction<TPageParam, TQueryFnData>\n    }\n\nexport type FetchInfiniteQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> = Omit<\n  FetchQueryOptions<\n    TQueryFnData,\n    TError,\n    InfiniteData<TData, TPageParam>,\n    TQueryKey,\n    TPageParam\n  >,\n  'initialPageParam'\n> &\n  InitialPageParam<TPageParam> &\n  FetchInfiniteQueryPages<TQueryFnData, TPageParam>\n\nexport interface ResultOptions {\n  throwOnError?: boolean\n}\n\nexport interface RefetchOptions extends ResultOptions {\n  /**\n   * If set to `true`, a currently running request will be cancelled before a new request is made\n   *\n   * If set to `false`, no refetch will be made if there is already a request running.\n   *\n   * Defaults to `true`.\n   */\n  cancelRefetch?: boolean\n}\n\nexport interface InvalidateQueryFilters<TQueryKey extends QueryKey = QueryKey>\n  extends QueryFilters<TQueryKey> {\n  refetchType?: QueryTypeFilter | 'none'\n}\n\nexport interface RefetchQueryFilters<TQueryKey extends QueryKey = QueryKey>\n  extends QueryFilters<TQueryKey> {}\n\nexport interface InvalidateOptions extends RefetchOptions {}\nexport interface ResetOptions extends RefetchOptions {}\n\nexport interface FetchNextPageOptions extends ResultOptions {\n  /**\n   * If set to `true`, calling `fetchNextPage` repeatedly will invoke `queryFn` every time,\n   * whether the previous invocation has resolved or not. Also, the result from previous invocations will be ignored.\n   *\n   * If set to `false`, calling `fetchNextPage` repeatedly won't have any effect until the first invocation has resolved.\n   *\n   * Defaults to `true`.\n   */\n  cancelRefetch?: boolean\n}\n\nexport interface FetchPreviousPageOptions extends ResultOptions {\n  /**\n   * If set to `true`, calling `fetchPreviousPage` repeatedly will invoke `queryFn` every time,\n   * whether the previous invocation has resolved or not. Also, the result from previous invocations will be ignored.\n   *\n   * If set to `false`, calling `fetchPreviousPage` repeatedly won't have any effect until the first invocation has resolved.\n   *\n   * Defaults to `true`.\n   */\n  cancelRefetch?: boolean\n}\n\nexport type QueryStatus = 'pending' | 'error' | 'success'\nexport type FetchStatus = 'fetching' | 'paused' | 'idle'\n\nexport interface QueryObserverBaseResult<\n  TData = unknown,\n  TError = DefaultError,\n> {\n  /**\n   * The last successfully resolved data for the query.\n   */\n  data: TData | undefined\n  /**\n   * The timestamp for when the query most recently returned the `status` as `\"success\"`.\n   */\n  dataUpdatedAt: number\n  /**\n   * The error object for the query, if an error was thrown.\n   * - Defaults to `null`.\n   */\n  error: TError | null\n  /**\n   * The timestamp for when the query most recently returned the `status` as `\"error\"`.\n   */\n  errorUpdatedAt: number\n  /**\n   * The failure count for the query.\n   * - Incremented every time the query fails.\n   * - Reset to `0` when the query succeeds.\n   */\n  failureCount: number\n  /**\n   * The failure reason for the query retry.\n   * - Reset to `null` when the query succeeds.\n   */\n  failureReason: TError | null\n  /**\n   * The sum of all errors.\n   */\n  errorUpdateCount: number\n  /**\n   * A derived boolean from the `status` variable, provided for convenience.\n   * - `true` if the query attempt resulted in an error.\n   */\n  isError: boolean\n  /**\n   * Will be `true` if the query has been fetched.\n   */\n  isFetched: boolean\n  /**\n   * Will be `true` if the query has been fetched after the component mounted.\n   * - This property can be used to not show any previously cached data.\n   */\n  isFetchedAfterMount: boolean\n  /**\n   * A derived boolean from the `fetchStatus` variable, provided for convenience.\n   * - `true` whenever the `queryFn` is executing, which includes initial `pending` as well as background refetch.\n   */\n  isFetching: boolean\n  /**\n   * Is `true` whenever the first fetch for a query is in-flight.\n   * - Is the same as `isFetching && isPending`.\n   */\n  isLoading: boolean\n  /**\n   * Will be `pending` if there's no cached data and no query attempt was finished yet.\n   */\n  isPending: boolean\n  /**\n   * Will be `true` if the query failed while fetching for the first time.\n   */\n  isLoadingError: boolean\n  /**\n   * @deprecated `isInitialLoading` is being deprecated in favor of `isLoading`\n   * and will be removed in the next major version.\n   */\n  isInitialLoading: boolean\n  /**\n   * A derived boolean from the `fetchStatus` variable, provided for convenience.\n   * - The query wanted to fetch, but has been `paused`.\n   */\n  isPaused: boolean\n  /**\n   * Will be `true` if the data shown is the placeholder data.\n   */\n  isPlaceholderData: boolean\n  /**\n   * Will be `true` if the query failed while refetching.\n   */\n  isRefetchError: boolean\n  /**\n   * Is `true` whenever a background refetch is in-flight, which _does not_ include initial `pending`.\n   * - Is the same as `isFetching && !isPending`.\n   */\n  isRefetching: boolean\n  /**\n   * Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.\n   */\n  isStale: boolean\n  /**\n   * A derived boolean from the `status` variable, provided for convenience.\n   * - `true` if the query has received a response with no errors and is ready to display its data.\n   */\n  isSuccess: boolean\n  /**\n   * A function to manually refetch the query.\n   */\n  refetch: (\n    options?: RefetchOptions,\n  ) => Promise<QueryObserverResult<TData, TError>>\n  /**\n   * The status of the query.\n   * - Will be:\n   *   - `pending` if there's no cached data and no query attempt was finished yet.\n   *   - `error` if the query attempt resulted in an error.\n   *   - `success` if the query has received a response with no errors and is ready to display its data.\n   */\n  status: QueryStatus\n  /**\n   * The fetch status of the query.\n   * - `fetching`: Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetch.\n   * - `paused`: The query wanted to fetch, but has been `paused`.\n   * - `idle`: The query is not fetching.\n   * - See [Network Mode](https://tanstack.com/query/latest/docs/framework/react/guides/network-mode) for more information.\n   */\n  fetchStatus: FetchStatus\n  /**\n   * A stable promise that will be resolved with the data of the query.\n   * Requires the `experimental_prefetchInRender` feature flag to be enabled.\n   * @example\n   *\n   * ### Enabling the feature flag\n   * ```ts\n   * const client = new QueryClient({\n   *   defaultOptions: {\n   *     queries: {\n   *       experimental_prefetchInRender: true,\n   *     },\n   *   },\n   * })\n   * ```\n   *\n   * ### Usage\n   * ```tsx\n   * import { useQuery } from '@tanstack/react-query'\n   * import React from 'react'\n   * import { fetchTodos, type Todo } from './api'\n   *\n   * function TodoList({ query }: { query: UseQueryResult<Todo[], Error> }) {\n   *   const data = React.use(query.promise)\n   *\n   *   return (\n   *     <ul>\n   *       {data.map(todo => (\n   *         <li key={todo.id}>{todo.title}</li>\n   *       ))}\n   *     </ul>\n   *   )\n   * }\n   *\n   * export function App() {\n   *   const query = useQuery({ queryKey: ['todos'], queryFn: fetchTodos })\n   *\n   *   return (\n   *     <>\n   *       <h1>Todos</h1>\n   *       <React.Suspense fallback={<div>Loading...</div>}>\n   *         <TodoList query={query} />\n   *       </React.Suspense>\n   *     </>\n   *   )\n   * }\n   * ```\n   */\n  promise: Promise<TData>\n}\n\nexport interface QueryObserverPendingResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: null\n  isError: false\n  isPending: true\n  isLoadingError: false\n  isRefetchError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'pending'\n}\n\nexport interface QueryObserverLoadingResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: null\n  isError: false\n  isPending: true\n  isLoading: true\n  isLoadingError: false\n  isRefetchError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'pending'\n}\n\nexport interface QueryObserverLoadingErrorResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: TError\n  isError: true\n  isPending: false\n  isLoading: false\n  isLoadingError: true\n  isRefetchError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'error'\n}\n\nexport interface QueryObserverRefetchErrorResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: TData\n  error: TError\n  isError: true\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: true\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'error'\n}\n\nexport interface QueryObserverSuccessResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: TData\n  error: null\n  isError: false\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: false\n  isSuccess: true\n  isPlaceholderData: false\n  status: 'success'\n}\n\nexport interface QueryObserverPlaceholderResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: TData\n  isError: false\n  error: null\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: false\n  isSuccess: true\n  isPlaceholderData: true\n  status: 'success'\n}\n\nexport type DefinedQueryObserverResult<\n  TData = unknown,\n  TError = DefaultError,\n> =\n  | QueryObserverRefetchErrorResult<TData, TError>\n  | QueryObserverSuccessResult<TData, TError>\n\nexport type QueryObserverResult<TData = unknown, TError = DefaultError> =\n  | DefinedQueryObserverResult<TData, TError>\n  | QueryObserverLoadingErrorResult<TData, TError>\n  | QueryObserverLoadingResult<TData, TError>\n  | QueryObserverPendingResult<TData, TError>\n  | QueryObserverPlaceholderResult<TData, TError>\n\nexport interface InfiniteQueryObserverBaseResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  /**\n   * This function allows you to fetch the next \"page\" of results.\n   */\n  fetchNextPage: (\n    options?: FetchNextPageOptions,\n  ) => Promise<InfiniteQueryObserverResult<TData, TError>>\n  /**\n   * This function allows you to fetch the previous \"page\" of results.\n   */\n  fetchPreviousPage: (\n    options?: FetchPreviousPageOptions,\n  ) => Promise<InfiniteQueryObserverResult<TData, TError>>\n  /**\n   * Will be `true` if there is a next page to be fetched (known via the `getNextPageParam` option).\n   */\n  hasNextPage: boolean\n  /**\n   * Will be `true` if there is a previous page to be fetched (known via the `getPreviousPageParam` option).\n   */\n  hasPreviousPage: boolean\n  /**\n   * Will be `true` if the query failed while fetching the next page.\n   */\n  isFetchNextPageError: boolean\n  /**\n   * Will be `true` while fetching the next page with `fetchNextPage`.\n   */\n  isFetchingNextPage: boolean\n  /**\n   * Will be `true` if the query failed while fetching the previous page.\n   */\n  isFetchPreviousPageError: boolean\n  /**\n   * Will be `true` while fetching the previous page with `fetchPreviousPage`.\n   */\n  isFetchingPreviousPage: boolean\n}\n\nexport interface InfiniteQueryObserverPendingResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: null\n  isError: false\n  isPending: true\n  isLoadingError: false\n  isRefetchError: false\n  isFetchNextPageError: false\n  isFetchPreviousPageError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'pending'\n}\n\nexport interface InfiniteQueryObserverLoadingResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: null\n  isError: false\n  isPending: true\n  isLoading: true\n  isLoadingError: false\n  isRefetchError: false\n  isFetchNextPageError: false\n  isFetchPreviousPageError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'pending'\n}\n\nexport interface InfiniteQueryObserverLoadingErrorResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: TError\n  isError: true\n  isPending: false\n  isLoading: false\n  isLoadingError: true\n  isRefetchError: false\n  isFetchNextPageError: false\n  isFetchPreviousPageError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'error'\n}\n\nexport interface InfiniteQueryObserverRefetchErrorResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: TData\n  error: TError\n  isError: true\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: true\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'error'\n}\n\nexport interface InfiniteQueryObserverSuccessResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: TData\n  error: null\n  isError: false\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: false\n  isFetchNextPageError: false\n  isFetchPreviousPageError: false\n  isSuccess: true\n  isPlaceholderData: false\n  status: 'success'\n}\n\nexport interface InfiniteQueryObserverPlaceholderResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: TData\n  isError: false\n  error: null\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: false\n  isSuccess: true\n  isPlaceholderData: true\n  isFetchNextPageError: false\n  isFetchPreviousPageError: false\n  status: 'success'\n}\n\nexport type DefinedInfiniteQueryObserverResult<\n  TData = unknown,\n  TError = DefaultError,\n> =\n  | InfiniteQueryObserverRefetchErrorResult<TData, TError>\n  | InfiniteQueryObserverSuccessResult<TData, TError>\n\nexport type InfiniteQueryObserverResult<\n  TData = unknown,\n  TError = DefaultError,\n> =\n  | DefinedInfiniteQueryObserverResult<TData, TError>\n  | InfiniteQueryObserverLoadingErrorResult<TData, TError>\n  | InfiniteQueryObserverLoadingResult<TData, TError>\n  | InfiniteQueryObserverPendingResult<TData, TError>\n  | InfiniteQueryObserverPlaceholderResult<TData, TError>\n\nexport type MutationKey = Register extends {\n  mutationKey: infer TMutationKey\n}\n  ? TMutationKey extends Array<unknown>\n    ? TMutationKey\n    : TMutationKey extends Array<unknown>\n      ? TMutationKey\n      : ReadonlyArray<unknown>\n  : ReadonlyArray<unknown>\n\nexport type MutationStatus = 'idle' | 'pending' | 'success' | 'error'\n\nexport type MutationScope = {\n  id: string\n}\n\nexport type MutationMeta = Register extends {\n  mutationMeta: infer TMutationMeta\n}\n  ? TMutationMeta extends Record<string, unknown>\n    ? TMutationMeta\n    : Record<string, unknown>\n  : Record<string, unknown>\n\nexport type MutationFunction<TData = unknown, TVariables = unknown> = (\n  variables: TVariables,\n) => Promise<TData>\n\nexport interface MutationOptions<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> {\n  mutationFn?: MutationFunction<TData, TVariables>\n  mutationKey?: MutationKey\n  onMutate?: (\n    variables: TVariables,\n  ) => Promise<TContext | undefined> | TContext | undefined\n  onSuccess?: (\n    data: TData,\n    variables: TVariables,\n    context: TContext,\n  ) => Promise<unknown> | unknown\n  onError?: (\n    error: TError,\n    variables: TVariables,\n    context: TContext | undefined,\n  ) => Promise<unknown> | unknown\n  onSettled?: (\n    data: TData | undefined,\n    error: TError | null,\n    variables: TVariables,\n    context: TContext | undefined,\n  ) => Promise<unknown> | unknown\n  retry?: RetryValue<TError>\n  retryDelay?: RetryDelayValue<TError>\n  networkMode?: NetworkMode\n  gcTime?: number\n  _defaulted?: boolean\n  meta?: MutationMeta\n  scope?: MutationScope\n}\n\nexport interface MutationObserverOptions<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationOptions<TData, TError, TVariables, TContext> {\n  throwOnError?: boolean | ((error: TError) => boolean)\n}\n\nexport interface MutateOptions<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> {\n  onSuccess?: (data: TData, variables: TVariables, context: TContext) => void\n  onError?: (\n    error: TError,\n    variables: TVariables,\n    context: TContext | undefined,\n  ) => void\n  onSettled?: (\n    data: TData | undefined,\n    error: TError | null,\n    variables: TVariables,\n    context: TContext | undefined,\n  ) => void\n}\n\nexport type MutateFunction<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> = (\n  variables: TVariables,\n  options?: MutateOptions<TData, TError, TVariables, TContext>,\n) => Promise<TData>\n\nexport interface MutationObserverBaseResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationState<TData, TError, TVariables, TContext> {\n  /**\n   * The last successfully resolved data for the mutation.\n   */\n  data: TData | undefined\n  /**\n   * The variables object passed to the `mutationFn`.\n   */\n  variables: TVariables | undefined\n  /**\n   * The error object for the mutation, if an error was encountered.\n   * - Defaults to `null`.\n   */\n  error: TError | null\n  /**\n   * A boolean variable derived from `status`.\n   * - `true` if the last mutation attempt resulted in an error.\n   */\n  isError: boolean\n  /**\n   * A boolean variable derived from `status`.\n   * - `true` if the mutation is in its initial state prior to executing.\n   */\n  isIdle: boolean\n  /**\n   * A boolean variable derived from `status`.\n   * - `true` if the mutation is currently executing.\n   */\n  isPending: boolean\n  /**\n   * A boolean variable derived from `status`.\n   * - `true` if the last mutation attempt was successful.\n   */\n  isSuccess: boolean\n  /**\n   * The status of the mutation.\n   * - Will be:\n   *   - `idle` initial status prior to the mutation function executing.\n   *   - `pending` if the mutation is currently executing.\n   *   - `error` if the last mutation attempt resulted in an error.\n   *   - `success` if the last mutation attempt was successful.\n   */\n  status: MutationStatus\n  /**\n   * The mutation function you can call with variables to trigger the mutation and optionally hooks on additional callback options.\n   * @param variables - The variables object to pass to the `mutationFn`.\n   * @param options.onSuccess - This function will fire when the mutation is successful and will be passed the mutation's result.\n   * @param options.onError - This function will fire if the mutation encounters an error and will be passed the error.\n   * @param options.onSettled - This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error.\n   * @remarks\n   * - If you make multiple requests, `onSuccess` will fire only after the latest call you've made.\n   * - All the callback functions (`onSuccess`, `onError`, `onSettled`) are void functions, and the returned value will be ignored.\n   */\n  mutate: MutateFunction<TData, TError, TVariables, TContext>\n  /**\n   * A function to clean the mutation internal state (i.e., it resets the mutation to its initial state).\n   */\n  reset: () => void\n}\n\nexport interface MutationObserverIdleResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationObserverBaseResult<TData, TError, TVariables, TContext> {\n  data: undefined\n  variables: undefined\n  error: null\n  isError: false\n  isIdle: true\n  isPending: false\n  isSuccess: false\n  status: 'idle'\n}\n\nexport interface MutationObserverLoadingResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationObserverBaseResult<TData, TError, TVariables, TContext> {\n  data: undefined\n  variables: TVariables\n  error: null\n  isError: false\n  isIdle: false\n  isPending: true\n  isSuccess: false\n  status: 'pending'\n}\n\nexport interface MutationObserverErrorResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationObserverBaseResult<TData, TError, TVariables, TContext> {\n  data: undefined\n  error: TError\n  variables: TVariables\n  isError: true\n  isIdle: false\n  isPending: false\n  isSuccess: false\n  status: 'error'\n}\n\nexport interface MutationObserverSuccessResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationObserverBaseResult<TData, TError, TVariables, TContext> {\n  data: TData\n  error: null\n  variables: TVariables\n  isError: false\n  isIdle: false\n  isPending: false\n  isSuccess: true\n  status: 'success'\n}\n\nexport type MutationObserverResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> =\n  | MutationObserverIdleResult<TData, TError, TVariables, TContext>\n  | MutationObserverLoadingResult<TData, TError, TVariables, TContext>\n  | MutationObserverErrorResult<TData, TError, TVariables, TContext>\n  | MutationObserverSuccessResult<TData, TError, TVariables, TContext>\n\nexport interface QueryClientConfig {\n  queryCache?: QueryCache\n  mutationCache?: MutationCache\n  defaultOptions?: DefaultOptions\n}\n\nexport interface DefaultOptions<TError = DefaultError> {\n  queries?: OmitKeyof<\n    QueryObserverOptions<unknown, TError>,\n    'suspense' | 'queryKey'\n  >\n  mutations?: MutationObserverOptions<unknown, TError, unknown, unknown>\n  hydrate?: HydrateOptions['defaultOptions']\n  dehydrate?: DehydrateOptions\n}\n\nexport interface CancelOptions {\n  revert?: boolean\n  silent?: boolean\n}\n\nexport interface SetDataOptions {\n  updatedAt?: number\n}\n\nexport type NotifyEventType =\n  | 'added'\n  | 'removed'\n  | 'updated'\n  | 'observerAdded'\n  | 'observerRemoved'\n  | 'observerResultsUpdated'\n  | 'observerOptionsUpdated'\n\nexport interface NotifyEvent {\n  type: NotifyEventType\n}\n"],"mappings":";;;AA8DO,IAAM,gBAAgB,OAAO,eAAe;AAE5C,IAAM,qBAAqB,OAAO,oBAAoB;AAEtD,IAAM,cAAc,OAAO,aAAa;","names":[]}
\ No newline at end of file
+{"version":3,"sources":["../../src/types.ts"],"sourcesContent":["/* istanbul ignore file */\n\nimport type { QueryClient } from './queryClient'\nimport type { DehydrateOptions, HydrateOptions } from './hydration'\nimport type { MutationState } from './mutation'\nimport type { FetchDirection, Query, QueryBehavior } from './query'\nimport type { RetryDelayValue, RetryValue } from './retryer'\nimport type { QueryFilters, QueryTypeFilter, SkipToken } from './utils'\nimport type { QueryCache } from './queryCache'\nimport type { MutationCache } from './mutationCache'\n\nexport type NonUndefinedGuard<T> = T extends undefined ? never : T\n\nexport type DistributiveOmit<\n  TObject,\n  TKey extends keyof TObject,\n> = TObject extends any ? Omit<TObject, TKey> : never\n\nexport type OmitKeyof<\n  TObject,\n  TKey extends TStrictly extends 'safely'\n    ?\n        | keyof TObject\n        | (string & Record<never, never>)\n        | (number & Record<never, never>)\n        | (symbol & Record<never, never>)\n    : keyof TObject,\n  TStrictly extends 'strictly' | 'safely' = 'strictly',\n> = Omit<TObject, TKey>\n\nexport type Override<TTargetA, TTargetB> = {\n  [AKey in keyof TTargetA]: AKey extends keyof TTargetB\n    ? TTargetB[AKey]\n    : TTargetA[AKey]\n}\n\nexport type NoInfer<T> = [T][T extends any ? 0 : never]\n\nexport interface Register {\n  // defaultError: Error\n  // queryMeta: Record<string, unknown>\n  // mutationMeta: Record<string, unknown>\n  // queryKey: ReadonlyArray<unknown>\n  // mutationKey: ReadonlyArray<unknown>\n}\n\nexport type DefaultError = Register extends {\n  defaultError: infer TError\n}\n  ? TError\n  : Error\n\nexport type QueryKey = Register extends {\n  queryKey: infer TQueryKey\n}\n  ? TQueryKey extends ReadonlyArray<unknown>\n    ? TQueryKey\n    : TQueryKey extends Array<unknown>\n      ? TQueryKey\n      : ReadonlyArray<unknown>\n  : ReadonlyArray<unknown>\n\nexport const dataTagSymbol = Symbol('dataTagSymbol')\nexport type dataTagSymbol = typeof dataTagSymbol\nexport const dataTagErrorSymbol = Symbol('dataTagErrorSymbol')\nexport type dataTagErrorSymbol = typeof dataTagErrorSymbol\nexport const unsetMarker = Symbol('unsetMarker')\nexport type UnsetMarker = typeof unsetMarker\nexport type AnyDataTag = {\n  [dataTagSymbol]: any\n  [dataTagErrorSymbol]: any\n}\nexport type DataTag<\n  TType,\n  TValue,\n  TError = UnsetMarker,\n> = TType extends AnyDataTag\n  ? TType\n  : TType & {\n      [dataTagSymbol]: TValue\n      [dataTagErrorSymbol]: TError\n    }\n\nexport type InferDataFromTag<TQueryFnData, TTaggedQueryKey extends QueryKey> =\n  TTaggedQueryKey extends DataTag<unknown, infer TaggedValue, unknown>\n    ? TaggedValue\n    : TQueryFnData\n\nexport type InferErrorFromTag<TError, TTaggedQueryKey extends QueryKey> =\n  TTaggedQueryKey extends DataTag<unknown, unknown, infer TaggedError>\n    ? TaggedError extends UnsetMarker\n      ? TError\n      : TaggedError\n    : TError\n\nexport type QueryFunction<\n  T = unknown,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> = (context: QueryFunctionContext<TQueryKey, TPageParam>) => T | Promise<T>\n\nexport type StaleTime = number | 'static'\n\nexport type StaleTimeFunction<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> =\n  | StaleTime\n  | ((query: Query<TQueryFnData, TError, TData, TQueryKey>) => StaleTime)\n\nexport type Enabled<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> =\n  | boolean\n  | ((query: Query<TQueryFnData, TError, TData, TQueryKey>) => boolean)\n\nexport type QueryPersister<\n  T = unknown,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> = [TPageParam] extends [never]\n  ? (\n      queryFn: QueryFunction<T, TQueryKey, never>,\n      context: QueryFunctionContext<TQueryKey>,\n      query: Query,\n    ) => T | Promise<T>\n  : (\n      queryFn: QueryFunction<T, TQueryKey, TPageParam>,\n      context: QueryFunctionContext<TQueryKey>,\n      query: Query,\n    ) => T | Promise<T>\n\nexport type QueryFunctionContext<\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> = [TPageParam] extends [never]\n  ? {\n      client: QueryClient\n      queryKey: TQueryKey\n      signal: AbortSignal\n      meta: QueryMeta | undefined\n      pageParam?: unknown\n      /**\n       * @deprecated\n       * if you want access to the direction, you can add it to the pageParam\n       */\n      direction?: unknown\n    }\n  : {\n      client: QueryClient\n      queryKey: TQueryKey\n      signal: AbortSignal\n      pageParam: TPageParam\n      /**\n       * @deprecated\n       * if you want access to the direction, you can add it to the pageParam\n       */\n      direction: FetchDirection\n      meta: QueryMeta | undefined\n    }\n\nexport type InitialDataFunction<T> = () => T | undefined\n\ntype NonFunctionGuard<T> = T extends Function ? never : T\n\nexport type PlaceholderDataFunction<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = (\n  previousData: TQueryData | undefined,\n  previousQuery: Query<TQueryFnData, TError, TQueryData, TQueryKey> | undefined,\n) => TQueryData | undefined\n\nexport type QueriesPlaceholderDataFunction<TQueryData> = (\n  previousData: undefined,\n  previousQuery: undefined,\n) => TQueryData | undefined\n\nexport type QueryKeyHashFunction<TQueryKey extends QueryKey> = (\n  queryKey: TQueryKey,\n) => string\n\nexport type GetPreviousPageParamFunction<TPageParam, TQueryFnData = unknown> = (\n  firstPage: TQueryFnData,\n  allPages: Array<TQueryFnData>,\n  firstPageParam: TPageParam,\n  allPageParams: Array<TPageParam>,\n) => TPageParam | undefined | null\n\nexport type GetNextPageParamFunction<TPageParam, TQueryFnData = unknown> = (\n  lastPage: TQueryFnData,\n  allPages: Array<TQueryFnData>,\n  lastPageParam: TPageParam,\n  allPageParams: Array<TPageParam>,\n) => TPageParam | undefined | null\n\nexport interface InfiniteData<TData, TPageParam = unknown> {\n  pages: Array<TData>\n  pageParams: Array<TPageParam>\n}\n\nexport type QueryMeta = Register extends {\n  queryMeta: infer TQueryMeta\n}\n  ? TQueryMeta extends Record<string, unknown>\n    ? TQueryMeta\n    : Record<string, unknown>\n  : Record<string, unknown>\n\nexport type NetworkMode = 'online' | 'always' | 'offlineFirst'\n\nexport type NotifyOnChangeProps =\n  | Array<keyof InfiniteQueryObserverResult>\n  | 'all'\n  | undefined\n  | (() => Array<keyof InfiniteQueryObserverResult> | 'all' | undefined)\n\nexport interface QueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> {\n  /**\n   * If `false`, failed queries will not retry by default.\n   * If `true`, failed queries will retry infinitely., failureCount: num\n   * If set to an integer number, e.g. 3, failed queries will retry until the failed query count meets that number.\n   * If set to a function `(failureCount, error) => boolean` failed queries will retry until the function returns false.\n   */\n  retry?: RetryValue<TError>\n  retryDelay?: RetryDelayValue<TError>\n  networkMode?: NetworkMode\n  /**\n   * The time in milliseconds that unused/inactive cache data remains in memory.\n   * When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration.\n   * When different garbage collection times are specified, the longest one will be used.\n   * Setting it to `Infinity` will disable garbage collection.\n   */\n  gcTime?: number\n  queryFn?: QueryFunction<TQueryFnData, TQueryKey, TPageParam> | SkipToken\n  persister?: QueryPersister<\n    NoInfer<TQueryFnData>,\n    NoInfer<TQueryKey>,\n    NoInfer<TPageParam>\n  >\n  queryHash?: string\n  queryKey?: TQueryKey\n  queryKeyHashFn?: QueryKeyHashFunction<TQueryKey>\n  initialData?: TData | InitialDataFunction<TData>\n  initialDataUpdatedAt?: number | (() => number | undefined)\n  behavior?: QueryBehavior<TQueryFnData, TError, TData, TQueryKey>\n  /**\n   * Set this to `false` to disable structural sharing between query results.\n   * Set this to a function which accepts the old and new data and returns resolved data of the same type to implement custom structural sharing logic.\n   * Defaults to `true`.\n   */\n  structuralSharing?:\n    | boolean\n    | ((oldData: unknown | undefined, newData: unknown) => unknown)\n  _defaulted?: boolean\n  /**\n   * Additional payload to be stored on each query.\n   * Use this property to pass information that can be used in other places.\n   */\n  meta?: QueryMeta\n  /**\n   * Maximum number of pages to store in the data of an infinite query.\n   */\n  maxPages?: number\n}\n\nexport interface InitialPageParam<TPageParam = unknown> {\n  initialPageParam: TPageParam\n}\n\nexport interface InfiniteQueryPageParamsOptions<\n  TQueryFnData = unknown,\n  TPageParam = unknown,\n> extends InitialPageParam<TPageParam> {\n  /**\n   * This function can be set to automatically get the previous cursor for infinite queries.\n   * The result will also be used to determine the value of `hasPreviousPage`.\n   */\n  getPreviousPageParam?: GetPreviousPageParamFunction<TPageParam, TQueryFnData>\n  /**\n   * This function can be set to automatically get the next cursor for infinite queries.\n   * The result will also be used to determine the value of `hasNextPage`.\n   */\n  getNextPageParam: GetNextPageParamFunction<TPageParam, TQueryFnData>\n}\n\nexport type ThrowOnError<\n  TQueryFnData,\n  TError,\n  TQueryData,\n  TQueryKey extends QueryKey,\n> =\n  | boolean\n  | ((\n      error: TError,\n      query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n    ) => boolean)\n\nexport interface QueryObserverOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> extends WithRequired<\n    QueryOptions<TQueryFnData, TError, TQueryData, TQueryKey, TPageParam>,\n    'queryKey'\n  > {\n  /**\n   * Set this to `false` or a function that returns `false` to disable automatic refetching when the query mounts or changes query keys.\n   * To refetch the query, use the `refetch` method returned from the `useQuery` instance.\n   * Accepts a boolean or function that returns a boolean.\n   * Defaults to `true`.\n   */\n  enabled?: Enabled<TQueryFnData, TError, TQueryData, TQueryKey>\n  /**\n   * The time in milliseconds after data is considered stale.\n   * If set to `Infinity`, the data will never be considered stale.\n   * If set to a function, the function will be executed with the query to compute a `staleTime`.\n   * Defaults to `0`.\n   */\n  staleTime?: StaleTimeFunction<TQueryFnData, TError, TQueryData, TQueryKey>\n  /**\n   * If set to a number, the query will continuously refetch at this frequency in milliseconds.\n   * If set to a function, the function will be executed with the latest data and query to compute a frequency\n   * Defaults to `false`.\n   */\n  refetchInterval?:\n    | number\n    | false\n    | ((\n        query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n      ) => number | false | undefined)\n  /**\n   * If set to `true`, the query will continue to refetch while their tab/window is in the background.\n   * Defaults to `false`.\n   */\n  refetchIntervalInBackground?: boolean\n  /**\n   * If set to `true`, the query will refetch on window focus if the data is stale.\n   * If set to `false`, the query will not refetch on window focus.\n   * If set to `'always'`, the query will always refetch on window focus.\n   * If set to a function, the function will be executed with the latest data and query to compute the value.\n   * Defaults to `true`.\n   */\n  refetchOnWindowFocus?:\n    | boolean\n    | 'always'\n    | ((\n        query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n      ) => boolean | 'always')\n  /**\n   * If set to `true`, the query will refetch on reconnect if the data is stale.\n   * If set to `false`, the query will not refetch on reconnect.\n   * If set to `'always'`, the query will always refetch on reconnect.\n   * If set to a function, the function will be executed with the latest data and query to compute the value.\n   * Defaults to the value of `networkOnline` (`true`)\n   */\n  refetchOnReconnect?:\n    | boolean\n    | 'always'\n    | ((\n        query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n      ) => boolean | 'always')\n  /**\n   * If set to `true`, the query will refetch on mount if the data is stale.\n   * If set to `false`, will disable additional instances of a query to trigger background refetch.\n   * If set to `'always'`, the query will always refetch on mount.\n   * If set to a function, the function will be executed with the latest data and query to compute the value\n   * Defaults to `true`.\n   */\n  refetchOnMount?:\n    | boolean\n    | 'always'\n    | ((\n        query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n      ) => boolean | 'always')\n  /**\n   * If set to `false`, the query will not be retried on mount if it contains an error.\n   * Defaults to `true`.\n   */\n  retryOnMount?: boolean\n  /**\n   * If set, the component will only re-render if any of the listed properties change.\n   * When set to `['data', 'error']`, the component will only re-render when the `data` or `error` properties change.\n   * When set to `'all'`, the component will re-render whenever a query is updated.\n   * When set to a function, the function will be executed to compute the list of properties.\n   * By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.\n   */\n  notifyOnChangeProps?: NotifyOnChangeProps\n  /**\n   * Whether errors should be thrown instead of setting the `error` property.\n   * If set to `true` or `suspense` is `true`, all errors will be thrown to the error boundary.\n   * If set to `false` and `suspense` is `false`, errors are returned as state.\n   * If set to a function, it will be passed the error and the query, and it should return a boolean indicating whether to show the error in an error boundary (`true`) or return the error as state (`false`).\n   * Defaults to `false`.\n   */\n  throwOnError?: ThrowOnError<TQueryFnData, TError, TQueryData, TQueryKey>\n  /**\n   * This option can be used to transform or select a part of the data returned by the query function.\n   */\n  select?: (data: TQueryData) => TData\n  /**\n   * If set to `true`, the query will suspend when `status === 'pending'`\n   * and throw errors when `status === 'error'`.\n   * Defaults to `false`.\n   */\n  suspense?: boolean\n  /**\n   * If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `loading` data and no initialData has been provided.\n   */\n  placeholderData?:\n    | NonFunctionGuard<TQueryData>\n    | PlaceholderDataFunction<\n        NonFunctionGuard<TQueryData>,\n        TError,\n        NonFunctionGuard<TQueryData>,\n        TQueryKey\n      >\n\n  _optimisticResults?: 'optimistic' | 'isRestoring'\n\n  /**\n   * Enable prefetching during rendering\n   */\n  experimental_prefetchInRender?: boolean\n}\n\nexport type WithRequired<TTarget, TKey extends keyof TTarget> = TTarget & {\n  [_ in TKey]: {}\n}\n\nexport type DefaultedQueryObserverOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = WithRequired<\n  QueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  'throwOnError' | 'refetchOnReconnect' | 'queryHash'\n>\n\nexport interface InfiniteQueryObserverOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> extends QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      InfiniteData<TQueryFnData, TPageParam>,\n      TQueryKey,\n      TPageParam\n    >,\n    InfiniteQueryPageParamsOptions<TQueryFnData, TPageParam> {}\n\nexport type DefaultedInfiniteQueryObserverOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> = WithRequired<\n  InfiniteQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  >,\n  'throwOnError' | 'refetchOnReconnect' | 'queryHash'\n>\n\nexport interface FetchQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> extends WithRequired<\n    QueryOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>,\n    'queryKey'\n  > {\n  initialPageParam?: never\n  /**\n   * The time in milliseconds after data is considered stale.\n   * If the data is fresh it will be returned from the cache.\n   */\n  staleTime?: StaleTimeFunction<TQueryFnData, TError, TData, TQueryKey>\n}\n\nexport interface EnsureQueryDataOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> extends FetchQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  > {\n  revalidateIfStale?: boolean\n}\n\nexport type EnsureInfiniteQueryDataOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> = FetchInfiniteQueryOptions<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey,\n  TPageParam\n> & {\n  revalidateIfStale?: boolean\n}\n\ntype FetchInfiniteQueryPages<TQueryFnData = unknown, TPageParam = unknown> =\n  | { pages?: never }\n  | {\n      pages: number\n      getNextPageParam: GetNextPageParamFunction<TPageParam, TQueryFnData>\n    }\n\nexport type FetchInfiniteQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> = Omit<\n  FetchQueryOptions<\n    TQueryFnData,\n    TError,\n    InfiniteData<TData, TPageParam>,\n    TQueryKey,\n    TPageParam\n  >,\n  'initialPageParam'\n> &\n  InitialPageParam<TPageParam> &\n  FetchInfiniteQueryPages<TQueryFnData, TPageParam>\n\nexport interface ResultOptions {\n  throwOnError?: boolean\n}\n\nexport interface RefetchOptions extends ResultOptions {\n  /**\n   * If set to `true`, a currently running request will be cancelled before a new request is made\n   *\n   * If set to `false`, no refetch will be made if there is already a request running.\n   *\n   * Defaults to `true`.\n   */\n  cancelRefetch?: boolean\n\n  updateMeta?: Record<string, unknown>\n}\n\nexport interface InvalidateQueryFilters<TQueryKey extends QueryKey = QueryKey>\n  extends QueryFilters<TQueryKey> {\n  refetchType?: QueryTypeFilter | 'none'\n}\n\nexport interface RefetchQueryFilters<TQueryKey extends QueryKey = QueryKey>\n  extends QueryFilters<TQueryKey> {}\n\nexport interface InvalidateOptions extends RefetchOptions {}\nexport interface ResetOptions extends RefetchOptions {}\n\nexport interface FetchNextPageOptions extends ResultOptions {\n  /**\n   * If set to `true`, calling `fetchNextPage` repeatedly will invoke `queryFn` every time,\n   * whether the previous invocation has resolved or not. Also, the result from previous invocations will be ignored.\n   *\n   * If set to `false`, calling `fetchNextPage` repeatedly won't have any effect until the first invocation has resolved.\n   *\n   * Defaults to `true`.\n   */\n  cancelRefetch?: boolean\n}\n\nexport interface FetchPreviousPageOptions extends ResultOptions {\n  /**\n   * If set to `true`, calling `fetchPreviousPage` repeatedly will invoke `queryFn` every time,\n   * whether the previous invocation has resolved or not. Also, the result from previous invocations will be ignored.\n   *\n   * If set to `false`, calling `fetchPreviousPage` repeatedly won't have any effect until the first invocation has resolved.\n   *\n   * Defaults to `true`.\n   */\n  cancelRefetch?: boolean\n}\n\nexport type QueryStatus = 'pending' | 'error' | 'success'\nexport type FetchStatus = 'fetching' | 'paused' | 'idle'\n\nexport interface QueryObserverBaseResult<\n  TData = unknown,\n  TError = DefaultError,\n> {\n  /**\n   * The last successfully resolved data for the query.\n   */\n  data: TData | undefined\n  /**\n   * The timestamp for when the query most recently returned the `status` as `\"success\"`.\n   */\n  dataUpdatedAt: number\n  /**\n   * The error object for the query, if an error was thrown.\n   * - Defaults to `null`.\n   */\n  error: TError | null\n  /**\n   * The timestamp for when the query most recently returned the `status` as `\"error\"`.\n   */\n  errorUpdatedAt: number\n  /**\n   * The failure count for the query.\n   * - Incremented every time the query fails.\n   * - Reset to `0` when the query succeeds.\n   */\n  failureCount: number\n  /**\n   * The failure reason for the query retry.\n   * - Reset to `null` when the query succeeds.\n   */\n  failureReason: TError | null\n  /**\n   * The sum of all errors.\n   */\n  errorUpdateCount: number\n  /**\n   * A derived boolean from the `status` variable, provided for convenience.\n   * - `true` if the query attempt resulted in an error.\n   */\n  isError: boolean\n  /**\n   * Will be `true` if the query has been fetched.\n   */\n  isFetched: boolean\n  /**\n   * Will be `true` if the query has been fetched after the component mounted.\n   * - This property can be used to not show any previously cached data.\n   */\n  isFetchedAfterMount: boolean\n  /**\n   * A derived boolean from the `fetchStatus` variable, provided for convenience.\n   * - `true` whenever the `queryFn` is executing, which includes initial `pending` as well as background refetch.\n   */\n  isFetching: boolean\n  /**\n   * Is `true` whenever the first fetch for a query is in-flight.\n   * - Is the same as `isFetching && isPending`.\n   */\n  isLoading: boolean\n  /**\n   * Will be `pending` if there's no cached data and no query attempt was finished yet.\n   */\n  isPending: boolean\n  /**\n   * Will be `true` if the query failed while fetching for the first time.\n   */\n  isLoadingError: boolean\n  /**\n   * @deprecated `isInitialLoading` is being deprecated in favor of `isLoading`\n   * and will be removed in the next major version.\n   */\n  isInitialLoading: boolean\n  /**\n   * A derived boolean from the `fetchStatus` variable, provided for convenience.\n   * - The query wanted to fetch, but has been `paused`.\n   */\n  isPaused: boolean\n  /**\n   * Will be `true` if the data shown is the placeholder data.\n   */\n  isPlaceholderData: boolean\n  /**\n   * Will be `true` if the query failed while refetching.\n   */\n  isRefetchError: boolean\n  /**\n   * Is `true` whenever a background refetch is in-flight, which _does not_ include initial `pending`.\n   * - Is the same as `isFetching && !isPending`.\n   */\n  isRefetching: boolean\n  /**\n   * Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.\n   */\n  isStale: boolean\n  /**\n   * A derived boolean from the `status` variable, provided for convenience.\n   * - `true` if the query has received a response with no errors and is ready to display its data.\n   */\n  isSuccess: boolean\n  /**\n   * A function to manually refetch the query.\n   */\n  refetch: (\n    options?: RefetchOptions,\n  ) => Promise<QueryObserverResult<TData, TError>>\n  /**\n   * The status of the query.\n   * - Will be:\n   *   - `pending` if there's no cached data and no query attempt was finished yet.\n   *   - `error` if the query attempt resulted in an error.\n   *   - `success` if the query has received a response with no errors and is ready to display its data.\n   */\n  status: QueryStatus\n  /**\n   * The fetch status of the query.\n   * - `fetching`: Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetch.\n   * - `paused`: The query wanted to fetch, but has been `paused`.\n   * - `idle`: The query is not fetching.\n   * - See [Network Mode](https://tanstack.com/query/latest/docs/framework/react/guides/network-mode) for more information.\n   */\n  fetchStatus: FetchStatus\n  /**\n   * A stable promise that will be resolved with the data of the query.\n   * Requires the `experimental_prefetchInRender` feature flag to be enabled.\n   * @example\n   *\n   * ### Enabling the feature flag\n   * ```ts\n   * const client = new QueryClient({\n   *   defaultOptions: {\n   *     queries: {\n   *       experimental_prefetchInRender: true,\n   *     },\n   *   },\n   * })\n   * ```\n   *\n   * ### Usage\n   * ```tsx\n   * import { useQuery } from '@tanstack/react-query'\n   * import React from 'react'\n   * import { fetchTodos, type Todo } from './api'\n   *\n   * function TodoList({ query }: { query: UseQueryResult<Todo[], Error> }) {\n   *   const data = React.use(query.promise)\n   *\n   *   return (\n   *     <ul>\n   *       {data.map(todo => (\n   *         <li key={todo.id}>{todo.title}</li>\n   *       ))}\n   *     </ul>\n   *   )\n   * }\n   *\n   * export function App() {\n   *   const query = useQuery({ queryKey: ['todos'], queryFn: fetchTodos })\n   *\n   *   return (\n   *     <>\n   *       <h1>Todos</h1>\n   *       <React.Suspense fallback={<div>Loading...</div>}>\n   *         <TodoList query={query} />\n   *       </React.Suspense>\n   *     </>\n   *   )\n   * }\n   * ```\n   */\n  promise: Promise<TData>\n}\n\nexport interface QueryObserverPendingResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: null\n  isError: false\n  isPending: true\n  isLoadingError: false\n  isRefetchError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'pending'\n}\n\nexport interface QueryObserverLoadingResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: null\n  isError: false\n  isPending: true\n  isLoading: true\n  isLoadingError: false\n  isRefetchError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'pending'\n}\n\nexport interface QueryObserverLoadingErrorResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: TError\n  isError: true\n  isPending: false\n  isLoading: false\n  isLoadingError: true\n  isRefetchError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'error'\n}\n\nexport interface QueryObserverRefetchErrorResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: TData\n  error: TError\n  isError: true\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: true\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'error'\n}\n\nexport interface QueryObserverSuccessResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: TData\n  error: null\n  isError: false\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: false\n  isSuccess: true\n  isPlaceholderData: false\n  status: 'success'\n}\n\nexport interface QueryObserverPlaceholderResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: TData\n  isError: false\n  error: null\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: false\n  isSuccess: true\n  isPlaceholderData: true\n  status: 'success'\n}\n\nexport type DefinedQueryObserverResult<\n  TData = unknown,\n  TError = DefaultError,\n> =\n  | QueryObserverRefetchErrorResult<TData, TError>\n  | QueryObserverSuccessResult<TData, TError>\n\nexport type QueryObserverResult<TData = unknown, TError = DefaultError> =\n  | DefinedQueryObserverResult<TData, TError>\n  | QueryObserverLoadingErrorResult<TData, TError>\n  | QueryObserverLoadingResult<TData, TError>\n  | QueryObserverPendingResult<TData, TError>\n  | QueryObserverPlaceholderResult<TData, TError>\n\nexport interface InfiniteQueryObserverBaseResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  /**\n   * This function allows you to fetch the next \"page\" of results.\n   */\n  fetchNextPage: (\n    options?: FetchNextPageOptions,\n  ) => Promise<InfiniteQueryObserverResult<TData, TError>>\n  /**\n   * This function allows you to fetch the previous \"page\" of results.\n   */\n  fetchPreviousPage: (\n    options?: FetchPreviousPageOptions,\n  ) => Promise<InfiniteQueryObserverResult<TData, TError>>\n  /**\n   * Will be `true` if there is a next page to be fetched (known via the `getNextPageParam` option).\n   */\n  hasNextPage: boolean\n  /**\n   * Will be `true` if there is a previous page to be fetched (known via the `getPreviousPageParam` option).\n   */\n  hasPreviousPage: boolean\n  /**\n   * Will be `true` if the query failed while fetching the next page.\n   */\n  isFetchNextPageError: boolean\n  /**\n   * Will be `true` while fetching the next page with `fetchNextPage`.\n   */\n  isFetchingNextPage: boolean\n  /**\n   * Will be `true` if the query failed while fetching the previous page.\n   */\n  isFetchPreviousPageError: boolean\n  /**\n   * Will be `true` while fetching the previous page with `fetchPreviousPage`.\n   */\n  isFetchingPreviousPage: boolean\n}\n\nexport interface InfiniteQueryObserverPendingResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: null\n  isError: false\n  isPending: true\n  isLoadingError: false\n  isRefetchError: false\n  isFetchNextPageError: false\n  isFetchPreviousPageError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'pending'\n}\n\nexport interface InfiniteQueryObserverLoadingResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: null\n  isError: false\n  isPending: true\n  isLoading: true\n  isLoadingError: false\n  isRefetchError: false\n  isFetchNextPageError: false\n  isFetchPreviousPageError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'pending'\n}\n\nexport interface InfiniteQueryObserverLoadingErrorResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: TError\n  isError: true\n  isPending: false\n  isLoading: false\n  isLoadingError: true\n  isRefetchError: false\n  isFetchNextPageError: false\n  isFetchPreviousPageError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'error'\n}\n\nexport interface InfiniteQueryObserverRefetchErrorResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: TData\n  error: TError\n  isError: true\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: true\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'error'\n}\n\nexport interface InfiniteQueryObserverSuccessResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: TData\n  error: null\n  isError: false\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: false\n  isFetchNextPageError: false\n  isFetchPreviousPageError: false\n  isSuccess: true\n  isPlaceholderData: false\n  status: 'success'\n}\n\nexport interface InfiniteQueryObserverPlaceholderResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: TData\n  isError: false\n  error: null\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: false\n  isSuccess: true\n  isPlaceholderData: true\n  isFetchNextPageError: false\n  isFetchPreviousPageError: false\n  status: 'success'\n}\n\nexport type DefinedInfiniteQueryObserverResult<\n  TData = unknown,\n  TError = DefaultError,\n> =\n  | InfiniteQueryObserverRefetchErrorResult<TData, TError>\n  | InfiniteQueryObserverSuccessResult<TData, TError>\n\nexport type InfiniteQueryObserverResult<\n  TData = unknown,\n  TError = DefaultError,\n> =\n  | DefinedInfiniteQueryObserverResult<TData, TError>\n  | InfiniteQueryObserverLoadingErrorResult<TData, TError>\n  | InfiniteQueryObserverLoadingResult<TData, TError>\n  | InfiniteQueryObserverPendingResult<TData, TError>\n  | InfiniteQueryObserverPlaceholderResult<TData, TError>\n\nexport type MutationKey = Register extends {\n  mutationKey: infer TMutationKey\n}\n  ? TMutationKey extends Array<unknown>\n    ? TMutationKey\n    : TMutationKey extends Array<unknown>\n      ? TMutationKey\n      : ReadonlyArray<unknown>\n  : ReadonlyArray<unknown>\n\nexport type MutationStatus = 'idle' | 'pending' | 'success' | 'error'\n\nexport type MutationScope = {\n  id: string\n}\n\nexport type MutationMeta = Register extends {\n  mutationMeta: infer TMutationMeta\n}\n  ? TMutationMeta extends Record<string, unknown>\n    ? TMutationMeta\n    : Record<string, unknown>\n  : Record<string, unknown>\n\nexport type MutationFunction<TData = unknown, TVariables = unknown> = (\n  variables: TVariables,\n) => Promise<TData>\n\nexport interface MutationOptions<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> {\n  mutationFn?: MutationFunction<TData, TVariables>\n  mutationKey?: MutationKey\n  onMutate?: (\n    variables: TVariables,\n  ) => Promise<TContext | undefined> | TContext | undefined\n  onSuccess?: (\n    data: TData,\n    variables: TVariables,\n    context: TContext,\n  ) => Promise<unknown> | unknown\n  onError?: (\n    error: TError,\n    variables: TVariables,\n    context: TContext | undefined,\n  ) => Promise<unknown> | unknown\n  onSettled?: (\n    data: TData | undefined,\n    error: TError | null,\n    variables: TVariables,\n    context: TContext | undefined,\n  ) => Promise<unknown> | unknown\n  retry?: RetryValue<TError>\n  retryDelay?: RetryDelayValue<TError>\n  networkMode?: NetworkMode\n  gcTime?: number\n  _defaulted?: boolean\n  meta?: MutationMeta\n  scope?: MutationScope\n}\n\nexport interface MutationObserverOptions<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationOptions<TData, TError, TVariables, TContext> {\n  throwOnError?: boolean | ((error: TError) => boolean)\n}\n\nexport interface MutateOptions<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> {\n  onSuccess?: (data: TData, variables: TVariables, context: TContext) => void\n  onError?: (\n    error: TError,\n    variables: TVariables,\n    context: TContext | undefined,\n  ) => void\n  onSettled?: (\n    data: TData | undefined,\n    error: TError | null,\n    variables: TVariables,\n    context: TContext | undefined,\n  ) => void\n}\n\nexport type MutateFunction<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> = (\n  variables: TVariables,\n  options?: MutateOptions<TData, TError, TVariables, TContext>,\n) => Promise<TData>\n\nexport interface MutationObserverBaseResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationState<TData, TError, TVariables, TContext> {\n  /**\n   * The last successfully resolved data for the mutation.\n   */\n  data: TData | undefined\n  /**\n   * The variables object passed to the `mutationFn`.\n   */\n  variables: TVariables | undefined\n  /**\n   * The error object for the mutation, if an error was encountered.\n   * - Defaults to `null`.\n   */\n  error: TError | null\n  /**\n   * A boolean variable derived from `status`.\n   * - `true` if the last mutation attempt resulted in an error.\n   */\n  isError: boolean\n  /**\n   * A boolean variable derived from `status`.\n   * - `true` if the mutation is in its initial state prior to executing.\n   */\n  isIdle: boolean\n  /**\n   * A boolean variable derived from `status`.\n   * - `true` if the mutation is currently executing.\n   */\n  isPending: boolean\n  /**\n   * A boolean variable derived from `status`.\n   * - `true` if the last mutation attempt was successful.\n   */\n  isSuccess: boolean\n  /**\n   * The status of the mutation.\n   * - Will be:\n   *   - `idle` initial status prior to the mutation function executing.\n   *   - `pending` if the mutation is currently executing.\n   *   - `error` if the last mutation attempt resulted in an error.\n   *   - `success` if the last mutation attempt was successful.\n   */\n  status: MutationStatus\n  /**\n   * The mutation function you can call with variables to trigger the mutation and optionally hooks on additional callback options.\n   * @param variables - The variables object to pass to the `mutationFn`.\n   * @param options.onSuccess - This function will fire when the mutation is successful and will be passed the mutation's result.\n   * @param options.onError - This function will fire if the mutation encounters an error and will be passed the error.\n   * @param options.onSettled - This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error.\n   * @remarks\n   * - If you make multiple requests, `onSuccess` will fire only after the latest call you've made.\n   * - All the callback functions (`onSuccess`, `onError`, `onSettled`) are void functions, and the returned value will be ignored.\n   */\n  mutate: MutateFunction<TData, TError, TVariables, TContext>\n  /**\n   * A function to clean the mutation internal state (i.e., it resets the mutation to its initial state).\n   */\n  reset: () => void\n}\n\nexport interface MutationObserverIdleResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationObserverBaseResult<TData, TError, TVariables, TContext> {\n  data: undefined\n  variables: undefined\n  error: null\n  isError: false\n  isIdle: true\n  isPending: false\n  isSuccess: false\n  status: 'idle'\n}\n\nexport interface MutationObserverLoadingResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationObserverBaseResult<TData, TError, TVariables, TContext> {\n  data: undefined\n  variables: TVariables\n  error: null\n  isError: false\n  isIdle: false\n  isPending: true\n  isSuccess: false\n  status: 'pending'\n}\n\nexport interface MutationObserverErrorResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationObserverBaseResult<TData, TError, TVariables, TContext> {\n  data: undefined\n  error: TError\n  variables: TVariables\n  isError: true\n  isIdle: false\n  isPending: false\n  isSuccess: false\n  status: 'error'\n}\n\nexport interface MutationObserverSuccessResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationObserverBaseResult<TData, TError, TVariables, TContext> {\n  data: TData\n  error: null\n  variables: TVariables\n  isError: false\n  isIdle: false\n  isPending: false\n  isSuccess: true\n  status: 'success'\n}\n\nexport type MutationObserverResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> =\n  | MutationObserverIdleResult<TData, TError, TVariables, TContext>\n  | MutationObserverLoadingResult<TData, TError, TVariables, TContext>\n  | MutationObserverErrorResult<TData, TError, TVariables, TContext>\n  | MutationObserverSuccessResult<TData, TError, TVariables, TContext>\n\nexport interface QueryClientConfig {\n  queryCache?: QueryCache\n  mutationCache?: MutationCache\n  defaultOptions?: DefaultOptions\n}\n\nexport interface DefaultOptions<TError = DefaultError> {\n  queries?: OmitKeyof<\n    QueryObserverOptions<unknown, TError>,\n    'suspense' | 'queryKey'\n  >\n  mutations?: MutationObserverOptions<unknown, TError, unknown, unknown>\n  hydrate?: HydrateOptions['defaultOptions']\n  dehydrate?: DehydrateOptions\n}\n\nexport interface CancelOptions {\n  revert?: boolean\n  silent?: boolean\n}\n\nexport interface SetDataOptions {\n  updatedAt?: number\n}\n\nexport type NotifyEventType =\n  | 'added'\n  | 'removed'\n  | 'updated'\n  | 'observerAdded'\n  | 'observerRemoved'\n  | 'observerResultsUpdated'\n  | 'observerOptionsUpdated'\n\nexport interface NotifyEvent {\n  type: NotifyEventType\n}\n"],"mappings":";;;AA8DO,IAAM,gBAAgB,OAAO,eAAe;AAE5C,IAAM,qBAAqB,OAAO,oBAAoB;AAEtD,IAAM,cAAc,OAAO,aAAa;","names":[]}
\ No newline at end of file
diff --git a/build/legacy/utils.d.cts b/build/legacy/utils.d.cts
index 1bfe40c0dec0c5e62e65e6a30fe6b90f9cd507ce..b16935f846f45d0e5bd2f65980156e3745c29bd4 100644
--- a/build/legacy/utils.d.cts
+++ b/build/legacy/utils.d.cts
@@ -1,3 +1,3 @@
-export { j as MutationFilters, l as QueryFilters, bk as QueryTypeFilter, S as SkipToken, U as Updater, bw as addToEnd, bx as addToStart, by as ensureQueryFn, bl as functionalUpdate, h as hashKey, bq as hashQueryKeyByOptions, bs as isPlainArray, bt as isPlainObject, i as isServer, bm as isValidTimeout, k as keepPreviousData, f as matchMutation, m as matchQuery, n as noop, p as partialMatchKey, bv as replaceData, r as replaceEqualDeep, bp as resolveEnabled, bo as resolveStaleTime, br as shallowEqualObjects, g as shouldThrowError, s as skipToken, bu as sleep, bn as timeUntilStale } from './hydration-CdBkFt9i.cjs';
+export { j as MutationFilters, l as QueryFilters, bk as QueryTypeFilter, S as SkipToken, U as Updater, bw as addToEnd, bx as addToStart, by as ensureQueryFn, bl as functionalUpdate, h as hashKey, bq as hashQueryKeyByOptions, bs as isPlainArray, bt as isPlainObject, i as isServer, bm as isValidTimeout, k as keepPreviousData, f as matchMutation, m as matchQuery, n as noop, p as partialMatchKey, bv as replaceData, r as replaceEqualDeep, bp as resolveEnabled, bo as resolveStaleTime, br as shallowEqualObjects, g as shouldThrowError, s as skipToken, bu as sleep, bn as timeUntilStale } from './hydration-Dv1t2VQO.cjs';
 import './removable.cjs';
 import './subscribable.cjs';
diff --git a/build/legacy/utils.d.ts b/build/legacy/utils.d.ts
index fe8b4dabe3b72015f40bb75f92fa7fa33cfaa1ff..76e4c1ad9e2da5e7cfe6eafe1cb5928195d588a8 100644
--- a/build/legacy/utils.d.ts
+++ b/build/legacy/utils.d.ts
@@ -1,3 +1,3 @@
-export { j as MutationFilters, l as QueryFilters, bk as QueryTypeFilter, S as SkipToken, U as Updater, bw as addToEnd, bx as addToStart, by as ensureQueryFn, bl as functionalUpdate, h as hashKey, bq as hashQueryKeyByOptions, bs as isPlainArray, bt as isPlainObject, i as isServer, bm as isValidTimeout, k as keepPreviousData, f as matchMutation, m as matchQuery, n as noop, p as partialMatchKey, bv as replaceData, r as replaceEqualDeep, bp as resolveEnabled, bo as resolveStaleTime, br as shallowEqualObjects, g as shouldThrowError, s as skipToken, bu as sleep, bn as timeUntilStale } from './hydration-Cr-4Kky1.js';
+export { j as MutationFilters, l as QueryFilters, bk as QueryTypeFilter, S as SkipToken, U as Updater, bw as addToEnd, bx as addToStart, by as ensureQueryFn, bl as functionalUpdate, h as hashKey, bq as hashQueryKeyByOptions, bs as isPlainArray, bt as isPlainObject, i as isServer, bm as isValidTimeout, k as keepPreviousData, f as matchMutation, m as matchQuery, n as noop, p as partialMatchKey, bv as replaceData, r as replaceEqualDeep, bp as resolveEnabled, bo as resolveStaleTime, br as shallowEqualObjects, g as shouldThrowError, s as skipToken, bu as sleep, bn as timeUntilStale } from './hydration-Dwnp99qT.js';
 import './removable.js';
 import './subscribable.js';
diff --git a/build/modern/hydration-CdBkFt9i.d.cts b/build/modern/hydration-Dv1t2VQO.d.cts
similarity index 99%
rename from build/modern/hydration-CdBkFt9i.d.cts
rename to build/modern/hydration-Dv1t2VQO.d.cts
index f76324f5b7145d4431d088092ae98a1ba2e4c49a..9486d3b175979caaedc9e8e03ae9d22b222bd654 100644
--- a/build/modern/hydration-CdBkFt9i.d.cts
+++ b/build/modern/hydration-Dv1t2VQO.d.cts
@@ -73,6 +73,7 @@ interface FetchOptions<TData = unknown> {
     cancelRefetch?: boolean;
     meta?: FetchMeta;
     initialPromise?: Promise<TData>;
+    updateMeta?: Record<string, unknown>;
 }
 interface FailedAction$1<TError> {
     type: 'failed';
@@ -775,6 +776,7 @@ interface RefetchOptions extends ResultOptions {
      * Defaults to `true`.
      */
     cancelRefetch?: boolean;
+    updateMeta?: Record<string, unknown>;
 }
 interface InvalidateQueryFilters<TQueryKey extends QueryKey = QueryKey> extends QueryFilters<TQueryKey> {
     refetchType?: QueryTypeFilter | 'none';
diff --git a/build/modern/hydration-Cr-4Kky1.d.ts b/build/modern/hydration-Dwnp99qT.d.ts
similarity index 99%
rename from build/modern/hydration-Cr-4Kky1.d.ts
rename to build/modern/hydration-Dwnp99qT.d.ts
index 588271203cacd383b4c706099683ce06fd08baa4..1f9fc5a22873edd4dde56e17568ce3810113f928 100644
--- a/build/modern/hydration-Cr-4Kky1.d.ts
+++ b/build/modern/hydration-Dwnp99qT.d.ts
@@ -73,6 +73,7 @@ interface FetchOptions<TData = unknown> {
     cancelRefetch?: boolean;
     meta?: FetchMeta;
     initialPromise?: Promise<TData>;
+    updateMeta?: Record<string, unknown>;
 }
 interface FailedAction$1<TError> {
     type: 'failed';
@@ -775,6 +776,7 @@ interface RefetchOptions extends ResultOptions {
      * Defaults to `true`.
      */
     cancelRefetch?: boolean;
+    updateMeta?: Record<string, unknown>;
 }
 interface InvalidateQueryFilters<TQueryKey extends QueryKey = QueryKey> extends QueryFilters<TQueryKey> {
     refetchType?: QueryTypeFilter | 'none';
diff --git a/build/modern/hydration.d.cts b/build/modern/hydration.d.cts
index 2c42c5f493852f161b80bc31c6dbd5d409727df1..27fe7f6e3cd6e8f116e390da439f969a491c8385 100644
--- a/build/modern/hydration.d.cts
+++ b/build/modern/hydration.d.cts
@@ -1,3 +1,3 @@
-export { D as DehydrateOptions, A as DehydratedState, H as HydrateOptions, v as defaultShouldDehydrateMutation, u as defaultShouldDehydrateQuery, q as dehydrate, t as hydrate } from './hydration-CdBkFt9i.cjs';
+export { D as DehydrateOptions, A as DehydratedState, H as HydrateOptions, v as defaultShouldDehydrateMutation, u as defaultShouldDehydrateQuery, q as dehydrate, t as hydrate } from './hydration-Dv1t2VQO.cjs';
 import './removable.cjs';
 import './subscribable.cjs';
diff --git a/build/modern/hydration.d.ts b/build/modern/hydration.d.ts
index 44e824db5f0a3d9af2f52bc8c49baa1a7789388d..6b9eed88f845f9d8f997e7c4d5c53416b1432a0b 100644
--- a/build/modern/hydration.d.ts
+++ b/build/modern/hydration.d.ts
@@ -1,3 +1,3 @@
-export { D as DehydrateOptions, A as DehydratedState, H as HydrateOptions, v as defaultShouldDehydrateMutation, u as defaultShouldDehydrateQuery, q as dehydrate, t as hydrate } from './hydration-Cr-4Kky1.js';
+export { D as DehydrateOptions, A as DehydratedState, H as HydrateOptions, v as defaultShouldDehydrateMutation, u as defaultShouldDehydrateQuery, q as dehydrate, t as hydrate } from './hydration-Dwnp99qT.js';
 import './removable.js';
 import './subscribable.js';
diff --git a/build/modern/index.d.cts b/build/modern/index.d.cts
index 0353f72e9c2210286ebfc9d4ce52b4601a13f7de..a308c0a3a4484c26ab7e64239394609425dec10e 100644
--- a/build/modern/index.d.cts
+++ b/build/modern/index.d.cts
@@ -1,4 +1,4 @@
-export { T as AnyDataTag, b6 as CancelOptions, C as CancelledError, V as DataTag, G as DefaultError, b5 as DefaultOptions, ak as DefaultedInfiniteQueryObserverOptions, ai as DefaultedQueryObserverOptions, aP as DefinedInfiniteQueryObserverResult, aG as DefinedQueryObserverResult, D as DehydrateOptions, A as DehydratedState, B as DistributiveOmit, $ as Enabled, an as EnsureInfiniteQueryDataOptions, am as EnsureQueryDataOptions, ao as FetchInfiniteQueryOptions, av as FetchNextPageOptions, aw as FetchPreviousPageOptions, al as FetchQueryOptions, ay as FetchStatus, a7 as GetNextPageParamFunction, a6 as GetPreviousPageParamFunction, H as HydrateOptions, W as InferDataFromTag, X as InferErrorFromTag, a8 as InfiniteData, aI as InfiniteQueryObserverBaseResult, aL as InfiniteQueryObserverLoadingErrorResult, aK as InfiniteQueryObserverLoadingResult, aj as InfiniteQueryObserverOptions, aJ as InfiniteQueryObserverPendingResult, aO as InfiniteQueryObserverPlaceholderResult, aM as InfiniteQueryObserverRefetchErrorResult, aQ as InfiniteQueryObserverResult, aN as InfiniteQueryObserverSuccessResult, ae as InfiniteQueryPageParamsOptions, a2 as InitialDataFunction, ad as InitialPageParam, at as InvalidateOptions, ar as InvalidateQueryFilters, aZ as MutateFunction, aY as MutateOptions, z as Mutation, M as MutationCache, d as MutationCacheNotifyEvent, j as MutationFilters, aV as MutationFunction, aR as MutationKey, aU as MutationMeta, e as MutationObserver, a_ as MutationObserverBaseResult, b1 as MutationObserverErrorResult, a$ as MutationObserverIdleResult, b0 as MutationObserverLoadingResult, aX as MutationObserverOptions, b3 as MutationObserverResult, b2 as MutationObserverSuccessResult, aW as MutationOptions, aT as MutationScope, y as MutationState, aS as MutationStatus, aa as NetworkMode, F as NoInfer, N as NonUndefinedGuard, b9 as NotifyEvent, b8 as NotifyEventType, ab as NotifyOnChangeProps, O as OmitKeyof, E as Override, a3 as PlaceholderDataFunction, a4 as QueriesPlaceholderDataFunction, x as Query, Q as QueryCache, a as QueryCacheNotifyEvent, b as QueryClient, b4 as QueryClientConfig, l as QueryFilters, Y as QueryFunction, a1 as QueryFunctionContext, I as QueryKey, a5 as QueryKeyHashFunction, a9 as QueryMeta, c as QueryObserver, az as QueryObserverBaseResult, aC as QueryObserverLoadingErrorResult, aB as QueryObserverLoadingResult, ag as QueryObserverOptions, aA as QueryObserverPendingResult, aF as QueryObserverPlaceholderResult, aD as QueryObserverRefetchErrorResult, aH as QueryObserverResult, aE as QueryObserverSuccessResult, ac as QueryOptions, a0 as QueryPersister, w as QueryState, ax as QueryStatus, aq as RefetchOptions, as as RefetchQueryFilters, R as Register, au as ResetOptions, ap as ResultOptions, b7 as SetDataOptions, S as SkipToken, Z as StaleTime, _ as StaleTimeFunction, af as ThrowOnError, P as UnsetMarker, U as Updater, ah as WithRequired, K as dataTagErrorSymbol, J as dataTagSymbol, v as defaultShouldDehydrateMutation, u as defaultShouldDehydrateQuery, q as dehydrate, h as hashKey, t as hydrate, o as isCancelledError, i as isServer, k as keepPreviousData, f as matchMutation, m as matchQuery, n as noop, p as partialMatchKey, r as replaceEqualDeep, g as shouldThrowError, s as skipToken, L as unsetMarker } from './hydration-CdBkFt9i.cjs';
+export { T as AnyDataTag, b6 as CancelOptions, C as CancelledError, V as DataTag, G as DefaultError, b5 as DefaultOptions, ak as DefaultedInfiniteQueryObserverOptions, ai as DefaultedQueryObserverOptions, aP as DefinedInfiniteQueryObserverResult, aG as DefinedQueryObserverResult, D as DehydrateOptions, A as DehydratedState, B as DistributiveOmit, $ as Enabled, an as EnsureInfiniteQueryDataOptions, am as EnsureQueryDataOptions, ao as FetchInfiniteQueryOptions, av as FetchNextPageOptions, aw as FetchPreviousPageOptions, al as FetchQueryOptions, ay as FetchStatus, a7 as GetNextPageParamFunction, a6 as GetPreviousPageParamFunction, H as HydrateOptions, W as InferDataFromTag, X as InferErrorFromTag, a8 as InfiniteData, aI as InfiniteQueryObserverBaseResult, aL as InfiniteQueryObserverLoadingErrorResult, aK as InfiniteQueryObserverLoadingResult, aj as InfiniteQueryObserverOptions, aJ as InfiniteQueryObserverPendingResult, aO as InfiniteQueryObserverPlaceholderResult, aM as InfiniteQueryObserverRefetchErrorResult, aQ as InfiniteQueryObserverResult, aN as InfiniteQueryObserverSuccessResult, ae as InfiniteQueryPageParamsOptions, a2 as InitialDataFunction, ad as InitialPageParam, at as InvalidateOptions, ar as InvalidateQueryFilters, aZ as MutateFunction, aY as MutateOptions, z as Mutation, M as MutationCache, d as MutationCacheNotifyEvent, j as MutationFilters, aV as MutationFunction, aR as MutationKey, aU as MutationMeta, e as MutationObserver, a_ as MutationObserverBaseResult, b1 as MutationObserverErrorResult, a$ as MutationObserverIdleResult, b0 as MutationObserverLoadingResult, aX as MutationObserverOptions, b3 as MutationObserverResult, b2 as MutationObserverSuccessResult, aW as MutationOptions, aT as MutationScope, y as MutationState, aS as MutationStatus, aa as NetworkMode, F as NoInfer, N as NonUndefinedGuard, b9 as NotifyEvent, b8 as NotifyEventType, ab as NotifyOnChangeProps, O as OmitKeyof, E as Override, a3 as PlaceholderDataFunction, a4 as QueriesPlaceholderDataFunction, x as Query, Q as QueryCache, a as QueryCacheNotifyEvent, b as QueryClient, b4 as QueryClientConfig, l as QueryFilters, Y as QueryFunction, a1 as QueryFunctionContext, I as QueryKey, a5 as QueryKeyHashFunction, a9 as QueryMeta, c as QueryObserver, az as QueryObserverBaseResult, aC as QueryObserverLoadingErrorResult, aB as QueryObserverLoadingResult, ag as QueryObserverOptions, aA as QueryObserverPendingResult, aF as QueryObserverPlaceholderResult, aD as QueryObserverRefetchErrorResult, aH as QueryObserverResult, aE as QueryObserverSuccessResult, ac as QueryOptions, a0 as QueryPersister, w as QueryState, ax as QueryStatus, aq as RefetchOptions, as as RefetchQueryFilters, R as Register, au as ResetOptions, ap as ResultOptions, b7 as SetDataOptions, S as SkipToken, Z as StaleTime, _ as StaleTimeFunction, af as ThrowOnError, P as UnsetMarker, U as Updater, ah as WithRequired, K as dataTagErrorSymbol, J as dataTagSymbol, v as defaultShouldDehydrateMutation, u as defaultShouldDehydrateQuery, q as dehydrate, h as hashKey, t as hydrate, o as isCancelledError, i as isServer, k as keepPreviousData, f as matchMutation, m as matchQuery, n as noop, p as partialMatchKey, r as replaceEqualDeep, g as shouldThrowError, s as skipToken, L as unsetMarker } from './hydration-Dv1t2VQO.cjs';
 export { QueriesObserver, QueriesObserverOptions } from './queriesObserver.cjs';
 export { InfiniteQueryObserver } from './infiniteQueryObserver.cjs';
 export { defaultScheduler, notifyManager } from './notifyManager.cjs';
diff --git a/build/modern/index.d.ts b/build/modern/index.d.ts
index 3eacee662d9884fd70e56b107415b6a8190dfa2a..5bdd7bf2642601f1e8a2c5505fd2a3ad68739dd6 100644
--- a/build/modern/index.d.ts
+++ b/build/modern/index.d.ts
@@ -1,4 +1,4 @@
-export { T as AnyDataTag, b6 as CancelOptions, C as CancelledError, V as DataTag, G as DefaultError, b5 as DefaultOptions, ak as DefaultedInfiniteQueryObserverOptions, ai as DefaultedQueryObserverOptions, aP as DefinedInfiniteQueryObserverResult, aG as DefinedQueryObserverResult, D as DehydrateOptions, A as DehydratedState, B as DistributiveOmit, $ as Enabled, an as EnsureInfiniteQueryDataOptions, am as EnsureQueryDataOptions, ao as FetchInfiniteQueryOptions, av as FetchNextPageOptions, aw as FetchPreviousPageOptions, al as FetchQueryOptions, ay as FetchStatus, a7 as GetNextPageParamFunction, a6 as GetPreviousPageParamFunction, H as HydrateOptions, W as InferDataFromTag, X as InferErrorFromTag, a8 as InfiniteData, aI as InfiniteQueryObserverBaseResult, aL as InfiniteQueryObserverLoadingErrorResult, aK as InfiniteQueryObserverLoadingResult, aj as InfiniteQueryObserverOptions, aJ as InfiniteQueryObserverPendingResult, aO as InfiniteQueryObserverPlaceholderResult, aM as InfiniteQueryObserverRefetchErrorResult, aQ as InfiniteQueryObserverResult, aN as InfiniteQueryObserverSuccessResult, ae as InfiniteQueryPageParamsOptions, a2 as InitialDataFunction, ad as InitialPageParam, at as InvalidateOptions, ar as InvalidateQueryFilters, aZ as MutateFunction, aY as MutateOptions, z as Mutation, M as MutationCache, d as MutationCacheNotifyEvent, j as MutationFilters, aV as MutationFunction, aR as MutationKey, aU as MutationMeta, e as MutationObserver, a_ as MutationObserverBaseResult, b1 as MutationObserverErrorResult, a$ as MutationObserverIdleResult, b0 as MutationObserverLoadingResult, aX as MutationObserverOptions, b3 as MutationObserverResult, b2 as MutationObserverSuccessResult, aW as MutationOptions, aT as MutationScope, y as MutationState, aS as MutationStatus, aa as NetworkMode, F as NoInfer, N as NonUndefinedGuard, b9 as NotifyEvent, b8 as NotifyEventType, ab as NotifyOnChangeProps, O as OmitKeyof, E as Override, a3 as PlaceholderDataFunction, a4 as QueriesPlaceholderDataFunction, x as Query, Q as QueryCache, a as QueryCacheNotifyEvent, b as QueryClient, b4 as QueryClientConfig, l as QueryFilters, Y as QueryFunction, a1 as QueryFunctionContext, I as QueryKey, a5 as QueryKeyHashFunction, a9 as QueryMeta, c as QueryObserver, az as QueryObserverBaseResult, aC as QueryObserverLoadingErrorResult, aB as QueryObserverLoadingResult, ag as QueryObserverOptions, aA as QueryObserverPendingResult, aF as QueryObserverPlaceholderResult, aD as QueryObserverRefetchErrorResult, aH as QueryObserverResult, aE as QueryObserverSuccessResult, ac as QueryOptions, a0 as QueryPersister, w as QueryState, ax as QueryStatus, aq as RefetchOptions, as as RefetchQueryFilters, R as Register, au as ResetOptions, ap as ResultOptions, b7 as SetDataOptions, S as SkipToken, Z as StaleTime, _ as StaleTimeFunction, af as ThrowOnError, P as UnsetMarker, U as Updater, ah as WithRequired, K as dataTagErrorSymbol, J as dataTagSymbol, v as defaultShouldDehydrateMutation, u as defaultShouldDehydrateQuery, q as dehydrate, h as hashKey, t as hydrate, o as isCancelledError, i as isServer, k as keepPreviousData, f as matchMutation, m as matchQuery, n as noop, p as partialMatchKey, r as replaceEqualDeep, g as shouldThrowError, s as skipToken, L as unsetMarker } from './hydration-Cr-4Kky1.js';
+export { T as AnyDataTag, b6 as CancelOptions, C as CancelledError, V as DataTag, G as DefaultError, b5 as DefaultOptions, ak as DefaultedInfiniteQueryObserverOptions, ai as DefaultedQueryObserverOptions, aP as DefinedInfiniteQueryObserverResult, aG as DefinedQueryObserverResult, D as DehydrateOptions, A as DehydratedState, B as DistributiveOmit, $ as Enabled, an as EnsureInfiniteQueryDataOptions, am as EnsureQueryDataOptions, ao as FetchInfiniteQueryOptions, av as FetchNextPageOptions, aw as FetchPreviousPageOptions, al as FetchQueryOptions, ay as FetchStatus, a7 as GetNextPageParamFunction, a6 as GetPreviousPageParamFunction, H as HydrateOptions, W as InferDataFromTag, X as InferErrorFromTag, a8 as InfiniteData, aI as InfiniteQueryObserverBaseResult, aL as InfiniteQueryObserverLoadingErrorResult, aK as InfiniteQueryObserverLoadingResult, aj as InfiniteQueryObserverOptions, aJ as InfiniteQueryObserverPendingResult, aO as InfiniteQueryObserverPlaceholderResult, aM as InfiniteQueryObserverRefetchErrorResult, aQ as InfiniteQueryObserverResult, aN as InfiniteQueryObserverSuccessResult, ae as InfiniteQueryPageParamsOptions, a2 as InitialDataFunction, ad as InitialPageParam, at as InvalidateOptions, ar as InvalidateQueryFilters, aZ as MutateFunction, aY as MutateOptions, z as Mutation, M as MutationCache, d as MutationCacheNotifyEvent, j as MutationFilters, aV as MutationFunction, aR as MutationKey, aU as MutationMeta, e as MutationObserver, a_ as MutationObserverBaseResult, b1 as MutationObserverErrorResult, a$ as MutationObserverIdleResult, b0 as MutationObserverLoadingResult, aX as MutationObserverOptions, b3 as MutationObserverResult, b2 as MutationObserverSuccessResult, aW as MutationOptions, aT as MutationScope, y as MutationState, aS as MutationStatus, aa as NetworkMode, F as NoInfer, N as NonUndefinedGuard, b9 as NotifyEvent, b8 as NotifyEventType, ab as NotifyOnChangeProps, O as OmitKeyof, E as Override, a3 as PlaceholderDataFunction, a4 as QueriesPlaceholderDataFunction, x as Query, Q as QueryCache, a as QueryCacheNotifyEvent, b as QueryClient, b4 as QueryClientConfig, l as QueryFilters, Y as QueryFunction, a1 as QueryFunctionContext, I as QueryKey, a5 as QueryKeyHashFunction, a9 as QueryMeta, c as QueryObserver, az as QueryObserverBaseResult, aC as QueryObserverLoadingErrorResult, aB as QueryObserverLoadingResult, ag as QueryObserverOptions, aA as QueryObserverPendingResult, aF as QueryObserverPlaceholderResult, aD as QueryObserverRefetchErrorResult, aH as QueryObserverResult, aE as QueryObserverSuccessResult, ac as QueryOptions, a0 as QueryPersister, w as QueryState, ax as QueryStatus, aq as RefetchOptions, as as RefetchQueryFilters, R as Register, au as ResetOptions, ap as ResultOptions, b7 as SetDataOptions, S as SkipToken, Z as StaleTime, _ as StaleTimeFunction, af as ThrowOnError, P as UnsetMarker, U as Updater, ah as WithRequired, K as dataTagErrorSymbol, J as dataTagSymbol, v as defaultShouldDehydrateMutation, u as defaultShouldDehydrateQuery, q as dehydrate, h as hashKey, t as hydrate, o as isCancelledError, i as isServer, k as keepPreviousData, f as matchMutation, m as matchQuery, n as noop, p as partialMatchKey, r as replaceEqualDeep, g as shouldThrowError, s as skipToken, L as unsetMarker } from './hydration-Dwnp99qT.js';
 export { QueriesObserver, QueriesObserverOptions } from './queriesObserver.js';
 export { InfiniteQueryObserver } from './infiniteQueryObserver.js';
 export { defaultScheduler, notifyManager } from './notifyManager.js';
diff --git a/build/modern/infiniteQueryBehavior.d.cts b/build/modern/infiniteQueryBehavior.d.cts
index dc431640774bd6ee0f8b6c38a7abf9afc1fe9a4f..2fb3508a04ce42f4a4dbd145b6b66ab9bdedfd80 100644
--- a/build/modern/infiniteQueryBehavior.d.cts
+++ b/build/modern/infiniteQueryBehavior.d.cts
@@ -1,4 +1,4 @@
-import { ba as QueryBehavior, a8 as InfiniteData, ae as InfiniteQueryPageParamsOptions } from './hydration-CdBkFt9i.cjs';
+import { ba as QueryBehavior, a8 as InfiniteData, ae as InfiniteQueryPageParamsOptions } from './hydration-Dv1t2VQO.cjs';
 import './removable.cjs';
 import './subscribable.cjs';
 
diff --git a/build/modern/infiniteQueryBehavior.d.ts b/build/modern/infiniteQueryBehavior.d.ts
index d101b7141e9ec1a7a963765a6e82b88dc788252f..b837c7b3ae5f5eee9c2a6e049db6ebd459707692 100644
--- a/build/modern/infiniteQueryBehavior.d.ts
+++ b/build/modern/infiniteQueryBehavior.d.ts
@@ -1,4 +1,4 @@
-import { ba as QueryBehavior, a8 as InfiniteData, ae as InfiniteQueryPageParamsOptions } from './hydration-Cr-4Kky1.js';
+import { ba as QueryBehavior, a8 as InfiniteData, ae as InfiniteQueryPageParamsOptions } from './hydration-Dwnp99qT.js';
 import './removable.js';
 import './subscribable.js';
 
diff --git a/build/modern/infiniteQueryObserver.d.cts b/build/modern/infiniteQueryObserver.d.cts
index fd5bc8a8ddfa244b2573d895a6eea2ed9f4a5b8e..8ee52ac9e2f6d8d2145866560a352cc3d372db55 100644
--- a/build/modern/infiniteQueryObserver.d.cts
+++ b/build/modern/infiniteQueryObserver.d.cts
@@ -1,4 +1,4 @@
-import { G as DefaultError, a8 as InfiniteData, I as QueryKey, c as QueryObserver, aQ as InfiniteQueryObserverResult, b as QueryClient, aj as InfiniteQueryObserverOptions, ak as DefaultedInfiniteQueryObserverOptions, av as FetchNextPageOptions, aw as FetchPreviousPageOptions, x as Query } from './hydration-CdBkFt9i.cjs';
+import { G as DefaultError, a8 as InfiniteData, I as QueryKey, c as QueryObserver, aQ as InfiniteQueryObserverResult, b as QueryClient, aj as InfiniteQueryObserverOptions, ak as DefaultedInfiniteQueryObserverOptions, av as FetchNextPageOptions, aw as FetchPreviousPageOptions, x as Query } from './hydration-Dv1t2VQO.cjs';
 import { Subscribable } from './subscribable.cjs';
 import './removable.cjs';
 
diff --git a/build/modern/infiniteQueryObserver.d.ts b/build/modern/infiniteQueryObserver.d.ts
index 88fff903875a31a48e0cc4d8bc101a9ad9e580f7..c49b3653191dd05cae8483611134c0a7691051e9 100644
--- a/build/modern/infiniteQueryObserver.d.ts
+++ b/build/modern/infiniteQueryObserver.d.ts
@@ -1,4 +1,4 @@
-import { G as DefaultError, a8 as InfiniteData, I as QueryKey, c as QueryObserver, aQ as InfiniteQueryObserverResult, b as QueryClient, aj as InfiniteQueryObserverOptions, ak as DefaultedInfiniteQueryObserverOptions, av as FetchNextPageOptions, aw as FetchPreviousPageOptions, x as Query } from './hydration-Cr-4Kky1.js';
+import { G as DefaultError, a8 as InfiniteData, I as QueryKey, c as QueryObserver, aQ as InfiniteQueryObserverResult, b as QueryClient, aj as InfiniteQueryObserverOptions, ak as DefaultedInfiniteQueryObserverOptions, av as FetchNextPageOptions, aw as FetchPreviousPageOptions, x as Query } from './hydration-Dwnp99qT.js';
 import { Subscribable } from './subscribable.js';
 import './removable.js';
 
diff --git a/build/modern/mutation.d.cts b/build/modern/mutation.d.cts
index a389982d2535be6422cf026b793653f16dbc2d06..b603e777bdb4850412e1b87c369fef1b47e3ae88 100644
--- a/build/modern/mutation.d.cts
+++ b/build/modern/mutation.d.cts
@@ -1,3 +1,3 @@
 import './removable.cjs';
-export { bi as Action, z as Mutation, y as MutationState, bj as getDefaultState } from './hydration-CdBkFt9i.cjs';
+export { bi as Action, z as Mutation, y as MutationState, bj as getDefaultState } from './hydration-Dv1t2VQO.cjs';
 import './subscribable.cjs';
diff --git a/build/modern/mutation.d.ts b/build/modern/mutation.d.ts
index dde7d7dfb71e8d32061bc1635e0e5318a561f3ac..c9e0754240c16882dd346345c0665ddc95f8ddbd 100644
--- a/build/modern/mutation.d.ts
+++ b/build/modern/mutation.d.ts
@@ -1,3 +1,3 @@
 import './removable.js';
-export { bi as Action, z as Mutation, y as MutationState, bj as getDefaultState } from './hydration-Cr-4Kky1.js';
+export { bi as Action, z as Mutation, y as MutationState, bj as getDefaultState } from './hydration-Dwnp99qT.js';
 import './subscribable.js';
diff --git a/build/modern/mutationCache.d.cts b/build/modern/mutationCache.d.cts
index cdf5fa04605fbe176955a33066dcea9d686ab2d3..103612e98a644c6a1fb8febfe8aa2aaaf63a1184 100644
--- a/build/modern/mutationCache.d.cts
+++ b/build/modern/mutationCache.d.cts
@@ -1,3 +1,3 @@
-export { M as MutationCache, d as MutationCacheNotifyEvent } from './hydration-CdBkFt9i.cjs';
+export { M as MutationCache, d as MutationCacheNotifyEvent } from './hydration-Dv1t2VQO.cjs';
 import './subscribable.cjs';
 import './removable.cjs';
diff --git a/build/modern/mutationCache.d.ts b/build/modern/mutationCache.d.ts
index 83e89ed128dd4ef9de638b4bee5a522467296a46..488b1ee5abe1bbe68ccb2cc4216ef7f004d59ec2 100644
--- a/build/modern/mutationCache.d.ts
+++ b/build/modern/mutationCache.d.ts
@@ -1,3 +1,3 @@
-export { M as MutationCache, d as MutationCacheNotifyEvent } from './hydration-Cr-4Kky1.js';
+export { M as MutationCache, d as MutationCacheNotifyEvent } from './hydration-Dwnp99qT.js';
 import './subscribable.js';
 import './removable.js';
diff --git a/build/modern/mutationObserver.d.cts b/build/modern/mutationObserver.d.cts
index 434d57afc47b6ba50c986e5912dfcc73e5e33518..2f1b51610ca0df15145e626bc7251ade5dd634f4 100644
--- a/build/modern/mutationObserver.d.cts
+++ b/build/modern/mutationObserver.d.cts
@@ -1,3 +1,3 @@
 import './subscribable.cjs';
-export { e as MutationObserver } from './hydration-CdBkFt9i.cjs';
+export { e as MutationObserver } from './hydration-Dv1t2VQO.cjs';
 import './removable.cjs';
diff --git a/build/modern/mutationObserver.d.ts b/build/modern/mutationObserver.d.ts
index 30812b79b3cf4b4ce01ec52d5301cabdcb47eba6..198ffa3584641b6b0ef4bfc90ca5fdbc56ede2c1 100644
--- a/build/modern/mutationObserver.d.ts
+++ b/build/modern/mutationObserver.d.ts
@@ -1,3 +1,3 @@
 import './subscribable.js';
-export { e as MutationObserver } from './hydration-Cr-4Kky1.js';
+export { e as MutationObserver } from './hydration-Dwnp99qT.js';
 import './removable.js';
diff --git a/build/modern/queriesObserver.d.cts b/build/modern/queriesObserver.d.cts
index 1fc8ee0fad7439f1ae1dbd04968fdde4fdf14e81..19cb98368ddc6f44696c883e9170cc45e6e3934d 100644
--- a/build/modern/queriesObserver.d.cts
+++ b/build/modern/queriesObserver.d.cts
@@ -1,4 +1,4 @@
-import { aH as QueryObserverResult, b as QueryClient, ag as QueryObserverOptions, x as Query, c as QueryObserver } from './hydration-CdBkFt9i.cjs';
+import { aH as QueryObserverResult, b as QueryClient, ag as QueryObserverOptions, x as Query, c as QueryObserver } from './hydration-Dv1t2VQO.cjs';
 import { Subscribable } from './subscribable.cjs';
 import './removable.cjs';
 
diff --git a/build/modern/queriesObserver.d.ts b/build/modern/queriesObserver.d.ts
index f58d4aa0cae947004220be2dd2f4fbede04b7bfe..3e2170cbdaf4fa8f4d65bb5cfb9fab3cf4e1e628 100644
--- a/build/modern/queriesObserver.d.ts
+++ b/build/modern/queriesObserver.d.ts
@@ -1,4 +1,4 @@
-import { aH as QueryObserverResult, b as QueryClient, ag as QueryObserverOptions, x as Query, c as QueryObserver } from './hydration-Cr-4Kky1.js';
+import { aH as QueryObserverResult, b as QueryClient, ag as QueryObserverOptions, x as Query, c as QueryObserver } from './hydration-Dwnp99qT.js';
 import { Subscribable } from './subscribable.js';
 import './removable.js';
 
diff --git a/build/modern/query.cjs b/build/modern/query.cjs
index 678c417f01c3cf085bb27535e25633c5f4d35fd2..357374b8d04f768cd28d4a2c067af9eeca7d80e0 100644
--- a/build/modern/query.cjs
+++ b/build/modern/query.cjs
@@ -212,7 +212,7 @@ var Query = class extends import_removable.Removable {
         const queryFnContext2 = {
           client: this.#client,
           queryKey: this.queryKey,
-          meta: this.meta
+          meta: fetchOptions?.updateMeta ? { ...this.meta, ...fetchOptions.updateMeta } : this.meta
         };
         addSignalProperty(queryFnContext2);
         return queryFnContext2;
diff --git a/build/modern/query.cjs.map b/build/modern/query.cjs.map
index 2f93be4ae1f490baaa1710256924e0bca71d3391..b473d288e57eb7a2c9a81ebf7c3cdf877be5a786 100644
--- a/build/modern/query.cjs.map
+++ b/build/modern/query.cjs.map
@@ -1 +1 @@
-{"version":3,"sources":["../../src/query.ts"],"sourcesContent":["import {\n  ensureQueryFn,\n  noop,\n  replaceData,\n  resolveEnabled,\n  resolveStaleTime,\n  skipToken,\n  timeUntilStale,\n} from './utils'\nimport { notifyManager } from './notifyManager'\nimport { canFetch, createRetryer, isCancelledError } from './retryer'\nimport { Removable } from './removable'\nimport type { QueryCache } from './queryCache'\nimport type { QueryClient } from './queryClient'\nimport type {\n  CancelOptions,\n  DefaultError,\n  FetchStatus,\n  InitialDataFunction,\n  OmitKeyof,\n  QueryFunctionContext,\n  QueryKey,\n  QueryMeta,\n  QueryOptions,\n  QueryStatus,\n  SetDataOptions,\n  StaleTime,\n} from './types'\nimport type { QueryObserver } from './queryObserver'\nimport type { Retryer } from './retryer'\n\n// TYPES\n\ninterface QueryConfig<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  client: QueryClient\n  queryKey: TQueryKey\n  queryHash: string\n  options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  state?: QueryState<TData, TError>\n}\n\nexport interface QueryState<TData = unknown, TError = DefaultError> {\n  data: TData | undefined\n  dataUpdateCount: number\n  dataUpdatedAt: number\n  error: TError | null\n  errorUpdateCount: number\n  errorUpdatedAt: number\n  fetchFailureCount: number\n  fetchFailureReason: TError | null\n  fetchMeta: FetchMeta | null\n  isInvalidated: boolean\n  status: QueryStatus\n  fetchStatus: FetchStatus\n}\n\nexport interface FetchContext<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  fetchFn: () => unknown | Promise<unknown>\n  fetchOptions?: FetchOptions\n  signal: AbortSignal\n  options: QueryOptions<TQueryFnData, TError, TData, any>\n  client: QueryClient\n  queryKey: TQueryKey\n  state: QueryState<TData, TError>\n}\n\nexport interface QueryBehavior<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  onFetch: (\n    context: FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n    query: Query,\n  ) => void\n}\n\nexport type FetchDirection = 'forward' | 'backward'\n\nexport interface FetchMeta {\n  fetchMore?: { direction: FetchDirection }\n}\n\nexport interface FetchOptions<TData = unknown> {\n  cancelRefetch?: boolean\n  meta?: FetchMeta\n  initialPromise?: Promise<TData>\n}\n\ninterface FailedAction<TError> {\n  type: 'failed'\n  failureCount: number\n  error: TError\n}\n\ninterface FetchAction {\n  type: 'fetch'\n  meta?: FetchMeta\n}\n\ninterface SuccessAction<TData> {\n  data: TData | undefined\n  type: 'success'\n  dataUpdatedAt?: number\n  manual?: boolean\n}\n\ninterface ErrorAction<TError> {\n  type: 'error'\n  error: TError\n}\n\ninterface InvalidateAction {\n  type: 'invalidate'\n}\n\ninterface PauseAction {\n  type: 'pause'\n}\n\ninterface ContinueAction {\n  type: 'continue'\n}\n\ninterface SetStateAction<TData, TError> {\n  type: 'setState'\n  state: Partial<QueryState<TData, TError>>\n  setStateOptions?: SetStateOptions\n}\n\nexport type Action<TData, TError> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction<TError>\n  | FetchAction\n  | InvalidateAction\n  | PauseAction\n  | SetStateAction<TData, TError>\n  | SuccessAction<TData>\n\nexport interface SetStateOptions {\n  meta?: any\n}\n\n// CLASS\n\nexport class Query<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Removable {\n  queryKey: TQueryKey\n  queryHash: string\n  options!: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  state: QueryState<TData, TError>\n\n  #initialState: QueryState<TData, TError>\n  #revertState?: QueryState<TData, TError>\n  #cache: QueryCache\n  #client: QueryClient\n  #retryer?: Retryer<TData>\n  observers: Array<QueryObserver<any, any, any, any, any>>\n  #defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  #abortSignalConsumed: boolean\n\n  constructor(config: QueryConfig<TQueryFnData, TError, TData, TQueryKey>) {\n    super()\n\n    this.#abortSignalConsumed = false\n    this.#defaultOptions = config.defaultOptions\n    this.setOptions(config.options)\n    this.observers = []\n    this.#client = config.client\n    this.#cache = this.#client.getQueryCache()\n    this.queryKey = config.queryKey\n    this.queryHash = config.queryHash\n    this.#initialState = getDefaultState(this.options)\n    this.state = config.state ?? this.#initialState\n    this.scheduleGc()\n  }\n  get meta(): QueryMeta | undefined {\n    return this.options.meta\n  }\n\n  get promise(): Promise<TData> | undefined {\n    return this.#retryer?.promise\n  }\n\n  setOptions(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): void {\n    this.options = { ...this.#defaultOptions, ...options }\n\n    this.updateGcTime(this.options.gcTime)\n  }\n\n  protected optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === 'idle') {\n      this.#cache.remove(this)\n    }\n  }\n\n  setData(\n    newData: TData,\n    options?: SetDataOptions & { manual: boolean },\n  ): TData {\n    const data = replaceData(this.state.data, newData, this.options)\n\n    // Set data and mark it as cached\n    this.#dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options?.updatedAt,\n      manual: options?.manual,\n    })\n\n    return data\n  }\n\n  setState(\n    state: Partial<QueryState<TData, TError>>,\n    setStateOptions?: SetStateOptions,\n  ): void {\n    this.#dispatch({ type: 'setState', state, setStateOptions })\n  }\n\n  cancel(options?: CancelOptions): Promise<void> {\n    const promise = this.#retryer?.promise\n    this.#retryer?.cancel(options)\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve()\n  }\n\n  destroy(): void {\n    super.destroy()\n\n    this.cancel({ silent: true })\n  }\n\n  reset(): void {\n    this.destroy()\n    this.setState(this.#initialState)\n  }\n\n  isActive(): boolean {\n    return this.observers.some(\n      (observer) => resolveEnabled(observer.options.enabled, this) !== false,\n    )\n  }\n\n  isDisabled(): boolean {\n    if (this.getObserversCount() > 0) {\n      return !this.isActive()\n    }\n    // if a query has no observers, it should still be considered disabled if it never attempted a fetch\n    return (\n      this.options.queryFn === skipToken ||\n      this.state.dataUpdateCount + this.state.errorUpdateCount === 0\n    )\n  }\n\n  isStatic(): boolean {\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(\n        (observer) =>\n          resolveStaleTime(observer.options.staleTime, this) === 'static',\n      )\n    }\n\n    return false\n  }\n\n  isStale(): boolean {\n    // check observers first, their `isStale` has the source of truth\n    // calculated with `isStaleByTime` and it takes `enabled` into account\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(\n        (observer) => observer.getCurrentResult().isStale,\n      )\n    }\n\n    return this.state.data === undefined || this.state.isInvalidated\n  }\n\n  isStaleByTime(staleTime: StaleTime = 0): boolean {\n    // no data is always stale\n    if (this.state.data === undefined) {\n      return true\n    }\n    // static is never stale\n    if (staleTime === 'static') {\n      return false\n    }\n    // if the query is invalidated, it is stale\n    if (this.state.isInvalidated) {\n      return true\n    }\n\n    return !timeUntilStale(this.state.dataUpdatedAt, staleTime)\n  }\n\n  onFocus(): void {\n    const observer = this.observers.find((x) => x.shouldFetchOnWindowFocus())\n\n    observer?.refetch({ cancelRefetch: false })\n\n    // Continue fetch if currently paused\n    this.#retryer?.continue()\n  }\n\n  onOnline(): void {\n    const observer = this.observers.find((x) => x.shouldFetchOnReconnect())\n\n    observer?.refetch({ cancelRefetch: false })\n\n    // Continue fetch if currently paused\n    this.#retryer?.continue()\n  }\n\n  addObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer)\n\n      // Stop the query from being garbage collected\n      this.clearGcTimeout()\n\n      this.#cache.notify({ type: 'observerAdded', query: this, observer })\n    }\n  }\n\n  removeObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (this.observers.includes(observer)) {\n      this.observers = this.observers.filter((x) => x !== observer)\n\n      if (!this.observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.#retryer) {\n          if (this.#abortSignalConsumed) {\n            this.#retryer.cancel({ revert: true })\n          } else {\n            this.#retryer.cancelRetry()\n          }\n        }\n\n        this.scheduleGc()\n      }\n\n      this.#cache.notify({ type: 'observerRemoved', query: this, observer })\n    }\n  }\n\n  getObserversCount(): number {\n    return this.observers.length\n  }\n\n  invalidate(): void {\n    if (!this.state.isInvalidated) {\n      this.#dispatch({ type: 'invalidate' })\n    }\n  }\n\n  fetch(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    fetchOptions?: FetchOptions<TQueryFnData>,\n  ): Promise<TData> {\n    if (this.state.fetchStatus !== 'idle') {\n      if (this.state.data !== undefined && fetchOptions?.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetch\n        this.cancel({ silent: true })\n      } else if (this.#retryer) {\n        // make sure that retries that were potentially cancelled due to unmounts can continue\n        this.#retryer.continueRetry()\n        // Return current promise if we are already fetching\n        return this.#retryer.promise\n      }\n    }\n\n    // Update config if passed, otherwise the config from the last execution is used\n    if (options) {\n      this.setOptions(options)\n    }\n\n    // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n    if (!this.options.queryFn) {\n      const observer = this.observers.find((x) => x.options.queryFn)\n      if (observer) {\n        this.setOptions(observer.options)\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!Array.isArray(this.options.queryKey)) {\n        console.error(\n          `As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`,\n        )\n      }\n    }\n\n    const abortController = new AbortController()\n\n    // Adds an enumerable signal property to the object that\n    // which sets abortSignalConsumed to true when the signal\n    // is read.\n    const addSignalProperty = (object: unknown) => {\n      Object.defineProperty(object, 'signal', {\n        enumerable: true,\n        get: () => {\n          this.#abortSignalConsumed = true\n          return abortController.signal\n        },\n      })\n    }\n\n    // Create fetch function\n    const fetchFn = () => {\n      const queryFn = ensureQueryFn(this.options, fetchOptions)\n\n      // Create query function context\n      const createQueryFnContext = (): QueryFunctionContext<TQueryKey> => {\n        const queryFnContext: OmitKeyof<\n          QueryFunctionContext<TQueryKey>,\n          'signal'\n        > = {\n          client: this.#client,\n          queryKey: this.queryKey,\n          meta: this.meta,\n        }\n        addSignalProperty(queryFnContext)\n        return queryFnContext as QueryFunctionContext<TQueryKey>\n      }\n\n      const queryFnContext = createQueryFnContext()\n\n      this.#abortSignalConsumed = false\n      if (this.options.persister) {\n        return this.options.persister(\n          queryFn,\n          queryFnContext,\n          this as unknown as Query,\n        )\n      }\n\n      return queryFn(queryFnContext)\n    }\n\n    // Trigger behavior hook\n    const createFetchContext = (): FetchContext<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey\n    > => {\n      const context: OmitKeyof<\n        FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n        'signal'\n      > = {\n        fetchOptions,\n        options: this.options,\n        queryKey: this.queryKey,\n        client: this.#client,\n        state: this.state,\n        fetchFn,\n      }\n\n      addSignalProperty(context)\n      return context as FetchContext<TQueryFnData, TError, TData, TQueryKey>\n    }\n\n    const context = createFetchContext()\n\n    this.options.behavior?.onFetch(context, this as unknown as Query)\n\n    // Store state in case the current fetch needs to be reverted\n    this.#revertState = this.state\n\n    // Set to fetching state if not already in it\n    if (\n      this.state.fetchStatus === 'idle' ||\n      this.state.fetchMeta !== context.fetchOptions?.meta\n    ) {\n      this.#dispatch({ type: 'fetch', meta: context.fetchOptions?.meta })\n    }\n\n    const onError = (error: TError | { silent?: boolean }) => {\n      // Optimistically update state if needed\n      if (!(isCancelledError(error) && error.silent)) {\n        this.#dispatch({\n          type: 'error',\n          error: error as TError,\n        })\n      }\n\n      if (!isCancelledError(error)) {\n        // Notify cache callback\n        this.#cache.config.onError?.(\n          error as any,\n          this as Query<any, any, any, any>,\n        )\n        this.#cache.config.onSettled?.(\n          this.state.data,\n          error as any,\n          this as Query<any, any, any, any>,\n        )\n      }\n\n      // Schedule query gc after fetching\n      this.scheduleGc()\n    }\n\n    // Try to fetch the data\n    this.#retryer = createRetryer({\n      initialPromise: fetchOptions?.initialPromise as\n        | Promise<TData>\n        | undefined,\n      fn: context.fetchFn as () => Promise<TData>,\n      abort: abortController.abort.bind(abortController),\n      onSuccess: (data) => {\n        if (data === undefined) {\n          if (process.env.NODE_ENV !== 'production') {\n            console.error(\n              `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`,\n            )\n          }\n          onError(new Error(`${this.queryHash} data is undefined`) as any)\n          return\n        }\n\n        try {\n          this.setData(data)\n        } catch (error) {\n          onError(error as TError)\n          return\n        }\n\n        // Notify cache callback\n        this.#cache.config.onSuccess?.(data, this as Query<any, any, any, any>)\n        this.#cache.config.onSettled?.(\n          data,\n          this.state.error as any,\n          this as Query<any, any, any, any>,\n        )\n\n        // Schedule query gc after fetching\n        this.scheduleGc()\n      },\n      onError,\n      onFail: (failureCount, error) => {\n        this.#dispatch({ type: 'failed', failureCount, error })\n      },\n      onPause: () => {\n        this.#dispatch({ type: 'pause' })\n      },\n      onContinue: () => {\n        this.#dispatch({ type: 'continue' })\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode,\n      canRun: () => true,\n    })\n\n    return this.#retryer.start()\n  }\n\n  #dispatch(action: Action<TData, TError>): void {\n    const reducer = (\n      state: QueryState<TData, TError>,\n    ): QueryState<TData, TError> => {\n      switch (action.type) {\n        case 'failed':\n          return {\n            ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error,\n          }\n        case 'pause':\n          return {\n            ...state,\n            fetchStatus: 'paused',\n          }\n        case 'continue':\n          return {\n            ...state,\n            fetchStatus: 'fetching',\n          }\n        case 'fetch':\n          return {\n            ...state,\n            ...fetchState(state.data, this.options),\n            fetchMeta: action.meta ?? null,\n          }\n        case 'success':\n          // If fetching ends successfully, we don't need revertState as a fallback anymore.\n          this.#revertState = undefined\n          return {\n            ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: 'success',\n            ...(!action.manual && {\n              fetchStatus: 'idle',\n              fetchFailureCount: 0,\n              fetchFailureReason: null,\n            }),\n          }\n        case 'error':\n          const error = action.error\n\n          if (isCancelledError(error) && error.revert && this.#revertState) {\n            return { ...this.#revertState, fetchStatus: 'idle' }\n          }\n\n          return {\n            ...state,\n            error,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error,\n            fetchStatus: 'idle',\n            status: 'error',\n          }\n        case 'invalidate':\n          return {\n            ...state,\n            isInvalidated: true,\n          }\n        case 'setState':\n          return {\n            ...state,\n            ...action.state,\n          }\n      }\n    }\n\n    this.state = reducer(this.state)\n\n    notifyManager.batch(() => {\n      this.observers.forEach((observer) => {\n        observer.onQueryUpdate()\n      })\n\n      this.#cache.notify({ query: this, type: 'updated', action })\n    })\n  }\n}\n\nexport function fetchState<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey,\n>(\n  data: TData | undefined,\n  options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n) {\n  return {\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchStatus: canFetch(options.networkMode) ? 'fetching' : 'paused',\n    ...(data === undefined &&\n      ({\n        error: null,\n        status: 'pending',\n      } as const)),\n  } as const\n}\n\nfunction getDefaultState<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey,\n>(\n  options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): QueryState<TData, TError> {\n  const data =\n    typeof options.initialData === 'function'\n      ? (options.initialData as InitialDataFunction<TData>)()\n      : options.initialData\n\n  const hasData = data !== undefined\n\n  const initialDataUpdatedAt = hasData\n    ? typeof options.initialDataUpdatedAt === 'function'\n      ? (options.initialDataUpdatedAt as () => number | undefined)()\n      : options.initialDataUpdatedAt\n    : 0\n\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? (initialDataUpdatedAt ?? Date.now()) : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'pending',\n    fetchStatus: 'idle',\n  }\n}\n"],"mappings":"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","names":["queryFnContext","context"]}
\ No newline at end of file
+{"version":3,"sources":["../../src/query.ts"],"sourcesContent":["import {\n  ensureQueryFn,\n  noop,\n  replaceData,\n  resolveEnabled,\n  resolveStaleTime,\n  skipToken,\n  timeUntilStale,\n} from './utils'\nimport { notifyManager } from './notifyManager'\nimport { canFetch, createRetryer, isCancelledError } from './retryer'\nimport { Removable } from './removable'\nimport type { QueryCache } from './queryCache'\nimport type { QueryClient } from './queryClient'\nimport type {\n  CancelOptions,\n  DefaultError,\n  FetchStatus,\n  InitialDataFunction,\n  OmitKeyof,\n  QueryFunctionContext,\n  QueryKey,\n  QueryMeta,\n  QueryOptions,\n  QueryStatus,\n  SetDataOptions,\n  StaleTime,\n} from './types'\nimport type { QueryObserver } from './queryObserver'\nimport type { Retryer } from './retryer'\n\n// TYPES\n\ninterface QueryConfig<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  client: QueryClient\n  queryKey: TQueryKey\n  queryHash: string\n  options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  state?: QueryState<TData, TError>\n}\n\nexport interface QueryState<TData = unknown, TError = DefaultError> {\n  data: TData | undefined\n  dataUpdateCount: number\n  dataUpdatedAt: number\n  error: TError | null\n  errorUpdateCount: number\n  errorUpdatedAt: number\n  fetchFailureCount: number\n  fetchFailureReason: TError | null\n  fetchMeta: FetchMeta | null\n  isInvalidated: boolean\n  status: QueryStatus\n  fetchStatus: FetchStatus\n}\n\nexport interface FetchContext<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  fetchFn: () => unknown | Promise<unknown>\n  fetchOptions?: FetchOptions\n  signal: AbortSignal\n  options: QueryOptions<TQueryFnData, TError, TData, any>\n  client: QueryClient\n  queryKey: TQueryKey\n  state: QueryState<TData, TError>\n}\n\nexport interface QueryBehavior<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  onFetch: (\n    context: FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n    query: Query,\n  ) => void\n}\n\nexport type FetchDirection = 'forward' | 'backward'\n\nexport interface FetchMeta {\n  fetchMore?: { direction: FetchDirection }\n}\n\nexport interface FetchOptions<TData = unknown> {\n  cancelRefetch?: boolean\n  meta?: FetchMeta\n  initialPromise?: Promise<TData>\n  updateMeta?: Record<string, unknown>\n}\n\ninterface FailedAction<TError> {\n  type: 'failed'\n  failureCount: number\n  error: TError\n}\n\ninterface FetchAction {\n  type: 'fetch'\n  meta?: FetchMeta\n}\n\ninterface SuccessAction<TData> {\n  data: TData | undefined\n  type: 'success'\n  dataUpdatedAt?: number\n  manual?: boolean\n}\n\ninterface ErrorAction<TError> {\n  type: 'error'\n  error: TError\n}\n\ninterface InvalidateAction {\n  type: 'invalidate'\n}\n\ninterface PauseAction {\n  type: 'pause'\n}\n\ninterface ContinueAction {\n  type: 'continue'\n}\n\ninterface SetStateAction<TData, TError> {\n  type: 'setState'\n  state: Partial<QueryState<TData, TError>>\n  setStateOptions?: SetStateOptions\n}\n\nexport type Action<TData, TError> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction<TError>\n  | FetchAction\n  | InvalidateAction\n  | PauseAction\n  | SetStateAction<TData, TError>\n  | SuccessAction<TData>\n\nexport interface SetStateOptions {\n  meta?: any\n}\n\n// CLASS\n\nexport class Query<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Removable {\n  queryKey: TQueryKey\n  queryHash: string\n  options!: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  state: QueryState<TData, TError>\n\n  #initialState: QueryState<TData, TError>\n  #revertState?: QueryState<TData, TError>\n  #cache: QueryCache\n  #client: QueryClient\n  #retryer?: Retryer<TData>\n  observers: Array<QueryObserver<any, any, any, any, any>>\n  #defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  #abortSignalConsumed: boolean\n\n  constructor(config: QueryConfig<TQueryFnData, TError, TData, TQueryKey>) {\n    super()\n\n    this.#abortSignalConsumed = false\n    this.#defaultOptions = config.defaultOptions\n    this.setOptions(config.options)\n    this.observers = []\n    this.#client = config.client\n    this.#cache = this.#client.getQueryCache()\n    this.queryKey = config.queryKey\n    this.queryHash = config.queryHash\n    this.#initialState = getDefaultState(this.options)\n    this.state = config.state ?? this.#initialState\n    this.scheduleGc()\n  }\n  get meta(): QueryMeta | undefined {\n    return this.options.meta\n  }\n\n  get promise(): Promise<TData> | undefined {\n    return this.#retryer?.promise\n  }\n\n  setOptions(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): void {\n    this.options = { ...this.#defaultOptions, ...options }\n\n    this.updateGcTime(this.options.gcTime)\n  }\n\n  protected optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === 'idle') {\n      this.#cache.remove(this)\n    }\n  }\n\n  setData(\n    newData: TData,\n    options?: SetDataOptions & { manual: boolean },\n  ): TData {\n    const data = replaceData(this.state.data, newData, this.options)\n\n    // Set data and mark it as cached\n    this.#dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options?.updatedAt,\n      manual: options?.manual,\n    })\n\n    return data\n  }\n\n  setState(\n    state: Partial<QueryState<TData, TError>>,\n    setStateOptions?: SetStateOptions,\n  ): void {\n    this.#dispatch({ type: 'setState', state, setStateOptions })\n  }\n\n  cancel(options?: CancelOptions): Promise<void> {\n    const promise = this.#retryer?.promise\n    this.#retryer?.cancel(options)\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve()\n  }\n\n  destroy(): void {\n    super.destroy()\n\n    this.cancel({ silent: true })\n  }\n\n  reset(): void {\n    this.destroy()\n    this.setState(this.#initialState)\n  }\n\n  isActive(): boolean {\n    return this.observers.some(\n      (observer) => resolveEnabled(observer.options.enabled, this) !== false,\n    )\n  }\n\n  isDisabled(): boolean {\n    if (this.getObserversCount() > 0) {\n      return !this.isActive()\n    }\n    // if a query has no observers, it should still be considered disabled if it never attempted a fetch\n    return (\n      this.options.queryFn === skipToken ||\n      this.state.dataUpdateCount + this.state.errorUpdateCount === 0\n    )\n  }\n\n  isStatic(): boolean {\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(\n        (observer) =>\n          resolveStaleTime(observer.options.staleTime, this) === 'static',\n      )\n    }\n\n    return false\n  }\n\n  isStale(): boolean {\n    // check observers first, their `isStale` has the source of truth\n    // calculated with `isStaleByTime` and it takes `enabled` into account\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(\n        (observer) => observer.getCurrentResult().isStale,\n      )\n    }\n\n    return this.state.data === undefined || this.state.isInvalidated\n  }\n\n  isStaleByTime(staleTime: StaleTime = 0): boolean {\n    // no data is always stale\n    if (this.state.data === undefined) {\n      return true\n    }\n    // static is never stale\n    if (staleTime === 'static') {\n      return false\n    }\n    // if the query is invalidated, it is stale\n    if (this.state.isInvalidated) {\n      return true\n    }\n\n    return !timeUntilStale(this.state.dataUpdatedAt, staleTime)\n  }\n\n  onFocus(): void {\n    const observer = this.observers.find((x) => x.shouldFetchOnWindowFocus())\n\n    observer?.refetch({ cancelRefetch: false })\n\n    // Continue fetch if currently paused\n    this.#retryer?.continue()\n  }\n\n  onOnline(): void {\n    const observer = this.observers.find((x) => x.shouldFetchOnReconnect())\n\n    observer?.refetch({ cancelRefetch: false })\n\n    // Continue fetch if currently paused\n    this.#retryer?.continue()\n  }\n\n  addObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer)\n\n      // Stop the query from being garbage collected\n      this.clearGcTimeout()\n\n      this.#cache.notify({ type: 'observerAdded', query: this, observer })\n    }\n  }\n\n  removeObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (this.observers.includes(observer)) {\n      this.observers = this.observers.filter((x) => x !== observer)\n\n      if (!this.observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.#retryer) {\n          if (this.#abortSignalConsumed) {\n            this.#retryer.cancel({ revert: true })\n          } else {\n            this.#retryer.cancelRetry()\n          }\n        }\n\n        this.scheduleGc()\n      }\n\n      this.#cache.notify({ type: 'observerRemoved', query: this, observer })\n    }\n  }\n\n  getObserversCount(): number {\n    return this.observers.length\n  }\n\n  invalidate(): void {\n    if (!this.state.isInvalidated) {\n      this.#dispatch({ type: 'invalidate' })\n    }\n  }\n\n  fetch(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    fetchOptions?: FetchOptions<TQueryFnData>,\n  ): Promise<TData> {\n    if (this.state.fetchStatus !== 'idle') {\n      if (this.state.data !== undefined && fetchOptions?.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetch\n        this.cancel({ silent: true })\n      } else if (this.#retryer) {\n        // make sure that retries that were potentially cancelled due to unmounts can continue\n        this.#retryer.continueRetry()\n        // Return current promise if we are already fetching\n        return this.#retryer.promise\n      }\n    }\n\n    // Update config if passed, otherwise the config from the last execution is used\n    if (options) {\n      this.setOptions(options)\n    }\n\n    // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n    if (!this.options.queryFn) {\n      const observer = this.observers.find((x) => x.options.queryFn)\n      if (observer) {\n        this.setOptions(observer.options)\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!Array.isArray(this.options.queryKey)) {\n        console.error(\n          `As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`,\n        )\n      }\n    }\n\n    const abortController = new AbortController()\n\n    // Adds an enumerable signal property to the object that\n    // which sets abortSignalConsumed to true when the signal\n    // is read.\n    const addSignalProperty = (object: unknown) => {\n      Object.defineProperty(object, 'signal', {\n        enumerable: true,\n        get: () => {\n          this.#abortSignalConsumed = true\n          return abortController.signal\n        },\n      })\n    }\n\n    // Create fetch function\n    const fetchFn = () => {\n      const queryFn = ensureQueryFn(this.options, fetchOptions)\n\n      // Create query function context\n      const createQueryFnContext = (): QueryFunctionContext<TQueryKey> => {\n        const queryFnContext: OmitKeyof<\n          QueryFunctionContext<TQueryKey>,\n          'signal'\n        > = {\n          client: this.#client,\n          queryKey: this.queryKey,\n          meta: fetchOptions?.updateMeta ? {...this.meta, ...fetchOptions.updateMeta } : this.meta,\n        }\n        addSignalProperty(queryFnContext)\n        return queryFnContext as QueryFunctionContext<TQueryKey>\n      }\n\n      const queryFnContext = createQueryFnContext()\n\n      this.#abortSignalConsumed = false\n      if (this.options.persister) {\n        return this.options.persister(\n          queryFn,\n          queryFnContext,\n          this as unknown as Query,\n        )\n      }\n\n      return queryFn(queryFnContext)\n    }\n\n    // Trigger behavior hook\n    const createFetchContext = (): FetchContext<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey\n    > => {\n      const context: OmitKeyof<\n        FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n        'signal'\n      > = {\n        fetchOptions,\n        options: this.options,\n        queryKey: this.queryKey,\n        client: this.#client,\n        state: this.state,\n        fetchFn,\n      }\n\n      addSignalProperty(context)\n      return context as FetchContext<TQueryFnData, TError, TData, TQueryKey>\n    }\n\n    const context = createFetchContext()\n\n    this.options.behavior?.onFetch(context, this as unknown as Query)\n\n    // Store state in case the current fetch needs to be reverted\n    this.#revertState = this.state\n\n    // Set to fetching state if not already in it\n    if (\n      this.state.fetchStatus === 'idle' ||\n      this.state.fetchMeta !== context.fetchOptions?.meta\n    ) {\n      this.#dispatch({ type: 'fetch', meta: context.fetchOptions?.meta })\n    }\n\n    const onError = (error: TError | { silent?: boolean }) => {\n      // Optimistically update state if needed\n      if (!(isCancelledError(error) && error.silent)) {\n        this.#dispatch({\n          type: 'error',\n          error: error as TError,\n        })\n      }\n\n      if (!isCancelledError(error)) {\n        // Notify cache callback\n        this.#cache.config.onError?.(\n          error as any,\n          this as Query<any, any, any, any>,\n        )\n        this.#cache.config.onSettled?.(\n          this.state.data,\n          error as any,\n          this as Query<any, any, any, any>,\n        )\n      }\n\n      // Schedule query gc after fetching\n      this.scheduleGc()\n    }\n\n    // Try to fetch the data\n    this.#retryer = createRetryer({\n      initialPromise: fetchOptions?.initialPromise as\n        | Promise<TData>\n        | undefined,\n      fn: context.fetchFn as () => Promise<TData>,\n      abort: abortController.abort.bind(abortController),\n      onSuccess: (data) => {\n        if (data === undefined) {\n          if (process.env.NODE_ENV !== 'production') {\n            console.error(\n              `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`,\n            )\n          }\n          onError(new Error(`${this.queryHash} data is undefined`) as any)\n          return\n        }\n\n        try {\n          this.setData(data)\n        } catch (error) {\n          onError(error as TError)\n          return\n        }\n\n        // Notify cache callback\n        this.#cache.config.onSuccess?.(data, this as Query<any, any, any, any>)\n        this.#cache.config.onSettled?.(\n          data,\n          this.state.error as any,\n          this as Query<any, any, any, any>,\n        )\n\n        // Schedule query gc after fetching\n        this.scheduleGc()\n      },\n      onError,\n      onFail: (failureCount, error) => {\n        this.#dispatch({ type: 'failed', failureCount, error })\n      },\n      onPause: () => {\n        this.#dispatch({ type: 'pause' })\n      },\n      onContinue: () => {\n        this.#dispatch({ type: 'continue' })\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode,\n      canRun: () => true,\n    })\n\n    return this.#retryer.start()\n  }\n\n  #dispatch(action: Action<TData, TError>): void {\n    const reducer = (\n      state: QueryState<TData, TError>,\n    ): QueryState<TData, TError> => {\n      switch (action.type) {\n        case 'failed':\n          return {\n            ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error,\n          }\n        case 'pause':\n          return {\n            ...state,\n            fetchStatus: 'paused',\n          }\n        case 'continue':\n          return {\n            ...state,\n            fetchStatus: 'fetching',\n          }\n        case 'fetch':\n          return {\n            ...state,\n            ...fetchState(state.data, this.options),\n            fetchMeta: action.meta ?? null,\n          }\n        case 'success':\n          // If fetching ends successfully, we don't need revertState as a fallback anymore.\n          this.#revertState = undefined\n          return {\n            ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: 'success',\n            ...(!action.manual && {\n              fetchStatus: 'idle',\n              fetchFailureCount: 0,\n              fetchFailureReason: null,\n            }),\n          }\n        case 'error':\n          const error = action.error\n\n          if (isCancelledError(error) && error.revert && this.#revertState) {\n            return { ...this.#revertState, fetchStatus: 'idle' }\n          }\n\n          return {\n            ...state,\n            error,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error,\n            fetchStatus: 'idle',\n            status: 'error',\n          }\n        case 'invalidate':\n          return {\n            ...state,\n            isInvalidated: true,\n          }\n        case 'setState':\n          return {\n            ...state,\n            ...action.state,\n          }\n      }\n    }\n\n    this.state = reducer(this.state)\n\n    notifyManager.batch(() => {\n      this.observers.forEach((observer) => {\n        observer.onQueryUpdate()\n      })\n\n      this.#cache.notify({ query: this, type: 'updated', action })\n    })\n  }\n}\n\nexport function fetchState<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey,\n>(\n  data: TData | undefined,\n  options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n) {\n  return {\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchStatus: canFetch(options.networkMode) ? 'fetching' : 'paused',\n    ...(data === undefined &&\n      ({\n        error: null,\n        status: 'pending',\n      } as const)),\n  } as const\n}\n\nfunction getDefaultState<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey,\n>(\n  options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): QueryState<TData, TError> {\n  const data =\n    typeof options.initialData === 'function'\n      ? (options.initialData as InitialDataFunction<TData>)()\n      : options.initialData\n\n  const hasData = data !== undefined\n\n  const initialDataUpdatedAt = hasData\n    ? typeof options.initialDataUpdatedAt === 'function'\n      ? (options.initialDataUpdatedAt as () => number | undefined)()\n      : options.initialDataUpdatedAt\n    : 0\n\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? (initialDataUpdatedAt ?? Date.now()) : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'pending',\n    fetchStatus: 'idle',\n  }\n}\n"],"mappings":"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","names":["queryFnContext","context"]}
\ No newline at end of file
diff --git a/build/modern/query.d.cts b/build/modern/query.d.cts
index 7102ddc2ee879ad195bbc42a5738357fe2302ab5..a74691fc23490e48760c1c3ee2f4dde1b371291e 100644
--- a/build/modern/query.d.cts
+++ b/build/modern/query.d.cts
@@ -1,3 +1,3 @@
 import './removable.cjs';
-export { bf as Action, bb as FetchContext, bc as FetchDirection, bd as FetchMeta, be as FetchOptions, x as Query, ba as QueryBehavior, w as QueryState, bg as SetStateOptions, bh as fetchState } from './hydration-CdBkFt9i.cjs';
+export { bf as Action, bb as FetchContext, bc as FetchDirection, bd as FetchMeta, be as FetchOptions, x as Query, ba as QueryBehavior, w as QueryState, bg as SetStateOptions, bh as fetchState } from './hydration-Dv1t2VQO.cjs';
 import './subscribable.cjs';
diff --git a/build/modern/query.d.ts b/build/modern/query.d.ts
index 99185759a513502a7449346065d0a9f79e199e0e..7775da43ddaa6eccc111ba60c644a1fac1e21fef 100644
--- a/build/modern/query.d.ts
+++ b/build/modern/query.d.ts
@@ -1,3 +1,3 @@
 import './removable.js';
-export { bf as Action, bb as FetchContext, bc as FetchDirection, bd as FetchMeta, be as FetchOptions, x as Query, ba as QueryBehavior, w as QueryState, bg as SetStateOptions, bh as fetchState } from './hydration-Cr-4Kky1.js';
+export { bf as Action, bb as FetchContext, bc as FetchDirection, bd as FetchMeta, be as FetchOptions, x as Query, ba as QueryBehavior, w as QueryState, bg as SetStateOptions, bh as fetchState } from './hydration-Dwnp99qT.js';
 import './subscribable.js';
diff --git a/build/modern/query.js b/build/modern/query.js
index 5df01852fa175cb195453521eaf84bc3c82bd797..3f2d5306d30196cab30b1132e5484087ff8a6de5 100644
--- a/build/modern/query.js
+++ b/build/modern/query.js
@@ -195,7 +195,7 @@ var Query = class extends Removable {
         const queryFnContext2 = {
           client: this.#client,
           queryKey: this.queryKey,
-          meta: this.meta
+          meta: fetchOptions?.updateMeta ? { ...this.meta, ...fetchOptions.updateMeta } : this.meta
         };
         addSignalProperty(queryFnContext2);
         return queryFnContext2;
diff --git a/build/modern/query.js.map b/build/modern/query.js.map
index d877cdb5420b3dfd3d5c0c7cf1431d77f1cb4a63..70a6c55f52def292b56a19918c5c1364bd17d183 100644
--- a/build/modern/query.js.map
+++ b/build/modern/query.js.map
@@ -1 +1 @@
-{"version":3,"sources":["../../src/query.ts"],"sourcesContent":["import {\n  ensureQueryFn,\n  noop,\n  replaceData,\n  resolveEnabled,\n  resolveStaleTime,\n  skipToken,\n  timeUntilStale,\n} from './utils'\nimport { notifyManager } from './notifyManager'\nimport { canFetch, createRetryer, isCancelledError } from './retryer'\nimport { Removable } from './removable'\nimport type { QueryCache } from './queryCache'\nimport type { QueryClient } from './queryClient'\nimport type {\n  CancelOptions,\n  DefaultError,\n  FetchStatus,\n  InitialDataFunction,\n  OmitKeyof,\n  QueryFunctionContext,\n  QueryKey,\n  QueryMeta,\n  QueryOptions,\n  QueryStatus,\n  SetDataOptions,\n  StaleTime,\n} from './types'\nimport type { QueryObserver } from './queryObserver'\nimport type { Retryer } from './retryer'\n\n// TYPES\n\ninterface QueryConfig<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  client: QueryClient\n  queryKey: TQueryKey\n  queryHash: string\n  options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  state?: QueryState<TData, TError>\n}\n\nexport interface QueryState<TData = unknown, TError = DefaultError> {\n  data: TData | undefined\n  dataUpdateCount: number\n  dataUpdatedAt: number\n  error: TError | null\n  errorUpdateCount: number\n  errorUpdatedAt: number\n  fetchFailureCount: number\n  fetchFailureReason: TError | null\n  fetchMeta: FetchMeta | null\n  isInvalidated: boolean\n  status: QueryStatus\n  fetchStatus: FetchStatus\n}\n\nexport interface FetchContext<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  fetchFn: () => unknown | Promise<unknown>\n  fetchOptions?: FetchOptions\n  signal: AbortSignal\n  options: QueryOptions<TQueryFnData, TError, TData, any>\n  client: QueryClient\n  queryKey: TQueryKey\n  state: QueryState<TData, TError>\n}\n\nexport interface QueryBehavior<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  onFetch: (\n    context: FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n    query: Query,\n  ) => void\n}\n\nexport type FetchDirection = 'forward' | 'backward'\n\nexport interface FetchMeta {\n  fetchMore?: { direction: FetchDirection }\n}\n\nexport interface FetchOptions<TData = unknown> {\n  cancelRefetch?: boolean\n  meta?: FetchMeta\n  initialPromise?: Promise<TData>\n}\n\ninterface FailedAction<TError> {\n  type: 'failed'\n  failureCount: number\n  error: TError\n}\n\ninterface FetchAction {\n  type: 'fetch'\n  meta?: FetchMeta\n}\n\ninterface SuccessAction<TData> {\n  data: TData | undefined\n  type: 'success'\n  dataUpdatedAt?: number\n  manual?: boolean\n}\n\ninterface ErrorAction<TError> {\n  type: 'error'\n  error: TError\n}\n\ninterface InvalidateAction {\n  type: 'invalidate'\n}\n\ninterface PauseAction {\n  type: 'pause'\n}\n\ninterface ContinueAction {\n  type: 'continue'\n}\n\ninterface SetStateAction<TData, TError> {\n  type: 'setState'\n  state: Partial<QueryState<TData, TError>>\n  setStateOptions?: SetStateOptions\n}\n\nexport type Action<TData, TError> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction<TError>\n  | FetchAction\n  | InvalidateAction\n  | PauseAction\n  | SetStateAction<TData, TError>\n  | SuccessAction<TData>\n\nexport interface SetStateOptions {\n  meta?: any\n}\n\n// CLASS\n\nexport class Query<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Removable {\n  queryKey: TQueryKey\n  queryHash: string\n  options!: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  state: QueryState<TData, TError>\n\n  #initialState: QueryState<TData, TError>\n  #revertState?: QueryState<TData, TError>\n  #cache: QueryCache\n  #client: QueryClient\n  #retryer?: Retryer<TData>\n  observers: Array<QueryObserver<any, any, any, any, any>>\n  #defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  #abortSignalConsumed: boolean\n\n  constructor(config: QueryConfig<TQueryFnData, TError, TData, TQueryKey>) {\n    super()\n\n    this.#abortSignalConsumed = false\n    this.#defaultOptions = config.defaultOptions\n    this.setOptions(config.options)\n    this.observers = []\n    this.#client = config.client\n    this.#cache = this.#client.getQueryCache()\n    this.queryKey = config.queryKey\n    this.queryHash = config.queryHash\n    this.#initialState = getDefaultState(this.options)\n    this.state = config.state ?? this.#initialState\n    this.scheduleGc()\n  }\n  get meta(): QueryMeta | undefined {\n    return this.options.meta\n  }\n\n  get promise(): Promise<TData> | undefined {\n    return this.#retryer?.promise\n  }\n\n  setOptions(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): void {\n    this.options = { ...this.#defaultOptions, ...options }\n\n    this.updateGcTime(this.options.gcTime)\n  }\n\n  protected optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === 'idle') {\n      this.#cache.remove(this)\n    }\n  }\n\n  setData(\n    newData: TData,\n    options?: SetDataOptions & { manual: boolean },\n  ): TData {\n    const data = replaceData(this.state.data, newData, this.options)\n\n    // Set data and mark it as cached\n    this.#dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options?.updatedAt,\n      manual: options?.manual,\n    })\n\n    return data\n  }\n\n  setState(\n    state: Partial<QueryState<TData, TError>>,\n    setStateOptions?: SetStateOptions,\n  ): void {\n    this.#dispatch({ type: 'setState', state, setStateOptions })\n  }\n\n  cancel(options?: CancelOptions): Promise<void> {\n    const promise = this.#retryer?.promise\n    this.#retryer?.cancel(options)\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve()\n  }\n\n  destroy(): void {\n    super.destroy()\n\n    this.cancel({ silent: true })\n  }\n\n  reset(): void {\n    this.destroy()\n    this.setState(this.#initialState)\n  }\n\n  isActive(): boolean {\n    return this.observers.some(\n      (observer) => resolveEnabled(observer.options.enabled, this) !== false,\n    )\n  }\n\n  isDisabled(): boolean {\n    if (this.getObserversCount() > 0) {\n      return !this.isActive()\n    }\n    // if a query has no observers, it should still be considered disabled if it never attempted a fetch\n    return (\n      this.options.queryFn === skipToken ||\n      this.state.dataUpdateCount + this.state.errorUpdateCount === 0\n    )\n  }\n\n  isStatic(): boolean {\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(\n        (observer) =>\n          resolveStaleTime(observer.options.staleTime, this) === 'static',\n      )\n    }\n\n    return false\n  }\n\n  isStale(): boolean {\n    // check observers first, their `isStale` has the source of truth\n    // calculated with `isStaleByTime` and it takes `enabled` into account\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(\n        (observer) => observer.getCurrentResult().isStale,\n      )\n    }\n\n    return this.state.data === undefined || this.state.isInvalidated\n  }\n\n  isStaleByTime(staleTime: StaleTime = 0): boolean {\n    // no data is always stale\n    if (this.state.data === undefined) {\n      return true\n    }\n    // static is never stale\n    if (staleTime === 'static') {\n      return false\n    }\n    // if the query is invalidated, it is stale\n    if (this.state.isInvalidated) {\n      return true\n    }\n\n    return !timeUntilStale(this.state.dataUpdatedAt, staleTime)\n  }\n\n  onFocus(): void {\n    const observer = this.observers.find((x) => x.shouldFetchOnWindowFocus())\n\n    observer?.refetch({ cancelRefetch: false })\n\n    // Continue fetch if currently paused\n    this.#retryer?.continue()\n  }\n\n  onOnline(): void {\n    const observer = this.observers.find((x) => x.shouldFetchOnReconnect())\n\n    observer?.refetch({ cancelRefetch: false })\n\n    // Continue fetch if currently paused\n    this.#retryer?.continue()\n  }\n\n  addObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer)\n\n      // Stop the query from being garbage collected\n      this.clearGcTimeout()\n\n      this.#cache.notify({ type: 'observerAdded', query: this, observer })\n    }\n  }\n\n  removeObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (this.observers.includes(observer)) {\n      this.observers = this.observers.filter((x) => x !== observer)\n\n      if (!this.observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.#retryer) {\n          if (this.#abortSignalConsumed) {\n            this.#retryer.cancel({ revert: true })\n          } else {\n            this.#retryer.cancelRetry()\n          }\n        }\n\n        this.scheduleGc()\n      }\n\n      this.#cache.notify({ type: 'observerRemoved', query: this, observer })\n    }\n  }\n\n  getObserversCount(): number {\n    return this.observers.length\n  }\n\n  invalidate(): void {\n    if (!this.state.isInvalidated) {\n      this.#dispatch({ type: 'invalidate' })\n    }\n  }\n\n  fetch(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    fetchOptions?: FetchOptions<TQueryFnData>,\n  ): Promise<TData> {\n    if (this.state.fetchStatus !== 'idle') {\n      if (this.state.data !== undefined && fetchOptions?.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetch\n        this.cancel({ silent: true })\n      } else if (this.#retryer) {\n        // make sure that retries that were potentially cancelled due to unmounts can continue\n        this.#retryer.continueRetry()\n        // Return current promise if we are already fetching\n        return this.#retryer.promise\n      }\n    }\n\n    // Update config if passed, otherwise the config from the last execution is used\n    if (options) {\n      this.setOptions(options)\n    }\n\n    // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n    if (!this.options.queryFn) {\n      const observer = this.observers.find((x) => x.options.queryFn)\n      if (observer) {\n        this.setOptions(observer.options)\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!Array.isArray(this.options.queryKey)) {\n        console.error(\n          `As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`,\n        )\n      }\n    }\n\n    const abortController = new AbortController()\n\n    // Adds an enumerable signal property to the object that\n    // which sets abortSignalConsumed to true when the signal\n    // is read.\n    const addSignalProperty = (object: unknown) => {\n      Object.defineProperty(object, 'signal', {\n        enumerable: true,\n        get: () => {\n          this.#abortSignalConsumed = true\n          return abortController.signal\n        },\n      })\n    }\n\n    // Create fetch function\n    const fetchFn = () => {\n      const queryFn = ensureQueryFn(this.options, fetchOptions)\n\n      // Create query function context\n      const createQueryFnContext = (): QueryFunctionContext<TQueryKey> => {\n        const queryFnContext: OmitKeyof<\n          QueryFunctionContext<TQueryKey>,\n          'signal'\n        > = {\n          client: this.#client,\n          queryKey: this.queryKey,\n          meta: this.meta,\n        }\n        addSignalProperty(queryFnContext)\n        return queryFnContext as QueryFunctionContext<TQueryKey>\n      }\n\n      const queryFnContext = createQueryFnContext()\n\n      this.#abortSignalConsumed = false\n      if (this.options.persister) {\n        return this.options.persister(\n          queryFn,\n          queryFnContext,\n          this as unknown as Query,\n        )\n      }\n\n      return queryFn(queryFnContext)\n    }\n\n    // Trigger behavior hook\n    const createFetchContext = (): FetchContext<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey\n    > => {\n      const context: OmitKeyof<\n        FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n        'signal'\n      > = {\n        fetchOptions,\n        options: this.options,\n        queryKey: this.queryKey,\n        client: this.#client,\n        state: this.state,\n        fetchFn,\n      }\n\n      addSignalProperty(context)\n      return context as FetchContext<TQueryFnData, TError, TData, TQueryKey>\n    }\n\n    const context = createFetchContext()\n\n    this.options.behavior?.onFetch(context, this as unknown as Query)\n\n    // Store state in case the current fetch needs to be reverted\n    this.#revertState = this.state\n\n    // Set to fetching state if not already in it\n    if (\n      this.state.fetchStatus === 'idle' ||\n      this.state.fetchMeta !== context.fetchOptions?.meta\n    ) {\n      this.#dispatch({ type: 'fetch', meta: context.fetchOptions?.meta })\n    }\n\n    const onError = (error: TError | { silent?: boolean }) => {\n      // Optimistically update state if needed\n      if (!(isCancelledError(error) && error.silent)) {\n        this.#dispatch({\n          type: 'error',\n          error: error as TError,\n        })\n      }\n\n      if (!isCancelledError(error)) {\n        // Notify cache callback\n        this.#cache.config.onError?.(\n          error as any,\n          this as Query<any, any, any, any>,\n        )\n        this.#cache.config.onSettled?.(\n          this.state.data,\n          error as any,\n          this as Query<any, any, any, any>,\n        )\n      }\n\n      // Schedule query gc after fetching\n      this.scheduleGc()\n    }\n\n    // Try to fetch the data\n    this.#retryer = createRetryer({\n      initialPromise: fetchOptions?.initialPromise as\n        | Promise<TData>\n        | undefined,\n      fn: context.fetchFn as () => Promise<TData>,\n      abort: abortController.abort.bind(abortController),\n      onSuccess: (data) => {\n        if (data === undefined) {\n          if (process.env.NODE_ENV !== 'production') {\n            console.error(\n              `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`,\n            )\n          }\n          onError(new Error(`${this.queryHash} data is undefined`) as any)\n          return\n        }\n\n        try {\n          this.setData(data)\n        } catch (error) {\n          onError(error as TError)\n          return\n        }\n\n        // Notify cache callback\n        this.#cache.config.onSuccess?.(data, this as Query<any, any, any, any>)\n        this.#cache.config.onSettled?.(\n          data,\n          this.state.error as any,\n          this as Query<any, any, any, any>,\n        )\n\n        // Schedule query gc after fetching\n        this.scheduleGc()\n      },\n      onError,\n      onFail: (failureCount, error) => {\n        this.#dispatch({ type: 'failed', failureCount, error })\n      },\n      onPause: () => {\n        this.#dispatch({ type: 'pause' })\n      },\n      onContinue: () => {\n        this.#dispatch({ type: 'continue' })\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode,\n      canRun: () => true,\n    })\n\n    return this.#retryer.start()\n  }\n\n  #dispatch(action: Action<TData, TError>): void {\n    const reducer = (\n      state: QueryState<TData, TError>,\n    ): QueryState<TData, TError> => {\n      switch (action.type) {\n        case 'failed':\n          return {\n            ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error,\n          }\n        case 'pause':\n          return {\n            ...state,\n            fetchStatus: 'paused',\n          }\n        case 'continue':\n          return {\n            ...state,\n            fetchStatus: 'fetching',\n          }\n        case 'fetch':\n          return {\n            ...state,\n            ...fetchState(state.data, this.options),\n            fetchMeta: action.meta ?? null,\n          }\n        case 'success':\n          // If fetching ends successfully, we don't need revertState as a fallback anymore.\n          this.#revertState = undefined\n          return {\n            ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: 'success',\n            ...(!action.manual && {\n              fetchStatus: 'idle',\n              fetchFailureCount: 0,\n              fetchFailureReason: null,\n            }),\n          }\n        case 'error':\n          const error = action.error\n\n          if (isCancelledError(error) && error.revert && this.#revertState) {\n            return { ...this.#revertState, fetchStatus: 'idle' }\n          }\n\n          return {\n            ...state,\n            error,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error,\n            fetchStatus: 'idle',\n            status: 'error',\n          }\n        case 'invalidate':\n          return {\n            ...state,\n            isInvalidated: true,\n          }\n        case 'setState':\n          return {\n            ...state,\n            ...action.state,\n          }\n      }\n    }\n\n    this.state = reducer(this.state)\n\n    notifyManager.batch(() => {\n      this.observers.forEach((observer) => {\n        observer.onQueryUpdate()\n      })\n\n      this.#cache.notify({ query: this, type: 'updated', action })\n    })\n  }\n}\n\nexport function fetchState<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey,\n>(\n  data: TData | undefined,\n  options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n) {\n  return {\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchStatus: canFetch(options.networkMode) ? 'fetching' : 'paused',\n    ...(data === undefined &&\n      ({\n        error: null,\n        status: 'pending',\n      } as const)),\n  } as const\n}\n\nfunction getDefaultState<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey,\n>(\n  options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): QueryState<TData, TError> {\n  const data =\n    typeof options.initialData === 'function'\n      ? (options.initialData as InitialDataFunction<TData>)()\n      : options.initialData\n\n  const hasData = data !== undefined\n\n  const initialDataUpdatedAt = hasData\n    ? typeof options.initialDataUpdatedAt === 'function'\n      ? (options.initialDataUpdatedAt as () => number | undefined)()\n      : options.initialDataUpdatedAt\n    : 0\n\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? (initialDataUpdatedAt ?? Date.now()) : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'pending',\n    fetchStatus: 'idle',\n  }\n}\n"],"mappings":"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","names":["queryFnContext","context"]}
\ No newline at end of file
+{"version":3,"sources":["../../src/query.ts"],"sourcesContent":["import {\n  ensureQueryFn,\n  noop,\n  replaceData,\n  resolveEnabled,\n  resolveStaleTime,\n  skipToken,\n  timeUntilStale,\n} from './utils'\nimport { notifyManager } from './notifyManager'\nimport { canFetch, createRetryer, isCancelledError } from './retryer'\nimport { Removable } from './removable'\nimport type { QueryCache } from './queryCache'\nimport type { QueryClient } from './queryClient'\nimport type {\n  CancelOptions,\n  DefaultError,\n  FetchStatus,\n  InitialDataFunction,\n  OmitKeyof,\n  QueryFunctionContext,\n  QueryKey,\n  QueryMeta,\n  QueryOptions,\n  QueryStatus,\n  SetDataOptions,\n  StaleTime,\n} from './types'\nimport type { QueryObserver } from './queryObserver'\nimport type { Retryer } from './retryer'\n\n// TYPES\n\ninterface QueryConfig<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  client: QueryClient\n  queryKey: TQueryKey\n  queryHash: string\n  options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  state?: QueryState<TData, TError>\n}\n\nexport interface QueryState<TData = unknown, TError = DefaultError> {\n  data: TData | undefined\n  dataUpdateCount: number\n  dataUpdatedAt: number\n  error: TError | null\n  errorUpdateCount: number\n  errorUpdatedAt: number\n  fetchFailureCount: number\n  fetchFailureReason: TError | null\n  fetchMeta: FetchMeta | null\n  isInvalidated: boolean\n  status: QueryStatus\n  fetchStatus: FetchStatus\n}\n\nexport interface FetchContext<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  fetchFn: () => unknown | Promise<unknown>\n  fetchOptions?: FetchOptions\n  signal: AbortSignal\n  options: QueryOptions<TQueryFnData, TError, TData, any>\n  client: QueryClient\n  queryKey: TQueryKey\n  state: QueryState<TData, TError>\n}\n\nexport interface QueryBehavior<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  onFetch: (\n    context: FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n    query: Query,\n  ) => void\n}\n\nexport type FetchDirection = 'forward' | 'backward'\n\nexport interface FetchMeta {\n  fetchMore?: { direction: FetchDirection }\n}\n\nexport interface FetchOptions<TData = unknown> {\n  cancelRefetch?: boolean\n  meta?: FetchMeta\n  initialPromise?: Promise<TData>\n  updateMeta?: Record<string, unknown>\n}\n\ninterface FailedAction<TError> {\n  type: 'failed'\n  failureCount: number\n  error: TError\n}\n\ninterface FetchAction {\n  type: 'fetch'\n  meta?: FetchMeta\n}\n\ninterface SuccessAction<TData> {\n  data: TData | undefined\n  type: 'success'\n  dataUpdatedAt?: number\n  manual?: boolean\n}\n\ninterface ErrorAction<TError> {\n  type: 'error'\n  error: TError\n}\n\ninterface InvalidateAction {\n  type: 'invalidate'\n}\n\ninterface PauseAction {\n  type: 'pause'\n}\n\ninterface ContinueAction {\n  type: 'continue'\n}\n\ninterface SetStateAction<TData, TError> {\n  type: 'setState'\n  state: Partial<QueryState<TData, TError>>\n  setStateOptions?: SetStateOptions\n}\n\nexport type Action<TData, TError> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction<TError>\n  | FetchAction\n  | InvalidateAction\n  | PauseAction\n  | SetStateAction<TData, TError>\n  | SuccessAction<TData>\n\nexport interface SetStateOptions {\n  meta?: any\n}\n\n// CLASS\n\nexport class Query<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Removable {\n  queryKey: TQueryKey\n  queryHash: string\n  options!: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  state: QueryState<TData, TError>\n\n  #initialState: QueryState<TData, TError>\n  #revertState?: QueryState<TData, TError>\n  #cache: QueryCache\n  #client: QueryClient\n  #retryer?: Retryer<TData>\n  observers: Array<QueryObserver<any, any, any, any, any>>\n  #defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  #abortSignalConsumed: boolean\n\n  constructor(config: QueryConfig<TQueryFnData, TError, TData, TQueryKey>) {\n    super()\n\n    this.#abortSignalConsumed = false\n    this.#defaultOptions = config.defaultOptions\n    this.setOptions(config.options)\n    this.observers = []\n    this.#client = config.client\n    this.#cache = this.#client.getQueryCache()\n    this.queryKey = config.queryKey\n    this.queryHash = config.queryHash\n    this.#initialState = getDefaultState(this.options)\n    this.state = config.state ?? this.#initialState\n    this.scheduleGc()\n  }\n  get meta(): QueryMeta | undefined {\n    return this.options.meta\n  }\n\n  get promise(): Promise<TData> | undefined {\n    return this.#retryer?.promise\n  }\n\n  setOptions(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): void {\n    this.options = { ...this.#defaultOptions, ...options }\n\n    this.updateGcTime(this.options.gcTime)\n  }\n\n  protected optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === 'idle') {\n      this.#cache.remove(this)\n    }\n  }\n\n  setData(\n    newData: TData,\n    options?: SetDataOptions & { manual: boolean },\n  ): TData {\n    const data = replaceData(this.state.data, newData, this.options)\n\n    // Set data and mark it as cached\n    this.#dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options?.updatedAt,\n      manual: options?.manual,\n    })\n\n    return data\n  }\n\n  setState(\n    state: Partial<QueryState<TData, TError>>,\n    setStateOptions?: SetStateOptions,\n  ): void {\n    this.#dispatch({ type: 'setState', state, setStateOptions })\n  }\n\n  cancel(options?: CancelOptions): Promise<void> {\n    const promise = this.#retryer?.promise\n    this.#retryer?.cancel(options)\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve()\n  }\n\n  destroy(): void {\n    super.destroy()\n\n    this.cancel({ silent: true })\n  }\n\n  reset(): void {\n    this.destroy()\n    this.setState(this.#initialState)\n  }\n\n  isActive(): boolean {\n    return this.observers.some(\n      (observer) => resolveEnabled(observer.options.enabled, this) !== false,\n    )\n  }\n\n  isDisabled(): boolean {\n    if (this.getObserversCount() > 0) {\n      return !this.isActive()\n    }\n    // if a query has no observers, it should still be considered disabled if it never attempted a fetch\n    return (\n      this.options.queryFn === skipToken ||\n      this.state.dataUpdateCount + this.state.errorUpdateCount === 0\n    )\n  }\n\n  isStatic(): boolean {\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(\n        (observer) =>\n          resolveStaleTime(observer.options.staleTime, this) === 'static',\n      )\n    }\n\n    return false\n  }\n\n  isStale(): boolean {\n    // check observers first, their `isStale` has the source of truth\n    // calculated with `isStaleByTime` and it takes `enabled` into account\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(\n        (observer) => observer.getCurrentResult().isStale,\n      )\n    }\n\n    return this.state.data === undefined || this.state.isInvalidated\n  }\n\n  isStaleByTime(staleTime: StaleTime = 0): boolean {\n    // no data is always stale\n    if (this.state.data === undefined) {\n      return true\n    }\n    // static is never stale\n    if (staleTime === 'static') {\n      return false\n    }\n    // if the query is invalidated, it is stale\n    if (this.state.isInvalidated) {\n      return true\n    }\n\n    return !timeUntilStale(this.state.dataUpdatedAt, staleTime)\n  }\n\n  onFocus(): void {\n    const observer = this.observers.find((x) => x.shouldFetchOnWindowFocus())\n\n    observer?.refetch({ cancelRefetch: false })\n\n    // Continue fetch if currently paused\n    this.#retryer?.continue()\n  }\n\n  onOnline(): void {\n    const observer = this.observers.find((x) => x.shouldFetchOnReconnect())\n\n    observer?.refetch({ cancelRefetch: false })\n\n    // Continue fetch if currently paused\n    this.#retryer?.continue()\n  }\n\n  addObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer)\n\n      // Stop the query from being garbage collected\n      this.clearGcTimeout()\n\n      this.#cache.notify({ type: 'observerAdded', query: this, observer })\n    }\n  }\n\n  removeObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (this.observers.includes(observer)) {\n      this.observers = this.observers.filter((x) => x !== observer)\n\n      if (!this.observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.#retryer) {\n          if (this.#abortSignalConsumed) {\n            this.#retryer.cancel({ revert: true })\n          } else {\n            this.#retryer.cancelRetry()\n          }\n        }\n\n        this.scheduleGc()\n      }\n\n      this.#cache.notify({ type: 'observerRemoved', query: this, observer })\n    }\n  }\n\n  getObserversCount(): number {\n    return this.observers.length\n  }\n\n  invalidate(): void {\n    if (!this.state.isInvalidated) {\n      this.#dispatch({ type: 'invalidate' })\n    }\n  }\n\n  fetch(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    fetchOptions?: FetchOptions<TQueryFnData>,\n  ): Promise<TData> {\n    if (this.state.fetchStatus !== 'idle') {\n      if (this.state.data !== undefined && fetchOptions?.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetch\n        this.cancel({ silent: true })\n      } else if (this.#retryer) {\n        // make sure that retries that were potentially cancelled due to unmounts can continue\n        this.#retryer.continueRetry()\n        // Return current promise if we are already fetching\n        return this.#retryer.promise\n      }\n    }\n\n    // Update config if passed, otherwise the config from the last execution is used\n    if (options) {\n      this.setOptions(options)\n    }\n\n    // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n    if (!this.options.queryFn) {\n      const observer = this.observers.find((x) => x.options.queryFn)\n      if (observer) {\n        this.setOptions(observer.options)\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!Array.isArray(this.options.queryKey)) {\n        console.error(\n          `As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`,\n        )\n      }\n    }\n\n    const abortController = new AbortController()\n\n    // Adds an enumerable signal property to the object that\n    // which sets abortSignalConsumed to true when the signal\n    // is read.\n    const addSignalProperty = (object: unknown) => {\n      Object.defineProperty(object, 'signal', {\n        enumerable: true,\n        get: () => {\n          this.#abortSignalConsumed = true\n          return abortController.signal\n        },\n      })\n    }\n\n    // Create fetch function\n    const fetchFn = () => {\n      const queryFn = ensureQueryFn(this.options, fetchOptions)\n\n      // Create query function context\n      const createQueryFnContext = (): QueryFunctionContext<TQueryKey> => {\n        const queryFnContext: OmitKeyof<\n          QueryFunctionContext<TQueryKey>,\n          'signal'\n        > = {\n          client: this.#client,\n          queryKey: this.queryKey,\n          meta: fetchOptions?.updateMeta ? {...this.meta, ...fetchOptions.updateMeta } : this.meta,\n        }\n        addSignalProperty(queryFnContext)\n        return queryFnContext as QueryFunctionContext<TQueryKey>\n      }\n\n      const queryFnContext = createQueryFnContext()\n\n      this.#abortSignalConsumed = false\n      if (this.options.persister) {\n        return this.options.persister(\n          queryFn,\n          queryFnContext,\n          this as unknown as Query,\n        )\n      }\n\n      return queryFn(queryFnContext)\n    }\n\n    // Trigger behavior hook\n    const createFetchContext = (): FetchContext<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey\n    > => {\n      const context: OmitKeyof<\n        FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n        'signal'\n      > = {\n        fetchOptions,\n        options: this.options,\n        queryKey: this.queryKey,\n        client: this.#client,\n        state: this.state,\n        fetchFn,\n      }\n\n      addSignalProperty(context)\n      return context as FetchContext<TQueryFnData, TError, TData, TQueryKey>\n    }\n\n    const context = createFetchContext()\n\n    this.options.behavior?.onFetch(context, this as unknown as Query)\n\n    // Store state in case the current fetch needs to be reverted\n    this.#revertState = this.state\n\n    // Set to fetching state if not already in it\n    if (\n      this.state.fetchStatus === 'idle' ||\n      this.state.fetchMeta !== context.fetchOptions?.meta\n    ) {\n      this.#dispatch({ type: 'fetch', meta: context.fetchOptions?.meta })\n    }\n\n    const onError = (error: TError | { silent?: boolean }) => {\n      // Optimistically update state if needed\n      if (!(isCancelledError(error) && error.silent)) {\n        this.#dispatch({\n          type: 'error',\n          error: error as TError,\n        })\n      }\n\n      if (!isCancelledError(error)) {\n        // Notify cache callback\n        this.#cache.config.onError?.(\n          error as any,\n          this as Query<any, any, any, any>,\n        )\n        this.#cache.config.onSettled?.(\n          this.state.data,\n          error as any,\n          this as Query<any, any, any, any>,\n        )\n      }\n\n      // Schedule query gc after fetching\n      this.scheduleGc()\n    }\n\n    // Try to fetch the data\n    this.#retryer = createRetryer({\n      initialPromise: fetchOptions?.initialPromise as\n        | Promise<TData>\n        | undefined,\n      fn: context.fetchFn as () => Promise<TData>,\n      abort: abortController.abort.bind(abortController),\n      onSuccess: (data) => {\n        if (data === undefined) {\n          if (process.env.NODE_ENV !== 'production') {\n            console.error(\n              `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`,\n            )\n          }\n          onError(new Error(`${this.queryHash} data is undefined`) as any)\n          return\n        }\n\n        try {\n          this.setData(data)\n        } catch (error) {\n          onError(error as TError)\n          return\n        }\n\n        // Notify cache callback\n        this.#cache.config.onSuccess?.(data, this as Query<any, any, any, any>)\n        this.#cache.config.onSettled?.(\n          data,\n          this.state.error as any,\n          this as Query<any, any, any, any>,\n        )\n\n        // Schedule query gc after fetching\n        this.scheduleGc()\n      },\n      onError,\n      onFail: (failureCount, error) => {\n        this.#dispatch({ type: 'failed', failureCount, error })\n      },\n      onPause: () => {\n        this.#dispatch({ type: 'pause' })\n      },\n      onContinue: () => {\n        this.#dispatch({ type: 'continue' })\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode,\n      canRun: () => true,\n    })\n\n    return this.#retryer.start()\n  }\n\n  #dispatch(action: Action<TData, TError>): void {\n    const reducer = (\n      state: QueryState<TData, TError>,\n    ): QueryState<TData, TError> => {\n      switch (action.type) {\n        case 'failed':\n          return {\n            ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error,\n          }\n        case 'pause':\n          return {\n            ...state,\n            fetchStatus: 'paused',\n          }\n        case 'continue':\n          return {\n            ...state,\n            fetchStatus: 'fetching',\n          }\n        case 'fetch':\n          return {\n            ...state,\n            ...fetchState(state.data, this.options),\n            fetchMeta: action.meta ?? null,\n          }\n        case 'success':\n          // If fetching ends successfully, we don't need revertState as a fallback anymore.\n          this.#revertState = undefined\n          return {\n            ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: 'success',\n            ...(!action.manual && {\n              fetchStatus: 'idle',\n              fetchFailureCount: 0,\n              fetchFailureReason: null,\n            }),\n          }\n        case 'error':\n          const error = action.error\n\n          if (isCancelledError(error) && error.revert && this.#revertState) {\n            return { ...this.#revertState, fetchStatus: 'idle' }\n          }\n\n          return {\n            ...state,\n            error,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error,\n            fetchStatus: 'idle',\n            status: 'error',\n          }\n        case 'invalidate':\n          return {\n            ...state,\n            isInvalidated: true,\n          }\n        case 'setState':\n          return {\n            ...state,\n            ...action.state,\n          }\n      }\n    }\n\n    this.state = reducer(this.state)\n\n    notifyManager.batch(() => {\n      this.observers.forEach((observer) => {\n        observer.onQueryUpdate()\n      })\n\n      this.#cache.notify({ query: this, type: 'updated', action })\n    })\n  }\n}\n\nexport function fetchState<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey,\n>(\n  data: TData | undefined,\n  options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n) {\n  return {\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchStatus: canFetch(options.networkMode) ? 'fetching' : 'paused',\n    ...(data === undefined &&\n      ({\n        error: null,\n        status: 'pending',\n      } as const)),\n  } as const\n}\n\nfunction getDefaultState<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey,\n>(\n  options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): QueryState<TData, TError> {\n  const data =\n    typeof options.initialData === 'function'\n      ? (options.initialData as InitialDataFunction<TData>)()\n      : options.initialData\n\n  const hasData = data !== undefined\n\n  const initialDataUpdatedAt = hasData\n    ? typeof options.initialDataUpdatedAt === 'function'\n      ? (options.initialDataUpdatedAt as () => number | undefined)()\n      : options.initialDataUpdatedAt\n    : 0\n\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? (initialDataUpdatedAt ?? Date.now()) : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'pending',\n    fetchStatus: 'idle',\n  }\n}\n"],"mappings":"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","names":["queryFnContext","context"]}
\ No newline at end of file
diff --git a/build/modern/queryCache.d.cts b/build/modern/queryCache.d.cts
index 823298712f10fa64a988313a0a4630cc4ac81ab0..a2fa0d9259fba8f56225bdc614a39139fca49461 100644
--- a/build/modern/queryCache.d.cts
+++ b/build/modern/queryCache.d.cts
@@ -1,3 +1,3 @@
-export { Q as QueryCache, a as QueryCacheNotifyEvent, bz as QueryStore } from './hydration-CdBkFt9i.cjs';
+export { Q as QueryCache, a as QueryCacheNotifyEvent, bz as QueryStore } from './hydration-Dv1t2VQO.cjs';
 import './subscribable.cjs';
 import './removable.cjs';
diff --git a/build/modern/queryCache.d.ts b/build/modern/queryCache.d.ts
index 58f890ba020958c8a681915aad77562995b2f1b6..1a160be96bc664ed52603abea62242f46b83c1e2 100644
--- a/build/modern/queryCache.d.ts
+++ b/build/modern/queryCache.d.ts
@@ -1,3 +1,3 @@
-export { Q as QueryCache, a as QueryCacheNotifyEvent, bz as QueryStore } from './hydration-Cr-4Kky1.js';
+export { Q as QueryCache, a as QueryCacheNotifyEvent, bz as QueryStore } from './hydration-Dwnp99qT.js';
 import './subscribable.js';
 import './removable.js';
diff --git a/build/modern/queryClient.d.cts b/build/modern/queryClient.d.cts
index c84587345211e4493170f348049ef7e1ae3ad5b8..d830a1e8c688a0bd3dd86e2fb28f5bdb99b2ec23 100644
--- a/build/modern/queryClient.d.cts
+++ b/build/modern/queryClient.d.cts
@@ -1,3 +1,3 @@
-export { b as QueryClient } from './hydration-CdBkFt9i.cjs';
+export { b as QueryClient } from './hydration-Dv1t2VQO.cjs';
 import './removable.cjs';
 import './subscribable.cjs';
diff --git a/build/modern/queryClient.d.ts b/build/modern/queryClient.d.ts
index 29d11e06d176d3092342d06a929723fb8c80f1cf..a5043b5e12b0dc379f20fb3e8d68a3ac4dccc264 100644
--- a/build/modern/queryClient.d.ts
+++ b/build/modern/queryClient.d.ts
@@ -1,3 +1,3 @@
-export { b as QueryClient } from './hydration-Cr-4Kky1.js';
+export { b as QueryClient } from './hydration-Dwnp99qT.js';
 import './removable.js';
 import './subscribable.js';
diff --git a/build/modern/queryObserver.d.cts b/build/modern/queryObserver.d.cts
index 6a958249d002d99525971fbf1dd57919bc4e3dfa..978b4385cf6939a0899f68614d57fa54df04d964 100644
--- a/build/modern/queryObserver.d.cts
+++ b/build/modern/queryObserver.d.cts
@@ -1,3 +1,3 @@
 import './subscribable.cjs';
-export { c as QueryObserver } from './hydration-CdBkFt9i.cjs';
+export { c as QueryObserver } from './hydration-Dv1t2VQO.cjs';
 import './removable.cjs';
diff --git a/build/modern/queryObserver.d.ts b/build/modern/queryObserver.d.ts
index 00215003b69f69df7eae0814fdf6380fc021ed4e..7999c5d235a0b731642c88b58ef247650f5767c1 100644
--- a/build/modern/queryObserver.d.ts
+++ b/build/modern/queryObserver.d.ts
@@ -1,3 +1,3 @@
 import './subscribable.js';
-export { c as QueryObserver } from './hydration-Cr-4Kky1.js';
+export { c as QueryObserver } from './hydration-Dwnp99qT.js';
 import './removable.js';
diff --git a/build/modern/retryer.d.cts b/build/modern/retryer.d.cts
index bf1c56ede4f0807fbd0f7ca6e3f148dc50206c6e..0582d235973f50c2dc89e14a138640d7a0787ead 100644
--- a/build/modern/retryer.d.cts
+++ b/build/modern/retryer.d.cts
@@ -1,3 +1,3 @@
-export { C as CancelledError, bC as RetryDelayValue, bB as RetryValue, bA as Retryer, bD as canFetch, bE as createRetryer, o as isCancelledError } from './hydration-CdBkFt9i.cjs';
+export { C as CancelledError, bC as RetryDelayValue, bB as RetryValue, bA as Retryer, bD as canFetch, bE as createRetryer, o as isCancelledError } from './hydration-Dv1t2VQO.cjs';
 import './removable.cjs';
 import './subscribable.cjs';
diff --git a/build/modern/retryer.d.ts b/build/modern/retryer.d.ts
index 93331066282045b745031a331a2393332186f0f0..a670219d8a6c98808ed82f311f6e5052ccd4c076 100644
--- a/build/modern/retryer.d.ts
+++ b/build/modern/retryer.d.ts
@@ -1,3 +1,3 @@
-export { C as CancelledError, bC as RetryDelayValue, bB as RetryValue, bA as Retryer, bD as canFetch, bE as createRetryer, o as isCancelledError } from './hydration-Cr-4Kky1.js';
+export { C as CancelledError, bC as RetryDelayValue, bB as RetryValue, bA as Retryer, bD as canFetch, bE as createRetryer, o as isCancelledError } from './hydration-Dwnp99qT.js';
 import './removable.js';
 import './subscribable.js';
diff --git a/build/modern/streamedQuery.d.cts b/build/modern/streamedQuery.d.cts
index cfd2a5264343d8714671ed59b73614331896224b..58cfa5ad3a910519f1c7d2095f5432ae943ab58a 100644
--- a/build/modern/streamedQuery.d.cts
+++ b/build/modern/streamedQuery.d.cts
@@ -1,4 +1,4 @@
-import { I as QueryKey, a1 as QueryFunctionContext, Y as QueryFunction } from './hydration-CdBkFt9i.cjs';
+import { I as QueryKey, a1 as QueryFunctionContext, Y as QueryFunction } from './hydration-Dv1t2VQO.cjs';
 import './removable.cjs';
 import './subscribable.cjs';
 
diff --git a/build/modern/streamedQuery.d.ts b/build/modern/streamedQuery.d.ts
index 9eeb1770117c52d30d047778aa4cac4bbacefe23..e9329415b81976c730b401b3194d775b55f5ba79 100644
--- a/build/modern/streamedQuery.d.ts
+++ b/build/modern/streamedQuery.d.ts
@@ -1,4 +1,4 @@
-import { I as QueryKey, a1 as QueryFunctionContext, Y as QueryFunction } from './hydration-Cr-4Kky1.js';
+import { I as QueryKey, a1 as QueryFunctionContext, Y as QueryFunction } from './hydration-Dwnp99qT.js';
 import './removable.js';
 import './subscribable.js';
 
diff --git a/build/modern/types.cjs.map b/build/modern/types.cjs.map
index 3490d3eba61a49729da77d8b6e41a4bf38406275..f2378602a3e9473e47fc9a27d19d502382d03535 100644
--- a/build/modern/types.cjs.map
+++ b/build/modern/types.cjs.map
@@ -1 +1 @@
-{"version":3,"sources":["../../src/types.ts"],"sourcesContent":["/* istanbul ignore file */\n\nimport type { QueryClient } from './queryClient'\nimport type { DehydrateOptions, HydrateOptions } from './hydration'\nimport type { MutationState } from './mutation'\nimport type { FetchDirection, Query, QueryBehavior } from './query'\nimport type { RetryDelayValue, RetryValue } from './retryer'\nimport type { QueryFilters, QueryTypeFilter, SkipToken } from './utils'\nimport type { QueryCache } from './queryCache'\nimport type { MutationCache } from './mutationCache'\n\nexport type NonUndefinedGuard<T> = T extends undefined ? never : T\n\nexport type DistributiveOmit<\n  TObject,\n  TKey extends keyof TObject,\n> = TObject extends any ? Omit<TObject, TKey> : never\n\nexport type OmitKeyof<\n  TObject,\n  TKey extends TStrictly extends 'safely'\n    ?\n        | keyof TObject\n        | (string & Record<never, never>)\n        | (number & Record<never, never>)\n        | (symbol & Record<never, never>)\n    : keyof TObject,\n  TStrictly extends 'strictly' | 'safely' = 'strictly',\n> = Omit<TObject, TKey>\n\nexport type Override<TTargetA, TTargetB> = {\n  [AKey in keyof TTargetA]: AKey extends keyof TTargetB\n    ? TTargetB[AKey]\n    : TTargetA[AKey]\n}\n\nexport type NoInfer<T> = [T][T extends any ? 0 : never]\n\nexport interface Register {\n  // defaultError: Error\n  // queryMeta: Record<string, unknown>\n  // mutationMeta: Record<string, unknown>\n  // queryKey: ReadonlyArray<unknown>\n  // mutationKey: ReadonlyArray<unknown>\n}\n\nexport type DefaultError = Register extends {\n  defaultError: infer TError\n}\n  ? TError\n  : Error\n\nexport type QueryKey = Register extends {\n  queryKey: infer TQueryKey\n}\n  ? TQueryKey extends ReadonlyArray<unknown>\n    ? TQueryKey\n    : TQueryKey extends Array<unknown>\n      ? TQueryKey\n      : ReadonlyArray<unknown>\n  : ReadonlyArray<unknown>\n\nexport const dataTagSymbol = Symbol('dataTagSymbol')\nexport type dataTagSymbol = typeof dataTagSymbol\nexport const dataTagErrorSymbol = Symbol('dataTagErrorSymbol')\nexport type dataTagErrorSymbol = typeof dataTagErrorSymbol\nexport const unsetMarker = Symbol('unsetMarker')\nexport type UnsetMarker = typeof unsetMarker\nexport type AnyDataTag = {\n  [dataTagSymbol]: any\n  [dataTagErrorSymbol]: any\n}\nexport type DataTag<\n  TType,\n  TValue,\n  TError = UnsetMarker,\n> = TType extends AnyDataTag\n  ? TType\n  : TType & {\n      [dataTagSymbol]: TValue\n      [dataTagErrorSymbol]: TError\n    }\n\nexport type InferDataFromTag<TQueryFnData, TTaggedQueryKey extends QueryKey> =\n  TTaggedQueryKey extends DataTag<unknown, infer TaggedValue, unknown>\n    ? TaggedValue\n    : TQueryFnData\n\nexport type InferErrorFromTag<TError, TTaggedQueryKey extends QueryKey> =\n  TTaggedQueryKey extends DataTag<unknown, unknown, infer TaggedError>\n    ? TaggedError extends UnsetMarker\n      ? TError\n      : TaggedError\n    : TError\n\nexport type QueryFunction<\n  T = unknown,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> = (context: QueryFunctionContext<TQueryKey, TPageParam>) => T | Promise<T>\n\nexport type StaleTime = number | 'static'\n\nexport type StaleTimeFunction<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> =\n  | StaleTime\n  | ((query: Query<TQueryFnData, TError, TData, TQueryKey>) => StaleTime)\n\nexport type Enabled<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> =\n  | boolean\n  | ((query: Query<TQueryFnData, TError, TData, TQueryKey>) => boolean)\n\nexport type QueryPersister<\n  T = unknown,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> = [TPageParam] extends [never]\n  ? (\n      queryFn: QueryFunction<T, TQueryKey, never>,\n      context: QueryFunctionContext<TQueryKey>,\n      query: Query,\n    ) => T | Promise<T>\n  : (\n      queryFn: QueryFunction<T, TQueryKey, TPageParam>,\n      context: QueryFunctionContext<TQueryKey>,\n      query: Query,\n    ) => T | Promise<T>\n\nexport type QueryFunctionContext<\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> = [TPageParam] extends [never]\n  ? {\n      client: QueryClient\n      queryKey: TQueryKey\n      signal: AbortSignal\n      meta: QueryMeta | undefined\n      pageParam?: unknown\n      /**\n       * @deprecated\n       * if you want access to the direction, you can add it to the pageParam\n       */\n      direction?: unknown\n    }\n  : {\n      client: QueryClient\n      queryKey: TQueryKey\n      signal: AbortSignal\n      pageParam: TPageParam\n      /**\n       * @deprecated\n       * if you want access to the direction, you can add it to the pageParam\n       */\n      direction: FetchDirection\n      meta: QueryMeta | undefined\n    }\n\nexport type InitialDataFunction<T> = () => T | undefined\n\ntype NonFunctionGuard<T> = T extends Function ? never : T\n\nexport type PlaceholderDataFunction<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = (\n  previousData: TQueryData | undefined,\n  previousQuery: Query<TQueryFnData, TError, TQueryData, TQueryKey> | undefined,\n) => TQueryData | undefined\n\nexport type QueriesPlaceholderDataFunction<TQueryData> = (\n  previousData: undefined,\n  previousQuery: undefined,\n) => TQueryData | undefined\n\nexport type QueryKeyHashFunction<TQueryKey extends QueryKey> = (\n  queryKey: TQueryKey,\n) => string\n\nexport type GetPreviousPageParamFunction<TPageParam, TQueryFnData = unknown> = (\n  firstPage: TQueryFnData,\n  allPages: Array<TQueryFnData>,\n  firstPageParam: TPageParam,\n  allPageParams: Array<TPageParam>,\n) => TPageParam | undefined | null\n\nexport type GetNextPageParamFunction<TPageParam, TQueryFnData = unknown> = (\n  lastPage: TQueryFnData,\n  allPages: Array<TQueryFnData>,\n  lastPageParam: TPageParam,\n  allPageParams: Array<TPageParam>,\n) => TPageParam | undefined | null\n\nexport interface InfiniteData<TData, TPageParam = unknown> {\n  pages: Array<TData>\n  pageParams: Array<TPageParam>\n}\n\nexport type QueryMeta = Register extends {\n  queryMeta: infer TQueryMeta\n}\n  ? TQueryMeta extends Record<string, unknown>\n    ? TQueryMeta\n    : Record<string, unknown>\n  : Record<string, unknown>\n\nexport type NetworkMode = 'online' | 'always' | 'offlineFirst'\n\nexport type NotifyOnChangeProps =\n  | Array<keyof InfiniteQueryObserverResult>\n  | 'all'\n  | undefined\n  | (() => Array<keyof InfiniteQueryObserverResult> | 'all' | undefined)\n\nexport interface QueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> {\n  /**\n   * If `false`, failed queries will not retry by default.\n   * If `true`, failed queries will retry infinitely., failureCount: num\n   * If set to an integer number, e.g. 3, failed queries will retry until the failed query count meets that number.\n   * If set to a function `(failureCount, error) => boolean` failed queries will retry until the function returns false.\n   */\n  retry?: RetryValue<TError>\n  retryDelay?: RetryDelayValue<TError>\n  networkMode?: NetworkMode\n  /**\n   * The time in milliseconds that unused/inactive cache data remains in memory.\n   * When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration.\n   * When different garbage collection times are specified, the longest one will be used.\n   * Setting it to `Infinity` will disable garbage collection.\n   */\n  gcTime?: number\n  queryFn?: QueryFunction<TQueryFnData, TQueryKey, TPageParam> | SkipToken\n  persister?: QueryPersister<\n    NoInfer<TQueryFnData>,\n    NoInfer<TQueryKey>,\n    NoInfer<TPageParam>\n  >\n  queryHash?: string\n  queryKey?: TQueryKey\n  queryKeyHashFn?: QueryKeyHashFunction<TQueryKey>\n  initialData?: TData | InitialDataFunction<TData>\n  initialDataUpdatedAt?: number | (() => number | undefined)\n  behavior?: QueryBehavior<TQueryFnData, TError, TData, TQueryKey>\n  /**\n   * Set this to `false` to disable structural sharing between query results.\n   * Set this to a function which accepts the old and new data and returns resolved data of the same type to implement custom structural sharing logic.\n   * Defaults to `true`.\n   */\n  structuralSharing?:\n    | boolean\n    | ((oldData: unknown | undefined, newData: unknown) => unknown)\n  _defaulted?: boolean\n  /**\n   * Additional payload to be stored on each query.\n   * Use this property to pass information that can be used in other places.\n   */\n  meta?: QueryMeta\n  /**\n   * Maximum number of pages to store in the data of an infinite query.\n   */\n  maxPages?: number\n}\n\nexport interface InitialPageParam<TPageParam = unknown> {\n  initialPageParam: TPageParam\n}\n\nexport interface InfiniteQueryPageParamsOptions<\n  TQueryFnData = unknown,\n  TPageParam = unknown,\n> extends InitialPageParam<TPageParam> {\n  /**\n   * This function can be set to automatically get the previous cursor for infinite queries.\n   * The result will also be used to determine the value of `hasPreviousPage`.\n   */\n  getPreviousPageParam?: GetPreviousPageParamFunction<TPageParam, TQueryFnData>\n  /**\n   * This function can be set to automatically get the next cursor for infinite queries.\n   * The result will also be used to determine the value of `hasNextPage`.\n   */\n  getNextPageParam: GetNextPageParamFunction<TPageParam, TQueryFnData>\n}\n\nexport type ThrowOnError<\n  TQueryFnData,\n  TError,\n  TQueryData,\n  TQueryKey extends QueryKey,\n> =\n  | boolean\n  | ((\n      error: TError,\n      query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n    ) => boolean)\n\nexport interface QueryObserverOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> extends WithRequired<\n    QueryOptions<TQueryFnData, TError, TQueryData, TQueryKey, TPageParam>,\n    'queryKey'\n  > {\n  /**\n   * Set this to `false` or a function that returns `false` to disable automatic refetching when the query mounts or changes query keys.\n   * To refetch the query, use the `refetch` method returned from the `useQuery` instance.\n   * Accepts a boolean or function that returns a boolean.\n   * Defaults to `true`.\n   */\n  enabled?: Enabled<TQueryFnData, TError, TQueryData, TQueryKey>\n  /**\n   * The time in milliseconds after data is considered stale.\n   * If set to `Infinity`, the data will never be considered stale.\n   * If set to a function, the function will be executed with the query to compute a `staleTime`.\n   * Defaults to `0`.\n   */\n  staleTime?: StaleTimeFunction<TQueryFnData, TError, TQueryData, TQueryKey>\n  /**\n   * If set to a number, the query will continuously refetch at this frequency in milliseconds.\n   * If set to a function, the function will be executed with the latest data and query to compute a frequency\n   * Defaults to `false`.\n   */\n  refetchInterval?:\n    | number\n    | false\n    | ((\n        query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n      ) => number | false | undefined)\n  /**\n   * If set to `true`, the query will continue to refetch while their tab/window is in the background.\n   * Defaults to `false`.\n   */\n  refetchIntervalInBackground?: boolean\n  /**\n   * If set to `true`, the query will refetch on window focus if the data is stale.\n   * If set to `false`, the query will not refetch on window focus.\n   * If set to `'always'`, the query will always refetch on window focus.\n   * If set to a function, the function will be executed with the latest data and query to compute the value.\n   * Defaults to `true`.\n   */\n  refetchOnWindowFocus?:\n    | boolean\n    | 'always'\n    | ((\n        query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n      ) => boolean | 'always')\n  /**\n   * If set to `true`, the query will refetch on reconnect if the data is stale.\n   * If set to `false`, the query will not refetch on reconnect.\n   * If set to `'always'`, the query will always refetch on reconnect.\n   * If set to a function, the function will be executed with the latest data and query to compute the value.\n   * Defaults to the value of `networkOnline` (`true`)\n   */\n  refetchOnReconnect?:\n    | boolean\n    | 'always'\n    | ((\n        query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n      ) => boolean | 'always')\n  /**\n   * If set to `true`, the query will refetch on mount if the data is stale.\n   * If set to `false`, will disable additional instances of a query to trigger background refetch.\n   * If set to `'always'`, the query will always refetch on mount.\n   * If set to a function, the function will be executed with the latest data and query to compute the value\n   * Defaults to `true`.\n   */\n  refetchOnMount?:\n    | boolean\n    | 'always'\n    | ((\n        query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n      ) => boolean | 'always')\n  /**\n   * If set to `false`, the query will not be retried on mount if it contains an error.\n   * Defaults to `true`.\n   */\n  retryOnMount?: boolean\n  /**\n   * If set, the component will only re-render if any of the listed properties change.\n   * When set to `['data', 'error']`, the component will only re-render when the `data` or `error` properties change.\n   * When set to `'all'`, the component will re-render whenever a query is updated.\n   * When set to a function, the function will be executed to compute the list of properties.\n   * By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.\n   */\n  notifyOnChangeProps?: NotifyOnChangeProps\n  /**\n   * Whether errors should be thrown instead of setting the `error` property.\n   * If set to `true` or `suspense` is `true`, all errors will be thrown to the error boundary.\n   * If set to `false` and `suspense` is `false`, errors are returned as state.\n   * If set to a function, it will be passed the error and the query, and it should return a boolean indicating whether to show the error in an error boundary (`true`) or return the error as state (`false`).\n   * Defaults to `false`.\n   */\n  throwOnError?: ThrowOnError<TQueryFnData, TError, TQueryData, TQueryKey>\n  /**\n   * This option can be used to transform or select a part of the data returned by the query function.\n   */\n  select?: (data: TQueryData) => TData\n  /**\n   * If set to `true`, the query will suspend when `status === 'pending'`\n   * and throw errors when `status === 'error'`.\n   * Defaults to `false`.\n   */\n  suspense?: boolean\n  /**\n   * If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `loading` data and no initialData has been provided.\n   */\n  placeholderData?:\n    | NonFunctionGuard<TQueryData>\n    | PlaceholderDataFunction<\n        NonFunctionGuard<TQueryData>,\n        TError,\n        NonFunctionGuard<TQueryData>,\n        TQueryKey\n      >\n\n  _optimisticResults?: 'optimistic' | 'isRestoring'\n\n  /**\n   * Enable prefetching during rendering\n   */\n  experimental_prefetchInRender?: boolean\n}\n\nexport type WithRequired<TTarget, TKey extends keyof TTarget> = TTarget & {\n  [_ in TKey]: {}\n}\n\nexport type DefaultedQueryObserverOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = WithRequired<\n  QueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  'throwOnError' | 'refetchOnReconnect' | 'queryHash'\n>\n\nexport interface InfiniteQueryObserverOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> extends QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      InfiniteData<TQueryFnData, TPageParam>,\n      TQueryKey,\n      TPageParam\n    >,\n    InfiniteQueryPageParamsOptions<TQueryFnData, TPageParam> {}\n\nexport type DefaultedInfiniteQueryObserverOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> = WithRequired<\n  InfiniteQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  >,\n  'throwOnError' | 'refetchOnReconnect' | 'queryHash'\n>\n\nexport interface FetchQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> extends WithRequired<\n    QueryOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>,\n    'queryKey'\n  > {\n  initialPageParam?: never\n  /**\n   * The time in milliseconds after data is considered stale.\n   * If the data is fresh it will be returned from the cache.\n   */\n  staleTime?: StaleTimeFunction<TQueryFnData, TError, TData, TQueryKey>\n}\n\nexport interface EnsureQueryDataOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> extends FetchQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  > {\n  revalidateIfStale?: boolean\n}\n\nexport type EnsureInfiniteQueryDataOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> = FetchInfiniteQueryOptions<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey,\n  TPageParam\n> & {\n  revalidateIfStale?: boolean\n}\n\ntype FetchInfiniteQueryPages<TQueryFnData = unknown, TPageParam = unknown> =\n  | { pages?: never }\n  | {\n      pages: number\n      getNextPageParam: GetNextPageParamFunction<TPageParam, TQueryFnData>\n    }\n\nexport type FetchInfiniteQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> = Omit<\n  FetchQueryOptions<\n    TQueryFnData,\n    TError,\n    InfiniteData<TData, TPageParam>,\n    TQueryKey,\n    TPageParam\n  >,\n  'initialPageParam'\n> &\n  InitialPageParam<TPageParam> &\n  FetchInfiniteQueryPages<TQueryFnData, TPageParam>\n\nexport interface ResultOptions {\n  throwOnError?: boolean\n}\n\nexport interface RefetchOptions extends ResultOptions {\n  /**\n   * If set to `true`, a currently running request will be cancelled before a new request is made\n   *\n   * If set to `false`, no refetch will be made if there is already a request running.\n   *\n   * Defaults to `true`.\n   */\n  cancelRefetch?: boolean\n}\n\nexport interface InvalidateQueryFilters<TQueryKey extends QueryKey = QueryKey>\n  extends QueryFilters<TQueryKey> {\n  refetchType?: QueryTypeFilter | 'none'\n}\n\nexport interface RefetchQueryFilters<TQueryKey extends QueryKey = QueryKey>\n  extends QueryFilters<TQueryKey> {}\n\nexport interface InvalidateOptions extends RefetchOptions {}\nexport interface ResetOptions extends RefetchOptions {}\n\nexport interface FetchNextPageOptions extends ResultOptions {\n  /**\n   * If set to `true`, calling `fetchNextPage` repeatedly will invoke `queryFn` every time,\n   * whether the previous invocation has resolved or not. Also, the result from previous invocations will be ignored.\n   *\n   * If set to `false`, calling `fetchNextPage` repeatedly won't have any effect until the first invocation has resolved.\n   *\n   * Defaults to `true`.\n   */\n  cancelRefetch?: boolean\n}\n\nexport interface FetchPreviousPageOptions extends ResultOptions {\n  /**\n   * If set to `true`, calling `fetchPreviousPage` repeatedly will invoke `queryFn` every time,\n   * whether the previous invocation has resolved or not. Also, the result from previous invocations will be ignored.\n   *\n   * If set to `false`, calling `fetchPreviousPage` repeatedly won't have any effect until the first invocation has resolved.\n   *\n   * Defaults to `true`.\n   */\n  cancelRefetch?: boolean\n}\n\nexport type QueryStatus = 'pending' | 'error' | 'success'\nexport type FetchStatus = 'fetching' | 'paused' | 'idle'\n\nexport interface QueryObserverBaseResult<\n  TData = unknown,\n  TError = DefaultError,\n> {\n  /**\n   * The last successfully resolved data for the query.\n   */\n  data: TData | undefined\n  /**\n   * The timestamp for when the query most recently returned the `status` as `\"success\"`.\n   */\n  dataUpdatedAt: number\n  /**\n   * The error object for the query, if an error was thrown.\n   * - Defaults to `null`.\n   */\n  error: TError | null\n  /**\n   * The timestamp for when the query most recently returned the `status` as `\"error\"`.\n   */\n  errorUpdatedAt: number\n  /**\n   * The failure count for the query.\n   * - Incremented every time the query fails.\n   * - Reset to `0` when the query succeeds.\n   */\n  failureCount: number\n  /**\n   * The failure reason for the query retry.\n   * - Reset to `null` when the query succeeds.\n   */\n  failureReason: TError | null\n  /**\n   * The sum of all errors.\n   */\n  errorUpdateCount: number\n  /**\n   * A derived boolean from the `status` variable, provided for convenience.\n   * - `true` if the query attempt resulted in an error.\n   */\n  isError: boolean\n  /**\n   * Will be `true` if the query has been fetched.\n   */\n  isFetched: boolean\n  /**\n   * Will be `true` if the query has been fetched after the component mounted.\n   * - This property can be used to not show any previously cached data.\n   */\n  isFetchedAfterMount: boolean\n  /**\n   * A derived boolean from the `fetchStatus` variable, provided for convenience.\n   * - `true` whenever the `queryFn` is executing, which includes initial `pending` as well as background refetch.\n   */\n  isFetching: boolean\n  /**\n   * Is `true` whenever the first fetch for a query is in-flight.\n   * - Is the same as `isFetching && isPending`.\n   */\n  isLoading: boolean\n  /**\n   * Will be `pending` if there's no cached data and no query attempt was finished yet.\n   */\n  isPending: boolean\n  /**\n   * Will be `true` if the query failed while fetching for the first time.\n   */\n  isLoadingError: boolean\n  /**\n   * @deprecated `isInitialLoading` is being deprecated in favor of `isLoading`\n   * and will be removed in the next major version.\n   */\n  isInitialLoading: boolean\n  /**\n   * A derived boolean from the `fetchStatus` variable, provided for convenience.\n   * - The query wanted to fetch, but has been `paused`.\n   */\n  isPaused: boolean\n  /**\n   * Will be `true` if the data shown is the placeholder data.\n   */\n  isPlaceholderData: boolean\n  /**\n   * Will be `true` if the query failed while refetching.\n   */\n  isRefetchError: boolean\n  /**\n   * Is `true` whenever a background refetch is in-flight, which _does not_ include initial `pending`.\n   * - Is the same as `isFetching && !isPending`.\n   */\n  isRefetching: boolean\n  /**\n   * Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.\n   */\n  isStale: boolean\n  /**\n   * A derived boolean from the `status` variable, provided for convenience.\n   * - `true` if the query has received a response with no errors and is ready to display its data.\n   */\n  isSuccess: boolean\n  /**\n   * A function to manually refetch the query.\n   */\n  refetch: (\n    options?: RefetchOptions,\n  ) => Promise<QueryObserverResult<TData, TError>>\n  /**\n   * The status of the query.\n   * - Will be:\n   *   - `pending` if there's no cached data and no query attempt was finished yet.\n   *   - `error` if the query attempt resulted in an error.\n   *   - `success` if the query has received a response with no errors and is ready to display its data.\n   */\n  status: QueryStatus\n  /**\n   * The fetch status of the query.\n   * - `fetching`: Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetch.\n   * - `paused`: The query wanted to fetch, but has been `paused`.\n   * - `idle`: The query is not fetching.\n   * - See [Network Mode](https://tanstack.com/query/latest/docs/framework/react/guides/network-mode) for more information.\n   */\n  fetchStatus: FetchStatus\n  /**\n   * A stable promise that will be resolved with the data of the query.\n   * Requires the `experimental_prefetchInRender` feature flag to be enabled.\n   * @example\n   *\n   * ### Enabling the feature flag\n   * ```ts\n   * const client = new QueryClient({\n   *   defaultOptions: {\n   *     queries: {\n   *       experimental_prefetchInRender: true,\n   *     },\n   *   },\n   * })\n   * ```\n   *\n   * ### Usage\n   * ```tsx\n   * import { useQuery } from '@tanstack/react-query'\n   * import React from 'react'\n   * import { fetchTodos, type Todo } from './api'\n   *\n   * function TodoList({ query }: { query: UseQueryResult<Todo[], Error> }) {\n   *   const data = React.use(query.promise)\n   *\n   *   return (\n   *     <ul>\n   *       {data.map(todo => (\n   *         <li key={todo.id}>{todo.title}</li>\n   *       ))}\n   *     </ul>\n   *   )\n   * }\n   *\n   * export function App() {\n   *   const query = useQuery({ queryKey: ['todos'], queryFn: fetchTodos })\n   *\n   *   return (\n   *     <>\n   *       <h1>Todos</h1>\n   *       <React.Suspense fallback={<div>Loading...</div>}>\n   *         <TodoList query={query} />\n   *       </React.Suspense>\n   *     </>\n   *   )\n   * }\n   * ```\n   */\n  promise: Promise<TData>\n}\n\nexport interface QueryObserverPendingResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: null\n  isError: false\n  isPending: true\n  isLoadingError: false\n  isRefetchError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'pending'\n}\n\nexport interface QueryObserverLoadingResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: null\n  isError: false\n  isPending: true\n  isLoading: true\n  isLoadingError: false\n  isRefetchError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'pending'\n}\n\nexport interface QueryObserverLoadingErrorResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: TError\n  isError: true\n  isPending: false\n  isLoading: false\n  isLoadingError: true\n  isRefetchError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'error'\n}\n\nexport interface QueryObserverRefetchErrorResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: TData\n  error: TError\n  isError: true\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: true\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'error'\n}\n\nexport interface QueryObserverSuccessResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: TData\n  error: null\n  isError: false\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: false\n  isSuccess: true\n  isPlaceholderData: false\n  status: 'success'\n}\n\nexport interface QueryObserverPlaceholderResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: TData\n  isError: false\n  error: null\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: false\n  isSuccess: true\n  isPlaceholderData: true\n  status: 'success'\n}\n\nexport type DefinedQueryObserverResult<\n  TData = unknown,\n  TError = DefaultError,\n> =\n  | QueryObserverRefetchErrorResult<TData, TError>\n  | QueryObserverSuccessResult<TData, TError>\n\nexport type QueryObserverResult<TData = unknown, TError = DefaultError> =\n  | DefinedQueryObserverResult<TData, TError>\n  | QueryObserverLoadingErrorResult<TData, TError>\n  | QueryObserverLoadingResult<TData, TError>\n  | QueryObserverPendingResult<TData, TError>\n  | QueryObserverPlaceholderResult<TData, TError>\n\nexport interface InfiniteQueryObserverBaseResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  /**\n   * This function allows you to fetch the next \"page\" of results.\n   */\n  fetchNextPage: (\n    options?: FetchNextPageOptions,\n  ) => Promise<InfiniteQueryObserverResult<TData, TError>>\n  /**\n   * This function allows you to fetch the previous \"page\" of results.\n   */\n  fetchPreviousPage: (\n    options?: FetchPreviousPageOptions,\n  ) => Promise<InfiniteQueryObserverResult<TData, TError>>\n  /**\n   * Will be `true` if there is a next page to be fetched (known via the `getNextPageParam` option).\n   */\n  hasNextPage: boolean\n  /**\n   * Will be `true` if there is a previous page to be fetched (known via the `getPreviousPageParam` option).\n   */\n  hasPreviousPage: boolean\n  /**\n   * Will be `true` if the query failed while fetching the next page.\n   */\n  isFetchNextPageError: boolean\n  /**\n   * Will be `true` while fetching the next page with `fetchNextPage`.\n   */\n  isFetchingNextPage: boolean\n  /**\n   * Will be `true` if the query failed while fetching the previous page.\n   */\n  isFetchPreviousPageError: boolean\n  /**\n   * Will be `true` while fetching the previous page with `fetchPreviousPage`.\n   */\n  isFetchingPreviousPage: boolean\n}\n\nexport interface InfiniteQueryObserverPendingResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: null\n  isError: false\n  isPending: true\n  isLoadingError: false\n  isRefetchError: false\n  isFetchNextPageError: false\n  isFetchPreviousPageError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'pending'\n}\n\nexport interface InfiniteQueryObserverLoadingResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: null\n  isError: false\n  isPending: true\n  isLoading: true\n  isLoadingError: false\n  isRefetchError: false\n  isFetchNextPageError: false\n  isFetchPreviousPageError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'pending'\n}\n\nexport interface InfiniteQueryObserverLoadingErrorResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: TError\n  isError: true\n  isPending: false\n  isLoading: false\n  isLoadingError: true\n  isRefetchError: false\n  isFetchNextPageError: false\n  isFetchPreviousPageError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'error'\n}\n\nexport interface InfiniteQueryObserverRefetchErrorResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: TData\n  error: TError\n  isError: true\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: true\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'error'\n}\n\nexport interface InfiniteQueryObserverSuccessResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: TData\n  error: null\n  isError: false\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: false\n  isFetchNextPageError: false\n  isFetchPreviousPageError: false\n  isSuccess: true\n  isPlaceholderData: false\n  status: 'success'\n}\n\nexport interface InfiniteQueryObserverPlaceholderResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: TData\n  isError: false\n  error: null\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: false\n  isSuccess: true\n  isPlaceholderData: true\n  isFetchNextPageError: false\n  isFetchPreviousPageError: false\n  status: 'success'\n}\n\nexport type DefinedInfiniteQueryObserverResult<\n  TData = unknown,\n  TError = DefaultError,\n> =\n  | InfiniteQueryObserverRefetchErrorResult<TData, TError>\n  | InfiniteQueryObserverSuccessResult<TData, TError>\n\nexport type InfiniteQueryObserverResult<\n  TData = unknown,\n  TError = DefaultError,\n> =\n  | DefinedInfiniteQueryObserverResult<TData, TError>\n  | InfiniteQueryObserverLoadingErrorResult<TData, TError>\n  | InfiniteQueryObserverLoadingResult<TData, TError>\n  | InfiniteQueryObserverPendingResult<TData, TError>\n  | InfiniteQueryObserverPlaceholderResult<TData, TError>\n\nexport type MutationKey = Register extends {\n  mutationKey: infer TMutationKey\n}\n  ? TMutationKey extends Array<unknown>\n    ? TMutationKey\n    : TMutationKey extends Array<unknown>\n      ? TMutationKey\n      : ReadonlyArray<unknown>\n  : ReadonlyArray<unknown>\n\nexport type MutationStatus = 'idle' | 'pending' | 'success' | 'error'\n\nexport type MutationScope = {\n  id: string\n}\n\nexport type MutationMeta = Register extends {\n  mutationMeta: infer TMutationMeta\n}\n  ? TMutationMeta extends Record<string, unknown>\n    ? TMutationMeta\n    : Record<string, unknown>\n  : Record<string, unknown>\n\nexport type MutationFunction<TData = unknown, TVariables = unknown> = (\n  variables: TVariables,\n) => Promise<TData>\n\nexport interface MutationOptions<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> {\n  mutationFn?: MutationFunction<TData, TVariables>\n  mutationKey?: MutationKey\n  onMutate?: (\n    variables: TVariables,\n  ) => Promise<TContext | undefined> | TContext | undefined\n  onSuccess?: (\n    data: TData,\n    variables: TVariables,\n    context: TContext,\n  ) => Promise<unknown> | unknown\n  onError?: (\n    error: TError,\n    variables: TVariables,\n    context: TContext | undefined,\n  ) => Promise<unknown> | unknown\n  onSettled?: (\n    data: TData | undefined,\n    error: TError | null,\n    variables: TVariables,\n    context: TContext | undefined,\n  ) => Promise<unknown> | unknown\n  retry?: RetryValue<TError>\n  retryDelay?: RetryDelayValue<TError>\n  networkMode?: NetworkMode\n  gcTime?: number\n  _defaulted?: boolean\n  meta?: MutationMeta\n  scope?: MutationScope\n}\n\nexport interface MutationObserverOptions<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationOptions<TData, TError, TVariables, TContext> {\n  throwOnError?: boolean | ((error: TError) => boolean)\n}\n\nexport interface MutateOptions<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> {\n  onSuccess?: (data: TData, variables: TVariables, context: TContext) => void\n  onError?: (\n    error: TError,\n    variables: TVariables,\n    context: TContext | undefined,\n  ) => void\n  onSettled?: (\n    data: TData | undefined,\n    error: TError | null,\n    variables: TVariables,\n    context: TContext | undefined,\n  ) => void\n}\n\nexport type MutateFunction<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> = (\n  variables: TVariables,\n  options?: MutateOptions<TData, TError, TVariables, TContext>,\n) => Promise<TData>\n\nexport interface MutationObserverBaseResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationState<TData, TError, TVariables, TContext> {\n  /**\n   * The last successfully resolved data for the mutation.\n   */\n  data: TData | undefined\n  /**\n   * The variables object passed to the `mutationFn`.\n   */\n  variables: TVariables | undefined\n  /**\n   * The error object for the mutation, if an error was encountered.\n   * - Defaults to `null`.\n   */\n  error: TError | null\n  /**\n   * A boolean variable derived from `status`.\n   * - `true` if the last mutation attempt resulted in an error.\n   */\n  isError: boolean\n  /**\n   * A boolean variable derived from `status`.\n   * - `true` if the mutation is in its initial state prior to executing.\n   */\n  isIdle: boolean\n  /**\n   * A boolean variable derived from `status`.\n   * - `true` if the mutation is currently executing.\n   */\n  isPending: boolean\n  /**\n   * A boolean variable derived from `status`.\n   * - `true` if the last mutation attempt was successful.\n   */\n  isSuccess: boolean\n  /**\n   * The status of the mutation.\n   * - Will be:\n   *   - `idle` initial status prior to the mutation function executing.\n   *   - `pending` if the mutation is currently executing.\n   *   - `error` if the last mutation attempt resulted in an error.\n   *   - `success` if the last mutation attempt was successful.\n   */\n  status: MutationStatus\n  /**\n   * The mutation function you can call with variables to trigger the mutation and optionally hooks on additional callback options.\n   * @param variables - The variables object to pass to the `mutationFn`.\n   * @param options.onSuccess - This function will fire when the mutation is successful and will be passed the mutation's result.\n   * @param options.onError - This function will fire if the mutation encounters an error and will be passed the error.\n   * @param options.onSettled - This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error.\n   * @remarks\n   * - If you make multiple requests, `onSuccess` will fire only after the latest call you've made.\n   * - All the callback functions (`onSuccess`, `onError`, `onSettled`) are void functions, and the returned value will be ignored.\n   */\n  mutate: MutateFunction<TData, TError, TVariables, TContext>\n  /**\n   * A function to clean the mutation internal state (i.e., it resets the mutation to its initial state).\n   */\n  reset: () => void\n}\n\nexport interface MutationObserverIdleResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationObserverBaseResult<TData, TError, TVariables, TContext> {\n  data: undefined\n  variables: undefined\n  error: null\n  isError: false\n  isIdle: true\n  isPending: false\n  isSuccess: false\n  status: 'idle'\n}\n\nexport interface MutationObserverLoadingResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationObserverBaseResult<TData, TError, TVariables, TContext> {\n  data: undefined\n  variables: TVariables\n  error: null\n  isError: false\n  isIdle: false\n  isPending: true\n  isSuccess: false\n  status: 'pending'\n}\n\nexport interface MutationObserverErrorResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationObserverBaseResult<TData, TError, TVariables, TContext> {\n  data: undefined\n  error: TError\n  variables: TVariables\n  isError: true\n  isIdle: false\n  isPending: false\n  isSuccess: false\n  status: 'error'\n}\n\nexport interface MutationObserverSuccessResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationObserverBaseResult<TData, TError, TVariables, TContext> {\n  data: TData\n  error: null\n  variables: TVariables\n  isError: false\n  isIdle: false\n  isPending: false\n  isSuccess: true\n  status: 'success'\n}\n\nexport type MutationObserverResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> =\n  | MutationObserverIdleResult<TData, TError, TVariables, TContext>\n  | MutationObserverLoadingResult<TData, TError, TVariables, TContext>\n  | MutationObserverErrorResult<TData, TError, TVariables, TContext>\n  | MutationObserverSuccessResult<TData, TError, TVariables, TContext>\n\nexport interface QueryClientConfig {\n  queryCache?: QueryCache\n  mutationCache?: MutationCache\n  defaultOptions?: DefaultOptions\n}\n\nexport interface DefaultOptions<TError = DefaultError> {\n  queries?: OmitKeyof<\n    QueryObserverOptions<unknown, TError>,\n    'suspense' | 'queryKey'\n  >\n  mutations?: MutationObserverOptions<unknown, TError, unknown, unknown>\n  hydrate?: HydrateOptions['defaultOptions']\n  dehydrate?: DehydrateOptions\n}\n\nexport interface CancelOptions {\n  revert?: boolean\n  silent?: boolean\n}\n\nexport interface SetDataOptions {\n  updatedAt?: number\n}\n\nexport type NotifyEventType =\n  | 'added'\n  | 'removed'\n  | 'updated'\n  | 'observerAdded'\n  | 'observerRemoved'\n  | 'observerResultsUpdated'\n  | 'observerOptionsUpdated'\n\nexport interface NotifyEvent {\n  type: NotifyEventType\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA8DO,IAAM,gBAAgB,OAAO,eAAe;AAE5C,IAAM,qBAAqB,OAAO,oBAAoB;AAEtD,IAAM,cAAc,OAAO,aAAa;","names":[]}
\ No newline at end of file
+{"version":3,"sources":["../../src/types.ts"],"sourcesContent":["/* istanbul ignore file */\n\nimport type { QueryClient } from './queryClient'\nimport type { DehydrateOptions, HydrateOptions } from './hydration'\nimport type { MutationState } from './mutation'\nimport type { FetchDirection, Query, QueryBehavior } from './query'\nimport type { RetryDelayValue, RetryValue } from './retryer'\nimport type { QueryFilters, QueryTypeFilter, SkipToken } from './utils'\nimport type { QueryCache } from './queryCache'\nimport type { MutationCache } from './mutationCache'\n\nexport type NonUndefinedGuard<T> = T extends undefined ? never : T\n\nexport type DistributiveOmit<\n  TObject,\n  TKey extends keyof TObject,\n> = TObject extends any ? Omit<TObject, TKey> : never\n\nexport type OmitKeyof<\n  TObject,\n  TKey extends TStrictly extends 'safely'\n    ?\n        | keyof TObject\n        | (string & Record<never, never>)\n        | (number & Record<never, never>)\n        | (symbol & Record<never, never>)\n    : keyof TObject,\n  TStrictly extends 'strictly' | 'safely' = 'strictly',\n> = Omit<TObject, TKey>\n\nexport type Override<TTargetA, TTargetB> = {\n  [AKey in keyof TTargetA]: AKey extends keyof TTargetB\n    ? TTargetB[AKey]\n    : TTargetA[AKey]\n}\n\nexport type NoInfer<T> = [T][T extends any ? 0 : never]\n\nexport interface Register {\n  // defaultError: Error\n  // queryMeta: Record<string, unknown>\n  // mutationMeta: Record<string, unknown>\n  // queryKey: ReadonlyArray<unknown>\n  // mutationKey: ReadonlyArray<unknown>\n}\n\nexport type DefaultError = Register extends {\n  defaultError: infer TError\n}\n  ? TError\n  : Error\n\nexport type QueryKey = Register extends {\n  queryKey: infer TQueryKey\n}\n  ? TQueryKey extends ReadonlyArray<unknown>\n    ? TQueryKey\n    : TQueryKey extends Array<unknown>\n      ? TQueryKey\n      : ReadonlyArray<unknown>\n  : ReadonlyArray<unknown>\n\nexport const dataTagSymbol = Symbol('dataTagSymbol')\nexport type dataTagSymbol = typeof dataTagSymbol\nexport const dataTagErrorSymbol = Symbol('dataTagErrorSymbol')\nexport type dataTagErrorSymbol = typeof dataTagErrorSymbol\nexport const unsetMarker = Symbol('unsetMarker')\nexport type UnsetMarker = typeof unsetMarker\nexport type AnyDataTag = {\n  [dataTagSymbol]: any\n  [dataTagErrorSymbol]: any\n}\nexport type DataTag<\n  TType,\n  TValue,\n  TError = UnsetMarker,\n> = TType extends AnyDataTag\n  ? TType\n  : TType & {\n      [dataTagSymbol]: TValue\n      [dataTagErrorSymbol]: TError\n    }\n\nexport type InferDataFromTag<TQueryFnData, TTaggedQueryKey extends QueryKey> =\n  TTaggedQueryKey extends DataTag<unknown, infer TaggedValue, unknown>\n    ? TaggedValue\n    : TQueryFnData\n\nexport type InferErrorFromTag<TError, TTaggedQueryKey extends QueryKey> =\n  TTaggedQueryKey extends DataTag<unknown, unknown, infer TaggedError>\n    ? TaggedError extends UnsetMarker\n      ? TError\n      : TaggedError\n    : TError\n\nexport type QueryFunction<\n  T = unknown,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> = (context: QueryFunctionContext<TQueryKey, TPageParam>) => T | Promise<T>\n\nexport type StaleTime = number | 'static'\n\nexport type StaleTimeFunction<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> =\n  | StaleTime\n  | ((query: Query<TQueryFnData, TError, TData, TQueryKey>) => StaleTime)\n\nexport type Enabled<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> =\n  | boolean\n  | ((query: Query<TQueryFnData, TError, TData, TQueryKey>) => boolean)\n\nexport type QueryPersister<\n  T = unknown,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> = [TPageParam] extends [never]\n  ? (\n      queryFn: QueryFunction<T, TQueryKey, never>,\n      context: QueryFunctionContext<TQueryKey>,\n      query: Query,\n    ) => T | Promise<T>\n  : (\n      queryFn: QueryFunction<T, TQueryKey, TPageParam>,\n      context: QueryFunctionContext<TQueryKey>,\n      query: Query,\n    ) => T | Promise<T>\n\nexport type QueryFunctionContext<\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> = [TPageParam] extends [never]\n  ? {\n      client: QueryClient\n      queryKey: TQueryKey\n      signal: AbortSignal\n      meta: QueryMeta | undefined\n      pageParam?: unknown\n      /**\n       * @deprecated\n       * if you want access to the direction, you can add it to the pageParam\n       */\n      direction?: unknown\n    }\n  : {\n      client: QueryClient\n      queryKey: TQueryKey\n      signal: AbortSignal\n      pageParam: TPageParam\n      /**\n       * @deprecated\n       * if you want access to the direction, you can add it to the pageParam\n       */\n      direction: FetchDirection\n      meta: QueryMeta | undefined\n    }\n\nexport type InitialDataFunction<T> = () => T | undefined\n\ntype NonFunctionGuard<T> = T extends Function ? never : T\n\nexport type PlaceholderDataFunction<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = (\n  previousData: TQueryData | undefined,\n  previousQuery: Query<TQueryFnData, TError, TQueryData, TQueryKey> | undefined,\n) => TQueryData | undefined\n\nexport type QueriesPlaceholderDataFunction<TQueryData> = (\n  previousData: undefined,\n  previousQuery: undefined,\n) => TQueryData | undefined\n\nexport type QueryKeyHashFunction<TQueryKey extends QueryKey> = (\n  queryKey: TQueryKey,\n) => string\n\nexport type GetPreviousPageParamFunction<TPageParam, TQueryFnData = unknown> = (\n  firstPage: TQueryFnData,\n  allPages: Array<TQueryFnData>,\n  firstPageParam: TPageParam,\n  allPageParams: Array<TPageParam>,\n) => TPageParam | undefined | null\n\nexport type GetNextPageParamFunction<TPageParam, TQueryFnData = unknown> = (\n  lastPage: TQueryFnData,\n  allPages: Array<TQueryFnData>,\n  lastPageParam: TPageParam,\n  allPageParams: Array<TPageParam>,\n) => TPageParam | undefined | null\n\nexport interface InfiniteData<TData, TPageParam = unknown> {\n  pages: Array<TData>\n  pageParams: Array<TPageParam>\n}\n\nexport type QueryMeta = Register extends {\n  queryMeta: infer TQueryMeta\n}\n  ? TQueryMeta extends Record<string, unknown>\n    ? TQueryMeta\n    : Record<string, unknown>\n  : Record<string, unknown>\n\nexport type NetworkMode = 'online' | 'always' | 'offlineFirst'\n\nexport type NotifyOnChangeProps =\n  | Array<keyof InfiniteQueryObserverResult>\n  | 'all'\n  | undefined\n  | (() => Array<keyof InfiniteQueryObserverResult> | 'all' | undefined)\n\nexport interface QueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> {\n  /**\n   * If `false`, failed queries will not retry by default.\n   * If `true`, failed queries will retry infinitely., failureCount: num\n   * If set to an integer number, e.g. 3, failed queries will retry until the failed query count meets that number.\n   * If set to a function `(failureCount, error) => boolean` failed queries will retry until the function returns false.\n   */\n  retry?: RetryValue<TError>\n  retryDelay?: RetryDelayValue<TError>\n  networkMode?: NetworkMode\n  /**\n   * The time in milliseconds that unused/inactive cache data remains in memory.\n   * When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration.\n   * When different garbage collection times are specified, the longest one will be used.\n   * Setting it to `Infinity` will disable garbage collection.\n   */\n  gcTime?: number\n  queryFn?: QueryFunction<TQueryFnData, TQueryKey, TPageParam> | SkipToken\n  persister?: QueryPersister<\n    NoInfer<TQueryFnData>,\n    NoInfer<TQueryKey>,\n    NoInfer<TPageParam>\n  >\n  queryHash?: string\n  queryKey?: TQueryKey\n  queryKeyHashFn?: QueryKeyHashFunction<TQueryKey>\n  initialData?: TData | InitialDataFunction<TData>\n  initialDataUpdatedAt?: number | (() => number | undefined)\n  behavior?: QueryBehavior<TQueryFnData, TError, TData, TQueryKey>\n  /**\n   * Set this to `false` to disable structural sharing between query results.\n   * Set this to a function which accepts the old and new data and returns resolved data of the same type to implement custom structural sharing logic.\n   * Defaults to `true`.\n   */\n  structuralSharing?:\n    | boolean\n    | ((oldData: unknown | undefined, newData: unknown) => unknown)\n  _defaulted?: boolean\n  /**\n   * Additional payload to be stored on each query.\n   * Use this property to pass information that can be used in other places.\n   */\n  meta?: QueryMeta\n  /**\n   * Maximum number of pages to store in the data of an infinite query.\n   */\n  maxPages?: number\n}\n\nexport interface InitialPageParam<TPageParam = unknown> {\n  initialPageParam: TPageParam\n}\n\nexport interface InfiniteQueryPageParamsOptions<\n  TQueryFnData = unknown,\n  TPageParam = unknown,\n> extends InitialPageParam<TPageParam> {\n  /**\n   * This function can be set to automatically get the previous cursor for infinite queries.\n   * The result will also be used to determine the value of `hasPreviousPage`.\n   */\n  getPreviousPageParam?: GetPreviousPageParamFunction<TPageParam, TQueryFnData>\n  /**\n   * This function can be set to automatically get the next cursor for infinite queries.\n   * The result will also be used to determine the value of `hasNextPage`.\n   */\n  getNextPageParam: GetNextPageParamFunction<TPageParam, TQueryFnData>\n}\n\nexport type ThrowOnError<\n  TQueryFnData,\n  TError,\n  TQueryData,\n  TQueryKey extends QueryKey,\n> =\n  | boolean\n  | ((\n      error: TError,\n      query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n    ) => boolean)\n\nexport interface QueryObserverOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> extends WithRequired<\n    QueryOptions<TQueryFnData, TError, TQueryData, TQueryKey, TPageParam>,\n    'queryKey'\n  > {\n  /**\n   * Set this to `false` or a function that returns `false` to disable automatic refetching when the query mounts or changes query keys.\n   * To refetch the query, use the `refetch` method returned from the `useQuery` instance.\n   * Accepts a boolean or function that returns a boolean.\n   * Defaults to `true`.\n   */\n  enabled?: Enabled<TQueryFnData, TError, TQueryData, TQueryKey>\n  /**\n   * The time in milliseconds after data is considered stale.\n   * If set to `Infinity`, the data will never be considered stale.\n   * If set to a function, the function will be executed with the query to compute a `staleTime`.\n   * Defaults to `0`.\n   */\n  staleTime?: StaleTimeFunction<TQueryFnData, TError, TQueryData, TQueryKey>\n  /**\n   * If set to a number, the query will continuously refetch at this frequency in milliseconds.\n   * If set to a function, the function will be executed with the latest data and query to compute a frequency\n   * Defaults to `false`.\n   */\n  refetchInterval?:\n    | number\n    | false\n    | ((\n        query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n      ) => number | false | undefined)\n  /**\n   * If set to `true`, the query will continue to refetch while their tab/window is in the background.\n   * Defaults to `false`.\n   */\n  refetchIntervalInBackground?: boolean\n  /**\n   * If set to `true`, the query will refetch on window focus if the data is stale.\n   * If set to `false`, the query will not refetch on window focus.\n   * If set to `'always'`, the query will always refetch on window focus.\n   * If set to a function, the function will be executed with the latest data and query to compute the value.\n   * Defaults to `true`.\n   */\n  refetchOnWindowFocus?:\n    | boolean\n    | 'always'\n    | ((\n        query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n      ) => boolean | 'always')\n  /**\n   * If set to `true`, the query will refetch on reconnect if the data is stale.\n   * If set to `false`, the query will not refetch on reconnect.\n   * If set to `'always'`, the query will always refetch on reconnect.\n   * If set to a function, the function will be executed with the latest data and query to compute the value.\n   * Defaults to the value of `networkOnline` (`true`)\n   */\n  refetchOnReconnect?:\n    | boolean\n    | 'always'\n    | ((\n        query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n      ) => boolean | 'always')\n  /**\n   * If set to `true`, the query will refetch on mount if the data is stale.\n   * If set to `false`, will disable additional instances of a query to trigger background refetch.\n   * If set to `'always'`, the query will always refetch on mount.\n   * If set to a function, the function will be executed with the latest data and query to compute the value\n   * Defaults to `true`.\n   */\n  refetchOnMount?:\n    | boolean\n    | 'always'\n    | ((\n        query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n      ) => boolean | 'always')\n  /**\n   * If set to `false`, the query will not be retried on mount if it contains an error.\n   * Defaults to `true`.\n   */\n  retryOnMount?: boolean\n  /**\n   * If set, the component will only re-render if any of the listed properties change.\n   * When set to `['data', 'error']`, the component will only re-render when the `data` or `error` properties change.\n   * When set to `'all'`, the component will re-render whenever a query is updated.\n   * When set to a function, the function will be executed to compute the list of properties.\n   * By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.\n   */\n  notifyOnChangeProps?: NotifyOnChangeProps\n  /**\n   * Whether errors should be thrown instead of setting the `error` property.\n   * If set to `true` or `suspense` is `true`, all errors will be thrown to the error boundary.\n   * If set to `false` and `suspense` is `false`, errors are returned as state.\n   * If set to a function, it will be passed the error and the query, and it should return a boolean indicating whether to show the error in an error boundary (`true`) or return the error as state (`false`).\n   * Defaults to `false`.\n   */\n  throwOnError?: ThrowOnError<TQueryFnData, TError, TQueryData, TQueryKey>\n  /**\n   * This option can be used to transform or select a part of the data returned by the query function.\n   */\n  select?: (data: TQueryData) => TData\n  /**\n   * If set to `true`, the query will suspend when `status === 'pending'`\n   * and throw errors when `status === 'error'`.\n   * Defaults to `false`.\n   */\n  suspense?: boolean\n  /**\n   * If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `loading` data and no initialData has been provided.\n   */\n  placeholderData?:\n    | NonFunctionGuard<TQueryData>\n    | PlaceholderDataFunction<\n        NonFunctionGuard<TQueryData>,\n        TError,\n        NonFunctionGuard<TQueryData>,\n        TQueryKey\n      >\n\n  _optimisticResults?: 'optimistic' | 'isRestoring'\n\n  /**\n   * Enable prefetching during rendering\n   */\n  experimental_prefetchInRender?: boolean\n}\n\nexport type WithRequired<TTarget, TKey extends keyof TTarget> = TTarget & {\n  [_ in TKey]: {}\n}\n\nexport type DefaultedQueryObserverOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = WithRequired<\n  QueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  'throwOnError' | 'refetchOnReconnect' | 'queryHash'\n>\n\nexport interface InfiniteQueryObserverOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> extends QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      InfiniteData<TQueryFnData, TPageParam>,\n      TQueryKey,\n      TPageParam\n    >,\n    InfiniteQueryPageParamsOptions<TQueryFnData, TPageParam> {}\n\nexport type DefaultedInfiniteQueryObserverOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> = WithRequired<\n  InfiniteQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  >,\n  'throwOnError' | 'refetchOnReconnect' | 'queryHash'\n>\n\nexport interface FetchQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> extends WithRequired<\n    QueryOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>,\n    'queryKey'\n  > {\n  initialPageParam?: never\n  /**\n   * The time in milliseconds after data is considered stale.\n   * If the data is fresh it will be returned from the cache.\n   */\n  staleTime?: StaleTimeFunction<TQueryFnData, TError, TData, TQueryKey>\n}\n\nexport interface EnsureQueryDataOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> extends FetchQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  > {\n  revalidateIfStale?: boolean\n}\n\nexport type EnsureInfiniteQueryDataOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> = FetchInfiniteQueryOptions<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey,\n  TPageParam\n> & {\n  revalidateIfStale?: boolean\n}\n\ntype FetchInfiniteQueryPages<TQueryFnData = unknown, TPageParam = unknown> =\n  | { pages?: never }\n  | {\n      pages: number\n      getNextPageParam: GetNextPageParamFunction<TPageParam, TQueryFnData>\n    }\n\nexport type FetchInfiniteQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> = Omit<\n  FetchQueryOptions<\n    TQueryFnData,\n    TError,\n    InfiniteData<TData, TPageParam>,\n    TQueryKey,\n    TPageParam\n  >,\n  'initialPageParam'\n> &\n  InitialPageParam<TPageParam> &\n  FetchInfiniteQueryPages<TQueryFnData, TPageParam>\n\nexport interface ResultOptions {\n  throwOnError?: boolean\n}\n\nexport interface RefetchOptions extends ResultOptions {\n  /**\n   * If set to `true`, a currently running request will be cancelled before a new request is made\n   *\n   * If set to `false`, no refetch will be made if there is already a request running.\n   *\n   * Defaults to `true`.\n   */\n  cancelRefetch?: boolean\n\n  updateMeta?: Record<string, unknown>\n}\n\nexport interface InvalidateQueryFilters<TQueryKey extends QueryKey = QueryKey>\n  extends QueryFilters<TQueryKey> {\n  refetchType?: QueryTypeFilter | 'none'\n}\n\nexport interface RefetchQueryFilters<TQueryKey extends QueryKey = QueryKey>\n  extends QueryFilters<TQueryKey> {}\n\nexport interface InvalidateOptions extends RefetchOptions {}\nexport interface ResetOptions extends RefetchOptions {}\n\nexport interface FetchNextPageOptions extends ResultOptions {\n  /**\n   * If set to `true`, calling `fetchNextPage` repeatedly will invoke `queryFn` every time,\n   * whether the previous invocation has resolved or not. Also, the result from previous invocations will be ignored.\n   *\n   * If set to `false`, calling `fetchNextPage` repeatedly won't have any effect until the first invocation has resolved.\n   *\n   * Defaults to `true`.\n   */\n  cancelRefetch?: boolean\n}\n\nexport interface FetchPreviousPageOptions extends ResultOptions {\n  /**\n   * If set to `true`, calling `fetchPreviousPage` repeatedly will invoke `queryFn` every time,\n   * whether the previous invocation has resolved or not. Also, the result from previous invocations will be ignored.\n   *\n   * If set to `false`, calling `fetchPreviousPage` repeatedly won't have any effect until the first invocation has resolved.\n   *\n   * Defaults to `true`.\n   */\n  cancelRefetch?: boolean\n}\n\nexport type QueryStatus = 'pending' | 'error' | 'success'\nexport type FetchStatus = 'fetching' | 'paused' | 'idle'\n\nexport interface QueryObserverBaseResult<\n  TData = unknown,\n  TError = DefaultError,\n> {\n  /**\n   * The last successfully resolved data for the query.\n   */\n  data: TData | undefined\n  /**\n   * The timestamp for when the query most recently returned the `status` as `\"success\"`.\n   */\n  dataUpdatedAt: number\n  /**\n   * The error object for the query, if an error was thrown.\n   * - Defaults to `null`.\n   */\n  error: TError | null\n  /**\n   * The timestamp for when the query most recently returned the `status` as `\"error\"`.\n   */\n  errorUpdatedAt: number\n  /**\n   * The failure count for the query.\n   * - Incremented every time the query fails.\n   * - Reset to `0` when the query succeeds.\n   */\n  failureCount: number\n  /**\n   * The failure reason for the query retry.\n   * - Reset to `null` when the query succeeds.\n   */\n  failureReason: TError | null\n  /**\n   * The sum of all errors.\n   */\n  errorUpdateCount: number\n  /**\n   * A derived boolean from the `status` variable, provided for convenience.\n   * - `true` if the query attempt resulted in an error.\n   */\n  isError: boolean\n  /**\n   * Will be `true` if the query has been fetched.\n   */\n  isFetched: boolean\n  /**\n   * Will be `true` if the query has been fetched after the component mounted.\n   * - This property can be used to not show any previously cached data.\n   */\n  isFetchedAfterMount: boolean\n  /**\n   * A derived boolean from the `fetchStatus` variable, provided for convenience.\n   * - `true` whenever the `queryFn` is executing, which includes initial `pending` as well as background refetch.\n   */\n  isFetching: boolean\n  /**\n   * Is `true` whenever the first fetch for a query is in-flight.\n   * - Is the same as `isFetching && isPending`.\n   */\n  isLoading: boolean\n  /**\n   * Will be `pending` if there's no cached data and no query attempt was finished yet.\n   */\n  isPending: boolean\n  /**\n   * Will be `true` if the query failed while fetching for the first time.\n   */\n  isLoadingError: boolean\n  /**\n   * @deprecated `isInitialLoading` is being deprecated in favor of `isLoading`\n   * and will be removed in the next major version.\n   */\n  isInitialLoading: boolean\n  /**\n   * A derived boolean from the `fetchStatus` variable, provided for convenience.\n   * - The query wanted to fetch, but has been `paused`.\n   */\n  isPaused: boolean\n  /**\n   * Will be `true` if the data shown is the placeholder data.\n   */\n  isPlaceholderData: boolean\n  /**\n   * Will be `true` if the query failed while refetching.\n   */\n  isRefetchError: boolean\n  /**\n   * Is `true` whenever a background refetch is in-flight, which _does not_ include initial `pending`.\n   * - Is the same as `isFetching && !isPending`.\n   */\n  isRefetching: boolean\n  /**\n   * Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.\n   */\n  isStale: boolean\n  /**\n   * A derived boolean from the `status` variable, provided for convenience.\n   * - `true` if the query has received a response with no errors and is ready to display its data.\n   */\n  isSuccess: boolean\n  /**\n   * A function to manually refetch the query.\n   */\n  refetch: (\n    options?: RefetchOptions,\n  ) => Promise<QueryObserverResult<TData, TError>>\n  /**\n   * The status of the query.\n   * - Will be:\n   *   - `pending` if there's no cached data and no query attempt was finished yet.\n   *   - `error` if the query attempt resulted in an error.\n   *   - `success` if the query has received a response with no errors and is ready to display its data.\n   */\n  status: QueryStatus\n  /**\n   * The fetch status of the query.\n   * - `fetching`: Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetch.\n   * - `paused`: The query wanted to fetch, but has been `paused`.\n   * - `idle`: The query is not fetching.\n   * - See [Network Mode](https://tanstack.com/query/latest/docs/framework/react/guides/network-mode) for more information.\n   */\n  fetchStatus: FetchStatus\n  /**\n   * A stable promise that will be resolved with the data of the query.\n   * Requires the `experimental_prefetchInRender` feature flag to be enabled.\n   * @example\n   *\n   * ### Enabling the feature flag\n   * ```ts\n   * const client = new QueryClient({\n   *   defaultOptions: {\n   *     queries: {\n   *       experimental_prefetchInRender: true,\n   *     },\n   *   },\n   * })\n   * ```\n   *\n   * ### Usage\n   * ```tsx\n   * import { useQuery } from '@tanstack/react-query'\n   * import React from 'react'\n   * import { fetchTodos, type Todo } from './api'\n   *\n   * function TodoList({ query }: { query: UseQueryResult<Todo[], Error> }) {\n   *   const data = React.use(query.promise)\n   *\n   *   return (\n   *     <ul>\n   *       {data.map(todo => (\n   *         <li key={todo.id}>{todo.title}</li>\n   *       ))}\n   *     </ul>\n   *   )\n   * }\n   *\n   * export function App() {\n   *   const query = useQuery({ queryKey: ['todos'], queryFn: fetchTodos })\n   *\n   *   return (\n   *     <>\n   *       <h1>Todos</h1>\n   *       <React.Suspense fallback={<div>Loading...</div>}>\n   *         <TodoList query={query} />\n   *       </React.Suspense>\n   *     </>\n   *   )\n   * }\n   * ```\n   */\n  promise: Promise<TData>\n}\n\nexport interface QueryObserverPendingResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: null\n  isError: false\n  isPending: true\n  isLoadingError: false\n  isRefetchError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'pending'\n}\n\nexport interface QueryObserverLoadingResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: null\n  isError: false\n  isPending: true\n  isLoading: true\n  isLoadingError: false\n  isRefetchError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'pending'\n}\n\nexport interface QueryObserverLoadingErrorResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: TError\n  isError: true\n  isPending: false\n  isLoading: false\n  isLoadingError: true\n  isRefetchError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'error'\n}\n\nexport interface QueryObserverRefetchErrorResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: TData\n  error: TError\n  isError: true\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: true\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'error'\n}\n\nexport interface QueryObserverSuccessResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: TData\n  error: null\n  isError: false\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: false\n  isSuccess: true\n  isPlaceholderData: false\n  status: 'success'\n}\n\nexport interface QueryObserverPlaceholderResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: TData\n  isError: false\n  error: null\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: false\n  isSuccess: true\n  isPlaceholderData: true\n  status: 'success'\n}\n\nexport type DefinedQueryObserverResult<\n  TData = unknown,\n  TError = DefaultError,\n> =\n  | QueryObserverRefetchErrorResult<TData, TError>\n  | QueryObserverSuccessResult<TData, TError>\n\nexport type QueryObserverResult<TData = unknown, TError = DefaultError> =\n  | DefinedQueryObserverResult<TData, TError>\n  | QueryObserverLoadingErrorResult<TData, TError>\n  | QueryObserverLoadingResult<TData, TError>\n  | QueryObserverPendingResult<TData, TError>\n  | QueryObserverPlaceholderResult<TData, TError>\n\nexport interface InfiniteQueryObserverBaseResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  /**\n   * This function allows you to fetch the next \"page\" of results.\n   */\n  fetchNextPage: (\n    options?: FetchNextPageOptions,\n  ) => Promise<InfiniteQueryObserverResult<TData, TError>>\n  /**\n   * This function allows you to fetch the previous \"page\" of results.\n   */\n  fetchPreviousPage: (\n    options?: FetchPreviousPageOptions,\n  ) => Promise<InfiniteQueryObserverResult<TData, TError>>\n  /**\n   * Will be `true` if there is a next page to be fetched (known via the `getNextPageParam` option).\n   */\n  hasNextPage: boolean\n  /**\n   * Will be `true` if there is a previous page to be fetched (known via the `getPreviousPageParam` option).\n   */\n  hasPreviousPage: boolean\n  /**\n   * Will be `true` if the query failed while fetching the next page.\n   */\n  isFetchNextPageError: boolean\n  /**\n   * Will be `true` while fetching the next page with `fetchNextPage`.\n   */\n  isFetchingNextPage: boolean\n  /**\n   * Will be `true` if the query failed while fetching the previous page.\n   */\n  isFetchPreviousPageError: boolean\n  /**\n   * Will be `true` while fetching the previous page with `fetchPreviousPage`.\n   */\n  isFetchingPreviousPage: boolean\n}\n\nexport interface InfiniteQueryObserverPendingResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: null\n  isError: false\n  isPending: true\n  isLoadingError: false\n  isRefetchError: false\n  isFetchNextPageError: false\n  isFetchPreviousPageError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'pending'\n}\n\nexport interface InfiniteQueryObserverLoadingResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: null\n  isError: false\n  isPending: true\n  isLoading: true\n  isLoadingError: false\n  isRefetchError: false\n  isFetchNextPageError: false\n  isFetchPreviousPageError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'pending'\n}\n\nexport interface InfiniteQueryObserverLoadingErrorResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: TError\n  isError: true\n  isPending: false\n  isLoading: false\n  isLoadingError: true\n  isRefetchError: false\n  isFetchNextPageError: false\n  isFetchPreviousPageError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'error'\n}\n\nexport interface InfiniteQueryObserverRefetchErrorResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: TData\n  error: TError\n  isError: true\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: true\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'error'\n}\n\nexport interface InfiniteQueryObserverSuccessResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: TData\n  error: null\n  isError: false\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: false\n  isFetchNextPageError: false\n  isFetchPreviousPageError: false\n  isSuccess: true\n  isPlaceholderData: false\n  status: 'success'\n}\n\nexport interface InfiniteQueryObserverPlaceholderResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: TData\n  isError: false\n  error: null\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: false\n  isSuccess: true\n  isPlaceholderData: true\n  isFetchNextPageError: false\n  isFetchPreviousPageError: false\n  status: 'success'\n}\n\nexport type DefinedInfiniteQueryObserverResult<\n  TData = unknown,\n  TError = DefaultError,\n> =\n  | InfiniteQueryObserverRefetchErrorResult<TData, TError>\n  | InfiniteQueryObserverSuccessResult<TData, TError>\n\nexport type InfiniteQueryObserverResult<\n  TData = unknown,\n  TError = DefaultError,\n> =\n  | DefinedInfiniteQueryObserverResult<TData, TError>\n  | InfiniteQueryObserverLoadingErrorResult<TData, TError>\n  | InfiniteQueryObserverLoadingResult<TData, TError>\n  | InfiniteQueryObserverPendingResult<TData, TError>\n  | InfiniteQueryObserverPlaceholderResult<TData, TError>\n\nexport type MutationKey = Register extends {\n  mutationKey: infer TMutationKey\n}\n  ? TMutationKey extends Array<unknown>\n    ? TMutationKey\n    : TMutationKey extends Array<unknown>\n      ? TMutationKey\n      : ReadonlyArray<unknown>\n  : ReadonlyArray<unknown>\n\nexport type MutationStatus = 'idle' | 'pending' | 'success' | 'error'\n\nexport type MutationScope = {\n  id: string\n}\n\nexport type MutationMeta = Register extends {\n  mutationMeta: infer TMutationMeta\n}\n  ? TMutationMeta extends Record<string, unknown>\n    ? TMutationMeta\n    : Record<string, unknown>\n  : Record<string, unknown>\n\nexport type MutationFunction<TData = unknown, TVariables = unknown> = (\n  variables: TVariables,\n) => Promise<TData>\n\nexport interface MutationOptions<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> {\n  mutationFn?: MutationFunction<TData, TVariables>\n  mutationKey?: MutationKey\n  onMutate?: (\n    variables: TVariables,\n  ) => Promise<TContext | undefined> | TContext | undefined\n  onSuccess?: (\n    data: TData,\n    variables: TVariables,\n    context: TContext,\n  ) => Promise<unknown> | unknown\n  onError?: (\n    error: TError,\n    variables: TVariables,\n    context: TContext | undefined,\n  ) => Promise<unknown> | unknown\n  onSettled?: (\n    data: TData | undefined,\n    error: TError | null,\n    variables: TVariables,\n    context: TContext | undefined,\n  ) => Promise<unknown> | unknown\n  retry?: RetryValue<TError>\n  retryDelay?: RetryDelayValue<TError>\n  networkMode?: NetworkMode\n  gcTime?: number\n  _defaulted?: boolean\n  meta?: MutationMeta\n  scope?: MutationScope\n}\n\nexport interface MutationObserverOptions<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationOptions<TData, TError, TVariables, TContext> {\n  throwOnError?: boolean | ((error: TError) => boolean)\n}\n\nexport interface MutateOptions<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> {\n  onSuccess?: (data: TData, variables: TVariables, context: TContext) => void\n  onError?: (\n    error: TError,\n    variables: TVariables,\n    context: TContext | undefined,\n  ) => void\n  onSettled?: (\n    data: TData | undefined,\n    error: TError | null,\n    variables: TVariables,\n    context: TContext | undefined,\n  ) => void\n}\n\nexport type MutateFunction<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> = (\n  variables: TVariables,\n  options?: MutateOptions<TData, TError, TVariables, TContext>,\n) => Promise<TData>\n\nexport interface MutationObserverBaseResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationState<TData, TError, TVariables, TContext> {\n  /**\n   * The last successfully resolved data for the mutation.\n   */\n  data: TData | undefined\n  /**\n   * The variables object passed to the `mutationFn`.\n   */\n  variables: TVariables | undefined\n  /**\n   * The error object for the mutation, if an error was encountered.\n   * - Defaults to `null`.\n   */\n  error: TError | null\n  /**\n   * A boolean variable derived from `status`.\n   * - `true` if the last mutation attempt resulted in an error.\n   */\n  isError: boolean\n  /**\n   * A boolean variable derived from `status`.\n   * - `true` if the mutation is in its initial state prior to executing.\n   */\n  isIdle: boolean\n  /**\n   * A boolean variable derived from `status`.\n   * - `true` if the mutation is currently executing.\n   */\n  isPending: boolean\n  /**\n   * A boolean variable derived from `status`.\n   * - `true` if the last mutation attempt was successful.\n   */\n  isSuccess: boolean\n  /**\n   * The status of the mutation.\n   * - Will be:\n   *   - `idle` initial status prior to the mutation function executing.\n   *   - `pending` if the mutation is currently executing.\n   *   - `error` if the last mutation attempt resulted in an error.\n   *   - `success` if the last mutation attempt was successful.\n   */\n  status: MutationStatus\n  /**\n   * The mutation function you can call with variables to trigger the mutation and optionally hooks on additional callback options.\n   * @param variables - The variables object to pass to the `mutationFn`.\n   * @param options.onSuccess - This function will fire when the mutation is successful and will be passed the mutation's result.\n   * @param options.onError - This function will fire if the mutation encounters an error and will be passed the error.\n   * @param options.onSettled - This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error.\n   * @remarks\n   * - If you make multiple requests, `onSuccess` will fire only after the latest call you've made.\n   * - All the callback functions (`onSuccess`, `onError`, `onSettled`) are void functions, and the returned value will be ignored.\n   */\n  mutate: MutateFunction<TData, TError, TVariables, TContext>\n  /**\n   * A function to clean the mutation internal state (i.e., it resets the mutation to its initial state).\n   */\n  reset: () => void\n}\n\nexport interface MutationObserverIdleResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationObserverBaseResult<TData, TError, TVariables, TContext> {\n  data: undefined\n  variables: undefined\n  error: null\n  isError: false\n  isIdle: true\n  isPending: false\n  isSuccess: false\n  status: 'idle'\n}\n\nexport interface MutationObserverLoadingResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationObserverBaseResult<TData, TError, TVariables, TContext> {\n  data: undefined\n  variables: TVariables\n  error: null\n  isError: false\n  isIdle: false\n  isPending: true\n  isSuccess: false\n  status: 'pending'\n}\n\nexport interface MutationObserverErrorResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationObserverBaseResult<TData, TError, TVariables, TContext> {\n  data: undefined\n  error: TError\n  variables: TVariables\n  isError: true\n  isIdle: false\n  isPending: false\n  isSuccess: false\n  status: 'error'\n}\n\nexport interface MutationObserverSuccessResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationObserverBaseResult<TData, TError, TVariables, TContext> {\n  data: TData\n  error: null\n  variables: TVariables\n  isError: false\n  isIdle: false\n  isPending: false\n  isSuccess: true\n  status: 'success'\n}\n\nexport type MutationObserverResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> =\n  | MutationObserverIdleResult<TData, TError, TVariables, TContext>\n  | MutationObserverLoadingResult<TData, TError, TVariables, TContext>\n  | MutationObserverErrorResult<TData, TError, TVariables, TContext>\n  | MutationObserverSuccessResult<TData, TError, TVariables, TContext>\n\nexport interface QueryClientConfig {\n  queryCache?: QueryCache\n  mutationCache?: MutationCache\n  defaultOptions?: DefaultOptions\n}\n\nexport interface DefaultOptions<TError = DefaultError> {\n  queries?: OmitKeyof<\n    QueryObserverOptions<unknown, TError>,\n    'suspense' | 'queryKey'\n  >\n  mutations?: MutationObserverOptions<unknown, TError, unknown, unknown>\n  hydrate?: HydrateOptions['defaultOptions']\n  dehydrate?: DehydrateOptions\n}\n\nexport interface CancelOptions {\n  revert?: boolean\n  silent?: boolean\n}\n\nexport interface SetDataOptions {\n  updatedAt?: number\n}\n\nexport type NotifyEventType =\n  | 'added'\n  | 'removed'\n  | 'updated'\n  | 'observerAdded'\n  | 'observerRemoved'\n  | 'observerResultsUpdated'\n  | 'observerOptionsUpdated'\n\nexport interface NotifyEvent {\n  type: NotifyEventType\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA8DO,IAAM,gBAAgB,OAAO,eAAe;AAE5C,IAAM,qBAAqB,OAAO,oBAAoB;AAEtD,IAAM,cAAc,OAAO,aAAa;","names":[]}
\ No newline at end of file
diff --git a/build/modern/types.d.cts b/build/modern/types.d.cts
index 2a21e2164c6adabc963945a2c7a192de945cc476..8db71ac4606137e1524fe45ce11bbb254ebc7a60 100644
--- a/build/modern/types.d.cts
+++ b/build/modern/types.d.cts
@@ -1,3 +1,3 @@
-export { T as AnyDataTag, b6 as CancelOptions, V as DataTag, G as DefaultError, b5 as DefaultOptions, ak as DefaultedInfiniteQueryObserverOptions, ai as DefaultedQueryObserverOptions, aP as DefinedInfiniteQueryObserverResult, aG as DefinedQueryObserverResult, B as DistributiveOmit, $ as Enabled, an as EnsureInfiniteQueryDataOptions, am as EnsureQueryDataOptions, ao as FetchInfiniteQueryOptions, av as FetchNextPageOptions, aw as FetchPreviousPageOptions, al as FetchQueryOptions, ay as FetchStatus, a7 as GetNextPageParamFunction, a6 as GetPreviousPageParamFunction, W as InferDataFromTag, X as InferErrorFromTag, a8 as InfiniteData, aI as InfiniteQueryObserverBaseResult, aL as InfiniteQueryObserverLoadingErrorResult, aK as InfiniteQueryObserverLoadingResult, aj as InfiniteQueryObserverOptions, aJ as InfiniteQueryObserverPendingResult, aO as InfiniteQueryObserverPlaceholderResult, aM as InfiniteQueryObserverRefetchErrorResult, aQ as InfiniteQueryObserverResult, aN as InfiniteQueryObserverSuccessResult, ae as InfiniteQueryPageParamsOptions, a2 as InitialDataFunction, ad as InitialPageParam, at as InvalidateOptions, ar as InvalidateQueryFilters, aZ as MutateFunction, aY as MutateOptions, aV as MutationFunction, aR as MutationKey, aU as MutationMeta, a_ as MutationObserverBaseResult, b1 as MutationObserverErrorResult, a$ as MutationObserverIdleResult, b0 as MutationObserverLoadingResult, aX as MutationObserverOptions, b3 as MutationObserverResult, b2 as MutationObserverSuccessResult, aW as MutationOptions, aT as MutationScope, aS as MutationStatus, aa as NetworkMode, F as NoInfer, N as NonUndefinedGuard, b9 as NotifyEvent, b8 as NotifyEventType, ab as NotifyOnChangeProps, O as OmitKeyof, E as Override, a3 as PlaceholderDataFunction, a4 as QueriesPlaceholderDataFunction, b4 as QueryClientConfig, Y as QueryFunction, a1 as QueryFunctionContext, I as QueryKey, a5 as QueryKeyHashFunction, a9 as QueryMeta, az as QueryObserverBaseResult, aC as QueryObserverLoadingErrorResult, aB as QueryObserverLoadingResult, ag as QueryObserverOptions, aA as QueryObserverPendingResult, aF as QueryObserverPlaceholderResult, aD as QueryObserverRefetchErrorResult, aH as QueryObserverResult, aE as QueryObserverSuccessResult, ac as QueryOptions, a0 as QueryPersister, ax as QueryStatus, aq as RefetchOptions, as as RefetchQueryFilters, R as Register, au as ResetOptions, ap as ResultOptions, b7 as SetDataOptions, Z as StaleTime, _ as StaleTimeFunction, af as ThrowOnError, P as UnsetMarker, ah as WithRequired, K as dataTagErrorSymbol, J as dataTagSymbol, L as unsetMarker } from './hydration-CdBkFt9i.cjs';
+export { T as AnyDataTag, b6 as CancelOptions, V as DataTag, G as DefaultError, b5 as DefaultOptions, ak as DefaultedInfiniteQueryObserverOptions, ai as DefaultedQueryObserverOptions, aP as DefinedInfiniteQueryObserverResult, aG as DefinedQueryObserverResult, B as DistributiveOmit, $ as Enabled, an as EnsureInfiniteQueryDataOptions, am as EnsureQueryDataOptions, ao as FetchInfiniteQueryOptions, av as FetchNextPageOptions, aw as FetchPreviousPageOptions, al as FetchQueryOptions, ay as FetchStatus, a7 as GetNextPageParamFunction, a6 as GetPreviousPageParamFunction, W as InferDataFromTag, X as InferErrorFromTag, a8 as InfiniteData, aI as InfiniteQueryObserverBaseResult, aL as InfiniteQueryObserverLoadingErrorResult, aK as InfiniteQueryObserverLoadingResult, aj as InfiniteQueryObserverOptions, aJ as InfiniteQueryObserverPendingResult, aO as InfiniteQueryObserverPlaceholderResult, aM as InfiniteQueryObserverRefetchErrorResult, aQ as InfiniteQueryObserverResult, aN as InfiniteQueryObserverSuccessResult, ae as InfiniteQueryPageParamsOptions, a2 as InitialDataFunction, ad as InitialPageParam, at as InvalidateOptions, ar as InvalidateQueryFilters, aZ as MutateFunction, aY as MutateOptions, aV as MutationFunction, aR as MutationKey, aU as MutationMeta, a_ as MutationObserverBaseResult, b1 as MutationObserverErrorResult, a$ as MutationObserverIdleResult, b0 as MutationObserverLoadingResult, aX as MutationObserverOptions, b3 as MutationObserverResult, b2 as MutationObserverSuccessResult, aW as MutationOptions, aT as MutationScope, aS as MutationStatus, aa as NetworkMode, F as NoInfer, N as NonUndefinedGuard, b9 as NotifyEvent, b8 as NotifyEventType, ab as NotifyOnChangeProps, O as OmitKeyof, E as Override, a3 as PlaceholderDataFunction, a4 as QueriesPlaceholderDataFunction, b4 as QueryClientConfig, Y as QueryFunction, a1 as QueryFunctionContext, I as QueryKey, a5 as QueryKeyHashFunction, a9 as QueryMeta, az as QueryObserverBaseResult, aC as QueryObserverLoadingErrorResult, aB as QueryObserverLoadingResult, ag as QueryObserverOptions, aA as QueryObserverPendingResult, aF as QueryObserverPlaceholderResult, aD as QueryObserverRefetchErrorResult, aH as QueryObserverResult, aE as QueryObserverSuccessResult, ac as QueryOptions, a0 as QueryPersister, ax as QueryStatus, aq as RefetchOptions, as as RefetchQueryFilters, R as Register, au as ResetOptions, ap as ResultOptions, b7 as SetDataOptions, Z as StaleTime, _ as StaleTimeFunction, af as ThrowOnError, P as UnsetMarker, ah as WithRequired, K as dataTagErrorSymbol, J as dataTagSymbol, L as unsetMarker } from './hydration-Dv1t2VQO.cjs';
 import './removable.cjs';
 import './subscribable.cjs';
diff --git a/build/modern/types.d.ts b/build/modern/types.d.ts
index 2dbce3d23404ae403761c9724e9d1216e7482973..2e8efb08886d46461a529058f834605a08e2f938 100644
--- a/build/modern/types.d.ts
+++ b/build/modern/types.d.ts
@@ -1,3 +1,3 @@
-export { T as AnyDataTag, b6 as CancelOptions, V as DataTag, G as DefaultError, b5 as DefaultOptions, ak as DefaultedInfiniteQueryObserverOptions, ai as DefaultedQueryObserverOptions, aP as DefinedInfiniteQueryObserverResult, aG as DefinedQueryObserverResult, B as DistributiveOmit, $ as Enabled, an as EnsureInfiniteQueryDataOptions, am as EnsureQueryDataOptions, ao as FetchInfiniteQueryOptions, av as FetchNextPageOptions, aw as FetchPreviousPageOptions, al as FetchQueryOptions, ay as FetchStatus, a7 as GetNextPageParamFunction, a6 as GetPreviousPageParamFunction, W as InferDataFromTag, X as InferErrorFromTag, a8 as InfiniteData, aI as InfiniteQueryObserverBaseResult, aL as InfiniteQueryObserverLoadingErrorResult, aK as InfiniteQueryObserverLoadingResult, aj as InfiniteQueryObserverOptions, aJ as InfiniteQueryObserverPendingResult, aO as InfiniteQueryObserverPlaceholderResult, aM as InfiniteQueryObserverRefetchErrorResult, aQ as InfiniteQueryObserverResult, aN as InfiniteQueryObserverSuccessResult, ae as InfiniteQueryPageParamsOptions, a2 as InitialDataFunction, ad as InitialPageParam, at as InvalidateOptions, ar as InvalidateQueryFilters, aZ as MutateFunction, aY as MutateOptions, aV as MutationFunction, aR as MutationKey, aU as MutationMeta, a_ as MutationObserverBaseResult, b1 as MutationObserverErrorResult, a$ as MutationObserverIdleResult, b0 as MutationObserverLoadingResult, aX as MutationObserverOptions, b3 as MutationObserverResult, b2 as MutationObserverSuccessResult, aW as MutationOptions, aT as MutationScope, aS as MutationStatus, aa as NetworkMode, F as NoInfer, N as NonUndefinedGuard, b9 as NotifyEvent, b8 as NotifyEventType, ab as NotifyOnChangeProps, O as OmitKeyof, E as Override, a3 as PlaceholderDataFunction, a4 as QueriesPlaceholderDataFunction, b4 as QueryClientConfig, Y as QueryFunction, a1 as QueryFunctionContext, I as QueryKey, a5 as QueryKeyHashFunction, a9 as QueryMeta, az as QueryObserverBaseResult, aC as QueryObserverLoadingErrorResult, aB as QueryObserverLoadingResult, ag as QueryObserverOptions, aA as QueryObserverPendingResult, aF as QueryObserverPlaceholderResult, aD as QueryObserverRefetchErrorResult, aH as QueryObserverResult, aE as QueryObserverSuccessResult, ac as QueryOptions, a0 as QueryPersister, ax as QueryStatus, aq as RefetchOptions, as as RefetchQueryFilters, R as Register, au as ResetOptions, ap as ResultOptions, b7 as SetDataOptions, Z as StaleTime, _ as StaleTimeFunction, af as ThrowOnError, P as UnsetMarker, ah as WithRequired, K as dataTagErrorSymbol, J as dataTagSymbol, L as unsetMarker } from './hydration-Cr-4Kky1.js';
+export { T as AnyDataTag, b6 as CancelOptions, V as DataTag, G as DefaultError, b5 as DefaultOptions, ak as DefaultedInfiniteQueryObserverOptions, ai as DefaultedQueryObserverOptions, aP as DefinedInfiniteQueryObserverResult, aG as DefinedQueryObserverResult, B as DistributiveOmit, $ as Enabled, an as EnsureInfiniteQueryDataOptions, am as EnsureQueryDataOptions, ao as FetchInfiniteQueryOptions, av as FetchNextPageOptions, aw as FetchPreviousPageOptions, al as FetchQueryOptions, ay as FetchStatus, a7 as GetNextPageParamFunction, a6 as GetPreviousPageParamFunction, W as InferDataFromTag, X as InferErrorFromTag, a8 as InfiniteData, aI as InfiniteQueryObserverBaseResult, aL as InfiniteQueryObserverLoadingErrorResult, aK as InfiniteQueryObserverLoadingResult, aj as InfiniteQueryObserverOptions, aJ as InfiniteQueryObserverPendingResult, aO as InfiniteQueryObserverPlaceholderResult, aM as InfiniteQueryObserverRefetchErrorResult, aQ as InfiniteQueryObserverResult, aN as InfiniteQueryObserverSuccessResult, ae as InfiniteQueryPageParamsOptions, a2 as InitialDataFunction, ad as InitialPageParam, at as InvalidateOptions, ar as InvalidateQueryFilters, aZ as MutateFunction, aY as MutateOptions, aV as MutationFunction, aR as MutationKey, aU as MutationMeta, a_ as MutationObserverBaseResult, b1 as MutationObserverErrorResult, a$ as MutationObserverIdleResult, b0 as MutationObserverLoadingResult, aX as MutationObserverOptions, b3 as MutationObserverResult, b2 as MutationObserverSuccessResult, aW as MutationOptions, aT as MutationScope, aS as MutationStatus, aa as NetworkMode, F as NoInfer, N as NonUndefinedGuard, b9 as NotifyEvent, b8 as NotifyEventType, ab as NotifyOnChangeProps, O as OmitKeyof, E as Override, a3 as PlaceholderDataFunction, a4 as QueriesPlaceholderDataFunction, b4 as QueryClientConfig, Y as QueryFunction, a1 as QueryFunctionContext, I as QueryKey, a5 as QueryKeyHashFunction, a9 as QueryMeta, az as QueryObserverBaseResult, aC as QueryObserverLoadingErrorResult, aB as QueryObserverLoadingResult, ag as QueryObserverOptions, aA as QueryObserverPendingResult, aF as QueryObserverPlaceholderResult, aD as QueryObserverRefetchErrorResult, aH as QueryObserverResult, aE as QueryObserverSuccessResult, ac as QueryOptions, a0 as QueryPersister, ax as QueryStatus, aq as RefetchOptions, as as RefetchQueryFilters, R as Register, au as ResetOptions, ap as ResultOptions, b7 as SetDataOptions, Z as StaleTime, _ as StaleTimeFunction, af as ThrowOnError, P as UnsetMarker, ah as WithRequired, K as dataTagErrorSymbol, J as dataTagSymbol, L as unsetMarker } from './hydration-Dwnp99qT.js';
 import './removable.js';
 import './subscribable.js';
diff --git a/build/modern/types.js.map b/build/modern/types.js.map
index 6a9327d7a66aaac424a93a380583df5bb88d7e23..7ad872f00c6d0ef2af337f8602fd4a04b567cd09 100644
--- a/build/modern/types.js.map
+++ b/build/modern/types.js.map
@@ -1 +1 @@
-{"version":3,"sources":["../../src/types.ts"],"sourcesContent":["/* istanbul ignore file */\n\nimport type { QueryClient } from './queryClient'\nimport type { DehydrateOptions, HydrateOptions } from './hydration'\nimport type { MutationState } from './mutation'\nimport type { FetchDirection, Query, QueryBehavior } from './query'\nimport type { RetryDelayValue, RetryValue } from './retryer'\nimport type { QueryFilters, QueryTypeFilter, SkipToken } from './utils'\nimport type { QueryCache } from './queryCache'\nimport type { MutationCache } from './mutationCache'\n\nexport type NonUndefinedGuard<T> = T extends undefined ? never : T\n\nexport type DistributiveOmit<\n  TObject,\n  TKey extends keyof TObject,\n> = TObject extends any ? Omit<TObject, TKey> : never\n\nexport type OmitKeyof<\n  TObject,\n  TKey extends TStrictly extends 'safely'\n    ?\n        | keyof TObject\n        | (string & Record<never, never>)\n        | (number & Record<never, never>)\n        | (symbol & Record<never, never>)\n    : keyof TObject,\n  TStrictly extends 'strictly' | 'safely' = 'strictly',\n> = Omit<TObject, TKey>\n\nexport type Override<TTargetA, TTargetB> = {\n  [AKey in keyof TTargetA]: AKey extends keyof TTargetB\n    ? TTargetB[AKey]\n    : TTargetA[AKey]\n}\n\nexport type NoInfer<T> = [T][T extends any ? 0 : never]\n\nexport interface Register {\n  // defaultError: Error\n  // queryMeta: Record<string, unknown>\n  // mutationMeta: Record<string, unknown>\n  // queryKey: ReadonlyArray<unknown>\n  // mutationKey: ReadonlyArray<unknown>\n}\n\nexport type DefaultError = Register extends {\n  defaultError: infer TError\n}\n  ? TError\n  : Error\n\nexport type QueryKey = Register extends {\n  queryKey: infer TQueryKey\n}\n  ? TQueryKey extends ReadonlyArray<unknown>\n    ? TQueryKey\n    : TQueryKey extends Array<unknown>\n      ? TQueryKey\n      : ReadonlyArray<unknown>\n  : ReadonlyArray<unknown>\n\nexport const dataTagSymbol = Symbol('dataTagSymbol')\nexport type dataTagSymbol = typeof dataTagSymbol\nexport const dataTagErrorSymbol = Symbol('dataTagErrorSymbol')\nexport type dataTagErrorSymbol = typeof dataTagErrorSymbol\nexport const unsetMarker = Symbol('unsetMarker')\nexport type UnsetMarker = typeof unsetMarker\nexport type AnyDataTag = {\n  [dataTagSymbol]: any\n  [dataTagErrorSymbol]: any\n}\nexport type DataTag<\n  TType,\n  TValue,\n  TError = UnsetMarker,\n> = TType extends AnyDataTag\n  ? TType\n  : TType & {\n      [dataTagSymbol]: TValue\n      [dataTagErrorSymbol]: TError\n    }\n\nexport type InferDataFromTag<TQueryFnData, TTaggedQueryKey extends QueryKey> =\n  TTaggedQueryKey extends DataTag<unknown, infer TaggedValue, unknown>\n    ? TaggedValue\n    : TQueryFnData\n\nexport type InferErrorFromTag<TError, TTaggedQueryKey extends QueryKey> =\n  TTaggedQueryKey extends DataTag<unknown, unknown, infer TaggedError>\n    ? TaggedError extends UnsetMarker\n      ? TError\n      : TaggedError\n    : TError\n\nexport type QueryFunction<\n  T = unknown,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> = (context: QueryFunctionContext<TQueryKey, TPageParam>) => T | Promise<T>\n\nexport type StaleTime = number | 'static'\n\nexport type StaleTimeFunction<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> =\n  | StaleTime\n  | ((query: Query<TQueryFnData, TError, TData, TQueryKey>) => StaleTime)\n\nexport type Enabled<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> =\n  | boolean\n  | ((query: Query<TQueryFnData, TError, TData, TQueryKey>) => boolean)\n\nexport type QueryPersister<\n  T = unknown,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> = [TPageParam] extends [never]\n  ? (\n      queryFn: QueryFunction<T, TQueryKey, never>,\n      context: QueryFunctionContext<TQueryKey>,\n      query: Query,\n    ) => T | Promise<T>\n  : (\n      queryFn: QueryFunction<T, TQueryKey, TPageParam>,\n      context: QueryFunctionContext<TQueryKey>,\n      query: Query,\n    ) => T | Promise<T>\n\nexport type QueryFunctionContext<\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> = [TPageParam] extends [never]\n  ? {\n      client: QueryClient\n      queryKey: TQueryKey\n      signal: AbortSignal\n      meta: QueryMeta | undefined\n      pageParam?: unknown\n      /**\n       * @deprecated\n       * if you want access to the direction, you can add it to the pageParam\n       */\n      direction?: unknown\n    }\n  : {\n      client: QueryClient\n      queryKey: TQueryKey\n      signal: AbortSignal\n      pageParam: TPageParam\n      /**\n       * @deprecated\n       * if you want access to the direction, you can add it to the pageParam\n       */\n      direction: FetchDirection\n      meta: QueryMeta | undefined\n    }\n\nexport type InitialDataFunction<T> = () => T | undefined\n\ntype NonFunctionGuard<T> = T extends Function ? never : T\n\nexport type PlaceholderDataFunction<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = (\n  previousData: TQueryData | undefined,\n  previousQuery: Query<TQueryFnData, TError, TQueryData, TQueryKey> | undefined,\n) => TQueryData | undefined\n\nexport type QueriesPlaceholderDataFunction<TQueryData> = (\n  previousData: undefined,\n  previousQuery: undefined,\n) => TQueryData | undefined\n\nexport type QueryKeyHashFunction<TQueryKey extends QueryKey> = (\n  queryKey: TQueryKey,\n) => string\n\nexport type GetPreviousPageParamFunction<TPageParam, TQueryFnData = unknown> = (\n  firstPage: TQueryFnData,\n  allPages: Array<TQueryFnData>,\n  firstPageParam: TPageParam,\n  allPageParams: Array<TPageParam>,\n) => TPageParam | undefined | null\n\nexport type GetNextPageParamFunction<TPageParam, TQueryFnData = unknown> = (\n  lastPage: TQueryFnData,\n  allPages: Array<TQueryFnData>,\n  lastPageParam: TPageParam,\n  allPageParams: Array<TPageParam>,\n) => TPageParam | undefined | null\n\nexport interface InfiniteData<TData, TPageParam = unknown> {\n  pages: Array<TData>\n  pageParams: Array<TPageParam>\n}\n\nexport type QueryMeta = Register extends {\n  queryMeta: infer TQueryMeta\n}\n  ? TQueryMeta extends Record<string, unknown>\n    ? TQueryMeta\n    : Record<string, unknown>\n  : Record<string, unknown>\n\nexport type NetworkMode = 'online' | 'always' | 'offlineFirst'\n\nexport type NotifyOnChangeProps =\n  | Array<keyof InfiniteQueryObserverResult>\n  | 'all'\n  | undefined\n  | (() => Array<keyof InfiniteQueryObserverResult> | 'all' | undefined)\n\nexport interface QueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> {\n  /**\n   * If `false`, failed queries will not retry by default.\n   * If `true`, failed queries will retry infinitely., failureCount: num\n   * If set to an integer number, e.g. 3, failed queries will retry until the failed query count meets that number.\n   * If set to a function `(failureCount, error) => boolean` failed queries will retry until the function returns false.\n   */\n  retry?: RetryValue<TError>\n  retryDelay?: RetryDelayValue<TError>\n  networkMode?: NetworkMode\n  /**\n   * The time in milliseconds that unused/inactive cache data remains in memory.\n   * When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration.\n   * When different garbage collection times are specified, the longest one will be used.\n   * Setting it to `Infinity` will disable garbage collection.\n   */\n  gcTime?: number\n  queryFn?: QueryFunction<TQueryFnData, TQueryKey, TPageParam> | SkipToken\n  persister?: QueryPersister<\n    NoInfer<TQueryFnData>,\n    NoInfer<TQueryKey>,\n    NoInfer<TPageParam>\n  >\n  queryHash?: string\n  queryKey?: TQueryKey\n  queryKeyHashFn?: QueryKeyHashFunction<TQueryKey>\n  initialData?: TData | InitialDataFunction<TData>\n  initialDataUpdatedAt?: number | (() => number | undefined)\n  behavior?: QueryBehavior<TQueryFnData, TError, TData, TQueryKey>\n  /**\n   * Set this to `false` to disable structural sharing between query results.\n   * Set this to a function which accepts the old and new data and returns resolved data of the same type to implement custom structural sharing logic.\n   * Defaults to `true`.\n   */\n  structuralSharing?:\n    | boolean\n    | ((oldData: unknown | undefined, newData: unknown) => unknown)\n  _defaulted?: boolean\n  /**\n   * Additional payload to be stored on each query.\n   * Use this property to pass information that can be used in other places.\n   */\n  meta?: QueryMeta\n  /**\n   * Maximum number of pages to store in the data of an infinite query.\n   */\n  maxPages?: number\n}\n\nexport interface InitialPageParam<TPageParam = unknown> {\n  initialPageParam: TPageParam\n}\n\nexport interface InfiniteQueryPageParamsOptions<\n  TQueryFnData = unknown,\n  TPageParam = unknown,\n> extends InitialPageParam<TPageParam> {\n  /**\n   * This function can be set to automatically get the previous cursor for infinite queries.\n   * The result will also be used to determine the value of `hasPreviousPage`.\n   */\n  getPreviousPageParam?: GetPreviousPageParamFunction<TPageParam, TQueryFnData>\n  /**\n   * This function can be set to automatically get the next cursor for infinite queries.\n   * The result will also be used to determine the value of `hasNextPage`.\n   */\n  getNextPageParam: GetNextPageParamFunction<TPageParam, TQueryFnData>\n}\n\nexport type ThrowOnError<\n  TQueryFnData,\n  TError,\n  TQueryData,\n  TQueryKey extends QueryKey,\n> =\n  | boolean\n  | ((\n      error: TError,\n      query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n    ) => boolean)\n\nexport interface QueryObserverOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> extends WithRequired<\n    QueryOptions<TQueryFnData, TError, TQueryData, TQueryKey, TPageParam>,\n    'queryKey'\n  > {\n  /**\n   * Set this to `false` or a function that returns `false` to disable automatic refetching when the query mounts or changes query keys.\n   * To refetch the query, use the `refetch` method returned from the `useQuery` instance.\n   * Accepts a boolean or function that returns a boolean.\n   * Defaults to `true`.\n   */\n  enabled?: Enabled<TQueryFnData, TError, TQueryData, TQueryKey>\n  /**\n   * The time in milliseconds after data is considered stale.\n   * If set to `Infinity`, the data will never be considered stale.\n   * If set to a function, the function will be executed with the query to compute a `staleTime`.\n   * Defaults to `0`.\n   */\n  staleTime?: StaleTimeFunction<TQueryFnData, TError, TQueryData, TQueryKey>\n  /**\n   * If set to a number, the query will continuously refetch at this frequency in milliseconds.\n   * If set to a function, the function will be executed with the latest data and query to compute a frequency\n   * Defaults to `false`.\n   */\n  refetchInterval?:\n    | number\n    | false\n    | ((\n        query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n      ) => number | false | undefined)\n  /**\n   * If set to `true`, the query will continue to refetch while their tab/window is in the background.\n   * Defaults to `false`.\n   */\n  refetchIntervalInBackground?: boolean\n  /**\n   * If set to `true`, the query will refetch on window focus if the data is stale.\n   * If set to `false`, the query will not refetch on window focus.\n   * If set to `'always'`, the query will always refetch on window focus.\n   * If set to a function, the function will be executed with the latest data and query to compute the value.\n   * Defaults to `true`.\n   */\n  refetchOnWindowFocus?:\n    | boolean\n    | 'always'\n    | ((\n        query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n      ) => boolean | 'always')\n  /**\n   * If set to `true`, the query will refetch on reconnect if the data is stale.\n   * If set to `false`, the query will not refetch on reconnect.\n   * If set to `'always'`, the query will always refetch on reconnect.\n   * If set to a function, the function will be executed with the latest data and query to compute the value.\n   * Defaults to the value of `networkOnline` (`true`)\n   */\n  refetchOnReconnect?:\n    | boolean\n    | 'always'\n    | ((\n        query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n      ) => boolean | 'always')\n  /**\n   * If set to `true`, the query will refetch on mount if the data is stale.\n   * If set to `false`, will disable additional instances of a query to trigger background refetch.\n   * If set to `'always'`, the query will always refetch on mount.\n   * If set to a function, the function will be executed with the latest data and query to compute the value\n   * Defaults to `true`.\n   */\n  refetchOnMount?:\n    | boolean\n    | 'always'\n    | ((\n        query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n      ) => boolean | 'always')\n  /**\n   * If set to `false`, the query will not be retried on mount if it contains an error.\n   * Defaults to `true`.\n   */\n  retryOnMount?: boolean\n  /**\n   * If set, the component will only re-render if any of the listed properties change.\n   * When set to `['data', 'error']`, the component will only re-render when the `data` or `error` properties change.\n   * When set to `'all'`, the component will re-render whenever a query is updated.\n   * When set to a function, the function will be executed to compute the list of properties.\n   * By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.\n   */\n  notifyOnChangeProps?: NotifyOnChangeProps\n  /**\n   * Whether errors should be thrown instead of setting the `error` property.\n   * If set to `true` or `suspense` is `true`, all errors will be thrown to the error boundary.\n   * If set to `false` and `suspense` is `false`, errors are returned as state.\n   * If set to a function, it will be passed the error and the query, and it should return a boolean indicating whether to show the error in an error boundary (`true`) or return the error as state (`false`).\n   * Defaults to `false`.\n   */\n  throwOnError?: ThrowOnError<TQueryFnData, TError, TQueryData, TQueryKey>\n  /**\n   * This option can be used to transform or select a part of the data returned by the query function.\n   */\n  select?: (data: TQueryData) => TData\n  /**\n   * If set to `true`, the query will suspend when `status === 'pending'`\n   * and throw errors when `status === 'error'`.\n   * Defaults to `false`.\n   */\n  suspense?: boolean\n  /**\n   * If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `loading` data and no initialData has been provided.\n   */\n  placeholderData?:\n    | NonFunctionGuard<TQueryData>\n    | PlaceholderDataFunction<\n        NonFunctionGuard<TQueryData>,\n        TError,\n        NonFunctionGuard<TQueryData>,\n        TQueryKey\n      >\n\n  _optimisticResults?: 'optimistic' | 'isRestoring'\n\n  /**\n   * Enable prefetching during rendering\n   */\n  experimental_prefetchInRender?: boolean\n}\n\nexport type WithRequired<TTarget, TKey extends keyof TTarget> = TTarget & {\n  [_ in TKey]: {}\n}\n\nexport type DefaultedQueryObserverOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = WithRequired<\n  QueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  'throwOnError' | 'refetchOnReconnect' | 'queryHash'\n>\n\nexport interface InfiniteQueryObserverOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> extends QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      InfiniteData<TQueryFnData, TPageParam>,\n      TQueryKey,\n      TPageParam\n    >,\n    InfiniteQueryPageParamsOptions<TQueryFnData, TPageParam> {}\n\nexport type DefaultedInfiniteQueryObserverOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> = WithRequired<\n  InfiniteQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  >,\n  'throwOnError' | 'refetchOnReconnect' | 'queryHash'\n>\n\nexport interface FetchQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> extends WithRequired<\n    QueryOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>,\n    'queryKey'\n  > {\n  initialPageParam?: never\n  /**\n   * The time in milliseconds after data is considered stale.\n   * If the data is fresh it will be returned from the cache.\n   */\n  staleTime?: StaleTimeFunction<TQueryFnData, TError, TData, TQueryKey>\n}\n\nexport interface EnsureQueryDataOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> extends FetchQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  > {\n  revalidateIfStale?: boolean\n}\n\nexport type EnsureInfiniteQueryDataOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> = FetchInfiniteQueryOptions<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey,\n  TPageParam\n> & {\n  revalidateIfStale?: boolean\n}\n\ntype FetchInfiniteQueryPages<TQueryFnData = unknown, TPageParam = unknown> =\n  | { pages?: never }\n  | {\n      pages: number\n      getNextPageParam: GetNextPageParamFunction<TPageParam, TQueryFnData>\n    }\n\nexport type FetchInfiniteQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> = Omit<\n  FetchQueryOptions<\n    TQueryFnData,\n    TError,\n    InfiniteData<TData, TPageParam>,\n    TQueryKey,\n    TPageParam\n  >,\n  'initialPageParam'\n> &\n  InitialPageParam<TPageParam> &\n  FetchInfiniteQueryPages<TQueryFnData, TPageParam>\n\nexport interface ResultOptions {\n  throwOnError?: boolean\n}\n\nexport interface RefetchOptions extends ResultOptions {\n  /**\n   * If set to `true`, a currently running request will be cancelled before a new request is made\n   *\n   * If set to `false`, no refetch will be made if there is already a request running.\n   *\n   * Defaults to `true`.\n   */\n  cancelRefetch?: boolean\n}\n\nexport interface InvalidateQueryFilters<TQueryKey extends QueryKey = QueryKey>\n  extends QueryFilters<TQueryKey> {\n  refetchType?: QueryTypeFilter | 'none'\n}\n\nexport interface RefetchQueryFilters<TQueryKey extends QueryKey = QueryKey>\n  extends QueryFilters<TQueryKey> {}\n\nexport interface InvalidateOptions extends RefetchOptions {}\nexport interface ResetOptions extends RefetchOptions {}\n\nexport interface FetchNextPageOptions extends ResultOptions {\n  /**\n   * If set to `true`, calling `fetchNextPage` repeatedly will invoke `queryFn` every time,\n   * whether the previous invocation has resolved or not. Also, the result from previous invocations will be ignored.\n   *\n   * If set to `false`, calling `fetchNextPage` repeatedly won't have any effect until the first invocation has resolved.\n   *\n   * Defaults to `true`.\n   */\n  cancelRefetch?: boolean\n}\n\nexport interface FetchPreviousPageOptions extends ResultOptions {\n  /**\n   * If set to `true`, calling `fetchPreviousPage` repeatedly will invoke `queryFn` every time,\n   * whether the previous invocation has resolved or not. Also, the result from previous invocations will be ignored.\n   *\n   * If set to `false`, calling `fetchPreviousPage` repeatedly won't have any effect until the first invocation has resolved.\n   *\n   * Defaults to `true`.\n   */\n  cancelRefetch?: boolean\n}\n\nexport type QueryStatus = 'pending' | 'error' | 'success'\nexport type FetchStatus = 'fetching' | 'paused' | 'idle'\n\nexport interface QueryObserverBaseResult<\n  TData = unknown,\n  TError = DefaultError,\n> {\n  /**\n   * The last successfully resolved data for the query.\n   */\n  data: TData | undefined\n  /**\n   * The timestamp for when the query most recently returned the `status` as `\"success\"`.\n   */\n  dataUpdatedAt: number\n  /**\n   * The error object for the query, if an error was thrown.\n   * - Defaults to `null`.\n   */\n  error: TError | null\n  /**\n   * The timestamp for when the query most recently returned the `status` as `\"error\"`.\n   */\n  errorUpdatedAt: number\n  /**\n   * The failure count for the query.\n   * - Incremented every time the query fails.\n   * - Reset to `0` when the query succeeds.\n   */\n  failureCount: number\n  /**\n   * The failure reason for the query retry.\n   * - Reset to `null` when the query succeeds.\n   */\n  failureReason: TError | null\n  /**\n   * The sum of all errors.\n   */\n  errorUpdateCount: number\n  /**\n   * A derived boolean from the `status` variable, provided for convenience.\n   * - `true` if the query attempt resulted in an error.\n   */\n  isError: boolean\n  /**\n   * Will be `true` if the query has been fetched.\n   */\n  isFetched: boolean\n  /**\n   * Will be `true` if the query has been fetched after the component mounted.\n   * - This property can be used to not show any previously cached data.\n   */\n  isFetchedAfterMount: boolean\n  /**\n   * A derived boolean from the `fetchStatus` variable, provided for convenience.\n   * - `true` whenever the `queryFn` is executing, which includes initial `pending` as well as background refetch.\n   */\n  isFetching: boolean\n  /**\n   * Is `true` whenever the first fetch for a query is in-flight.\n   * - Is the same as `isFetching && isPending`.\n   */\n  isLoading: boolean\n  /**\n   * Will be `pending` if there's no cached data and no query attempt was finished yet.\n   */\n  isPending: boolean\n  /**\n   * Will be `true` if the query failed while fetching for the first time.\n   */\n  isLoadingError: boolean\n  /**\n   * @deprecated `isInitialLoading` is being deprecated in favor of `isLoading`\n   * and will be removed in the next major version.\n   */\n  isInitialLoading: boolean\n  /**\n   * A derived boolean from the `fetchStatus` variable, provided for convenience.\n   * - The query wanted to fetch, but has been `paused`.\n   */\n  isPaused: boolean\n  /**\n   * Will be `true` if the data shown is the placeholder data.\n   */\n  isPlaceholderData: boolean\n  /**\n   * Will be `true` if the query failed while refetching.\n   */\n  isRefetchError: boolean\n  /**\n   * Is `true` whenever a background refetch is in-flight, which _does not_ include initial `pending`.\n   * - Is the same as `isFetching && !isPending`.\n   */\n  isRefetching: boolean\n  /**\n   * Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.\n   */\n  isStale: boolean\n  /**\n   * A derived boolean from the `status` variable, provided for convenience.\n   * - `true` if the query has received a response with no errors and is ready to display its data.\n   */\n  isSuccess: boolean\n  /**\n   * A function to manually refetch the query.\n   */\n  refetch: (\n    options?: RefetchOptions,\n  ) => Promise<QueryObserverResult<TData, TError>>\n  /**\n   * The status of the query.\n   * - Will be:\n   *   - `pending` if there's no cached data and no query attempt was finished yet.\n   *   - `error` if the query attempt resulted in an error.\n   *   - `success` if the query has received a response with no errors and is ready to display its data.\n   */\n  status: QueryStatus\n  /**\n   * The fetch status of the query.\n   * - `fetching`: Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetch.\n   * - `paused`: The query wanted to fetch, but has been `paused`.\n   * - `idle`: The query is not fetching.\n   * - See [Network Mode](https://tanstack.com/query/latest/docs/framework/react/guides/network-mode) for more information.\n   */\n  fetchStatus: FetchStatus\n  /**\n   * A stable promise that will be resolved with the data of the query.\n   * Requires the `experimental_prefetchInRender` feature flag to be enabled.\n   * @example\n   *\n   * ### Enabling the feature flag\n   * ```ts\n   * const client = new QueryClient({\n   *   defaultOptions: {\n   *     queries: {\n   *       experimental_prefetchInRender: true,\n   *     },\n   *   },\n   * })\n   * ```\n   *\n   * ### Usage\n   * ```tsx\n   * import { useQuery } from '@tanstack/react-query'\n   * import React from 'react'\n   * import { fetchTodos, type Todo } from './api'\n   *\n   * function TodoList({ query }: { query: UseQueryResult<Todo[], Error> }) {\n   *   const data = React.use(query.promise)\n   *\n   *   return (\n   *     <ul>\n   *       {data.map(todo => (\n   *         <li key={todo.id}>{todo.title}</li>\n   *       ))}\n   *     </ul>\n   *   )\n   * }\n   *\n   * export function App() {\n   *   const query = useQuery({ queryKey: ['todos'], queryFn: fetchTodos })\n   *\n   *   return (\n   *     <>\n   *       <h1>Todos</h1>\n   *       <React.Suspense fallback={<div>Loading...</div>}>\n   *         <TodoList query={query} />\n   *       </React.Suspense>\n   *     </>\n   *   )\n   * }\n   * ```\n   */\n  promise: Promise<TData>\n}\n\nexport interface QueryObserverPendingResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: null\n  isError: false\n  isPending: true\n  isLoadingError: false\n  isRefetchError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'pending'\n}\n\nexport interface QueryObserverLoadingResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: null\n  isError: false\n  isPending: true\n  isLoading: true\n  isLoadingError: false\n  isRefetchError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'pending'\n}\n\nexport interface QueryObserverLoadingErrorResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: TError\n  isError: true\n  isPending: false\n  isLoading: false\n  isLoadingError: true\n  isRefetchError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'error'\n}\n\nexport interface QueryObserverRefetchErrorResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: TData\n  error: TError\n  isError: true\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: true\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'error'\n}\n\nexport interface QueryObserverSuccessResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: TData\n  error: null\n  isError: false\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: false\n  isSuccess: true\n  isPlaceholderData: false\n  status: 'success'\n}\n\nexport interface QueryObserverPlaceholderResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: TData\n  isError: false\n  error: null\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: false\n  isSuccess: true\n  isPlaceholderData: true\n  status: 'success'\n}\n\nexport type DefinedQueryObserverResult<\n  TData = unknown,\n  TError = DefaultError,\n> =\n  | QueryObserverRefetchErrorResult<TData, TError>\n  | QueryObserverSuccessResult<TData, TError>\n\nexport type QueryObserverResult<TData = unknown, TError = DefaultError> =\n  | DefinedQueryObserverResult<TData, TError>\n  | QueryObserverLoadingErrorResult<TData, TError>\n  | QueryObserverLoadingResult<TData, TError>\n  | QueryObserverPendingResult<TData, TError>\n  | QueryObserverPlaceholderResult<TData, TError>\n\nexport interface InfiniteQueryObserverBaseResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  /**\n   * This function allows you to fetch the next \"page\" of results.\n   */\n  fetchNextPage: (\n    options?: FetchNextPageOptions,\n  ) => Promise<InfiniteQueryObserverResult<TData, TError>>\n  /**\n   * This function allows you to fetch the previous \"page\" of results.\n   */\n  fetchPreviousPage: (\n    options?: FetchPreviousPageOptions,\n  ) => Promise<InfiniteQueryObserverResult<TData, TError>>\n  /**\n   * Will be `true` if there is a next page to be fetched (known via the `getNextPageParam` option).\n   */\n  hasNextPage: boolean\n  /**\n   * Will be `true` if there is a previous page to be fetched (known via the `getPreviousPageParam` option).\n   */\n  hasPreviousPage: boolean\n  /**\n   * Will be `true` if the query failed while fetching the next page.\n   */\n  isFetchNextPageError: boolean\n  /**\n   * Will be `true` while fetching the next page with `fetchNextPage`.\n   */\n  isFetchingNextPage: boolean\n  /**\n   * Will be `true` if the query failed while fetching the previous page.\n   */\n  isFetchPreviousPageError: boolean\n  /**\n   * Will be `true` while fetching the previous page with `fetchPreviousPage`.\n   */\n  isFetchingPreviousPage: boolean\n}\n\nexport interface InfiniteQueryObserverPendingResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: null\n  isError: false\n  isPending: true\n  isLoadingError: false\n  isRefetchError: false\n  isFetchNextPageError: false\n  isFetchPreviousPageError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'pending'\n}\n\nexport interface InfiniteQueryObserverLoadingResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: null\n  isError: false\n  isPending: true\n  isLoading: true\n  isLoadingError: false\n  isRefetchError: false\n  isFetchNextPageError: false\n  isFetchPreviousPageError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'pending'\n}\n\nexport interface InfiniteQueryObserverLoadingErrorResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: TError\n  isError: true\n  isPending: false\n  isLoading: false\n  isLoadingError: true\n  isRefetchError: false\n  isFetchNextPageError: false\n  isFetchPreviousPageError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'error'\n}\n\nexport interface InfiniteQueryObserverRefetchErrorResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: TData\n  error: TError\n  isError: true\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: true\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'error'\n}\n\nexport interface InfiniteQueryObserverSuccessResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: TData\n  error: null\n  isError: false\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: false\n  isFetchNextPageError: false\n  isFetchPreviousPageError: false\n  isSuccess: true\n  isPlaceholderData: false\n  status: 'success'\n}\n\nexport interface InfiniteQueryObserverPlaceholderResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: TData\n  isError: false\n  error: null\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: false\n  isSuccess: true\n  isPlaceholderData: true\n  isFetchNextPageError: false\n  isFetchPreviousPageError: false\n  status: 'success'\n}\n\nexport type DefinedInfiniteQueryObserverResult<\n  TData = unknown,\n  TError = DefaultError,\n> =\n  | InfiniteQueryObserverRefetchErrorResult<TData, TError>\n  | InfiniteQueryObserverSuccessResult<TData, TError>\n\nexport type InfiniteQueryObserverResult<\n  TData = unknown,\n  TError = DefaultError,\n> =\n  | DefinedInfiniteQueryObserverResult<TData, TError>\n  | InfiniteQueryObserverLoadingErrorResult<TData, TError>\n  | InfiniteQueryObserverLoadingResult<TData, TError>\n  | InfiniteQueryObserverPendingResult<TData, TError>\n  | InfiniteQueryObserverPlaceholderResult<TData, TError>\n\nexport type MutationKey = Register extends {\n  mutationKey: infer TMutationKey\n}\n  ? TMutationKey extends Array<unknown>\n    ? TMutationKey\n    : TMutationKey extends Array<unknown>\n      ? TMutationKey\n      : ReadonlyArray<unknown>\n  : ReadonlyArray<unknown>\n\nexport type MutationStatus = 'idle' | 'pending' | 'success' | 'error'\n\nexport type MutationScope = {\n  id: string\n}\n\nexport type MutationMeta = Register extends {\n  mutationMeta: infer TMutationMeta\n}\n  ? TMutationMeta extends Record<string, unknown>\n    ? TMutationMeta\n    : Record<string, unknown>\n  : Record<string, unknown>\n\nexport type MutationFunction<TData = unknown, TVariables = unknown> = (\n  variables: TVariables,\n) => Promise<TData>\n\nexport interface MutationOptions<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> {\n  mutationFn?: MutationFunction<TData, TVariables>\n  mutationKey?: MutationKey\n  onMutate?: (\n    variables: TVariables,\n  ) => Promise<TContext | undefined> | TContext | undefined\n  onSuccess?: (\n    data: TData,\n    variables: TVariables,\n    context: TContext,\n  ) => Promise<unknown> | unknown\n  onError?: (\n    error: TError,\n    variables: TVariables,\n    context: TContext | undefined,\n  ) => Promise<unknown> | unknown\n  onSettled?: (\n    data: TData | undefined,\n    error: TError | null,\n    variables: TVariables,\n    context: TContext | undefined,\n  ) => Promise<unknown> | unknown\n  retry?: RetryValue<TError>\n  retryDelay?: RetryDelayValue<TError>\n  networkMode?: NetworkMode\n  gcTime?: number\n  _defaulted?: boolean\n  meta?: MutationMeta\n  scope?: MutationScope\n}\n\nexport interface MutationObserverOptions<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationOptions<TData, TError, TVariables, TContext> {\n  throwOnError?: boolean | ((error: TError) => boolean)\n}\n\nexport interface MutateOptions<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> {\n  onSuccess?: (data: TData, variables: TVariables, context: TContext) => void\n  onError?: (\n    error: TError,\n    variables: TVariables,\n    context: TContext | undefined,\n  ) => void\n  onSettled?: (\n    data: TData | undefined,\n    error: TError | null,\n    variables: TVariables,\n    context: TContext | undefined,\n  ) => void\n}\n\nexport type MutateFunction<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> = (\n  variables: TVariables,\n  options?: MutateOptions<TData, TError, TVariables, TContext>,\n) => Promise<TData>\n\nexport interface MutationObserverBaseResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationState<TData, TError, TVariables, TContext> {\n  /**\n   * The last successfully resolved data for the mutation.\n   */\n  data: TData | undefined\n  /**\n   * The variables object passed to the `mutationFn`.\n   */\n  variables: TVariables | undefined\n  /**\n   * The error object for the mutation, if an error was encountered.\n   * - Defaults to `null`.\n   */\n  error: TError | null\n  /**\n   * A boolean variable derived from `status`.\n   * - `true` if the last mutation attempt resulted in an error.\n   */\n  isError: boolean\n  /**\n   * A boolean variable derived from `status`.\n   * - `true` if the mutation is in its initial state prior to executing.\n   */\n  isIdle: boolean\n  /**\n   * A boolean variable derived from `status`.\n   * - `true` if the mutation is currently executing.\n   */\n  isPending: boolean\n  /**\n   * A boolean variable derived from `status`.\n   * - `true` if the last mutation attempt was successful.\n   */\n  isSuccess: boolean\n  /**\n   * The status of the mutation.\n   * - Will be:\n   *   - `idle` initial status prior to the mutation function executing.\n   *   - `pending` if the mutation is currently executing.\n   *   - `error` if the last mutation attempt resulted in an error.\n   *   - `success` if the last mutation attempt was successful.\n   */\n  status: MutationStatus\n  /**\n   * The mutation function you can call with variables to trigger the mutation and optionally hooks on additional callback options.\n   * @param variables - The variables object to pass to the `mutationFn`.\n   * @param options.onSuccess - This function will fire when the mutation is successful and will be passed the mutation's result.\n   * @param options.onError - This function will fire if the mutation encounters an error and will be passed the error.\n   * @param options.onSettled - This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error.\n   * @remarks\n   * - If you make multiple requests, `onSuccess` will fire only after the latest call you've made.\n   * - All the callback functions (`onSuccess`, `onError`, `onSettled`) are void functions, and the returned value will be ignored.\n   */\n  mutate: MutateFunction<TData, TError, TVariables, TContext>\n  /**\n   * A function to clean the mutation internal state (i.e., it resets the mutation to its initial state).\n   */\n  reset: () => void\n}\n\nexport interface MutationObserverIdleResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationObserverBaseResult<TData, TError, TVariables, TContext> {\n  data: undefined\n  variables: undefined\n  error: null\n  isError: false\n  isIdle: true\n  isPending: false\n  isSuccess: false\n  status: 'idle'\n}\n\nexport interface MutationObserverLoadingResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationObserverBaseResult<TData, TError, TVariables, TContext> {\n  data: undefined\n  variables: TVariables\n  error: null\n  isError: false\n  isIdle: false\n  isPending: true\n  isSuccess: false\n  status: 'pending'\n}\n\nexport interface MutationObserverErrorResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationObserverBaseResult<TData, TError, TVariables, TContext> {\n  data: undefined\n  error: TError\n  variables: TVariables\n  isError: true\n  isIdle: false\n  isPending: false\n  isSuccess: false\n  status: 'error'\n}\n\nexport interface MutationObserverSuccessResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationObserverBaseResult<TData, TError, TVariables, TContext> {\n  data: TData\n  error: null\n  variables: TVariables\n  isError: false\n  isIdle: false\n  isPending: false\n  isSuccess: true\n  status: 'success'\n}\n\nexport type MutationObserverResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> =\n  | MutationObserverIdleResult<TData, TError, TVariables, TContext>\n  | MutationObserverLoadingResult<TData, TError, TVariables, TContext>\n  | MutationObserverErrorResult<TData, TError, TVariables, TContext>\n  | MutationObserverSuccessResult<TData, TError, TVariables, TContext>\n\nexport interface QueryClientConfig {\n  queryCache?: QueryCache\n  mutationCache?: MutationCache\n  defaultOptions?: DefaultOptions\n}\n\nexport interface DefaultOptions<TError = DefaultError> {\n  queries?: OmitKeyof<\n    QueryObserverOptions<unknown, TError>,\n    'suspense' | 'queryKey'\n  >\n  mutations?: MutationObserverOptions<unknown, TError, unknown, unknown>\n  hydrate?: HydrateOptions['defaultOptions']\n  dehydrate?: DehydrateOptions\n}\n\nexport interface CancelOptions {\n  revert?: boolean\n  silent?: boolean\n}\n\nexport interface SetDataOptions {\n  updatedAt?: number\n}\n\nexport type NotifyEventType =\n  | 'added'\n  | 'removed'\n  | 'updated'\n  | 'observerAdded'\n  | 'observerRemoved'\n  | 'observerResultsUpdated'\n  | 'observerOptionsUpdated'\n\nexport interface NotifyEvent {\n  type: NotifyEventType\n}\n"],"mappings":";AA8DO,IAAM,gBAAgB,OAAO,eAAe;AAE5C,IAAM,qBAAqB,OAAO,oBAAoB;AAEtD,IAAM,cAAc,OAAO,aAAa;","names":[]}
\ No newline at end of file
+{"version":3,"sources":["../../src/types.ts"],"sourcesContent":["/* istanbul ignore file */\n\nimport type { QueryClient } from './queryClient'\nimport type { DehydrateOptions, HydrateOptions } from './hydration'\nimport type { MutationState } from './mutation'\nimport type { FetchDirection, Query, QueryBehavior } from './query'\nimport type { RetryDelayValue, RetryValue } from './retryer'\nimport type { QueryFilters, QueryTypeFilter, SkipToken } from './utils'\nimport type { QueryCache } from './queryCache'\nimport type { MutationCache } from './mutationCache'\n\nexport type NonUndefinedGuard<T> = T extends undefined ? never : T\n\nexport type DistributiveOmit<\n  TObject,\n  TKey extends keyof TObject,\n> = TObject extends any ? Omit<TObject, TKey> : never\n\nexport type OmitKeyof<\n  TObject,\n  TKey extends TStrictly extends 'safely'\n    ?\n        | keyof TObject\n        | (string & Record<never, never>)\n        | (number & Record<never, never>)\n        | (symbol & Record<never, never>)\n    : keyof TObject,\n  TStrictly extends 'strictly' | 'safely' = 'strictly',\n> = Omit<TObject, TKey>\n\nexport type Override<TTargetA, TTargetB> = {\n  [AKey in keyof TTargetA]: AKey extends keyof TTargetB\n    ? TTargetB[AKey]\n    : TTargetA[AKey]\n}\n\nexport type NoInfer<T> = [T][T extends any ? 0 : never]\n\nexport interface Register {\n  // defaultError: Error\n  // queryMeta: Record<string, unknown>\n  // mutationMeta: Record<string, unknown>\n  // queryKey: ReadonlyArray<unknown>\n  // mutationKey: ReadonlyArray<unknown>\n}\n\nexport type DefaultError = Register extends {\n  defaultError: infer TError\n}\n  ? TError\n  : Error\n\nexport type QueryKey = Register extends {\n  queryKey: infer TQueryKey\n}\n  ? TQueryKey extends ReadonlyArray<unknown>\n    ? TQueryKey\n    : TQueryKey extends Array<unknown>\n      ? TQueryKey\n      : ReadonlyArray<unknown>\n  : ReadonlyArray<unknown>\n\nexport const dataTagSymbol = Symbol('dataTagSymbol')\nexport type dataTagSymbol = typeof dataTagSymbol\nexport const dataTagErrorSymbol = Symbol('dataTagErrorSymbol')\nexport type dataTagErrorSymbol = typeof dataTagErrorSymbol\nexport const unsetMarker = Symbol('unsetMarker')\nexport type UnsetMarker = typeof unsetMarker\nexport type AnyDataTag = {\n  [dataTagSymbol]: any\n  [dataTagErrorSymbol]: any\n}\nexport type DataTag<\n  TType,\n  TValue,\n  TError = UnsetMarker,\n> = TType extends AnyDataTag\n  ? TType\n  : TType & {\n      [dataTagSymbol]: TValue\n      [dataTagErrorSymbol]: TError\n    }\n\nexport type InferDataFromTag<TQueryFnData, TTaggedQueryKey extends QueryKey> =\n  TTaggedQueryKey extends DataTag<unknown, infer TaggedValue, unknown>\n    ? TaggedValue\n    : TQueryFnData\n\nexport type InferErrorFromTag<TError, TTaggedQueryKey extends QueryKey> =\n  TTaggedQueryKey extends DataTag<unknown, unknown, infer TaggedError>\n    ? TaggedError extends UnsetMarker\n      ? TError\n      : TaggedError\n    : TError\n\nexport type QueryFunction<\n  T = unknown,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> = (context: QueryFunctionContext<TQueryKey, TPageParam>) => T | Promise<T>\n\nexport type StaleTime = number | 'static'\n\nexport type StaleTimeFunction<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> =\n  | StaleTime\n  | ((query: Query<TQueryFnData, TError, TData, TQueryKey>) => StaleTime)\n\nexport type Enabled<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> =\n  | boolean\n  | ((query: Query<TQueryFnData, TError, TData, TQueryKey>) => boolean)\n\nexport type QueryPersister<\n  T = unknown,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> = [TPageParam] extends [never]\n  ? (\n      queryFn: QueryFunction<T, TQueryKey, never>,\n      context: QueryFunctionContext<TQueryKey>,\n      query: Query,\n    ) => T | Promise<T>\n  : (\n      queryFn: QueryFunction<T, TQueryKey, TPageParam>,\n      context: QueryFunctionContext<TQueryKey>,\n      query: Query,\n    ) => T | Promise<T>\n\nexport type QueryFunctionContext<\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> = [TPageParam] extends [never]\n  ? {\n      client: QueryClient\n      queryKey: TQueryKey\n      signal: AbortSignal\n      meta: QueryMeta | undefined\n      pageParam?: unknown\n      /**\n       * @deprecated\n       * if you want access to the direction, you can add it to the pageParam\n       */\n      direction?: unknown\n    }\n  : {\n      client: QueryClient\n      queryKey: TQueryKey\n      signal: AbortSignal\n      pageParam: TPageParam\n      /**\n       * @deprecated\n       * if you want access to the direction, you can add it to the pageParam\n       */\n      direction: FetchDirection\n      meta: QueryMeta | undefined\n    }\n\nexport type InitialDataFunction<T> = () => T | undefined\n\ntype NonFunctionGuard<T> = T extends Function ? never : T\n\nexport type PlaceholderDataFunction<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = (\n  previousData: TQueryData | undefined,\n  previousQuery: Query<TQueryFnData, TError, TQueryData, TQueryKey> | undefined,\n) => TQueryData | undefined\n\nexport type QueriesPlaceholderDataFunction<TQueryData> = (\n  previousData: undefined,\n  previousQuery: undefined,\n) => TQueryData | undefined\n\nexport type QueryKeyHashFunction<TQueryKey extends QueryKey> = (\n  queryKey: TQueryKey,\n) => string\n\nexport type GetPreviousPageParamFunction<TPageParam, TQueryFnData = unknown> = (\n  firstPage: TQueryFnData,\n  allPages: Array<TQueryFnData>,\n  firstPageParam: TPageParam,\n  allPageParams: Array<TPageParam>,\n) => TPageParam | undefined | null\n\nexport type GetNextPageParamFunction<TPageParam, TQueryFnData = unknown> = (\n  lastPage: TQueryFnData,\n  allPages: Array<TQueryFnData>,\n  lastPageParam: TPageParam,\n  allPageParams: Array<TPageParam>,\n) => TPageParam | undefined | null\n\nexport interface InfiniteData<TData, TPageParam = unknown> {\n  pages: Array<TData>\n  pageParams: Array<TPageParam>\n}\n\nexport type QueryMeta = Register extends {\n  queryMeta: infer TQueryMeta\n}\n  ? TQueryMeta extends Record<string, unknown>\n    ? TQueryMeta\n    : Record<string, unknown>\n  : Record<string, unknown>\n\nexport type NetworkMode = 'online' | 'always' | 'offlineFirst'\n\nexport type NotifyOnChangeProps =\n  | Array<keyof InfiniteQueryObserverResult>\n  | 'all'\n  | undefined\n  | (() => Array<keyof InfiniteQueryObserverResult> | 'all' | undefined)\n\nexport interface QueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> {\n  /**\n   * If `false`, failed queries will not retry by default.\n   * If `true`, failed queries will retry infinitely., failureCount: num\n   * If set to an integer number, e.g. 3, failed queries will retry until the failed query count meets that number.\n   * If set to a function `(failureCount, error) => boolean` failed queries will retry until the function returns false.\n   */\n  retry?: RetryValue<TError>\n  retryDelay?: RetryDelayValue<TError>\n  networkMode?: NetworkMode\n  /**\n   * The time in milliseconds that unused/inactive cache data remains in memory.\n   * When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration.\n   * When different garbage collection times are specified, the longest one will be used.\n   * Setting it to `Infinity` will disable garbage collection.\n   */\n  gcTime?: number\n  queryFn?: QueryFunction<TQueryFnData, TQueryKey, TPageParam> | SkipToken\n  persister?: QueryPersister<\n    NoInfer<TQueryFnData>,\n    NoInfer<TQueryKey>,\n    NoInfer<TPageParam>\n  >\n  queryHash?: string\n  queryKey?: TQueryKey\n  queryKeyHashFn?: QueryKeyHashFunction<TQueryKey>\n  initialData?: TData | InitialDataFunction<TData>\n  initialDataUpdatedAt?: number | (() => number | undefined)\n  behavior?: QueryBehavior<TQueryFnData, TError, TData, TQueryKey>\n  /**\n   * Set this to `false` to disable structural sharing between query results.\n   * Set this to a function which accepts the old and new data and returns resolved data of the same type to implement custom structural sharing logic.\n   * Defaults to `true`.\n   */\n  structuralSharing?:\n    | boolean\n    | ((oldData: unknown | undefined, newData: unknown) => unknown)\n  _defaulted?: boolean\n  /**\n   * Additional payload to be stored on each query.\n   * Use this property to pass information that can be used in other places.\n   */\n  meta?: QueryMeta\n  /**\n   * Maximum number of pages to store in the data of an infinite query.\n   */\n  maxPages?: number\n}\n\nexport interface InitialPageParam<TPageParam = unknown> {\n  initialPageParam: TPageParam\n}\n\nexport interface InfiniteQueryPageParamsOptions<\n  TQueryFnData = unknown,\n  TPageParam = unknown,\n> extends InitialPageParam<TPageParam> {\n  /**\n   * This function can be set to automatically get the previous cursor for infinite queries.\n   * The result will also be used to determine the value of `hasPreviousPage`.\n   */\n  getPreviousPageParam?: GetPreviousPageParamFunction<TPageParam, TQueryFnData>\n  /**\n   * This function can be set to automatically get the next cursor for infinite queries.\n   * The result will also be used to determine the value of `hasNextPage`.\n   */\n  getNextPageParam: GetNextPageParamFunction<TPageParam, TQueryFnData>\n}\n\nexport type ThrowOnError<\n  TQueryFnData,\n  TError,\n  TQueryData,\n  TQueryKey extends QueryKey,\n> =\n  | boolean\n  | ((\n      error: TError,\n      query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n    ) => boolean)\n\nexport interface QueryObserverOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> extends WithRequired<\n    QueryOptions<TQueryFnData, TError, TQueryData, TQueryKey, TPageParam>,\n    'queryKey'\n  > {\n  /**\n   * Set this to `false` or a function that returns `false` to disable automatic refetching when the query mounts or changes query keys.\n   * To refetch the query, use the `refetch` method returned from the `useQuery` instance.\n   * Accepts a boolean or function that returns a boolean.\n   * Defaults to `true`.\n   */\n  enabled?: Enabled<TQueryFnData, TError, TQueryData, TQueryKey>\n  /**\n   * The time in milliseconds after data is considered stale.\n   * If set to `Infinity`, the data will never be considered stale.\n   * If set to a function, the function will be executed with the query to compute a `staleTime`.\n   * Defaults to `0`.\n   */\n  staleTime?: StaleTimeFunction<TQueryFnData, TError, TQueryData, TQueryKey>\n  /**\n   * If set to a number, the query will continuously refetch at this frequency in milliseconds.\n   * If set to a function, the function will be executed with the latest data and query to compute a frequency\n   * Defaults to `false`.\n   */\n  refetchInterval?:\n    | number\n    | false\n    | ((\n        query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n      ) => number | false | undefined)\n  /**\n   * If set to `true`, the query will continue to refetch while their tab/window is in the background.\n   * Defaults to `false`.\n   */\n  refetchIntervalInBackground?: boolean\n  /**\n   * If set to `true`, the query will refetch on window focus if the data is stale.\n   * If set to `false`, the query will not refetch on window focus.\n   * If set to `'always'`, the query will always refetch on window focus.\n   * If set to a function, the function will be executed with the latest data and query to compute the value.\n   * Defaults to `true`.\n   */\n  refetchOnWindowFocus?:\n    | boolean\n    | 'always'\n    | ((\n        query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n      ) => boolean | 'always')\n  /**\n   * If set to `true`, the query will refetch on reconnect if the data is stale.\n   * If set to `false`, the query will not refetch on reconnect.\n   * If set to `'always'`, the query will always refetch on reconnect.\n   * If set to a function, the function will be executed with the latest data and query to compute the value.\n   * Defaults to the value of `networkOnline` (`true`)\n   */\n  refetchOnReconnect?:\n    | boolean\n    | 'always'\n    | ((\n        query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n      ) => boolean | 'always')\n  /**\n   * If set to `true`, the query will refetch on mount if the data is stale.\n   * If set to `false`, will disable additional instances of a query to trigger background refetch.\n   * If set to `'always'`, the query will always refetch on mount.\n   * If set to a function, the function will be executed with the latest data and query to compute the value\n   * Defaults to `true`.\n   */\n  refetchOnMount?:\n    | boolean\n    | 'always'\n    | ((\n        query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n      ) => boolean | 'always')\n  /**\n   * If set to `false`, the query will not be retried on mount if it contains an error.\n   * Defaults to `true`.\n   */\n  retryOnMount?: boolean\n  /**\n   * If set, the component will only re-render if any of the listed properties change.\n   * When set to `['data', 'error']`, the component will only re-render when the `data` or `error` properties change.\n   * When set to `'all'`, the component will re-render whenever a query is updated.\n   * When set to a function, the function will be executed to compute the list of properties.\n   * By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.\n   */\n  notifyOnChangeProps?: NotifyOnChangeProps\n  /**\n   * Whether errors should be thrown instead of setting the `error` property.\n   * If set to `true` or `suspense` is `true`, all errors will be thrown to the error boundary.\n   * If set to `false` and `suspense` is `false`, errors are returned as state.\n   * If set to a function, it will be passed the error and the query, and it should return a boolean indicating whether to show the error in an error boundary (`true`) or return the error as state (`false`).\n   * Defaults to `false`.\n   */\n  throwOnError?: ThrowOnError<TQueryFnData, TError, TQueryData, TQueryKey>\n  /**\n   * This option can be used to transform or select a part of the data returned by the query function.\n   */\n  select?: (data: TQueryData) => TData\n  /**\n   * If set to `true`, the query will suspend when `status === 'pending'`\n   * and throw errors when `status === 'error'`.\n   * Defaults to `false`.\n   */\n  suspense?: boolean\n  /**\n   * If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `loading` data and no initialData has been provided.\n   */\n  placeholderData?:\n    | NonFunctionGuard<TQueryData>\n    | PlaceholderDataFunction<\n        NonFunctionGuard<TQueryData>,\n        TError,\n        NonFunctionGuard<TQueryData>,\n        TQueryKey\n      >\n\n  _optimisticResults?: 'optimistic' | 'isRestoring'\n\n  /**\n   * Enable prefetching during rendering\n   */\n  experimental_prefetchInRender?: boolean\n}\n\nexport type WithRequired<TTarget, TKey extends keyof TTarget> = TTarget & {\n  [_ in TKey]: {}\n}\n\nexport type DefaultedQueryObserverOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = WithRequired<\n  QueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  'throwOnError' | 'refetchOnReconnect' | 'queryHash'\n>\n\nexport interface InfiniteQueryObserverOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> extends QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      InfiniteData<TQueryFnData, TPageParam>,\n      TQueryKey,\n      TPageParam\n    >,\n    InfiniteQueryPageParamsOptions<TQueryFnData, TPageParam> {}\n\nexport type DefaultedInfiniteQueryObserverOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> = WithRequired<\n  InfiniteQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  >,\n  'throwOnError' | 'refetchOnReconnect' | 'queryHash'\n>\n\nexport interface FetchQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> extends WithRequired<\n    QueryOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>,\n    'queryKey'\n  > {\n  initialPageParam?: never\n  /**\n   * The time in milliseconds after data is considered stale.\n   * If the data is fresh it will be returned from the cache.\n   */\n  staleTime?: StaleTimeFunction<TQueryFnData, TError, TData, TQueryKey>\n}\n\nexport interface EnsureQueryDataOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> extends FetchQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  > {\n  revalidateIfStale?: boolean\n}\n\nexport type EnsureInfiniteQueryDataOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> = FetchInfiniteQueryOptions<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey,\n  TPageParam\n> & {\n  revalidateIfStale?: boolean\n}\n\ntype FetchInfiniteQueryPages<TQueryFnData = unknown, TPageParam = unknown> =\n  | { pages?: never }\n  | {\n      pages: number\n      getNextPageParam: GetNextPageParamFunction<TPageParam, TQueryFnData>\n    }\n\nexport type FetchInfiniteQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> = Omit<\n  FetchQueryOptions<\n    TQueryFnData,\n    TError,\n    InfiniteData<TData, TPageParam>,\n    TQueryKey,\n    TPageParam\n  >,\n  'initialPageParam'\n> &\n  InitialPageParam<TPageParam> &\n  FetchInfiniteQueryPages<TQueryFnData, TPageParam>\n\nexport interface ResultOptions {\n  throwOnError?: boolean\n}\n\nexport interface RefetchOptions extends ResultOptions {\n  /**\n   * If set to `true`, a currently running request will be cancelled before a new request is made\n   *\n   * If set to `false`, no refetch will be made if there is already a request running.\n   *\n   * Defaults to `true`.\n   */\n  cancelRefetch?: boolean\n\n  updateMeta?: Record<string, unknown>\n}\n\nexport interface InvalidateQueryFilters<TQueryKey extends QueryKey = QueryKey>\n  extends QueryFilters<TQueryKey> {\n  refetchType?: QueryTypeFilter | 'none'\n}\n\nexport interface RefetchQueryFilters<TQueryKey extends QueryKey = QueryKey>\n  extends QueryFilters<TQueryKey> {}\n\nexport interface InvalidateOptions extends RefetchOptions {}\nexport interface ResetOptions extends RefetchOptions {}\n\nexport interface FetchNextPageOptions extends ResultOptions {\n  /**\n   * If set to `true`, calling `fetchNextPage` repeatedly will invoke `queryFn` every time,\n   * whether the previous invocation has resolved or not. Also, the result from previous invocations will be ignored.\n   *\n   * If set to `false`, calling `fetchNextPage` repeatedly won't have any effect until the first invocation has resolved.\n   *\n   * Defaults to `true`.\n   */\n  cancelRefetch?: boolean\n}\n\nexport interface FetchPreviousPageOptions extends ResultOptions {\n  /**\n   * If set to `true`, calling `fetchPreviousPage` repeatedly will invoke `queryFn` every time,\n   * whether the previous invocation has resolved or not. Also, the result from previous invocations will be ignored.\n   *\n   * If set to `false`, calling `fetchPreviousPage` repeatedly won't have any effect until the first invocation has resolved.\n   *\n   * Defaults to `true`.\n   */\n  cancelRefetch?: boolean\n}\n\nexport type QueryStatus = 'pending' | 'error' | 'success'\nexport type FetchStatus = 'fetching' | 'paused' | 'idle'\n\nexport interface QueryObserverBaseResult<\n  TData = unknown,\n  TError = DefaultError,\n> {\n  /**\n   * The last successfully resolved data for the query.\n   */\n  data: TData | undefined\n  /**\n   * The timestamp for when the query most recently returned the `status` as `\"success\"`.\n   */\n  dataUpdatedAt: number\n  /**\n   * The error object for the query, if an error was thrown.\n   * - Defaults to `null`.\n   */\n  error: TError | null\n  /**\n   * The timestamp for when the query most recently returned the `status` as `\"error\"`.\n   */\n  errorUpdatedAt: number\n  /**\n   * The failure count for the query.\n   * - Incremented every time the query fails.\n   * - Reset to `0` when the query succeeds.\n   */\n  failureCount: number\n  /**\n   * The failure reason for the query retry.\n   * - Reset to `null` when the query succeeds.\n   */\n  failureReason: TError | null\n  /**\n   * The sum of all errors.\n   */\n  errorUpdateCount: number\n  /**\n   * A derived boolean from the `status` variable, provided for convenience.\n   * - `true` if the query attempt resulted in an error.\n   */\n  isError: boolean\n  /**\n   * Will be `true` if the query has been fetched.\n   */\n  isFetched: boolean\n  /**\n   * Will be `true` if the query has been fetched after the component mounted.\n   * - This property can be used to not show any previously cached data.\n   */\n  isFetchedAfterMount: boolean\n  /**\n   * A derived boolean from the `fetchStatus` variable, provided for convenience.\n   * - `true` whenever the `queryFn` is executing, which includes initial `pending` as well as background refetch.\n   */\n  isFetching: boolean\n  /**\n   * Is `true` whenever the first fetch for a query is in-flight.\n   * - Is the same as `isFetching && isPending`.\n   */\n  isLoading: boolean\n  /**\n   * Will be `pending` if there's no cached data and no query attempt was finished yet.\n   */\n  isPending: boolean\n  /**\n   * Will be `true` if the query failed while fetching for the first time.\n   */\n  isLoadingError: boolean\n  /**\n   * @deprecated `isInitialLoading` is being deprecated in favor of `isLoading`\n   * and will be removed in the next major version.\n   */\n  isInitialLoading: boolean\n  /**\n   * A derived boolean from the `fetchStatus` variable, provided for convenience.\n   * - The query wanted to fetch, but has been `paused`.\n   */\n  isPaused: boolean\n  /**\n   * Will be `true` if the data shown is the placeholder data.\n   */\n  isPlaceholderData: boolean\n  /**\n   * Will be `true` if the query failed while refetching.\n   */\n  isRefetchError: boolean\n  /**\n   * Is `true` whenever a background refetch is in-flight, which _does not_ include initial `pending`.\n   * - Is the same as `isFetching && !isPending`.\n   */\n  isRefetching: boolean\n  /**\n   * Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.\n   */\n  isStale: boolean\n  /**\n   * A derived boolean from the `status` variable, provided for convenience.\n   * - `true` if the query has received a response with no errors and is ready to display its data.\n   */\n  isSuccess: boolean\n  /**\n   * A function to manually refetch the query.\n   */\n  refetch: (\n    options?: RefetchOptions,\n  ) => Promise<QueryObserverResult<TData, TError>>\n  /**\n   * The status of the query.\n   * - Will be:\n   *   - `pending` if there's no cached data and no query attempt was finished yet.\n   *   - `error` if the query attempt resulted in an error.\n   *   - `success` if the query has received a response with no errors and is ready to display its data.\n   */\n  status: QueryStatus\n  /**\n   * The fetch status of the query.\n   * - `fetching`: Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetch.\n   * - `paused`: The query wanted to fetch, but has been `paused`.\n   * - `idle`: The query is not fetching.\n   * - See [Network Mode](https://tanstack.com/query/latest/docs/framework/react/guides/network-mode) for more information.\n   */\n  fetchStatus: FetchStatus\n  /**\n   * A stable promise that will be resolved with the data of the query.\n   * Requires the `experimental_prefetchInRender` feature flag to be enabled.\n   * @example\n   *\n   * ### Enabling the feature flag\n   * ```ts\n   * const client = new QueryClient({\n   *   defaultOptions: {\n   *     queries: {\n   *       experimental_prefetchInRender: true,\n   *     },\n   *   },\n   * })\n   * ```\n   *\n   * ### Usage\n   * ```tsx\n   * import { useQuery } from '@tanstack/react-query'\n   * import React from 'react'\n   * import { fetchTodos, type Todo } from './api'\n   *\n   * function TodoList({ query }: { query: UseQueryResult<Todo[], Error> }) {\n   *   const data = React.use(query.promise)\n   *\n   *   return (\n   *     <ul>\n   *       {data.map(todo => (\n   *         <li key={todo.id}>{todo.title}</li>\n   *       ))}\n   *     </ul>\n   *   )\n   * }\n   *\n   * export function App() {\n   *   const query = useQuery({ queryKey: ['todos'], queryFn: fetchTodos })\n   *\n   *   return (\n   *     <>\n   *       <h1>Todos</h1>\n   *       <React.Suspense fallback={<div>Loading...</div>}>\n   *         <TodoList query={query} />\n   *       </React.Suspense>\n   *     </>\n   *   )\n   * }\n   * ```\n   */\n  promise: Promise<TData>\n}\n\nexport interface QueryObserverPendingResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: null\n  isError: false\n  isPending: true\n  isLoadingError: false\n  isRefetchError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'pending'\n}\n\nexport interface QueryObserverLoadingResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: null\n  isError: false\n  isPending: true\n  isLoading: true\n  isLoadingError: false\n  isRefetchError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'pending'\n}\n\nexport interface QueryObserverLoadingErrorResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: TError\n  isError: true\n  isPending: false\n  isLoading: false\n  isLoadingError: true\n  isRefetchError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'error'\n}\n\nexport interface QueryObserverRefetchErrorResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: TData\n  error: TError\n  isError: true\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: true\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'error'\n}\n\nexport interface QueryObserverSuccessResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: TData\n  error: null\n  isError: false\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: false\n  isSuccess: true\n  isPlaceholderData: false\n  status: 'success'\n}\n\nexport interface QueryObserverPlaceholderResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: TData\n  isError: false\n  error: null\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: false\n  isSuccess: true\n  isPlaceholderData: true\n  status: 'success'\n}\n\nexport type DefinedQueryObserverResult<\n  TData = unknown,\n  TError = DefaultError,\n> =\n  | QueryObserverRefetchErrorResult<TData, TError>\n  | QueryObserverSuccessResult<TData, TError>\n\nexport type QueryObserverResult<TData = unknown, TError = DefaultError> =\n  | DefinedQueryObserverResult<TData, TError>\n  | QueryObserverLoadingErrorResult<TData, TError>\n  | QueryObserverLoadingResult<TData, TError>\n  | QueryObserverPendingResult<TData, TError>\n  | QueryObserverPlaceholderResult<TData, TError>\n\nexport interface InfiniteQueryObserverBaseResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  /**\n   * This function allows you to fetch the next \"page\" of results.\n   */\n  fetchNextPage: (\n    options?: FetchNextPageOptions,\n  ) => Promise<InfiniteQueryObserverResult<TData, TError>>\n  /**\n   * This function allows you to fetch the previous \"page\" of results.\n   */\n  fetchPreviousPage: (\n    options?: FetchPreviousPageOptions,\n  ) => Promise<InfiniteQueryObserverResult<TData, TError>>\n  /**\n   * Will be `true` if there is a next page to be fetched (known via the `getNextPageParam` option).\n   */\n  hasNextPage: boolean\n  /**\n   * Will be `true` if there is a previous page to be fetched (known via the `getPreviousPageParam` option).\n   */\n  hasPreviousPage: boolean\n  /**\n   * Will be `true` if the query failed while fetching the next page.\n   */\n  isFetchNextPageError: boolean\n  /**\n   * Will be `true` while fetching the next page with `fetchNextPage`.\n   */\n  isFetchingNextPage: boolean\n  /**\n   * Will be `true` if the query failed while fetching the previous page.\n   */\n  isFetchPreviousPageError: boolean\n  /**\n   * Will be `true` while fetching the previous page with `fetchPreviousPage`.\n   */\n  isFetchingPreviousPage: boolean\n}\n\nexport interface InfiniteQueryObserverPendingResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: null\n  isError: false\n  isPending: true\n  isLoadingError: false\n  isRefetchError: false\n  isFetchNextPageError: false\n  isFetchPreviousPageError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'pending'\n}\n\nexport interface InfiniteQueryObserverLoadingResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: null\n  isError: false\n  isPending: true\n  isLoading: true\n  isLoadingError: false\n  isRefetchError: false\n  isFetchNextPageError: false\n  isFetchPreviousPageError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'pending'\n}\n\nexport interface InfiniteQueryObserverLoadingErrorResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: TError\n  isError: true\n  isPending: false\n  isLoading: false\n  isLoadingError: true\n  isRefetchError: false\n  isFetchNextPageError: false\n  isFetchPreviousPageError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'error'\n}\n\nexport interface InfiniteQueryObserverRefetchErrorResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: TData\n  error: TError\n  isError: true\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: true\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'error'\n}\n\nexport interface InfiniteQueryObserverSuccessResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: TData\n  error: null\n  isError: false\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: false\n  isFetchNextPageError: false\n  isFetchPreviousPageError: false\n  isSuccess: true\n  isPlaceholderData: false\n  status: 'success'\n}\n\nexport interface InfiniteQueryObserverPlaceholderResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: TData\n  isError: false\n  error: null\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: false\n  isSuccess: true\n  isPlaceholderData: true\n  isFetchNextPageError: false\n  isFetchPreviousPageError: false\n  status: 'success'\n}\n\nexport type DefinedInfiniteQueryObserverResult<\n  TData = unknown,\n  TError = DefaultError,\n> =\n  | InfiniteQueryObserverRefetchErrorResult<TData, TError>\n  | InfiniteQueryObserverSuccessResult<TData, TError>\n\nexport type InfiniteQueryObserverResult<\n  TData = unknown,\n  TError = DefaultError,\n> =\n  | DefinedInfiniteQueryObserverResult<TData, TError>\n  | InfiniteQueryObserverLoadingErrorResult<TData, TError>\n  | InfiniteQueryObserverLoadingResult<TData, TError>\n  | InfiniteQueryObserverPendingResult<TData, TError>\n  | InfiniteQueryObserverPlaceholderResult<TData, TError>\n\nexport type MutationKey = Register extends {\n  mutationKey: infer TMutationKey\n}\n  ? TMutationKey extends Array<unknown>\n    ? TMutationKey\n    : TMutationKey extends Array<unknown>\n      ? TMutationKey\n      : ReadonlyArray<unknown>\n  : ReadonlyArray<unknown>\n\nexport type MutationStatus = 'idle' | 'pending' | 'success' | 'error'\n\nexport type MutationScope = {\n  id: string\n}\n\nexport type MutationMeta = Register extends {\n  mutationMeta: infer TMutationMeta\n}\n  ? TMutationMeta extends Record<string, unknown>\n    ? TMutationMeta\n    : Record<string, unknown>\n  : Record<string, unknown>\n\nexport type MutationFunction<TData = unknown, TVariables = unknown> = (\n  variables: TVariables,\n) => Promise<TData>\n\nexport interface MutationOptions<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> {\n  mutationFn?: MutationFunction<TData, TVariables>\n  mutationKey?: MutationKey\n  onMutate?: (\n    variables: TVariables,\n  ) => Promise<TContext | undefined> | TContext | undefined\n  onSuccess?: (\n    data: TData,\n    variables: TVariables,\n    context: TContext,\n  ) => Promise<unknown> | unknown\n  onError?: (\n    error: TError,\n    variables: TVariables,\n    context: TContext | undefined,\n  ) => Promise<unknown> | unknown\n  onSettled?: (\n    data: TData | undefined,\n    error: TError | null,\n    variables: TVariables,\n    context: TContext | undefined,\n  ) => Promise<unknown> | unknown\n  retry?: RetryValue<TError>\n  retryDelay?: RetryDelayValue<TError>\n  networkMode?: NetworkMode\n  gcTime?: number\n  _defaulted?: boolean\n  meta?: MutationMeta\n  scope?: MutationScope\n}\n\nexport interface MutationObserverOptions<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationOptions<TData, TError, TVariables, TContext> {\n  throwOnError?: boolean | ((error: TError) => boolean)\n}\n\nexport interface MutateOptions<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> {\n  onSuccess?: (data: TData, variables: TVariables, context: TContext) => void\n  onError?: (\n    error: TError,\n    variables: TVariables,\n    context: TContext | undefined,\n  ) => void\n  onSettled?: (\n    data: TData | undefined,\n    error: TError | null,\n    variables: TVariables,\n    context: TContext | undefined,\n  ) => void\n}\n\nexport type MutateFunction<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> = (\n  variables: TVariables,\n  options?: MutateOptions<TData, TError, TVariables, TContext>,\n) => Promise<TData>\n\nexport interface MutationObserverBaseResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationState<TData, TError, TVariables, TContext> {\n  /**\n   * The last successfully resolved data for the mutation.\n   */\n  data: TData | undefined\n  /**\n   * The variables object passed to the `mutationFn`.\n   */\n  variables: TVariables | undefined\n  /**\n   * The error object for the mutation, if an error was encountered.\n   * - Defaults to `null`.\n   */\n  error: TError | null\n  /**\n   * A boolean variable derived from `status`.\n   * - `true` if the last mutation attempt resulted in an error.\n   */\n  isError: boolean\n  /**\n   * A boolean variable derived from `status`.\n   * - `true` if the mutation is in its initial state prior to executing.\n   */\n  isIdle: boolean\n  /**\n   * A boolean variable derived from `status`.\n   * - `true` if the mutation is currently executing.\n   */\n  isPending: boolean\n  /**\n   * A boolean variable derived from `status`.\n   * - `true` if the last mutation attempt was successful.\n   */\n  isSuccess: boolean\n  /**\n   * The status of the mutation.\n   * - Will be:\n   *   - `idle` initial status prior to the mutation function executing.\n   *   - `pending` if the mutation is currently executing.\n   *   - `error` if the last mutation attempt resulted in an error.\n   *   - `success` if the last mutation attempt was successful.\n   */\n  status: MutationStatus\n  /**\n   * The mutation function you can call with variables to trigger the mutation and optionally hooks on additional callback options.\n   * @param variables - The variables object to pass to the `mutationFn`.\n   * @param options.onSuccess - This function will fire when the mutation is successful and will be passed the mutation's result.\n   * @param options.onError - This function will fire if the mutation encounters an error and will be passed the error.\n   * @param options.onSettled - This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error.\n   * @remarks\n   * - If you make multiple requests, `onSuccess` will fire only after the latest call you've made.\n   * - All the callback functions (`onSuccess`, `onError`, `onSettled`) are void functions, and the returned value will be ignored.\n   */\n  mutate: MutateFunction<TData, TError, TVariables, TContext>\n  /**\n   * A function to clean the mutation internal state (i.e., it resets the mutation to its initial state).\n   */\n  reset: () => void\n}\n\nexport interface MutationObserverIdleResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationObserverBaseResult<TData, TError, TVariables, TContext> {\n  data: undefined\n  variables: undefined\n  error: null\n  isError: false\n  isIdle: true\n  isPending: false\n  isSuccess: false\n  status: 'idle'\n}\n\nexport interface MutationObserverLoadingResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationObserverBaseResult<TData, TError, TVariables, TContext> {\n  data: undefined\n  variables: TVariables\n  error: null\n  isError: false\n  isIdle: false\n  isPending: true\n  isSuccess: false\n  status: 'pending'\n}\n\nexport interface MutationObserverErrorResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationObserverBaseResult<TData, TError, TVariables, TContext> {\n  data: undefined\n  error: TError\n  variables: TVariables\n  isError: true\n  isIdle: false\n  isPending: false\n  isSuccess: false\n  status: 'error'\n}\n\nexport interface MutationObserverSuccessResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationObserverBaseResult<TData, TError, TVariables, TContext> {\n  data: TData\n  error: null\n  variables: TVariables\n  isError: false\n  isIdle: false\n  isPending: false\n  isSuccess: true\n  status: 'success'\n}\n\nexport type MutationObserverResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> =\n  | MutationObserverIdleResult<TData, TError, TVariables, TContext>\n  | MutationObserverLoadingResult<TData, TError, TVariables, TContext>\n  | MutationObserverErrorResult<TData, TError, TVariables, TContext>\n  | MutationObserverSuccessResult<TData, TError, TVariables, TContext>\n\nexport interface QueryClientConfig {\n  queryCache?: QueryCache\n  mutationCache?: MutationCache\n  defaultOptions?: DefaultOptions\n}\n\nexport interface DefaultOptions<TError = DefaultError> {\n  queries?: OmitKeyof<\n    QueryObserverOptions<unknown, TError>,\n    'suspense' | 'queryKey'\n  >\n  mutations?: MutationObserverOptions<unknown, TError, unknown, unknown>\n  hydrate?: HydrateOptions['defaultOptions']\n  dehydrate?: DehydrateOptions\n}\n\nexport interface CancelOptions {\n  revert?: boolean\n  silent?: boolean\n}\n\nexport interface SetDataOptions {\n  updatedAt?: number\n}\n\nexport type NotifyEventType =\n  | 'added'\n  | 'removed'\n  | 'updated'\n  | 'observerAdded'\n  | 'observerRemoved'\n  | 'observerResultsUpdated'\n  | 'observerOptionsUpdated'\n\nexport interface NotifyEvent {\n  type: NotifyEventType\n}\n"],"mappings":";AA8DO,IAAM,gBAAgB,OAAO,eAAe;AAE5C,IAAM,qBAAqB,OAAO,oBAAoB;AAEtD,IAAM,cAAc,OAAO,aAAa;","names":[]}
\ No newline at end of file
diff --git a/build/modern/utils.d.cts b/build/modern/utils.d.cts
index 1bfe40c0dec0c5e62e65e6a30fe6b90f9cd507ce..b16935f846f45d0e5bd2f65980156e3745c29bd4 100644
--- a/build/modern/utils.d.cts
+++ b/build/modern/utils.d.cts
@@ -1,3 +1,3 @@
-export { j as MutationFilters, l as QueryFilters, bk as QueryTypeFilter, S as SkipToken, U as Updater, bw as addToEnd, bx as addToStart, by as ensureQueryFn, bl as functionalUpdate, h as hashKey, bq as hashQueryKeyByOptions, bs as isPlainArray, bt as isPlainObject, i as isServer, bm as isValidTimeout, k as keepPreviousData, f as matchMutation, m as matchQuery, n as noop, p as partialMatchKey, bv as replaceData, r as replaceEqualDeep, bp as resolveEnabled, bo as resolveStaleTime, br as shallowEqualObjects, g as shouldThrowError, s as skipToken, bu as sleep, bn as timeUntilStale } from './hydration-CdBkFt9i.cjs';
+export { j as MutationFilters, l as QueryFilters, bk as QueryTypeFilter, S as SkipToken, U as Updater, bw as addToEnd, bx as addToStart, by as ensureQueryFn, bl as functionalUpdate, h as hashKey, bq as hashQueryKeyByOptions, bs as isPlainArray, bt as isPlainObject, i as isServer, bm as isValidTimeout, k as keepPreviousData, f as matchMutation, m as matchQuery, n as noop, p as partialMatchKey, bv as replaceData, r as replaceEqualDeep, bp as resolveEnabled, bo as resolveStaleTime, br as shallowEqualObjects, g as shouldThrowError, s as skipToken, bu as sleep, bn as timeUntilStale } from './hydration-Dv1t2VQO.cjs';
 import './removable.cjs';
 import './subscribable.cjs';
diff --git a/build/modern/utils.d.ts b/build/modern/utils.d.ts
index fe8b4dabe3b72015f40bb75f92fa7fa33cfaa1ff..76e4c1ad9e2da5e7cfe6eafe1cb5928195d588a8 100644
--- a/build/modern/utils.d.ts
+++ b/build/modern/utils.d.ts
@@ -1,3 +1,3 @@
-export { j as MutationFilters, l as QueryFilters, bk as QueryTypeFilter, S as SkipToken, U as Updater, bw as addToEnd, bx as addToStart, by as ensureQueryFn, bl as functionalUpdate, h as hashKey, bq as hashQueryKeyByOptions, bs as isPlainArray, bt as isPlainObject, i as isServer, bm as isValidTimeout, k as keepPreviousData, f as matchMutation, m as matchQuery, n as noop, p as partialMatchKey, bv as replaceData, r as replaceEqualDeep, bp as resolveEnabled, bo as resolveStaleTime, br as shallowEqualObjects, g as shouldThrowError, s as skipToken, bu as sleep, bn as timeUntilStale } from './hydration-Cr-4Kky1.js';
+export { j as MutationFilters, l as QueryFilters, bk as QueryTypeFilter, S as SkipToken, U as Updater, bw as addToEnd, bx as addToStart, by as ensureQueryFn, bl as functionalUpdate, h as hashKey, bq as hashQueryKeyByOptions, bs as isPlainArray, bt as isPlainObject, i as isServer, bm as isValidTimeout, k as keepPreviousData, f as matchMutation, m as matchQuery, n as noop, p as partialMatchKey, bv as replaceData, r as replaceEqualDeep, bp as resolveEnabled, bo as resolveStaleTime, br as shallowEqualObjects, g as shouldThrowError, s as skipToken, bu as sleep, bn as timeUntilStale } from './hydration-Dwnp99qT.js';
 import './removable.js';
 import './subscribable.js';
diff --git a/src/query.ts b/src/query.ts
index 09875646946d29bcbeabf93d9fa79ca055953d87..8aba2f07cc440956c52ab6d9233960b8f6f5d5f2 100644
--- a/src/query.ts
+++ b/src/query.ts
@@ -97,6 +97,7 @@ export interface FetchOptions<TData = unknown> {
   cancelRefetch?: boolean
   meta?: FetchMeta
   initialPromise?: Promise<TData>
+  updateMeta?: Record<string, unknown>
 }
 
 interface FailedAction<TError> {
@@ -437,7 +438,7 @@ export class Query<
         > = {
           client: this.#client,
           queryKey: this.queryKey,
-          meta: this.meta,
+          meta: fetchOptions?.updateMeta ? {...this.meta, ...fetchOptions.updateMeta } : this.meta,
         }
         addSignalProperty(queryFnContext)
         return queryFnContext as QueryFunctionContext<TQueryKey>
diff --git a/src/types.ts b/src/types.ts
index e4ed081539f06493ce925bec7642af416440e8db..6b532c44a5524dc7be14d67a848fd165eb56785e 100644
--- a/src/types.ts
+++ b/src/types.ts
@@ -577,6 +577,8 @@ export interface RefetchOptions extends ResultOptions {
    * Defaults to `true`.
    */
   cancelRefetch?: boolean
+
+  updateMeta?: Record<string, unknown>
 }
 
 export interface InvalidateQueryFilters<TQueryKey extends QueryKey = QueryKey>
