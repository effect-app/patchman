diff --git a/lib/typescript.js b/lib/typescript.js
index 2643aa12aa6497ca0b90ecd99b202f37ea0e6330..1c602d55fd8a6ca155928bad28a9377d109896f5 100644
--- a/lib/typescript.js
+++ b/lib/typescript.js
@@ -159172,10 +159172,129 @@ function getFixInfos(context, errorCode, pos, useAutoImportProvider) {
   const packageJsonImportFilter = createPackageJsonImportFilter(context.sourceFile, context.preferences, context.host);
   return info && sortFixInfo(info, context.sourceFile, context.program, packageJsonImportFilter, context.host, context.preferences);
 }
+const autoImportOrderModule = (() => {
+
+  const fs = require("fs");
+  const path = require("path");
+
+  let pluginConfig = null;
+  let moveUpRegexes = [];
+  let moveDownRegexes = [];
+  const overrides = new Map()
+
+  function getProjectRoot(startDir = __dirname) {
+    let currentDir = startDir;
+    while (!fs.existsSync(path.join(currentDir, "package.json"))) {
+      const parentDir = path.dirname(currentDir);
+      if (parentDir === currentDir) {
+        return null; // Unable to find the project root (package.json not found)
+      }
+      currentDir = parentDir;
+    }
+    return currentDir.split(path.sep + "node_modules")[0];
+  }
+
+  function log(message, overwrite = false) {
+    const _message = (typeof message === "string" ? message : JSON.stringify(message, null, 2)) + "\n"
+    if(overwrite) {
+      fs.writeFileSync(path.resolve(__dirname, './import-order-plugin.log'), _message, 'utf8');
+    } else {
+      fs.appendFileSync(
+        path.resolve(__dirname, './import-order-plugin.log'),
+        _message,
+        'utf8'
+      );
+    }
+  }
+
+  function compare(a, b) {
+    if(pluginConfig) {
+
+      // always tries to match with regexes that have higher prio first (moveUpRegexes > moveDownRegexes; moveXRegexes[n+1] > moveXRegexes[n])
+      // moveDownRegexes.length is the default value for when no regex matches the moduleSpecifier
+      // no match has higher prio over moveDownRegexes match
+
+      const def = moveDownRegexes.length
+      let aSort = moveUpRegexes.findLastIndex((re) => re.test(a.moduleSpecifier)) + def + 1
+      let bSort = moveUpRegexes.findLastIndex((re) => re.test(b.moduleSpecifier)) + def + 1
+
+      aSort = aSort === def ? moveDownRegexes.findLastIndex((re) => re.test(a.moduleSpecifier)) : aSort
+      bSort = bSort === def ? moveDownRegexes.findLastIndex((re) => re.test(b.moduleSpecifier)) : bSort
+
+      aSort = ~aSort ? aSort : def
+      bSort = ~bSort ? bSort : def
+
+      return bSort - aSort;
+    } else {
+      return 0
+    }
+  }
+
+  function getOverridenModule(symbol) {
+    return overrides.get(symbol)
+  }
+
+  const pr = getProjectRoot();
+
+  if(!pr) {
+    log("Cannot read import-order-plugin root");
+  } else {
+    log("starting import plugin with root " + getProjectRoot(), true)
+
+    try {
+      const filePath = path.resolve(pr, 'tsconfig.plugins.json');
+      const content = fs.readFileSync(filePath, 'utf8');
+      pluginConfig = JSON.parse(content).compilerOptions?.plugins?.find(p => p.name === "ts-plugin-sort-import-suggestions");
+
+      if(pluginConfig) {
+        // reverse arrays so that the position is the right prio (higher index means higher prio)
+        moveUpRegexes = pluginConfig.moveUpPatterns.map((_) => new RegExp(_)).toReversed();
+        moveDownRegexes = pluginConfig.moveDownPatterns.map((_) => new RegExp(_)).toReversed();
+
+        if(pluginConfig.overrides) {
+          Object.entries(pluginConfig.overrides).forEach(([module, symbols]) => {
+            for (const symbol of symbols) {
+              overrides.set(symbol, module)
+            }
+          })
+        }
+      }
+
+      log("Successfully read import-order-plugin configuration:");
+      log(pluginConfig)
+
+    } catch(e) {
+      log("Cannot read import-order-plugin configuration: " + e.message);
+    }
+  }
+
+  return {
+    log,
+    compare,
+    inverseCompare: (a, b) => compare(b, a),
+    getOverridenModule,
+  }
+})();
 function sortFixInfo(fixes, sourceFile, program, packageJsonImportFilter, host, preferences) {
-  const _toPath = (fileName) => toPath(fileName, host.getCurrentDirectory(), hostGetCanonicalFileName(host));
-  return toSorted(fixes, (a, b) => compareBooleans(!!a.isJsxNamespaceFix, !!b.isJsxNamespaceFix) || compareValues(a.fix.kind, b.fix.kind) || compareModuleSpecifiers(a.fix, b.fix, sourceFile, program, preferences, packageJsonImportFilter.allowsImportingSpecifier, _toPath));
-}
+   const _toPath = (fileName) => toPath(fileName, host.getCurrentDirectory(), hostGetCanonicalFileName(host));
+   const sortedFixes = toSorted(fixes, (a, b) => compareBooleans(!!a.isJsxNamespaceFix, !!b.isJsxNamespaceFix) || compareValues(a.fix.kind, b.fix.kind) || compareModuleSpecifiers(a.fix, b.fix, sourceFile, program, preferences, packageJsonImportFilter.allowsImportingSpecifier, _toPath));
+
+   if(sortedFixes.length !== 0) {
+     const symbolName = sortedFixes[0].symbolName;
+     const override = autoImportOrderModule.getOverridenModule(symbolName);
+
+     if(override) {
+       const idx = sortedFixes.findIndex(f => f.fix.moduleSpecifier === override)
+       if(idx !== -1 && idx !== 0) {
+         const temp = sortedFixes[0]
+         sortedFixes[0] = sortedFixes[idx]
+         sortedFixes[idx] = temp
+       }
+     }
+   }
+
+   return sortedFixes;
+ }
 function getFixInfosWithoutDiagnostic(context, symbolToken, useAutoImportProvider) {
   const info = getFixesInfoForNonUMDImport(context, symbolToken, useAutoImportProvider);
   const packageJsonImportFilter = createPackageJsonImportFilter(context.sourceFile, context.preferences, context.host);
@@ -159183,6 +159302,7 @@ function getFixInfosWithoutDiagnostic(context, symbolToken, useAutoImportProvide
 }
 function getBestFix(fixes, sourceFile, program, packageJsonImportFilter, host, preferences) {
   if (!some(fixes)) return;
+  // These will always be placed first if available, and are better than other kinds
   if (fixes[0].kind === 0 /* UseNamespace */ || fixes[0].kind === 2 /* AddToExisting */) {
     return fixes[0];
   }
@@ -159203,13 +159323,19 @@ function getBestFix(fixes, sourceFile, program, packageJsonImportFilter, host, p
 }
 function compareModuleSpecifiers(a, b, importingFile, program, preferences, allowsImportingSpecifier, toPath3) {
   if (a.kind !== 0 /* UseNamespace */ && b.kind !== 0 /* UseNamespace */) {
-    return compareBooleans(
-      b.moduleSpecifierKind !== "node_modules" || allowsImportingSpecifier(b.moduleSpecifier),
-      a.moduleSpecifierKind !== "node_modules" || allowsImportingSpecifier(a.moduleSpecifier)
-    ) || compareModuleSpecifierRelativity(a, b, preferences) || compareNodeCoreModuleSpecifiers(a.moduleSpecifier, b.moduleSpecifier, importingFile, program) || compareBooleans(
-      isFixPossiblyReExportingImportingFile(a, importingFile.path, toPath3),
-      isFixPossiblyReExportingImportingFile(b, importingFile.path, toPath3)
-    ) || compareNumberOfDirectorySeparators(a.moduleSpecifier, b.moduleSpecifier);
+    return false
+      || compareBooleans(
+          b.moduleSpecifierKind !== "node_modules" || allowsImportingSpecifier(b.moduleSpecifier),
+          a.moduleSpecifierKind !== "node_modules" || allowsImportingSpecifier(a.moduleSpecifier)
+      )
+      || compareModuleSpecifierRelativity(a, b, preferences)
+      || compareNodeCoreModuleSpecifiers(a.moduleSpecifier, b.moduleSpecifier, importingFile, program)
+      || compareBooleans(
+          isFixPossiblyReExportingImportingFile(a, importingFile.path, toPath3),
+          isFixPossiblyReExportingImportingFile(b, importingFile.path, toPath3)
+      )
+      || autoImportOrderModule.compare(a, b)
+      || compareNumberOfDirectorySeparators(a.moduleSpecifier, b.moduleSpecifier);
   }
   return 0 /* EqualTo */;
 }
