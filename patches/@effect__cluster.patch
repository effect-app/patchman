diff --git a/ClusterError/package.json b/ClusterError/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..17b9d51930d9f7c8a88672cf408496e1d1962191
--- /dev/null
+++ b/ClusterError/package.json
@@ -0,0 +1,6 @@
+{
+  "main": "../dist/cjs/ClusterError.js",
+  "module": "../dist/esm/ClusterError.js",
+  "types": "../dist/dts/ClusterError.d.ts",
+  "sideEffects": []
+}
diff --git a/ClusterMetrics/package.json b/ClusterMetrics/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..da47dfc963a25b7b34b2c1aa17882907311258c0
--- /dev/null
+++ b/ClusterMetrics/package.json
@@ -0,0 +1,6 @@
+{
+  "main": "../dist/cjs/ClusterMetrics.js",
+  "module": "../dist/esm/ClusterMetrics.js",
+  "types": "../dist/dts/ClusterMetrics.d.ts",
+  "sideEffects": []
+}
diff --git a/ClusterSchema/package.json b/ClusterSchema/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..52e89771403dae46929723b8af4f41271a5263bb
--- /dev/null
+++ b/ClusterSchema/package.json
@@ -0,0 +1,6 @@
+{
+  "main": "../dist/cjs/ClusterSchema.js",
+  "module": "../dist/esm/ClusterSchema.js",
+  "types": "../dist/dts/ClusterSchema.d.ts",
+  "sideEffects": []
+}
diff --git a/DeliverAt/package.json b/DeliverAt/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..327a4be8790f0efd9d4a5812a0ff72ededb8dd03
--- /dev/null
+++ b/DeliverAt/package.json
@@ -0,0 +1,6 @@
+{
+  "main": "../dist/cjs/DeliverAt.js",
+  "module": "../dist/esm/DeliverAt.js",
+  "types": "../dist/dts/DeliverAt.d.ts",
+  "sideEffects": []
+}
diff --git a/Entity/package.json b/Entity/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..22e4685ce76947935cc17e97b00ce90fa46073cf
--- /dev/null
+++ b/Entity/package.json
@@ -0,0 +1,6 @@
+{
+  "main": "../dist/cjs/Entity.js",
+  "module": "../dist/esm/Entity.js",
+  "types": "../dist/dts/Entity.d.ts",
+  "sideEffects": []
+}
diff --git a/EntityAddress/package.json b/EntityAddress/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..31365cc5190a1206ebe0c4986dde127ce2fd7708
--- /dev/null
+++ b/EntityAddress/package.json
@@ -0,0 +1,6 @@
+{
+  "main": "../dist/cjs/EntityAddress.js",
+  "module": "../dist/esm/EntityAddress.js",
+  "types": "../dist/dts/EntityAddress.d.ts",
+  "sideEffects": []
+}
diff --git a/EntityId/package.json b/EntityId/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..95fa131f3ee5c2e401ca8daaf1988c749724639b
--- /dev/null
+++ b/EntityId/package.json
@@ -0,0 +1,6 @@
+{
+  "main": "../dist/cjs/EntityId.js",
+  "module": "../dist/esm/EntityId.js",
+  "types": "../dist/dts/EntityId.d.ts",
+  "sideEffects": []
+}
diff --git a/EntityType/package.json b/EntityType/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..b0fa9b0c879bc1132438b66e5a4a6cd129cb6981
--- /dev/null
+++ b/EntityType/package.json
@@ -0,0 +1,6 @@
+{
+  "main": "../dist/cjs/EntityType.js",
+  "module": "../dist/esm/EntityType.js",
+  "types": "../dist/dts/EntityType.d.ts",
+  "sideEffects": []
+}
diff --git a/Envelope/package.json b/Envelope/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..70d75ca30ec13a800a9566d43258695f4ba6e457
--- /dev/null
+++ b/Envelope/package.json
@@ -0,0 +1,6 @@
+{
+  "main": "../dist/cjs/Envelope.js",
+  "module": "../dist/esm/Envelope.js",
+  "types": "../dist/dts/Envelope.d.ts",
+  "sideEffects": []
+}
diff --git a/HttpCommon/package.json b/HttpCommon/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..bb707e6fec0c4b6e534ea01ad4bfacda3df3d596
--- /dev/null
+++ b/HttpCommon/package.json
@@ -0,0 +1,6 @@
+{
+  "main": "../dist/cjs/HttpCommon.js",
+  "module": "../dist/esm/HttpCommon.js",
+  "types": "../dist/dts/HttpCommon.d.ts",
+  "sideEffects": []
+}
diff --git a/HttpRunner/package.json b/HttpRunner/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..ee8b544d294b68e022cb793f32cd1e26a8bba478
--- /dev/null
+++ b/HttpRunner/package.json
@@ -0,0 +1,6 @@
+{
+  "main": "../dist/cjs/HttpRunner.js",
+  "module": "../dist/esm/HttpRunner.js",
+  "types": "../dist/dts/HttpRunner.d.ts",
+  "sideEffects": []
+}
diff --git a/HttpShardManager/package.json b/HttpShardManager/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..7e7e88f7d9df147983acd83d0ed1ba5f0c67439f
--- /dev/null
+++ b/HttpShardManager/package.json
@@ -0,0 +1,6 @@
+{
+  "main": "../dist/cjs/HttpShardManager.js",
+  "module": "../dist/esm/HttpShardManager.js",
+  "types": "../dist/dts/HttpShardManager.d.ts",
+  "sideEffects": []
+}
diff --git a/MachineId/package.json b/MachineId/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..797306c3dc6a8f2f08026c756459b9b0d2e07bcb
--- /dev/null
+++ b/MachineId/package.json
@@ -0,0 +1,6 @@
+{
+  "main": "../dist/cjs/MachineId.js",
+  "module": "../dist/esm/MachineId.js",
+  "types": "../dist/dts/MachineId.d.ts",
+  "sideEffects": []
+}
diff --git a/MessageStorage/package.json b/MessageStorage/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..5f1835297d36f6f39986b453593f2b3cdeb5c8fe
--- /dev/null
+++ b/MessageStorage/package.json
@@ -0,0 +1,6 @@
+{
+  "main": "../dist/cjs/MessageStorage.js",
+  "module": "../dist/esm/MessageStorage.js",
+  "types": "../dist/dts/MessageStorage.d.ts",
+  "sideEffects": []
+}
diff --git a/README.md b/README.md
index 18090c05295c0f27ba746b93eee40bc201ee48af..e0edb8ba76165ba0849165d52d325f8fd0f28cad 100644
--- a/README.md
+++ b/README.md
@@ -1,5 +1,5 @@
-# `@effect/cluster`
-
 ## Documentation
 
 - **API Reference**: [View the full documentation](https://effect-ts.github.io/effect/docs/cluster).
+
+.
diff --git a/Reply/package.json b/Reply/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..11d0ed1ed869c7bf57db00fde8855c9b4f14903e
--- /dev/null
+++ b/Reply/package.json
@@ -0,0 +1,6 @@
+{
+  "main": "../dist/cjs/Reply.js",
+  "module": "../dist/esm/Reply.js",
+  "types": "../dist/dts/Reply.d.ts",
+  "sideEffects": []
+}
diff --git a/Runner/package.json b/Runner/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..48920ca40f75b544b7aad7aa9f3152514735d669
--- /dev/null
+++ b/Runner/package.json
@@ -0,0 +1,6 @@
+{
+  "main": "../dist/cjs/Runner.js",
+  "module": "../dist/esm/Runner.js",
+  "types": "../dist/dts/Runner.d.ts",
+  "sideEffects": []
+}
diff --git a/RunnerAddress/package.json b/RunnerAddress/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..c5940023f6b87c769a6fbe161615ed590fca0fda
--- /dev/null
+++ b/RunnerAddress/package.json
@@ -0,0 +1,6 @@
+{
+  "main": "../dist/cjs/RunnerAddress.js",
+  "module": "../dist/esm/RunnerAddress.js",
+  "types": "../dist/dts/RunnerAddress.d.ts",
+  "sideEffects": []
+}
diff --git a/RunnerHealth/package.json b/RunnerHealth/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..12c33e2d3bb8100256e7ac00437896d756ceb2e2
--- /dev/null
+++ b/RunnerHealth/package.json
@@ -0,0 +1,6 @@
+{
+  "main": "../dist/cjs/RunnerHealth.js",
+  "module": "../dist/esm/RunnerHealth.js",
+  "types": "../dist/dts/RunnerHealth.d.ts",
+  "sideEffects": []
+}
diff --git a/RunnerServer/package.json b/RunnerServer/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..3c59ade831fc91a233f3850871317e8e019e87f5
--- /dev/null
+++ b/RunnerServer/package.json
@@ -0,0 +1,6 @@
+{
+  "main": "../dist/cjs/RunnerServer.js",
+  "module": "../dist/esm/RunnerServer.js",
+  "types": "../dist/dts/RunnerServer.d.ts",
+  "sideEffects": []
+}
diff --git a/Runners/package.json b/Runners/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..39078932265b515801f504cb99dec492b42a796e
--- /dev/null
+++ b/Runners/package.json
@@ -0,0 +1,6 @@
+{
+  "main": "../dist/cjs/Runners.js",
+  "module": "../dist/esm/Runners.js",
+  "types": "../dist/dts/Runners.d.ts",
+  "sideEffects": []
+}
diff --git a/ShardStorage/package.json b/ShardStorage/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..cee5c3b0bd5e969228134fad32ba22354c7512cb
--- /dev/null
+++ b/ShardStorage/package.json
@@ -0,0 +1,6 @@
+{
+  "main": "../dist/cjs/ShardStorage.js",
+  "module": "../dist/esm/ShardStorage.js",
+  "types": "../dist/dts/ShardStorage.d.ts",
+  "sideEffects": []
+}
diff --git a/Singleton/package.json b/Singleton/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..5d0b5d0cce3611069e626b5b2895b1dc1f6b9986
--- /dev/null
+++ b/Singleton/package.json
@@ -0,0 +1,6 @@
+{
+  "main": "../dist/cjs/Singleton.js",
+  "module": "../dist/esm/Singleton.js",
+  "types": "../dist/dts/Singleton.d.ts",
+  "sideEffects": []
+}
diff --git a/SingletonAddress/package.json b/SingletonAddress/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..b65a81967d8beb4d22ba3cb80ad9277ae1d282ea
--- /dev/null
+++ b/SingletonAddress/package.json
@@ -0,0 +1,6 @@
+{
+  "main": "../dist/cjs/SingletonAddress.js",
+  "module": "../dist/esm/SingletonAddress.js",
+  "types": "../dist/dts/SingletonAddress.d.ts",
+  "sideEffects": []
+}
diff --git a/Snowflake/package.json b/Snowflake/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..475fd314c2d31e41bc8ce181cbc406b622bdffd7
--- /dev/null
+++ b/Snowflake/package.json
@@ -0,0 +1,6 @@
+{
+  "main": "../dist/cjs/Snowflake.js",
+  "module": "../dist/esm/Snowflake.js",
+  "types": "../dist/dts/Snowflake.d.ts",
+  "sideEffects": []
+}
diff --git a/SocketRunner/package.json b/SocketRunner/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..d1618ba1e416e2f5886e57bc93702e9a2fa8a476
--- /dev/null
+++ b/SocketRunner/package.json
@@ -0,0 +1,6 @@
+{
+  "main": "../dist/cjs/SocketRunner.js",
+  "module": "../dist/esm/SocketRunner.js",
+  "types": "../dist/dts/SocketRunner.d.ts",
+  "sideEffects": []
+}
diff --git a/SocketShardManager/package.json b/SocketShardManager/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..56ed40d7cbeaf9511b1cf42bf95eee88d2a87cd5
--- /dev/null
+++ b/SocketShardManager/package.json
@@ -0,0 +1,6 @@
+{
+  "main": "../dist/cjs/SocketShardManager.js",
+  "module": "../dist/esm/SocketShardManager.js",
+  "types": "../dist/dts/SocketShardManager.d.ts",
+  "sideEffects": []
+}
diff --git a/SqlMessageStorage/package.json b/SqlMessageStorage/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..ff4d9d0ddbb626f7f2019533bb81ec32b9140be0
--- /dev/null
+++ b/SqlMessageStorage/package.json
@@ -0,0 +1,6 @@
+{
+  "main": "../dist/cjs/SqlMessageStorage.js",
+  "module": "../dist/esm/SqlMessageStorage.js",
+  "types": "../dist/dts/SqlMessageStorage.d.ts",
+  "sideEffects": []
+}
diff --git a/SqlShardStorage/package.json b/SqlShardStorage/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..c21022e80fa7ac5962b8d5f5cf9d4ad13f56e9f4
--- /dev/null
+++ b/SqlShardStorage/package.json
@@ -0,0 +1,6 @@
+{
+  "main": "../dist/cjs/SqlShardStorage.js",
+  "module": "../dist/esm/SqlShardStorage.js",
+  "types": "../dist/dts/SqlShardStorage.d.ts",
+  "sideEffects": []
+}
diff --git a/SynchronizedClock/package.json b/SynchronizedClock/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..130c748c0a38ae4d7e465c52ace97ea890e2787b
--- /dev/null
+++ b/SynchronizedClock/package.json
@@ -0,0 +1,6 @@
+{
+  "main": "../dist/cjs/SynchronizedClock.js",
+  "module": "../dist/esm/SynchronizedClock.js",
+  "types": "../dist/dts/SynchronizedClock.d.ts",
+  "sideEffects": []
+}
diff --git a/dist/cjs/ClusterError.js b/dist/cjs/ClusterError.js
new file mode 100644
index 0000000000000000000000000000000000000000..2609f26f0cc20a5d0d3fce539e5f665572faff06
--- /dev/null
+++ b/dist/cjs/ClusterError.js
@@ -0,0 +1,180 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.TypeId = exports.RunnerUnavailable = exports.RunnerNotRegistered = exports.PersistenceError = exports.MalformedMessage = exports.MailboxFull = exports.EntityNotManagedByRunner = exports.AlreadyProcessingMessage = void 0;
+var Cause = _interopRequireWildcard(require("effect/Cause"));
+var Effect = _interopRequireWildcard(require("effect/Effect"));
+var _Predicate = require("effect/Predicate");
+var Schema = _interopRequireWildcard(require("effect/Schema"));
+var _EntityAddress = require("./EntityAddress.js");
+var _RunnerAddress = require("./RunnerAddress.js");
+var _Snowflake = require("./Snowflake.js");
+function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
+function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
+/**
+ * @since 1.0.0
+ */
+
+/**
+ * @since 1.0.0
+ * @category Symbols
+ */
+const TypeId = exports.TypeId = /*#__PURE__*/Symbol.for("@effect/cluster/ClusterError");
+/**
+ * Represents an error that occurs when a Runner receives a message for an entity
+ * that it is not responsible for managing.
+ *
+ * @since 1.0.0
+ * @category errors
+ */
+class EntityNotManagedByRunner extends /*#__PURE__*/Schema.TaggedError()("EntityNotManagedByRunner", {
+  address: _EntityAddress.EntityAddress
+}) {
+  /**
+   * @since 1.0.0
+   */
+  [TypeId] = TypeId;
+  /**
+   * @since 1.0.0
+   */
+  static is(u) {
+    return (0, _Predicate.hasProperty)(u, TypeId) && (0, _Predicate.isTagged)(u, "EntityNotManagedByRunner");
+  }
+}
+/**
+ * Represents an error that occurs when a message fails to be properly
+ * deserialized by an entity.
+ *
+ * @since 1.0.0
+ * @category errors
+ */
+exports.EntityNotManagedByRunner = EntityNotManagedByRunner;
+class MalformedMessage extends /*#__PURE__*/Schema.TaggedError()("MalformedMessage", {
+  cause: Schema.Defect
+}) {
+  /**
+   * @since 1.0.0
+   */
+  [TypeId] = TypeId;
+  /**
+   * @since 1.0.0
+   */
+  static is(u) {
+    return (0, _Predicate.hasProperty)(u, TypeId) && (0, _Predicate.isTagged)(u, "MalformedMessage");
+  }
+  /**
+   * @since 1.0.0
+   */
+  static refail = /*#__PURE__*/Effect.mapError(cause => new MalformedMessage({
+    cause
+  }));
+}
+/**
+ * Represents an error that occurs when a message fails to be persisted into
+ * cluster's mailbox storage.
+ *
+ * @since 1.0.0
+ * @category errors
+ */
+exports.MalformedMessage = MalformedMessage;
+class PersistenceError extends /*#__PURE__*/Schema.TaggedError()("PersistenceError", {
+  cause: Schema.Defect
+}) {
+  /**
+   * @since 1.0.0
+   */
+  [TypeId] = TypeId;
+  /**
+   * @since 1.0.0
+   */
+  static refail(effect) {
+    return Effect.catchAllCause(effect, cause => Effect.fail(new PersistenceError({
+      cause: Cause.squash(cause)
+    })));
+  }
+}
+/**
+ * Represents an error that occurs when a Runner is not registered with the shard
+ * manager.
+ *
+ * @since 1.0.0
+ * @category errors
+ */
+exports.PersistenceError = PersistenceError;
+class RunnerNotRegistered extends /*#__PURE__*/Schema.TaggedError()("RunnerNotRegistered", {
+  address: _RunnerAddress.RunnerAddress
+}) {
+  /**
+   * @since 1.0.0
+   */
+  [TypeId] = TypeId;
+}
+/**
+ * Represents an error that occurs when a Runner is unresponsive.
+ *
+ * @since 1.0.0
+ * @category errors
+ */
+exports.RunnerNotRegistered = RunnerNotRegistered;
+class RunnerUnavailable extends /*#__PURE__*/Schema.TaggedError()("RunnerUnavailable", {
+  address: _RunnerAddress.RunnerAddress
+}) {
+  /**
+   * @since 1.0.0
+   */
+  [TypeId] = TypeId;
+  /**
+   * @since 1.0.0
+   */
+  static is(u) {
+    return (0, _Predicate.hasProperty)(u, TypeId) && (0, _Predicate.isTagged)(u, "RunnerUnavailable");
+  }
+}
+/**
+ * Represents an error that occurs when the entities mailbox is full.
+ *
+ * @since 1.0.0
+ * @category errors
+ */
+exports.RunnerUnavailable = RunnerUnavailable;
+class MailboxFull extends /*#__PURE__*/Schema.TaggedError()("MailboxFull", {
+  address: _EntityAddress.EntityAddress
+}) {
+  /**
+   * @since 1.0.0
+   */
+  [TypeId] = TypeId;
+  /**
+   * @since 1.0.0
+   */
+  static is(u) {
+    return (0, _Predicate.hasProperty)(u, TypeId) && (0, _Predicate.isTagged)(u, "MailboxFull");
+  }
+}
+/**
+ * Represents an error that occurs when the entity is already processing a
+ * request.
+ *
+ * @since 1.0.0
+ * @category errors
+ */
+exports.MailboxFull = MailboxFull;
+class AlreadyProcessingMessage extends /*#__PURE__*/Schema.TaggedError()("AlreadyProcessingMessage", {
+  envelopeId: _Snowflake.SnowflakeFromString,
+  address: _EntityAddress.EntityAddress
+}) {
+  /**
+   * @since 1.0.0
+   */
+  [TypeId] = TypeId;
+  /**
+   * @since 1.0.0
+   */
+  static is(u) {
+    return (0, _Predicate.hasProperty)(u, TypeId) && (0, _Predicate.isTagged)(u, "AlreadyProcessingMessage");
+  }
+}
+exports.AlreadyProcessingMessage = AlreadyProcessingMessage;
+//# sourceMappingURL=ClusterError.js.map
\ No newline at end of file
diff --git a/dist/cjs/ClusterError.js.map b/dist/cjs/ClusterError.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..06ae3c41aa2c9f2a8a11f20f7fc43260e68a17d3
--- /dev/null
+++ b/dist/cjs/ClusterError.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"ClusterError.js","names":["Cause","_interopRequireWildcard","require","Effect","_Predicate","Schema","_EntityAddress","_RunnerAddress","_Snowflake","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","TypeId","exports","Symbol","for","EntityNotManagedByRunner","TaggedError","address","EntityAddress","is","hasProperty","isTagged","MalformedMessage","cause","Defect","refail","mapError","PersistenceError","effect","catchAllCause","fail","squash","RunnerNotRegistered","RunnerAddress","RunnerUnavailable","MailboxFull","AlreadyProcessingMessage","envelopeId","SnowflakeFromString"],"sources":["../../src/ClusterError.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/cjs/ClusterMetrics.js b/dist/cjs/ClusterMetrics.js
new file mode 100644
index 0000000000000000000000000000000000000000..7168242e274aef26fb30e0dfe9dba04f93c7cd99
--- /dev/null
+++ b/dist/cjs/ClusterMetrics.js
@@ -0,0 +1,63 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.unassignedShards = exports.singletons = exports.shards = exports.runners = exports.runnerHealthChecked = exports.rebalances = exports.mailboxSize = exports.entities = exports.assignedShards = void 0;
+var Metric = _interopRequireWildcard(require("effect/Metric"));
+function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
+function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
+/**
+ * @since 1.0.0
+ */
+
+/**
+ * @since 1.0.0
+ * @category metrics
+ */
+const shards = exports.shards = /*#__PURE__*/Metric.gauge("effect_cluster_shards");
+/**
+ * @since 1.0.0
+ * @category metrics
+ */
+const entities = exports.entities = /*#__PURE__*/Metric.gauge("effect_cluster_entities", {
+  bigint: true
+});
+/**
+ * @since 1.0.0
+ * @category metrics
+ */
+const mailboxSize = exports.mailboxSize = /*#__PURE__*/Metric.gauge("effect_cluster_mailbox_size", {
+  bigint: true
+});
+/**
+ * @since 1.0.0
+ * @category metrics
+ */
+const singletons = exports.singletons = /*#__PURE__*/Metric.gauge("effect_cluster_singletons");
+/**
+ * @since 1.0.0
+ * @category metrics
+ */
+const runners = exports.runners = /*#__PURE__*/Metric.gauge("effect_cluster_runners");
+/**
+ * @since 1.0.0
+ * @category metrics
+ */
+const assignedShards = exports.assignedShards = /*#__PURE__*/Metric.gauge("effect_cluster_shards_assigned");
+/**
+ * @since 1.0.0
+ * @category metrics
+ */
+const unassignedShards = exports.unassignedShards = /*#__PURE__*/Metric.gauge("effect_cluster_shards_unassigned");
+/**
+ * @since 1.0.0
+ * @category metrics
+ */
+const rebalances = exports.rebalances = /*#__PURE__*/Metric.counter("effect_cluster_rebalances");
+/**
+ * @since 1.0.0
+ * @category metrics
+ */
+const runnerHealthChecked = exports.runnerHealthChecked = /*#__PURE__*/Metric.counter("effect_cluster_runner_health_checked");
+//# sourceMappingURL=ClusterMetrics.js.map
\ No newline at end of file
diff --git a/dist/cjs/ClusterMetrics.js.map b/dist/cjs/ClusterMetrics.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..f3b7a081639dd9b6ac9a8acff84217687c9ce90a
--- /dev/null
+++ b/dist/cjs/ClusterMetrics.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"ClusterMetrics.js","names":["Metric","_interopRequireWildcard","require","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","shards","exports","gauge","entities","bigint","mailboxSize","singletons","runners","assignedShards","unassignedShards","rebalances","counter","runnerHealthChecked"],"sources":["../../src/ClusterMetrics.ts"],"sourcesContent":[null],"mappings":";;;;;;AAGA,IAAAA,MAAA,GAAAC,uBAAA,CAAAC,OAAA;AAAuC,SAAAC,yBAAAC,CAAA,6BAAAC,OAAA,mBAAAC,CAAA,OAAAD,OAAA,IAAAE,CAAA,OAAAF,OAAA,YAAAF,wBAAA,YAAAA,CAAAC,CAAA,WAAAA,CAAA,GAAAG,CAAA,GAAAD,CAAA,KAAAF,CAAA;AAAA,SAAAH,wBAAAG,CAAA,EAAAE,CAAA,SAAAA,CAAA,IAAAF,CAAA,IAAAA,CAAA,CAAAI,UAAA,SAAAJ,CAAA,eAAAA,CAAA,uBAAAA,CAAA,yBAAAA,CAAA,WAAAK,OAAA,EAAAL,CAAA,QAAAG,CAAA,GAAAJ,wBAAA,CAAAG,CAAA,OAAAC,CAAA,IAAAA,CAAA,CAAAG,GAAA,CAAAN,CAAA,UAAAG,CAAA,CAAAI,GAAA,CAAAP,CAAA,OAAAQ,CAAA,KAAAC,SAAA,UAAAC,CAAA,GAAAC,MAAA,CAAAC,cAAA,IAAAD,MAAA,CAAAE,wBAAA,WAAAC,CAAA,IAAAd,CAAA,oBAAAc,CAAA,OAAAC,cAAA,CAAAC,IAAA,CAAAhB,CAAA,EAAAc,CAAA,SAAAG,CAAA,GAAAP,CAAA,GAAAC,MAAA,CAAAE,wBAAA,CAAAb,CAAA,EAAAc,CAAA,UAAAG,CAAA,KAAAA,CAAA,CAAAV,GAAA,IAAAU,CAAA,CAAAC,GAAA,IAAAP,MAAA,CAAAC,cAAA,CAAAJ,CAAA,EAAAM,CAAA,EAAAG,CAAA,IAAAT,CAAA,CAAAM,CAAA,IAAAd,CAAA,CAAAc,CAAA,YAAAN,CAAA,CAAAH,OAAA,GAAAL,CAAA,EAAAG,CAAA,IAAAA,CAAA,CAAAe,GAAA,CAAAlB,CAAA,EAAAQ,CAAA,GAAAA,CAAA;AAHvC;;;;AAKA;;;;AAIO,MAAMW,MAAM,GAAAC,OAAA,CAAAD,MAAA,gBAAGvB,MAAM,CAACyB,KAAK,CAAC,uBAAuB,CAAC;AAE3D;;;;AAIO,MAAMC,QAAQ,GAAAF,OAAA,CAAAE,QAAA,gBAAG1B,MAAM,CAACyB,KAAK,CAAC,yBAAyB,EAAE;EAC9DE,MAAM,EAAE;CACT,CAAC;AAEF;;;;AAIO,MAAMC,WAAW,GAAAJ,OAAA,CAAAI,WAAA,gBAAG5B,MAAM,CAACyB,KAAK,CAAC,6BAA6B,EAAE;EACrEE,MAAM,EAAE;CACT,CAAC;AAEF;;;;AAIO,MAAME,UAAU,GAAAL,OAAA,CAAAK,UAAA,gBAAG7B,MAAM,CAACyB,KAAK,CAAC,2BAA2B,CAAC;AAEnE;;;;AAIO,MAAMK,OAAO,GAAAN,OAAA,CAAAM,OAAA,gBAAG9B,MAAM,CAACyB,KAAK,CAAC,wBAAwB,CAAC;AAE7D;;;;AAIO,MAAMM,cAAc,GAAAP,OAAA,CAAAO,cAAA,gBAAG/B,MAAM,CAACyB,KAAK,CAAC,gCAAgC,CAAC;AAE5E;;;;AAIO,MAAMO,gBAAgB,GAAAR,OAAA,CAAAQ,gBAAA,gBAAGhC,MAAM,CAACyB,KAAK,CAAC,kCAAkC,CAAC;AAEhF;;;;AAIO,MAAMQ,UAAU,GAAAT,OAAA,CAAAS,UAAA,gBAAGjC,MAAM,CAACkC,OAAO,CAAC,2BAA2B,CAAC;AAErE;;;;AAIO,MAAMC,mBAAmB,GAAAX,OAAA,CAAAW,mBAAA,gBAAGnC,MAAM,CAACkC,OAAO,CAAC,sCAAsC,CAAC","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/cjs/ClusterSchema.js b/dist/cjs/ClusterSchema.js
new file mode 100644
index 0000000000000000000000000000000000000000..58be82ab41b416b5c49f4192e3b9ae81ddd93981
--- /dev/null
+++ b/dist/cjs/ClusterSchema.js
@@ -0,0 +1,23 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.Persisted = void 0;
+var Context = _interopRequireWildcard(require("effect/Context"));
+var _Function = require("effect/Function");
+function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
+function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
+/**
+ * @since 1.0.0
+ */
+
+/**
+ * @since 1.0.0
+ * @category Annotations
+ */
+class Persisted extends /*#__PURE__*/Context.Reference()("@effect/cluster/ClusterSchema/Persisted", {
+  defaultValue: _Function.constFalse
+}) {}
+exports.Persisted = Persisted;
+//# sourceMappingURL=ClusterSchema.js.map
\ No newline at end of file
diff --git a/dist/cjs/ClusterSchema.js.map b/dist/cjs/ClusterSchema.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..70cae693707673fdb0f5e7028e71938de77daedd
--- /dev/null
+++ b/dist/cjs/ClusterSchema.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"ClusterSchema.js","names":["Context","_interopRequireWildcard","require","_Function","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","Persisted","Reference","defaultValue","constFalse","exports"],"sources":["../../src/ClusterSchema.ts"],"sourcesContent":[null],"mappings":";;;;;;AAGA,IAAAA,OAAA,GAAAC,uBAAA,CAAAC,OAAA;AACA,IAAAC,SAAA,GAAAD,OAAA;AAA4C,SAAAE,yBAAAC,CAAA,6BAAAC,OAAA,mBAAAC,CAAA,OAAAD,OAAA,IAAAE,CAAA,OAAAF,OAAA,YAAAF,wBAAA,YAAAA,CAAAC,CAAA,WAAAA,CAAA,GAAAG,CAAA,GAAAD,CAAA,KAAAF,CAAA;AAAA,SAAAJ,wBAAAI,CAAA,EAAAE,CAAA,SAAAA,CAAA,IAAAF,CAAA,IAAAA,CAAA,CAAAI,UAAA,SAAAJ,CAAA,eAAAA,CAAA,uBAAAA,CAAA,yBAAAA,CAAA,WAAAK,OAAA,EAAAL,CAAA,QAAAG,CAAA,GAAAJ,wBAAA,CAAAG,CAAA,OAAAC,CAAA,IAAAA,CAAA,CAAAG,GAAA,CAAAN,CAAA,UAAAG,CAAA,CAAAI,GAAA,CAAAP,CAAA,OAAAQ,CAAA,KAAAC,SAAA,UAAAC,CAAA,GAAAC,MAAA,CAAAC,cAAA,IAAAD,MAAA,CAAAE,wBAAA,WAAAC,CAAA,IAAAd,CAAA,oBAAAc,CAAA,OAAAC,cAAA,CAAAC,IAAA,CAAAhB,CAAA,EAAAc,CAAA,SAAAG,CAAA,GAAAP,CAAA,GAAAC,MAAA,CAAAE,wBAAA,CAAAb,CAAA,EAAAc,CAAA,UAAAG,CAAA,KAAAA,CAAA,CAAAV,GAAA,IAAAU,CAAA,CAAAC,GAAA,IAAAP,MAAA,CAAAC,cAAA,CAAAJ,CAAA,EAAAM,CAAA,EAAAG,CAAA,IAAAT,CAAA,CAAAM,CAAA,IAAAd,CAAA,CAAAc,CAAA,YAAAN,CAAA,CAAAH,OAAA,GAAAL,CAAA,EAAAG,CAAA,IAAAA,CAAA,CAAAe,GAAA,CAAAlB,CAAA,EAAAQ,CAAA,GAAAA,CAAA;AAJ5C;;;;AAMA;;;;AAIM,MAAOW,SAAU,sBAAQxB,OAAO,CAACyB,SAAS,EAAa,CAAC,yCAAyC,EAAE;EACvGC,YAAY,EAAEC;CACf,CAAC;AAAAC,OAAA,CAAAJ,SAAA,GAAAA,SAAA","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/cjs/DeliverAt.js b/dist/cjs/DeliverAt.js
new file mode 100644
index 0000000000000000000000000000000000000000..3c3fac058ea40d31ba1879d234823f14856bb73b
--- /dev/null
+++ b/dist/cjs/DeliverAt.js
@@ -0,0 +1,30 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.toMillis = exports.symbol = exports.isDeliverAt = void 0;
+var _Predicate = require("effect/Predicate");
+/**
+ * @since 1.0.0
+ * @category symbols
+ */
+const symbol = exports.symbol = /*#__PURE__*/Symbol.for("@effect/cluster/DeliverAt");
+/**
+ * @since 1.0.0
+ * @category guards
+ */
+const isDeliverAt = self => (0, _Predicate.hasProperty)(self, symbol);
+/**
+ * @since 1.0.0
+ * @category accessors
+ */
+exports.isDeliverAt = isDeliverAt;
+const toMillis = self => {
+  if (isDeliverAt(self)) {
+    return self[symbol]().epochMillis;
+  }
+  return null;
+};
+exports.toMillis = toMillis;
+//# sourceMappingURL=DeliverAt.js.map
\ No newline at end of file
diff --git a/dist/cjs/DeliverAt.js.map b/dist/cjs/DeliverAt.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..235c7e12729c281e4f93b281eb94783a4d050eb0
--- /dev/null
+++ b/dist/cjs/DeliverAt.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"DeliverAt.js","names":["_Predicate","require","symbol","exports","Symbol","for","isDeliverAt","self","hasProperty","toMillis","epochMillis"],"sources":["../../src/DeliverAt.ts"],"sourcesContent":[null],"mappings":";;;;;;AAIA,IAAAA,UAAA,GAAAC,OAAA;AAEA;;;;AAIO,MAAMC,MAAM,GAAAC,OAAA,CAAAD,MAAA,gBAAkBE,MAAM,CAACC,GAAG,CAAC,2BAA2B,CAAC;AAU5E;;;;AAIO,MAAMC,WAAW,GAAIC,IAAa,IAAwB,IAAAC,sBAAW,EAACD,IAAI,EAAEL,MAAM,CAAC;AAE1F;;;;AAAAC,OAAA,CAAAG,WAAA,GAAAA,WAAA;AAIO,MAAMG,QAAQ,GAAIF,IAAa,IAAmB;EACvD,IAAID,WAAW,CAACC,IAAI,CAAC,EAAE;IACrB,OAAOA,IAAI,CAACL,MAAM,CAAC,EAAE,CAACQ,WAAW;EACnC;EACA,OAAO,IAAI;AACb,CAAC;AAAAP,OAAA,CAAAM,QAAA,GAAAA,QAAA","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/cjs/Entity.js b/dist/cjs/Entity.js
new file mode 100644
index 0000000000000000000000000000000000000000..33ad294ae03e9ff7b682a75f72af553b6224f83f
--- /dev/null
+++ b/dist/cjs/Entity.js
@@ -0,0 +1,187 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.make = exports.isEntity = exports.fromRpcGroup = exports.TypeId = exports.Request = exports.CurrentRunnerAddress = exports.CurrentAddress = void 0;
+var RpcGroup = _interopRequireWildcard(require("@effect/rpc/RpcGroup"));
+var Arr = _interopRequireWildcard(require("effect/Array"));
+var Context = _interopRequireWildcard(require("effect/Context"));
+var Data = _interopRequireWildcard(require("effect/Data"));
+var Effect = _interopRequireWildcard(require("effect/Effect"));
+var Equal = _interopRequireWildcard(require("effect/Equal"));
+var Exit = _interopRequireWildcard(require("effect/Exit"));
+var Hash = _interopRequireWildcard(require("effect/Hash"));
+var Layer = _interopRequireWildcard(require("effect/Layer"));
+var Mailbox = _interopRequireWildcard(require("effect/Mailbox"));
+var Option = _interopRequireWildcard(require("effect/Option"));
+var Predicate = _interopRequireWildcard(require("effect/Predicate"));
+var _EntityType = require("./EntityType.js");
+function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
+function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
+/**
+ * @since 1.0.0
+ * @category type ids
+ */
+const TypeId = exports.TypeId = /*#__PURE__*/Symbol.for("@effect/cluster/Entity");
+/**
+ * @since 1.0.0
+ * @category refinements
+ */
+const isEntity = u => Predicate.hasProperty(u, TypeId);
+exports.isEntity = isEntity;
+const Proto = {
+  [TypeId]: TypeId,
+  [Hash.symbol]() {
+    return Hash.structure({
+      type: this.type
+    });
+  },
+  [Equal.symbol](that) {
+    return isEntity(that) && this.type === that.type;
+  },
+  annotate(tag, value) {
+    return fromRpcGroup(this.type, this.protocol.annotate(tag, value));
+  },
+  annotateRpcs(tag, value) {
+    return fromRpcGroup(this.type, this.protocol.annotateRpcs(tag, value));
+  },
+  annotateContext(context) {
+    return fromRpcGroup(this.type, this.protocol.annotateContext(context));
+  },
+  annotateRpcsContext(context) {
+    return fromRpcGroup(this.type, this.protocol.annotateRpcsContext(context));
+  },
+  get client() {
+    return shardingTag.pipe(Effect.flatMap(sharding => sharding.makeClient(this)));
+  },
+  toLayer(build, options) {
+    return shardingTag.pipe(Effect.flatMap(sharding => sharding.registerEntity(this, Effect.isEffect(build) ? build : Effect.succeed(build), options)), Layer.effectDiscard);
+  },
+  toLayerMailbox(build, options) {
+    const buildHandlers = Effect.gen(this, function* () {
+      const behaviour = Effect.isEffect(build) ? yield* build : build;
+      const mailbox = yield* Mailbox.make();
+      // create the rpc handlers for the entity
+      const handler = envelope => {
+        return Effect.async(resume => {
+          mailbox.unsafeOffer(envelope);
+          resumes.set(envelope, resume);
+        });
+      };
+      const handlers = {};
+      for (const rpc of this.protocol.requests.keys()) {
+        handlers[rpc] = handler;
+      }
+      // make the Replier for the behaviour
+      const resumes = new Map();
+      const complete = (request, exit) => Effect.sync(() => {
+        const resume = resumes.get(request);
+        if (resume) {
+          resumes.delete(request);
+          resume(exit);
+        }
+      });
+      const replier = {
+        succeed: (request, value) => complete(request, Exit.succeed(value)),
+        fail: (request, error) => complete(request, Exit.fail(error)),
+        failCause: (request, cause) => complete(request, Exit.failCause(cause)),
+        complete
+      };
+      // fork the behaviour into the layer scope
+      yield* behaviour(mailbox, replier).pipe(Effect.catchAllCause(cause => {
+        const exit = Exit.failCause(cause);
+        for (const resume of resumes.values()) {
+          resume(exit);
+        }
+        return Effect.void;
+      }), Effect.interruptible, Effect.forkScoped);
+      return handlers;
+    });
+    return this.toLayer(buildHandlers, {
+      ...options,
+      concurrency: "unbounded"
+    });
+  }
+};
+/**
+ * Creates a new `Entity` of the specified `type` which will accept messages
+ * that adhere to the provided `RpcGroup`.
+ *
+ * @since 1.0.0
+ * @category constructors
+ */
+const fromRpcGroup = (
+/**
+ * The entity type name.
+ */
+type,
+/**
+ * The schema definition for messages that the entity is capable of
+ * processing.
+ */
+protocol) => {
+  const self = Object.create(Proto);
+  self.type = _EntityType.EntityType.make(type);
+  self.protocol = protocol;
+  return self;
+};
+/**
+ * Creates a new `Entity` of the specified `type` which will accept messages
+ * that adhere to the provided schemas.
+ *
+ * @since 1.0.0
+ * @category constructors
+ */
+exports.fromRpcGroup = fromRpcGroup;
+const make = (
+/**
+ * The entity type name.
+ */
+type,
+/**
+ * The schema definition for messages that the entity is capable of
+ * processing.
+ */
+protocol) => fromRpcGroup(type, RpcGroup.make(...protocol));
+/**
+ * A Context.Tag to access the current entity address.
+ *
+ * @since 1.0.0
+ * @category context
+ */
+exports.make = make;
+class CurrentAddress extends /*#__PURE__*/Context.Tag("@effect/cluster/Entity/EntityAddress")() {}
+/**
+ * A Context.Tag to access the current Runner address.
+ *
+ * @since 1.0.0
+ * @category context
+ */
+exports.CurrentAddress = CurrentAddress;
+class CurrentRunnerAddress extends /*#__PURE__*/Context.Tag("@effect/cluster/Entity/RunnerAddress")() {}
+/**
+ * @since 1.0.0
+ * @category Request
+ */
+exports.CurrentRunnerAddress = CurrentRunnerAddress;
+class Request extends Data.Class {
+  /**
+   * @since 1.0.0
+   */
+  get lastSentChunkValue() {
+    return this.lastSentChunk.pipe(Option.map(chunk => Arr.lastNonEmpty(chunk.values)));
+  }
+  /**
+   * @since 1.0.0
+   */
+  get nextSequence() {
+    if (Option.isNone(this.lastSentChunk)) {
+      return 0;
+    }
+    return this.lastSentChunk.value.sequence + 1;
+  }
+}
+exports.Request = Request;
+const shardingTag = /*#__PURE__*/Context.GenericTag("@effect/cluster/Sharding");
+//# sourceMappingURL=Entity.js.map
\ No newline at end of file
diff --git a/dist/cjs/Entity.js.map b/dist/cjs/Entity.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..8e83cebf305220683b129fb0e9c5a2df990d1fb1
--- /dev/null
+++ b/dist/cjs/Entity.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"Entity.js","names":["RpcGroup","_interopRequireWildcard","require","Arr","Context","Data","Effect","Equal","Exit","Hash","Layer","Mailbox","Option","Predicate","_EntityType","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","TypeId","exports","Symbol","for","isEntity","hasProperty","Proto","symbol","structure","type","that","annotate","tag","value","fromRpcGroup","protocol","annotateRpcs","annotateContext","context","annotateRpcsContext","client","shardingTag","pipe","flatMap","sharding","makeClient","toLayer","build","options","registerEntity","isEffect","succeed","effectDiscard","toLayerMailbox","buildHandlers","gen","behaviour","mailbox","make","handler","envelope","async","resume","unsafeOffer","resumes","handlers","rpc","requests","keys","Map","complete","request","exit","sync","delete","replier","fail","error","failCause","cause","catchAllCause","values","void","interruptible","forkScoped","concurrency","self","create","EntityType","CurrentAddress","Tag","CurrentRunnerAddress","Request","Class","lastSentChunkValue","lastSentChunk","map","chunk","lastNonEmpty","nextSequence","isNone","sequence","GenericTag"],"sources":["../../src/Entity.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/cjs/EntityAddress.js b/dist/cjs/EntityAddress.js
new file mode 100644
index 0000000000000000000000000000000000000000..d80bd9f893c3d410228dfe02bbe9f3268d1c825e
--- /dev/null
+++ b/dist/cjs/EntityAddress.js
@@ -0,0 +1,54 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.TypeId = exports.EntityAddressFromSelf = exports.EntityAddress = void 0;
+var Hash = _interopRequireWildcard(require("effect/Hash"));
+var Schema = _interopRequireWildcard(require("effect/Schema"));
+var _EntityId = require("./EntityId.js");
+var _EntityType = require("./EntityType.js");
+var _ShardId = require("./ShardId.js");
+function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
+function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
+/**
+ * @since 1.0.0
+ */
+
+const SymbolKey = "@effect/cluster/EntityAddress";
+/**
+ * @since 1.0.0
+ * @category type ids
+ */
+const TypeId = exports.TypeId = /*#__PURE__*/Symbol.for(SymbolKey);
+/**
+ * Represents the unique address of an entity within the cluster.
+ *
+ * @since 1.0.0
+ * @category models
+ */
+class EntityAddress extends /*#__PURE__*/Schema.Class(SymbolKey)({
+  shardId: _ShardId.ShardId,
+  entityType: _EntityType.EntityType,
+  entityId: _EntityId.EntityId
+}) {
+  /**
+   * @since 1.0.0
+   */
+  [TypeId] = TypeId;
+  /**
+   * @since 1.0.0
+   */
+  [Hash.symbol]() {
+    return Hash.cached(this)(Hash.string(`${this.shardId}:${this.entityType}:${this.entityId}`));
+  }
+}
+/**
+ * Represents the unique address of an entity within the cluster.
+ *
+ * @since 1.0.0
+ * @category schemas
+ */
+exports.EntityAddress = EntityAddress;
+const EntityAddressFromSelf = exports.EntityAddressFromSelf = /*#__PURE__*/Schema.typeSchema(EntityAddress);
+//# sourceMappingURL=EntityAddress.js.map
\ No newline at end of file
diff --git a/dist/cjs/EntityAddress.js.map b/dist/cjs/EntityAddress.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..f3e76b3ebdf9a2c2bd25da10e438bf6f436b944e
--- /dev/null
+++ b/dist/cjs/EntityAddress.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"EntityAddress.js","names":["Hash","_interopRequireWildcard","require","Schema","_EntityId","_EntityType","_ShardId","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","SymbolKey","TypeId","exports","Symbol","for","EntityAddress","Class","shardId","ShardId","entityType","EntityType","entityId","EntityId","symbol","cached","string","EntityAddressFromSelf","typeSchema"],"sources":["../../src/EntityAddress.ts"],"sourcesContent":[null],"mappings":";;;;;;AAGA,IAAAA,IAAA,GAAAC,uBAAA,CAAAC,OAAA;AACA,IAAAC,MAAA,GAAAF,uBAAA,CAAAC,OAAA;AACA,IAAAE,SAAA,GAAAF,OAAA;AACA,IAAAG,WAAA,GAAAH,OAAA;AACA,IAAAI,QAAA,GAAAJ,OAAA;AAAsC,SAAAK,yBAAAC,CAAA,6BAAAC,OAAA,mBAAAC,CAAA,OAAAD,OAAA,IAAAE,CAAA,OAAAF,OAAA,YAAAF,wBAAA,YAAAA,CAAAC,CAAA,WAAAA,CAAA,GAAAG,CAAA,GAAAD,CAAA,KAAAF,CAAA;AAAA,SAAAP,wBAAAO,CAAA,EAAAE,CAAA,SAAAA,CAAA,IAAAF,CAAA,IAAAA,CAAA,CAAAI,UAAA,SAAAJ,CAAA,eAAAA,CAAA,uBAAAA,CAAA,yBAAAA,CAAA,WAAAK,OAAA,EAAAL,CAAA,QAAAG,CAAA,GAAAJ,wBAAA,CAAAG,CAAA,OAAAC,CAAA,IAAAA,CAAA,CAAAG,GAAA,CAAAN,CAAA,UAAAG,CAAA,CAAAI,GAAA,CAAAP,CAAA,OAAAQ,CAAA,KAAAC,SAAA,UAAAC,CAAA,GAAAC,MAAA,CAAAC,cAAA,IAAAD,MAAA,CAAAE,wBAAA,WAAAC,CAAA,IAAAd,CAAA,oBAAAc,CAAA,OAAAC,cAAA,CAAAC,IAAA,CAAAhB,CAAA,EAAAc,CAAA,SAAAG,CAAA,GAAAP,CAAA,GAAAC,MAAA,CAAAE,wBAAA,CAAAb,CAAA,EAAAc,CAAA,UAAAG,CAAA,KAAAA,CAAA,CAAAV,GAAA,IAAAU,CAAA,CAAAC,GAAA,IAAAP,MAAA,CAAAC,cAAA,CAAAJ,CAAA,EAAAM,CAAA,EAAAG,CAAA,IAAAT,CAAA,CAAAM,CAAA,IAAAd,CAAA,CAAAc,CAAA,YAAAN,CAAA,CAAAH,OAAA,GAAAL,CAAA,EAAAG,CAAA,IAAAA,CAAA,CAAAe,GAAA,CAAAlB,CAAA,EAAAQ,CAAA,GAAAA,CAAA;AAPtC;;;;AASA,MAAMW,SAAS,GAAG,+BAA+B;AAEjD;;;;AAIO,MAAMC,MAAM,GAAAC,OAAA,CAAAD,MAAA,gBAAkBE,MAAM,CAACC,GAAG,CAACJ,SAAS,CAAC;AAQ1D;;;;;;AAMM,MAAOK,aAAc,sBAAQ7B,MAAM,CAAC8B,KAAK,CAAgBN,SAAS,CAAC,CAAC;EACxEO,OAAO,EAAEC,gBAAO;EAChBC,UAAU,EAAEC,sBAAU;EACtBC,QAAQ,EAAEC;CACX,CAAC;EACA;;;EAGS,CAACX,MAAM,IAAIA,MAAM;EAC1B;;;EAGA,CAAC5B,IAAI,CAACwC,MAAM,IAAC;IACX,OAAOxC,IAAI,CAACyC,MAAM,CAAC,IAAI,CAAC,CAACzC,IAAI,CAAC0C,MAAM,CAAC,GAAG,IAAI,CAACR,OAAO,IAAI,IAAI,CAACE,UAAU,IAAI,IAAI,CAACE,QAAQ,EAAE,CAAC,CAAC;EAC9F;;AAGF;;;;;;AAAAT,OAAA,CAAAG,aAAA,GAAAA,aAAA;AAMO,MAAMW,qBAAqB,GAAAd,OAAA,CAAAc,qBAAA,gBAAiCxC,MAAM,CAACyC,UAAU,CAClFZ,aAAa,CACd","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/cjs/EntityId.js b/dist/cjs/EntityId.js
new file mode 100644
index 0000000000000000000000000000000000000000..caf358f9203b70954a2a946c976f72ff3801ab2d
--- /dev/null
+++ b/dist/cjs/EntityId.js
@@ -0,0 +1,19 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.EntityId = void 0;
+var Schema = _interopRequireWildcard(require("effect/Schema"));
+function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
+function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
+/**
+ * @since 1.0.0
+ */
+
+/**
+ * @since 1.0.0
+ * @category constructors
+ */
+const EntityId = exports.EntityId = /*#__PURE__*/Schema.NonEmptyTrimmedString.pipe( /*#__PURE__*/Schema.brand("EntityId"));
+//# sourceMappingURL=EntityId.js.map
\ No newline at end of file
diff --git a/dist/cjs/EntityId.js.map b/dist/cjs/EntityId.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..11ba382e1f4a026cbaef13e5b34f99a294d117ff
--- /dev/null
+++ b/dist/cjs/EntityId.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"EntityId.js","names":["Schema","_interopRequireWildcard","require","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","EntityId","exports","NonEmptyTrimmedString","pipe","brand"],"sources":["../../src/EntityId.ts"],"sourcesContent":[null],"mappings":";;;;;;AAGA,IAAAA,MAAA,GAAAC,uBAAA,CAAAC,OAAA;AAAuC,SAAAC,yBAAAC,CAAA,6BAAAC,OAAA,mBAAAC,CAAA,OAAAD,OAAA,IAAAE,CAAA,OAAAF,OAAA,YAAAF,wBAAA,YAAAA,CAAAC,CAAA,WAAAA,CAAA,GAAAG,CAAA,GAAAD,CAAA,KAAAF,CAAA;AAAA,SAAAH,wBAAAG,CAAA,EAAAE,CAAA,SAAAA,CAAA,IAAAF,CAAA,IAAAA,CAAA,CAAAI,UAAA,SAAAJ,CAAA,eAAAA,CAAA,uBAAAA,CAAA,yBAAAA,CAAA,WAAAK,OAAA,EAAAL,CAAA,QAAAG,CAAA,GAAAJ,wBAAA,CAAAG,CAAA,OAAAC,CAAA,IAAAA,CAAA,CAAAG,GAAA,CAAAN,CAAA,UAAAG,CAAA,CAAAI,GAAA,CAAAP,CAAA,OAAAQ,CAAA,KAAAC,SAAA,UAAAC,CAAA,GAAAC,MAAA,CAAAC,cAAA,IAAAD,MAAA,CAAAE,wBAAA,WAAAC,CAAA,IAAAd,CAAA,oBAAAc,CAAA,OAAAC,cAAA,CAAAC,IAAA,CAAAhB,CAAA,EAAAc,CAAA,SAAAG,CAAA,GAAAP,CAAA,GAAAC,MAAA,CAAAE,wBAAA,CAAAb,CAAA,EAAAc,CAAA,UAAAG,CAAA,KAAAA,CAAA,CAAAV,GAAA,IAAAU,CAAA,CAAAC,GAAA,IAAAP,MAAA,CAAAC,cAAA,CAAAJ,CAAA,EAAAM,CAAA,EAAAG,CAAA,IAAAT,CAAA,CAAAM,CAAA,IAAAd,CAAA,CAAAc,CAAA,YAAAN,CAAA,CAAAH,OAAA,GAAAL,CAAA,EAAAG,CAAA,IAAAA,CAAA,CAAAe,GAAA,CAAAlB,CAAA,EAAAQ,CAAA,GAAAA,CAAA;AAHvC;;;;AAKA;;;;AAIO,MAAMW,QAAQ,GAAAC,OAAA,CAAAD,QAAA,gBAAGvB,MAAM,CAACyB,qBAAqB,CAACC,IAAI,eAAC1B,MAAM,CAAC2B,KAAK,CAAC,UAAU,CAAC,CAAC","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/cjs/EntityType.js b/dist/cjs/EntityType.js
new file mode 100644
index 0000000000000000000000000000000000000000..eca0055353f8145bcfbb2552a381ca1aa750186e
--- /dev/null
+++ b/dist/cjs/EntityType.js
@@ -0,0 +1,19 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.EntityType = void 0;
+var Schema = _interopRequireWildcard(require("effect/Schema"));
+function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
+function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
+/**
+ * @since 1.0.0
+ */
+
+/**
+ * @since 1.0.0
+ * @category constructors
+ */
+const EntityType = exports.EntityType = /*#__PURE__*/Schema.NonEmptyTrimmedString.pipe( /*#__PURE__*/Schema.brand("EntityType"));
+//# sourceMappingURL=EntityType.js.map
\ No newline at end of file
diff --git a/dist/cjs/EntityType.js.map b/dist/cjs/EntityType.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..048797a513e51eea97f59e1d8f2d4fb202adc637
--- /dev/null
+++ b/dist/cjs/EntityType.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"EntityType.js","names":["Schema","_interopRequireWildcard","require","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","EntityType","exports","NonEmptyTrimmedString","pipe","brand"],"sources":["../../src/EntityType.ts"],"sourcesContent":[null],"mappings":";;;;;;AAGA,IAAAA,MAAA,GAAAC,uBAAA,CAAAC,OAAA;AAAuC,SAAAC,yBAAAC,CAAA,6BAAAC,OAAA,mBAAAC,CAAA,OAAAD,OAAA,IAAAE,CAAA,OAAAF,OAAA,YAAAF,wBAAA,YAAAA,CAAAC,CAAA,WAAAA,CAAA,GAAAG,CAAA,GAAAD,CAAA,KAAAF,CAAA;AAAA,SAAAH,wBAAAG,CAAA,EAAAE,CAAA,SAAAA,CAAA,IAAAF,CAAA,IAAAA,CAAA,CAAAI,UAAA,SAAAJ,CAAA,eAAAA,CAAA,uBAAAA,CAAA,yBAAAA,CAAA,WAAAK,OAAA,EAAAL,CAAA,QAAAG,CAAA,GAAAJ,wBAAA,CAAAG,CAAA,OAAAC,CAAA,IAAAA,CAAA,CAAAG,GAAA,CAAAN,CAAA,UAAAG,CAAA,CAAAI,GAAA,CAAAP,CAAA,OAAAQ,CAAA,KAAAC,SAAA,UAAAC,CAAA,GAAAC,MAAA,CAAAC,cAAA,IAAAD,MAAA,CAAAE,wBAAA,WAAAC,CAAA,IAAAd,CAAA,oBAAAc,CAAA,OAAAC,cAAA,CAAAC,IAAA,CAAAhB,CAAA,EAAAc,CAAA,SAAAG,CAAA,GAAAP,CAAA,GAAAC,MAAA,CAAAE,wBAAA,CAAAb,CAAA,EAAAc,CAAA,UAAAG,CAAA,KAAAA,CAAA,CAAAV,GAAA,IAAAU,CAAA,CAAAC,GAAA,IAAAP,MAAA,CAAAC,cAAA,CAAAJ,CAAA,EAAAM,CAAA,EAAAG,CAAA,IAAAT,CAAA,CAAAM,CAAA,IAAAd,CAAA,CAAAc,CAAA,YAAAN,CAAA,CAAAH,OAAA,GAAAL,CAAA,EAAAG,CAAA,IAAAA,CAAA,CAAAe,GAAA,CAAAlB,CAAA,EAAAQ,CAAA,GAAAA,CAAA;AAHvC;;;;AAKA;;;;AAIO,MAAMW,UAAU,GAAAC,OAAA,CAAAD,UAAA,gBAAGvB,MAAM,CAACyB,qBAAqB,CAACC,IAAI,eAAC1B,MAAM,CAAC2B,KAAK,CAAC,YAAY,CAAC,CAAC","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/cjs/Envelope.js b/dist/cjs/Envelope.js
new file mode 100644
index 0000000000000000000000000000000000000000..637b1bda737d5ec52b24a994ac957d077e1b4f8e
--- /dev/null
+++ b/dist/cjs/Envelope.js
@@ -0,0 +1,168 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.primaryKey = exports.makeRequest = exports.isEnvelope = exports.TypeId = exports.RequestFromSelf = exports.PartialEncodedRequestFromSelf = exports.PartialEncodedRequest = exports.PartialEncodedFromSelf = exports.PartialEncodedArray = exports.PartialEncoded = exports.Interrupt = exports.EnvelopeFromSelf = exports.AckChunk = void 0;
+var Headers = _interopRequireWildcard(require("@effect/platform/Headers"));
+var Predicate = _interopRequireWildcard(require("effect/Predicate"));
+var PrimaryKey = _interopRequireWildcard(require("effect/PrimaryKey"));
+var Schema = _interopRequireWildcard(require("effect/Schema"));
+var _EntityAddress = require("./EntityAddress.js");
+var _Snowflake = require("./Snowflake.js");
+function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
+function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
+/**
+ * @since 1.0.0
+ */
+
+/**
+ * @since 1.0.0
+ * @category type ids
+ */
+const TypeId = exports.TypeId = /*#__PURE__*/Symbol.for("@effect/cluster/Envelope");
+/**
+ * @since 1.0.0
+ * @category models
+ */
+class AckChunk extends /*#__PURE__*/Schema.TaggedClass("@effect/cluster/Envelope/AckChunk")("AckChunk", {
+  id: _Snowflake.SnowflakeFromString,
+  address: _EntityAddress.EntityAddress,
+  requestId: _Snowflake.SnowflakeFromString,
+  replyId: _Snowflake.SnowflakeFromString
+}) {
+  /**
+   * @since 1.0.0
+   */
+  [TypeId] = TypeId;
+  /**
+   * @since 1.0.0
+   */
+  withRequestId(requestId) {
+    return new AckChunk({
+      ...this,
+      requestId
+    });
+  }
+}
+/**
+ * @since 1.0.0
+ * @category models
+ */
+exports.AckChunk = AckChunk;
+class Interrupt extends /*#__PURE__*/Schema.TaggedClass("@effect/cluster/Envelope/Interrupt")("Interrupt", {
+  id: _Snowflake.SnowflakeFromString,
+  address: _EntityAddress.EntityAddress,
+  requestId: _Snowflake.SnowflakeFromString
+}) {
+  /**
+   * @since 1.0.0
+   */
+  [TypeId] = TypeId;
+  /**
+   * @since 1.0.0
+   */
+  withRequestId(requestId) {
+    return new Interrupt({
+      ...this,
+      requestId
+    });
+  }
+}
+/**
+ * @since 1.0.0
+ * @category refinements
+ */
+exports.Interrupt = Interrupt;
+const isEnvelope = u => Predicate.hasProperty(u, TypeId);
+/**
+ * @since 1.0.0
+ * @category constructors
+ */
+exports.isEnvelope = isEnvelope;
+const makeRequest = options => ({
+  [TypeId]: TypeId,
+  _tag: "Request",
+  requestId: options.requestId,
+  tag: options.tag,
+  address: options.address,
+  payload: options.payload,
+  headers: options.headers,
+  traceId: options.traceId,
+  spanId: options.spanId,
+  sampled: options.sampled
+});
+/**
+ * @since 1.0.0
+ * @category serialization / deserialization
+ */
+exports.makeRequest = makeRequest;
+const EnvelopeFromSelf = exports.EnvelopeFromSelf = /*#__PURE__*/Schema.declare(isEnvelope, {
+  identifier: "Envelope"
+});
+/**
+ * @since 1.0.0
+ * @category serialization / deserialization
+ */
+const RequestFromSelf = exports.RequestFromSelf = /*#__PURE__*/Schema.declare(u => isEnvelope(u) && u._tag === "Request", {
+  identifier: "Envelope"
+});
+/**
+ * @since 1.0.0
+ * @category serialization / deserialization
+ */
+const PartialEncodedRequest = exports.PartialEncodedRequest = /*#__PURE__*/Schema.Struct({
+  _tag: /*#__PURE__*/Schema.Literal("Request"),
+  requestId: _Snowflake.SnowflakeFromString,
+  address: _EntityAddress.EntityAddress,
+  tag: Schema.String,
+  payload: Schema.Unknown,
+  headers: Headers.schema,
+  traceId: Schema.String,
+  spanId: Schema.String,
+  sampled: Schema.Boolean
+});
+/**
+ * @since 1.0.0
+ * @category serialization / deserialization
+ */
+const PartialEncoded = exports.PartialEncoded = /*#__PURE__*/Schema.Union(PartialEncodedRequest, AckChunk, Interrupt);
+/**
+ * @since 1.0.0
+ * @category serialization / deserialization
+ */
+const PartialEncodedArray = exports.PartialEncodedArray = /*#__PURE__*/Schema.mutable( /*#__PURE__*/Schema.Array(PartialEncoded));
+/**
+ * @since 1.0.0
+ * @category serialization / deserialization
+ */
+const PartialEncodedRequestFromSelf = exports.PartialEncodedRequestFromSelf = /*#__PURE__*/Schema.Struct({
+  _tag: /*#__PURE__*/Schema.Literal("Request"),
+  requestId: /*#__PURE__*/Schema.typeSchema(_Snowflake.SnowflakeFromString),
+  address: _EntityAddress.EntityAddressFromSelf,
+  tag: Schema.String,
+  payload: Schema.Unknown,
+  headers: Headers.schemaFromSelf,
+  traceId: Schema.String,
+  spanId: Schema.String,
+  sampled: Schema.Boolean
+});
+/**
+ * @since 1.0.0
+ * @category serialization / deserialization
+ */
+const PartialEncodedFromSelf = exports.PartialEncodedFromSelf = /*#__PURE__*/Schema.Union(PartialEncodedRequestFromSelf, /*#__PURE__*/Schema.typeSchema(AckChunk), /*#__PURE__*/Schema.typeSchema(Interrupt));
+/**
+ * @since 1.0.0
+ * @category primary key
+ */
+const primaryKey = envelope => {
+  if (envelope._tag !== "Request" || !Predicate.hasProperty(envelope.payload, PrimaryKey.symbol)) {
+    return null;
+  }
+  const value = PrimaryKey.value(envelope.payload);
+  // hash the entity address to save space?
+  return `${envelope.address.entityType}/${envelope.address.entityId}/${envelope.tag}/${value}`;
+};
+exports.primaryKey = primaryKey;
+//# sourceMappingURL=Envelope.js.map
\ No newline at end of file
diff --git a/dist/cjs/Envelope.js.map b/dist/cjs/Envelope.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..14b32d28f945525662b1305a81bb55d64e849e1e
--- /dev/null
+++ b/dist/cjs/Envelope.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"Envelope.js","names":["Headers","_interopRequireWildcard","require","Predicate","PrimaryKey","Schema","_EntityAddress","_Snowflake","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","TypeId","exports","Symbol","for","AckChunk","TaggedClass","id","SnowflakeFromString","address","EntityAddress","requestId","replyId","withRequestId","Interrupt","isEnvelope","hasProperty","makeRequest","options","_tag","tag","payload","headers","traceId","spanId","sampled","EnvelopeFromSelf","declare","identifier","RequestFromSelf","PartialEncodedRequest","Struct","Literal","String","Unknown","schema","Boolean","PartialEncoded","Union","PartialEncodedArray","mutable","Array","PartialEncodedRequestFromSelf","typeSchema","EntityAddressFromSelf","schemaFromSelf","PartialEncodedFromSelf","primaryKey","envelope","symbol","value","entityType","entityId"],"sources":["../../src/Envelope.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/cjs/HttpCommon.js b/dist/cjs/HttpCommon.js
new file mode 100644
index 0000000000000000000000000000000000000000..0f1b790af3f330cfb4074a5b39e151a9232cddf6
--- /dev/null
+++ b/dist/cjs/HttpCommon.js
@@ -0,0 +1,49 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.layerClientProtocolWebsocket = exports.layerClientProtocolHttp = void 0;
+var HttpClient = _interopRequireWildcard(require("@effect/platform/HttpClient"));
+var HttpClientRequest = _interopRequireWildcard(require("@effect/platform/HttpClientRequest"));
+var Socket = _interopRequireWildcard(require("@effect/platform/Socket"));
+var RpcClient = _interopRequireWildcard(require("@effect/rpc/RpcClient"));
+var RpcSerialization = _interopRequireWildcard(require("@effect/rpc/RpcSerialization"));
+var Effect = _interopRequireWildcard(require("effect/Effect"));
+var Layer = _interopRequireWildcard(require("effect/Layer"));
+var _Runners = require("./Runners.js");
+function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
+function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
+/**
+ * @since 1.0.0
+ */
+
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+const layerClientProtocolHttp = options => Layer.effect(_Runners.RpcClientProtocol, Effect.gen(function* () {
+  const serialization = yield* RpcSerialization.RpcSerialization;
+  const client = yield* HttpClient.HttpClient;
+  const https = options.https ?? false;
+  return address => {
+    const clientWithUrl = HttpClient.mapRequest(client, HttpClientRequest.prependUrl(`http${https ? "s" : ""}://${address.host}:${address.port}/${options.path}`));
+    return RpcClient.makeProtocolHttp(clientWithUrl).pipe(Effect.provideService(RpcSerialization.RpcSerialization, serialization));
+  };
+}));
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+exports.layerClientProtocolHttp = layerClientProtocolHttp;
+const layerClientProtocolWebsocket = options => Layer.effect(_Runners.RpcClientProtocol, Effect.gen(function* () {
+  const serialization = yield* RpcSerialization.RpcSerialization;
+  const https = options.https ?? false;
+  const constructor = yield* Socket.WebSocketConstructor;
+  return Effect.fnUntraced(function* (address) {
+    const socket = yield* Socket.makeWebSocket(`ws${https ? "s" : ""}://${address.host}:${address.port}/${options.path}`).pipe(Effect.provideService(Socket.WebSocketConstructor, constructor));
+    return yield* RpcClient.makeProtocolSocket.pipe(Effect.provideService(Socket.Socket, socket), Effect.provideService(RpcSerialization.RpcSerialization, serialization));
+  });
+}));
+exports.layerClientProtocolWebsocket = layerClientProtocolWebsocket;
+//# sourceMappingURL=HttpCommon.js.map
\ No newline at end of file
diff --git a/dist/cjs/HttpCommon.js.map b/dist/cjs/HttpCommon.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..708a7e32508fbab8b2cd03e4e63aa8498d326574
--- /dev/null
+++ b/dist/cjs/HttpCommon.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"HttpCommon.js","names":["HttpClient","_interopRequireWildcard","require","HttpClientRequest","Socket","RpcClient","RpcSerialization","Effect","Layer","_Runners","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","layerClientProtocolHttp","options","effect","RpcClientProtocol","gen","serialization","client","https","address","clientWithUrl","mapRequest","prependUrl","host","port","path","makeProtocolHttp","pipe","provideService","exports","layerClientProtocolWebsocket","constructor","WebSocketConstructor","fnUntraced","socket","makeWebSocket","makeProtocolSocket"],"sources":["../../src/HttpCommon.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/cjs/HttpRunner.js b/dist/cjs/HttpRunner.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3661f53fc4cdac73461e67a44ef28076cc3c711
--- /dev/null
+++ b/dist/cjs/HttpRunner.js
@@ -0,0 +1,108 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.toHttpAppWebsocket = exports.toHttpApp = exports.layerWebsocketOptions = exports.layerWebsocketClientOnly = exports.layerWebsocket = exports.layerHttpClientOnly = exports.layerHttp = exports.layerClient = exports.layer = void 0;
+var HttpRouter = _interopRequireWildcard(require("@effect/platform/HttpRouter"));
+var HttpServer = _interopRequireWildcard(require("@effect/platform/HttpServer"));
+var RpcServer = _interopRequireWildcard(require("@effect/rpc/RpcServer"));
+var Effect = _interopRequireWildcard(require("effect/Effect"));
+var Layer = _interopRequireWildcard(require("effect/Layer"));
+var _HttpCommon = require("./HttpCommon.js");
+var Runners = _interopRequireWildcard(require("./Runners.js"));
+var RunnerServer = _interopRequireWildcard(require("./RunnerServer.js"));
+var Sharding = _interopRequireWildcard(require("./Sharding.js"));
+var ShardManager = _interopRequireWildcard(require("./ShardManager.js"));
+var SynchronizedClock = _interopRequireWildcard(require("./SynchronizedClock.js"));
+function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
+function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
+/**
+ * @since 1.0.0
+ * @category Http App
+ */
+const toHttpApp = exports.toHttpApp = /*#__PURE__*/Effect.gen(function* () {
+  const handlers = yield* Layer.build(RunnerServer.layerHandlers);
+  return yield* RpcServer.toHttpApp(Runners.Rpcs, {
+    spanPrefix: "RunnerServer",
+    disableTracing: true
+  }).pipe(Effect.provide(handlers));
+});
+/**
+ * @since 1.0.0
+ * @category Http App
+ */
+const toHttpAppWebsocket = exports.toHttpAppWebsocket = /*#__PURE__*/Effect.gen(function* () {
+  const handlers = yield* Layer.build(RunnerServer.layerHandlers);
+  return yield* RpcServer.toHttpAppWebsocket(Runners.Rpcs, {
+    spanPrefix: "RunnerServer",
+    disableTracing: true
+  }).pipe(Effect.provide(handlers));
+});
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+const layerClient = exports.layerClient = /*#__PURE__*/Sharding.layer.pipe( /*#__PURE__*/Layer.provideMerge(Runners.layerRpc), /*#__PURE__*/Layer.provideMerge(SynchronizedClock.layer), /*#__PURE__*/Layer.provide(ShardManager.layerClientRpc));
+/**
+ * A HTTP layer for the `Runners` services, that adds a route to the provided
+ * `HttpRouter.Tag`.
+ *
+ * By default, it uses the `HttpRouter.Default` tag.
+ *
+ * @since 1.0.0
+ * @category Layers
+ */
+const layer = options => {
+  const layer = RunnerServer.layerWithClients.pipe(Layer.provide(RpcServer.layerProtocolHttp(options)));
+  return options.logAddress ? withLogAddress(layer) : layer;
+};
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+exports.layer = layer;
+const layerWebsocketOptions = options => {
+  const layer = RunnerServer.layerWithClients.pipe(Layer.provide(RpcServer.layerProtocolWebsocket(options)));
+  return options.logAddress ? withLogAddress(layer) : layer;
+};
+exports.layerWebsocketOptions = layerWebsocketOptions;
+const withLogAddress = layer => Layer.effectDiscard(HttpServer.addressFormattedWith(address => Effect.annotateLogs(Effect.logInfo(`Listening on: ${address}`), {
+  package: "@effect/cluster",
+  service: "Runner"
+}))).pipe(Layer.provideMerge(layer));
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+const layerHttp = exports.layerHttp = /*#__PURE__*/HttpRouter.Default.serve().pipe( /*#__PURE__*/Layer.provideMerge( /*#__PURE__*/layer({
+  path: "/",
+  logAddress: true
+})), /*#__PURE__*/Layer.provide( /*#__PURE__*/(0, _HttpCommon.layerClientProtocolHttp)({
+  path: "/"
+})));
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+const layerHttpClientOnly = exports.layerHttpClientOnly = /*#__PURE__*/RunnerServer.layerClientOnly.pipe( /*#__PURE__*/Layer.provide( /*#__PURE__*/(0, _HttpCommon.layerClientProtocolHttp)({
+  path: "/"
+})));
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+const layerWebsocket = exports.layerWebsocket = /*#__PURE__*/HttpRouter.Default.serve().pipe( /*#__PURE__*/Layer.provideMerge( /*#__PURE__*/layerWebsocketOptions({
+  path: "/",
+  logAddress: true
+})), /*#__PURE__*/Layer.provide( /*#__PURE__*/(0, _HttpCommon.layerClientProtocolWebsocket)({
+  path: "/"
+})));
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+const layerWebsocketClientOnly = exports.layerWebsocketClientOnly = /*#__PURE__*/RunnerServer.layerClientOnly.pipe( /*#__PURE__*/Layer.provide( /*#__PURE__*/(0, _HttpCommon.layerClientProtocolWebsocket)({
+  path: "/"
+})));
+//# sourceMappingURL=HttpRunner.js.map
\ No newline at end of file
diff --git a/dist/cjs/HttpRunner.js.map b/dist/cjs/HttpRunner.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..4ddd2bd7e9439353196a89f33664ca9e57e9e01a
--- /dev/null
+++ b/dist/cjs/HttpRunner.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"HttpRunner.js","names":["HttpRouter","_interopRequireWildcard","require","HttpServer","RpcServer","Effect","Layer","_HttpCommon","Runners","RunnerServer","Sharding","ShardManager","SynchronizedClock","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","toHttpApp","exports","gen","handlers","build","layerHandlers","Rpcs","spanPrefix","disableTracing","pipe","provide","toHttpAppWebsocket","layerClient","layer","provideMerge","layerRpc","layerClientRpc","options","layerWithClients","layerProtocolHttp","logAddress","withLogAddress","layerWebsocketOptions","layerProtocolWebsocket","effectDiscard","addressFormattedWith","address","annotateLogs","logInfo","package","service","layerHttp","Default","serve","path","layerClientProtocolHttp","layerHttpClientOnly","layerClientOnly","layerWebsocket","layerClientProtocolWebsocket","layerWebsocketClientOnly"],"sources":["../../src/HttpRunner.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/cjs/HttpShardManager.js b/dist/cjs/HttpShardManager.js
new file mode 100644
index 0000000000000000000000000000000000000000..3be47290a1ce538e04b55264730071af63be1292
--- /dev/null
+++ b/dist/cjs/HttpShardManager.js
@@ -0,0 +1,140 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.toHttpAppWebsocket = exports.toHttpApp = exports.layerWebsocketOptions = exports.layerWebsocket = exports.layerRunnerHealthWebsocket = exports.layerRunnerHealthHttp = exports.layerNoServerWebsocket = exports.layerNoServerHttp = exports.layerHttpOptions = exports.layerHttp = void 0;
+var HttpRouter = _interopRequireWildcard(require("@effect/platform/HttpRouter"));
+var HttpServer = _interopRequireWildcard(require("@effect/platform/HttpServer"));
+var RpcServer = _interopRequireWildcard(require("@effect/rpc/RpcServer"));
+var Effect = _interopRequireWildcard(require("effect/Effect"));
+var _Function = require("effect/Function");
+var Layer = _interopRequireWildcard(require("effect/Layer"));
+var _HttpCommon = require("./HttpCommon.js");
+var MessageStorage = _interopRequireWildcard(require("./MessageStorage.js"));
+var RunnerHealth = _interopRequireWildcard(require("./RunnerHealth.js"));
+var Runners = _interopRequireWildcard(require("./Runners.js"));
+var ShardManager = _interopRequireWildcard(require("./ShardManager.js"));
+function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
+function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
+/**
+ * @since 1.0.0
+ * @category Http App
+ */
+const toHttpApp = exports.toHttpApp = /*#__PURE__*/Effect.gen(function* () {
+  const handlers = yield* Layer.build(ShardManager.layerServerHandlers);
+  return yield* RpcServer.toHttpApp(ShardManager.Rpcs).pipe(Effect.provide(handlers));
+});
+/**
+ * @since 1.0.0
+ * @category Http App
+ */
+const toHttpAppWebsocket = exports.toHttpAppWebsocket = /*#__PURE__*/Effect.gen(function* () {
+  const handlers = yield* Layer.build(ShardManager.layerServerHandlers);
+  return yield* RpcServer.toHttpAppWebsocket(ShardManager.Rpcs).pipe(Effect.provide(handlers));
+});
+/**
+ * A layer for the `ShardManager` service, that does not run a server.
+ *
+ * It only provides the `Runners` rpc client.
+ *
+ * You can use this with the `toHttpApp` and `toHttpAppWebsocket` apis
+ * to run a complete `ShardManager` server.
+ *
+ * @since 1.0.0
+ * @category Layers
+ */
+const layerNoServerHttp = options => ShardManager.layer.pipe(Layer.provide(Runners.layerRpc.pipe(Layer.provide([(0, _HttpCommon.layerClientProtocolHttp)({
+  path: options.runnerPath,
+  https: options.runnerHttps
+}), MessageStorage.layerNoop]))));
+/**
+ * A layer for the `ShardManager` service, that does not run a server.
+ *
+ * It only provides the `Runners` rpc client.
+ *
+ * You can use this with the `toHttpApp` and `toHttpAppWebsocket` apis
+ * to run a complete `ShardManager` server.
+ *
+ * @since 1.0.0
+ * @category Layers
+ */
+exports.layerNoServerHttp = layerNoServerHttp;
+const layerNoServerWebsocket = options => ShardManager.layer.pipe(Layer.provide(Runners.layerRpc.pipe(Layer.provide([(0, _HttpCommon.layerClientProtocolWebsocket)({
+  path: options.runnerPath,
+  https: options.runnerHttps
+}), MessageStorage.layerNoop]))));
+/**
+ * A HTTP layer for the `ShardManager` server, that adds a route to the provided
+ * `HttpRouter.Tag`.
+ *
+ * By default, it uses the `HttpRouter.Default` tag.
+ *
+ * @since 1.0.0
+ * @category Layers
+ */
+exports.layerNoServerWebsocket = layerNoServerWebsocket;
+const layerHttpOptions = options => {
+  const routerTag = options.routerTag ?? HttpRouter.Default;
+  return routerTag.serve().pipe(options.logAddress ? withLogAddress : _Function.identity, Layer.merge(ShardManager.layerServer), Layer.provide(RpcServer.layerProtocolHttp(options)), Layer.provideMerge(layerNoServerHttp(options)));
+};
+/**
+ * A WebSocket layer for the `ShardManager` server, that adds a route to the provided
+ * `HttpRouter.Tag`.
+ *
+ * By default, it uses the `HttpRouter.Default` tag.
+ *
+ * @since 1.0.0
+ * @category Layers
+ */
+exports.layerHttpOptions = layerHttpOptions;
+const layerWebsocketOptions = options => {
+  const routerTag = options.routerTag ?? HttpRouter.Default;
+  return routerTag.serve().pipe(options.logAddress ? withLogAddress : _Function.identity, Layer.merge(ShardManager.layerServer), Layer.provide(RpcServer.layerProtocolWebsocket(options)), Layer.provideMerge(layerNoServerWebsocket(options)));
+};
+exports.layerWebsocketOptions = layerWebsocketOptions;
+const withLogAddress = layer => Layer.effectDiscard(HttpServer.addressFormattedWith(address => Effect.annotateLogs(Effect.logInfo(`Listening on: ${address}`), {
+  package: "@effect/cluster",
+  service: "ShardManager"
+}))).pipe(Layer.provideMerge(layer));
+/**
+ * A HTTP layer for the `ShardManager` server, that adds a route to the provided
+ * `HttpRouter.Tag`.
+ *
+ * By default, it uses the `HttpRouter.Default` tag.
+ *
+ * @since 1.0.0
+ * @category Layers
+ */
+const layerHttp = exports.layerHttp = /*#__PURE__*/layerHttpOptions({
+  path: "/",
+  runnerPath: "/"
+});
+/**
+ * A Websocket layer for the `ShardManager` server, that adds a route to the provided
+ * `HttpRouter.Tag`.
+ *
+ * By default, it uses the `HttpRouter.Default` tag.
+ *
+ * @since 1.0.0
+ * @category Layers
+ */
+const layerWebsocket = exports.layerWebsocket = /*#__PURE__*/layerWebsocketOptions({
+  path: "/",
+  runnerPath: "/"
+});
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+const layerRunnerHealthHttp = exports.layerRunnerHealthHttp = /*#__PURE__*/Layer.provide(RunnerHealth.layerRpc, /*#__PURE__*/(0, _HttpCommon.layerClientProtocolHttp)({
+  path: "/"
+}));
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+const layerRunnerHealthWebsocket = exports.layerRunnerHealthWebsocket = /*#__PURE__*/Layer.provide(RunnerHealth.layerRpc, /*#__PURE__*/(0, _HttpCommon.layerClientProtocolWebsocket)({
+  path: "/"
+}));
+//# sourceMappingURL=HttpShardManager.js.map
\ No newline at end of file
diff --git a/dist/cjs/HttpShardManager.js.map b/dist/cjs/HttpShardManager.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..668349be3364a599434532ea316c40006d764d77
--- /dev/null
+++ b/dist/cjs/HttpShardManager.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"HttpShardManager.js","names":["HttpRouter","_interopRequireWildcard","require","HttpServer","RpcServer","Effect","_Function","Layer","_HttpCommon","MessageStorage","RunnerHealth","Runners","ShardManager","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","toHttpApp","exports","gen","handlers","build","layerServerHandlers","Rpcs","pipe","provide","toHttpAppWebsocket","layerNoServerHttp","options","layer","layerRpc","layerClientProtocolHttp","path","runnerPath","https","runnerHttps","layerNoop","layerNoServerWebsocket","layerClientProtocolWebsocket","layerHttpOptions","routerTag","Default","serve","logAddress","withLogAddress","identity","merge","layerServer","layerProtocolHttp","provideMerge","layerWebsocketOptions","layerProtocolWebsocket","effectDiscard","addressFormattedWith","address","annotateLogs","logInfo","package","service","layerHttp","layerWebsocket","layerRunnerHealthHttp","layerRunnerHealthWebsocket"],"sources":["../../src/HttpShardManager.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/cjs/MachineId.js b/dist/cjs/MachineId.js
new file mode 100644
index 0000000000000000000000000000000000000000..31fac00fb72cc78ac8bd6d17267480afe0554538
--- /dev/null
+++ b/dist/cjs/MachineId.js
@@ -0,0 +1,27 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.make = exports.MachineId = void 0;
+var Schema = _interopRequireWildcard(require("effect/Schema"));
+function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
+function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
+/**
+ * @since 1.0.0
+ */
+
+/**
+ * @since 1.0.0
+ * @category constructors
+ */
+const MachineId = exports.MachineId = /*#__PURE__*/Schema.Int.pipe( /*#__PURE__*/Schema.brand("MachineId"), /*#__PURE__*/Schema.annotations({
+  pretty: () => machineId => `MachineId(${machineId})`
+}));
+/**
+ * @since 1.0.0
+ * @category Constructors
+ */
+const make = shardId => MachineId.make(shardId);
+exports.make = make;
+//# sourceMappingURL=MachineId.js.map
\ No newline at end of file
diff --git a/dist/cjs/MachineId.js.map b/dist/cjs/MachineId.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..e976323d9ceb1cc2aa49de9b1c9e6cfd524df50d
--- /dev/null
+++ b/dist/cjs/MachineId.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"MachineId.js","names":["Schema","_interopRequireWildcard","require","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","MachineId","exports","Int","pipe","brand","annotations","pretty","machineId","make","shardId"],"sources":["../../src/MachineId.ts"],"sourcesContent":[null],"mappings":";;;;;;AAGA,IAAAA,MAAA,GAAAC,uBAAA,CAAAC,OAAA;AAAuC,SAAAC,yBAAAC,CAAA,6BAAAC,OAAA,mBAAAC,CAAA,OAAAD,OAAA,IAAAE,CAAA,OAAAF,OAAA,YAAAF,wBAAA,YAAAA,CAAAC,CAAA,WAAAA,CAAA,GAAAG,CAAA,GAAAD,CAAA,KAAAF,CAAA;AAAA,SAAAH,wBAAAG,CAAA,EAAAE,CAAA,SAAAA,CAAA,IAAAF,CAAA,IAAAA,CAAA,CAAAI,UAAA,SAAAJ,CAAA,eAAAA,CAAA,uBAAAA,CAAA,yBAAAA,CAAA,WAAAK,OAAA,EAAAL,CAAA,QAAAG,CAAA,GAAAJ,wBAAA,CAAAG,CAAA,OAAAC,CAAA,IAAAA,CAAA,CAAAG,GAAA,CAAAN,CAAA,UAAAG,CAAA,CAAAI,GAAA,CAAAP,CAAA,OAAAQ,CAAA,KAAAC,SAAA,UAAAC,CAAA,GAAAC,MAAA,CAAAC,cAAA,IAAAD,MAAA,CAAAE,wBAAA,WAAAC,CAAA,IAAAd,CAAA,oBAAAc,CAAA,OAAAC,cAAA,CAAAC,IAAA,CAAAhB,CAAA,EAAAc,CAAA,SAAAG,CAAA,GAAAP,CAAA,GAAAC,MAAA,CAAAE,wBAAA,CAAAb,CAAA,EAAAc,CAAA,UAAAG,CAAA,KAAAA,CAAA,CAAAV,GAAA,IAAAU,CAAA,CAAAC,GAAA,IAAAP,MAAA,CAAAC,cAAA,CAAAJ,CAAA,EAAAM,CAAA,EAAAG,CAAA,IAAAT,CAAA,CAAAM,CAAA,IAAAd,CAAA,CAAAc,CAAA,YAAAN,CAAA,CAAAH,OAAA,GAAAL,CAAA,EAAAG,CAAA,IAAAA,CAAA,CAAAe,GAAA,CAAAlB,CAAA,EAAAQ,CAAA,GAAAA,CAAA;AAHvC;;;;AAKA;;;;AAIO,MAAMW,SAAS,GAAAC,OAAA,CAAAD,SAAA,gBAAGvB,MAAM,CAACyB,GAAG,CAACC,IAAI,eACtC1B,MAAM,CAAC2B,KAAK,CAAC,WAAW,CAAC,eACzB3B,MAAM,CAAC4B,WAAW,CAAC;EACjBC,MAAM,EAAEA,CAAA,KAAOC,SAAS,IAAK,aAAaA,SAAS;CACpD,CAAC,CACH;AAQD;;;;AAIO,MAAMC,IAAI,GAAIC,OAAe,IAAgBT,SAAS,CAACQ,IAAI,CAACC,OAAO,CAAC;AAAAR,OAAA,CAAAO,IAAA,GAAAA,IAAA","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/cjs/Message.js b/dist/cjs/Message.js
index ffee881b70194e431c36fbae04feb23b5908c444..ed70cfc9310b06d42de606ac134fe7c8978eaaec 100644
--- a/dist/cjs/Message.js
+++ b/dist/cjs/Message.js
@@ -3,39 +3,120 @@
 Object.defineProperty(exports, "__esModule", {
   value: true
 });
-exports.successSchema = exports.isMessageWithResult = exports.failureSchema = exports.exitSchema = exports.TaggedMessage = void 0;
-var internal = _interopRequireWildcard(require("./internal/message.js"));
+exports.serializeRequest = exports.serializeEnvelope = exports.serialize = exports.incomingLocalFromOutgoing = exports.deserializeLocal = exports.OutgoingRequest = exports.OutgoingEnvelope = exports.IncomingRequestLocal = exports.IncomingRequest = exports.IncomingEnvelope = void 0;
+var _effect = require("effect");
+var Data = _interopRequireWildcard(require("effect/Data"));
+var Effect = _interopRequireWildcard(require("effect/Effect"));
+var Option = _interopRequireWildcard(require("effect/Option"));
+var Schema = _interopRequireWildcard(require("effect/Schema"));
+var _ClusterError = require("./ClusterError.js");
+var Envelope = _interopRequireWildcard(require("./Envelope.js"));
 function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
 function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
 /**
  * @since 1.0.0
- * @category schemas
+ * @category incoming
  */
-const TaggedMessage = exports.TaggedMessage = internal.TaggedMessage_;
+const incomingLocalFromOutgoing = self => {
+  if (self._tag === "OutgoingEnvelope") {
+    return new IncomingEnvelope({
+      envelope: self.envelope
+    });
+  }
+  return new IncomingRequestLocal({
+    envelope: self.envelope,
+    respond: self.respond,
+    lastSentReply: Option.none()
+  });
+};
 /**
  * @since 1.0.0
- * @category utils
+ * @category incoming
  */
-const isMessageWithResult = exports.isMessageWithResult = internal.isMessageWithResult;
+exports.incomingLocalFromOutgoing = incomingLocalFromOutgoing;
+class IncomingRequest extends /*#__PURE__*/Data.TaggedClass("IncomingRequest") {}
 /**
- * Extracts the exit schema from a Message. This schema will be used to encode the remote exit of the Message processor.
- *
  * @since 1.0.0
- * @category utils
+ * @category outgoing
  */
-const exitSchema = exports.exitSchema = internal.exitSchema;
+exports.IncomingRequest = IncomingRequest;
+class IncomingRequestLocal extends /*#__PURE__*/Data.TaggedClass("IncomingRequestLocal") {}
 /**
- * Extracts the failure schema from a Message. This schema will be used to encode remote failures of the Message processor.
- *
  * @since 1.0.0
- * @category utils
+ * @category incoming
  */
-const failureSchema = exports.failureSchema = internal.failureSchema;
+exports.IncomingRequestLocal = IncomingRequestLocal;
+class IncomingEnvelope extends /*#__PURE__*/Data.TaggedClass("IncomingEnvelope") {}
 /**
- * Extracts the success schema from a Message. This schema will be used to encode the remote success of the Message processor.
- *
  * @since 1.0.0
- * @category utils
+ * @category outgoing
  */
-const successSchema = exports.successSchema = internal.successSchema;
+exports.IncomingEnvelope = IncomingEnvelope;
+class OutgoingRequest extends /*#__PURE__*/Data.TaggedClass("OutgoingRequest") {
+  /**
+   * @since 1.0.0
+   */
+  encodedCache;
+}
+/**
+ * @since 1.0.0
+ * @category outgoing
+ */
+exports.OutgoingRequest = OutgoingRequest;
+class OutgoingEnvelope extends /*#__PURE__*/Data.TaggedClass("OutgoingEnvelope") {}
+/**
+ * @since 1.0.0
+ * @category serialization / deserialization
+ */
+exports.OutgoingEnvelope = OutgoingEnvelope;
+const serialize = message => {
+  if (message._tag !== "OutgoingRequest") {
+    return Effect.succeed(message.envelope);
+  }
+  return Effect.suspend(() => message.encodedCache ? Effect.succeed(message.encodedCache) : serializeRequest(message));
+};
+/**
+ * @since 1.0.0
+ * @category serialization / deserialization
+ */
+exports.serialize = serialize;
+const serializeEnvelope = message => Effect.flatMap(serialize(message), envelope => _ClusterError.MalformedMessage.refail(Schema.encode(Envelope.PartialEncoded)(envelope)));
+/**
+ * @since 1.0.0
+ * @category serialization / deserialization
+ */
+exports.serializeEnvelope = serializeEnvelope;
+const serializeRequest = self => {
+  const rpc = self.rpc;
+  return Schema.encode(rpc.payloadSchema)(self.envelope.payload).pipe(Effect.locally(_effect.FiberRef.currentContext, self.context), _ClusterError.MalformedMessage.refail, Effect.map(payload => ({
+    ...self.envelope,
+    payload
+  })));
+};
+/**
+ * @since 1.0.0
+ * @category serialization / deserialization
+ */
+exports.serializeRequest = serializeRequest;
+const deserializeLocal = (self, encoded) => {
+  if (encoded._tag !== "Request") {
+    return Effect.succeed(new IncomingEnvelope({
+      envelope: encoded
+    }));
+  } else if (self._tag !== "OutgoingRequest") {
+    return Effect.fail(new _ClusterError.MalformedMessage({
+      cause: new Error("Can only deserialize a Request with an OutgoingRequest message")
+    }));
+  }
+  const rpc = self.rpc;
+  return Schema.decode(rpc.payloadSchema)(encoded.payload).pipe(Effect.locally(_effect.FiberRef.currentContext, self.context), _ClusterError.MalformedMessage.refail, Effect.map(payload => new IncomingRequestLocal({
+    envelope: Envelope.makeRequest({
+      ...encoded,
+      payload
+    }),
+    lastSentReply: Option.none(),
+    respond: self.respond
+  })));
+};
+exports.deserializeLocal = deserializeLocal;
 //# sourceMappingURL=Message.js.map
\ No newline at end of file
diff --git a/dist/cjs/Message.js.map b/dist/cjs/Message.js.map
index 0a9e2b20ff18a0787c1a1f8b0e2bdc8d48729ca2..032e6b4334ffa79c912afd28f1c7bea6eb17adf2 100644
--- a/dist/cjs/Message.js.map
+++ b/dist/cjs/Message.js.map
@@ -1 +1 @@
-{"version":3,"file":"Message.js","names":["internal","_interopRequireWildcard","require","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","TaggedMessage","exports","TaggedMessage_","isMessageWithResult","exitSchema","failureSchema","successSchema"],"sources":["../../src/Message.ts"],"sourcesContent":[null],"mappings":";;;;;;AAOA,IAAAA,QAAA,GAAAC,uBAAA,CAAAC,OAAA;AAAiD,SAAAC,yBAAAC,CAAA,6BAAAC,OAAA,mBAAAC,CAAA,OAAAD,OAAA,IAAAE,CAAA,OAAAF,OAAA,YAAAF,wBAAA,YAAAA,CAAAC,CAAA,WAAAA,CAAA,GAAAG,CAAA,GAAAD,CAAA,KAAAF,CAAA;AAAA,SAAAH,wBAAAG,CAAA,EAAAE,CAAA,SAAAA,CAAA,IAAAF,CAAA,IAAAA,CAAA,CAAAI,UAAA,SAAAJ,CAAA,eAAAA,CAAA,uBAAAA,CAAA,yBAAAA,CAAA,WAAAK,OAAA,EAAAL,CAAA,QAAAG,CAAA,GAAAJ,wBAAA,CAAAG,CAAA,OAAAC,CAAA,IAAAA,CAAA,CAAAG,GAAA,CAAAN,CAAA,UAAAG,CAAA,CAAAI,GAAA,CAAAP,CAAA,OAAAQ,CAAA,KAAAC,SAAA,UAAAC,CAAA,GAAAC,MAAA,CAAAC,cAAA,IAAAD,MAAA,CAAAE,wBAAA,WAAAC,CAAA,IAAAd,CAAA,oBAAAc,CAAA,OAAAC,cAAA,CAAAC,IAAA,CAAAhB,CAAA,EAAAc,CAAA,SAAAG,CAAA,GAAAP,CAAA,GAAAC,MAAA,CAAAE,wBAAA,CAAAb,CAAA,EAAAc,CAAA,UAAAG,CAAA,KAAAA,CAAA,CAAAV,GAAA,IAAAU,CAAA,CAAAC,GAAA,IAAAP,MAAA,CAAAC,cAAA,CAAAJ,CAAA,EAAAM,CAAA,EAAAG,CAAA,IAAAT,CAAA,CAAAM,CAAA,IAAAd,CAAA,CAAAc,CAAA,YAAAN,CAAA,CAAAH,OAAA,GAAAL,CAAA,EAAAG,CAAA,IAAAA,CAAA,CAAAe,GAAA,CAAAlB,CAAA,EAAAQ,CAAA,GAAAA,CAAA;AAoFjD;;;;AAIO,MAAMW,aAAa,GAAAC,OAAA,CAAAD,aAAA,GAAGvB,QAAQ,CAACyB,cAAc;AAEpD;;;;AAIO,MAAMC,mBAAmB,GAAAF,OAAA,CAAAE,mBAAA,GAC9B1B,QAAQ,CAAC0B,mBAAmB;AAE9B;;;;;;AAMO,MAAMC,UAAU,GAAAH,OAAA,CAAAG,UAAA,GAEwB3B,QAAQ,CAAC2B,UAAU;AAElE;;;;;;AAMO,MAAMC,aAAa,GAAAJ,OAAA,CAAAI,aAAA,GAEsB5B,QAAQ,CAAC4B,aAAa;AAEtE;;;;;;AAMO,MAAMC,aAAa,GAAAL,OAAA,CAAAK,aAAA,GAEwB7B,QAAQ,CAAC6B,aAAa","ignoreList":[]}
\ No newline at end of file
+{"version":3,"file":"Message.js","names":["_effect","require","Data","_interopRequireWildcard","Effect","Option","Schema","_ClusterError","Envelope","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","incomingLocalFromOutgoing","self","_tag","IncomingEnvelope","envelope","IncomingRequestLocal","respond","lastSentReply","none","exports","IncomingRequest","TaggedClass","OutgoingRequest","encodedCache","OutgoingEnvelope","serialize","message","succeed","suspend","serializeRequest","serializeEnvelope","flatMap","MalformedMessage","refail","encode","PartialEncoded","rpc","payloadSchema","payload","pipe","locally","FiberRef","currentContext","context","map","deserializeLocal","encoded","fail","cause","Error","decode","makeRequest"],"sources":["../../src/Message.ts"],"sourcesContent":[null],"mappings":";;;;;;AAIA,IAAAA,OAAA,GAAAC,OAAA;AAEA,IAAAC,IAAA,GAAAC,uBAAA,CAAAF,OAAA;AACA,IAAAG,MAAA,GAAAD,uBAAA,CAAAF,OAAA;AACA,IAAAI,MAAA,GAAAF,uBAAA,CAAAF,OAAA;AACA,IAAAK,MAAA,GAAAH,uBAAA,CAAAF,OAAA;AAEA,IAAAM,aAAA,GAAAN,OAAA;AACA,IAAAO,QAAA,GAAAL,uBAAA,CAAAF,OAAA;AAAyC,SAAAQ,yBAAAC,CAAA,6BAAAC,OAAA,mBAAAC,CAAA,OAAAD,OAAA,IAAAE,CAAA,OAAAF,OAAA,YAAAF,wBAAA,YAAAA,CAAAC,CAAA,WAAAA,CAAA,GAAAG,CAAA,GAAAD,CAAA,KAAAF,CAAA;AAAA,SAAAP,wBAAAO,CAAA,EAAAE,CAAA,SAAAA,CAAA,IAAAF,CAAA,IAAAA,CAAA,CAAAI,UAAA,SAAAJ,CAAA,eAAAA,CAAA,uBAAAA,CAAA,yBAAAA,CAAA,WAAAK,OAAA,EAAAL,CAAA,QAAAG,CAAA,GAAAJ,wBAAA,CAAAG,CAAA,OAAAC,CAAA,IAAAA,CAAA,CAAAG,GAAA,CAAAN,CAAA,UAAAG,CAAA,CAAAI,GAAA,CAAAP,CAAA,OAAAQ,CAAA,KAAAC,SAAA,UAAAC,CAAA,GAAAC,MAAA,CAAAC,cAAA,IAAAD,MAAA,CAAAE,wBAAA,WAAAC,CAAA,IAAAd,CAAA,oBAAAc,CAAA,OAAAC,cAAA,CAAAC,IAAA,CAAAhB,CAAA,EAAAc,CAAA,SAAAG,CAAA,GAAAP,CAAA,GAAAC,MAAA,CAAAE,wBAAA,CAAAb,CAAA,EAAAc,CAAA,UAAAG,CAAA,KAAAA,CAAA,CAAAV,GAAA,IAAAU,CAAA,CAAAC,GAAA,IAAAP,MAAA,CAAAC,cAAA,CAAAJ,CAAA,EAAAM,CAAA,EAAAG,CAAA,IAAAT,CAAA,CAAAM,CAAA,IAAAd,CAAA,CAAAc,CAAA,YAAAN,CAAA,CAAAH,OAAA,GAAAL,CAAA,EAAAG,CAAA,IAAAA,CAAA,CAAAe,GAAA,CAAAlB,CAAA,EAAAQ,CAAA,GAAAA,CAAA;AAezC;;;;AAIO,MAAMW,yBAAyB,GAAuBC,IAAiB,IAAsB;EAClG,IAAIA,IAAI,CAACC,IAAI,KAAK,kBAAkB,EAAE;IACpC,OAAO,IAAIC,gBAAgB,CAAC;MAAEC,QAAQ,EAAEH,IAAI,CAACG;IAAQ,CAAE,CAAC;EAC1D;EACA,OAAO,IAAIC,oBAAoB,CAAC;IAC9BD,QAAQ,EAAEH,IAAI,CAACG,QAAQ;IACvBE,OAAO,EAAEL,IAAI,CAACK,OAAO;IACrBC,aAAa,EAAE/B,MAAM,CAACgC,IAAI;GAC3B,CAAC;AACJ,CAAC;AAED;;;;AAAAC,OAAA,CAAAT,yBAAA,GAAAA,yBAAA;AAIM,MAAOU,eAAmC,sBAAQrC,IAAI,CAACsC,WAAW,CAAC,iBAAiB,CAIxF;AAEF;;;;AAAAF,OAAA,CAAAC,eAAA,GAAAA,eAAA;AAIM,MAAOL,oBAAwC,sBAAQhC,IAAI,CAACsC,WAAW,CAAC,sBAAsB,CAIlG;AAEF;;;;AAAAF,OAAA,CAAAJ,oBAAA,GAAAA,oBAAA;AAIM,MAAOF,gBAAiB,sBAAQ9B,IAAI,CAACsC,WAAW,CAAC,kBAAkB,CAGvE;AAQF;;;;AAAAF,OAAA,CAAAN,gBAAA,GAAAA,gBAAA;AAIM,MAAOS,eAAmC,sBAAQvC,IAAI,CAACsC,WAAW,CAAC,iBAAiB,CAMxF;EACA;;;EAGOE,YAAY;;AAGrB;;;;AAAAJ,OAAA,CAAAG,eAAA,GAAAA,eAAA;AAIM,MAAOE,gBAAiB,sBAAQzC,IAAI,CAACsC,WAAW,CAAC,kBAAkB,CAGvE;AAEF;;;;AAAAF,OAAA,CAAAK,gBAAA,GAAAA,gBAAA;AAIO,MAAMC,SAAS,GACpBC,OAAsB,IAC+C;EACrE,IAAIA,OAAO,CAACd,IAAI,KAAK,iBAAiB,EAAE;IACtC,OAAO3B,MAAM,CAAC0C,OAAO,CAACD,OAAO,CAACZ,QAAQ,CAAC;EACzC;EACA,OAAO7B,MAAM,CAAC2C,OAAO,CAAC,MACpBF,OAAO,CAACH,YAAY,GAChBtC,MAAM,CAAC0C,OAAO,CAACD,OAAO,CAACH,YAAY,CAAC,GACpCM,gBAAgB,CAACH,OAAO,CAAC,CAC9B;AACH,CAAC;AAED;;;;AAAAP,OAAA,CAAAM,SAAA,GAAAA,SAAA;AAIO,MAAMK,iBAAiB,GAC5BJ,OAAsB,IAEtBzC,MAAM,CAAC8C,OAAO,CACZN,SAAS,CAACC,OAAO,CAAC,EACjBZ,QAAQ,IAAKkB,8BAAgB,CAACC,MAAM,CAAC9C,MAAM,CAAC+C,MAAM,CAAC7C,QAAQ,CAAC8C,cAAc,CAAC,CAACrB,QAAQ,CAAC,CAAC,CACxF;AAEH;;;;AAAAK,OAAA,CAAAW,iBAAA,GAAAA,iBAAA;AAIO,MAAMD,gBAAgB,GAC3BlB,IAA0B,IAC0C;EACpE,MAAMyB,GAAG,GAAGzB,IAAI,CAACyB,GAA8B;EAC/C,OAAOjD,MAAM,CAAC+C,MAAM,CAACE,GAAG,CAACC,aAAa,CAAC,CAAC1B,IAAI,CAACG,QAAQ,CAACwB,OAAO,CAAC,CAACC,IAAI,CACjEtD,MAAM,CAACuD,OAAO,CAACC,gBAAQ,CAACC,cAAc,EAAE/B,IAAI,CAACgC,OAAO,CAAC,EACrDX,8BAAgB,CAACC,MAAM,EACvBhD,MAAM,CAAC2D,GAAG,CAAEN,OAAO,KAAM;IACvB,GAAG3B,IAAI,CAACG,QAAQ;IAChBwB;GACD,CAAC,CAAC,CACuE;AAC9E,CAAC;AAED;;;;AAAAnB,OAAA,CAAAU,gBAAA,GAAAA,gBAAA;AAIO,MAAMgB,gBAAgB,GAAGA,CAC9BlC,IAAmB,EACnBmC,OAAyC,KAIvC;EACF,IAAIA,OAAO,CAAClC,IAAI,KAAK,SAAS,EAAE;IAC9B,OAAO3B,MAAM,CAAC0C,OAAO,CAAC,IAAId,gBAAgB,CAAC;MAAEC,QAAQ,EAAEgC;IAAO,CAAE,CAAC,CAAC;EACpE,CAAC,MAAM,IAAInC,IAAI,CAACC,IAAI,KAAK,iBAAiB,EAAE;IAC1C,OAAO3B,MAAM,CAAC8D,IAAI,CAChB,IAAIf,8BAAgB,CAAC;MAAEgB,KAAK,EAAE,IAAIC,KAAK,CAAC,gEAAgE;IAAC,CAAE,CAAC,CAC7G;EACH;EACA,MAAMb,GAAG,GAAGzB,IAAI,CAACyB,GAA8B;EAC/C,OAAOjD,MAAM,CAAC+D,MAAM,CAACd,GAAG,CAACC,aAAa,CAAC,CAACS,OAAO,CAACR,OAAO,CAAC,CAACC,IAAI,CAC3DtD,MAAM,CAACuD,OAAO,CAACC,gBAAQ,CAACC,cAAc,EAAE/B,IAAI,CAACgC,OAAO,CAAC,EACrDX,8BAAgB,CAACC,MAAM,EACvBhD,MAAM,CAAC2D,GAAG,CAAEN,OAAO,IACjB,IAAIvB,oBAAoB,CAAC;IACvBD,QAAQ,EAAEzB,QAAQ,CAAC8D,WAAW,CAAC;MAC7B,GAAGL,OAAO;MACVR;KACM,CAAC;IACTrB,aAAa,EAAE/B,MAAM,CAACgC,IAAI,EAAE;IAC5BF,OAAO,EAAEL,IAAI,CAACK;GACf,CAAC,CACH,CAC4D;AACjE,CAAC;AAAAG,OAAA,CAAA0B,gBAAA,GAAAA,gBAAA","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/cjs/MessageStorage.js b/dist/cjs/MessageStorage.js
new file mode 100644
index 0000000000000000000000000000000000000000..d647f4f5333ba2b55fc91bab97a0e3a0aeca5e30
--- /dev/null
+++ b/dist/cjs/MessageStorage.js
@@ -0,0 +1,356 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.noop = exports.makeEncoded = exports.make = exports.layerNoop = exports.layerMemory = exports.SaveResultEncoded = exports.SaveResult = exports.MessageStorage = exports.MemoryDriver = void 0;
+var Arr = _interopRequireWildcard(require("effect/Array"));
+var Context = _interopRequireWildcard(require("effect/Context"));
+var Data = _interopRequireWildcard(require("effect/Data"));
+var Effect = _interopRequireWildcard(require("effect/Effect"));
+var Exit = _interopRequireWildcard(require("effect/Exit"));
+var FiberRef = _interopRequireWildcard(require("effect/FiberRef"));
+var _GlobalValue = require("effect/GlobalValue");
+var Iterable = _interopRequireWildcard(require("effect/Iterable"));
+var Layer = _interopRequireWildcard(require("effect/Layer"));
+var Option = _interopRequireWildcard(require("effect/Option"));
+var Schema = _interopRequireWildcard(require("effect/Schema"));
+var _ClusterError = require("./ClusterError.js");
+var DeliverAt = _interopRequireWildcard(require("./DeliverAt.js"));
+var Envelope = _interopRequireWildcard(require("./Envelope.js"));
+var Message = _interopRequireWildcard(require("./Message.js"));
+var Reply = _interopRequireWildcard(require("./Reply.js"));
+var Snowflake = _interopRequireWildcard(require("./Snowflake.js"));
+function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
+function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
+/**
+ * @since 1.0.0
+ * @category context
+ */
+class MessageStorage extends /*#__PURE__*/Context.Tag("@effect/cluster/MessageStorage")() {}
+/**
+ * @since 1.0.0
+ * @category SaveResult
+ */
+exports.MessageStorage = MessageStorage;
+const SaveResult = exports.SaveResult = /*#__PURE__*/Data.taggedEnum();
+/**
+ * @since 1.0.0
+ * @category SaveResult
+ */
+const SaveResultEncoded = exports.SaveResultEncoded = /*#__PURE__*/Data.taggedEnum();
+/**
+ * @since 1.0.0
+ * @category constructors
+ */
+const make = storage => Effect.sync(() => {
+  const replyHandlers = new Map();
+  return MessageStorage.of({
+    ...storage,
+    registerReplyHandler: message => Effect.sync(() => {
+      replyHandlers.set(message.envelope.requestId, message.respond);
+    }),
+    saveReply(reply) {
+      return Effect.flatMap(storage.saveReply(reply), () => {
+        const handler = replyHandlers.get(reply.reply.requestId);
+        if (!handler) {
+          return Effect.void;
+        } else if (reply.reply._tag === "WithExit") {
+          replyHandlers.delete(reply.reply.requestId);
+        }
+        return handler(reply.reply);
+      });
+    }
+  });
+});
+/**
+ * @since 1.0.0
+ * @category constructors
+ */
+exports.make = make;
+const makeEncoded = exports.makeEncoded = /*#__PURE__*/Effect.fnUntraced(function* (encoded) {
+  const snowflakeGen = yield* Snowflake.Generator;
+  const clock = yield* Effect.clock;
+  const storage = yield* make({
+    saveRequest: message => Message.serializeEnvelope(message).pipe(Effect.flatMap(envelope => encoded.saveEnvelope({
+      envelope,
+      primaryKey: Envelope.primaryKey(message.envelope),
+      deliverAt: DeliverAt.toMillis(message.envelope.payload)
+    })), Effect.flatMap(result => {
+      if (result._tag === "Success" || result.lastReceivedReply._tag === "None") {
+        return Effect.succeed(result);
+      }
+      const duplicate = result;
+      const schema = Reply.Reply(message.rpc);
+      return Schema.decode(schema)(result.lastReceivedReply.value).pipe(Effect.locally(FiberRef.currentContext, message.context), _ClusterError.MalformedMessage.refail, Effect.map(reply => SaveResult.Duplicate({
+        originalId: duplicate.originalId,
+        lastReceivedReply: Option.some(reply)
+      })));
+    })),
+    saveEnvelope: message => Message.serializeEnvelope(message).pipe(Effect.flatMap(envelope => encoded.saveEnvelope({
+      envelope,
+      primaryKey: null,
+      deliverAt: null
+    })), Effect.asVoid),
+    saveReply: reply => Effect.flatMap(Reply.serialize(reply), encoded.saveReply),
+    repliesFor: Effect.fnUntraced(function* (messages) {
+      const requestIds = Arr.empty();
+      const map = new Map();
+      for (const message of messages) {
+        const id = String(message.envelope.requestId);
+        requestIds.push(id);
+        map.set(id, message);
+      }
+      if (requestIds.length === 0) return [];
+      const encodedReplies = yield* encoded.repliesFor(requestIds);
+      return yield* decodeReplies(map, encodedReplies);
+    }),
+    unprocessedMessages: shardIds => {
+      const shards = Array.from(shardIds);
+      if (shards.length === 0) return Effect.succeed([]);
+      return Effect.flatMap(Effect.suspend(() => encoded.unprocessedMessages(shards, clock.unsafeCurrentTimeMillis())), decodeMessages);
+    },
+    unprocessedMessagesById(messageIds) {
+      const ids = Array.from(messageIds);
+      if (ids.length === 0) return Effect.succeed([]);
+      return Effect.flatMap(Effect.suspend(() => encoded.unprocessedMessagesById(ids, clock.unsafeCurrentTimeMillis())), decodeMessages);
+    },
+    resetAddress: address => encoded.resetAddress(address)
+  });
+  const decodeMessages = envelopes => {
+    const messages = [];
+    let index = 0;
+    // if we have a malformed message, we should not return it and update
+    // the storage with a defect
+    const decodeMessage = Effect.catchAll(Effect.suspend(() => {
+      const envelope = envelopes[index];
+      if (!envelope) return Effect.succeed(undefined);
+      return decodeEnvelopeWithReply(envelope);
+    }), error => {
+      const envelope = envelopes[index];
+      return storage.saveReply(Reply.ReplyWithContext.fromDefect({
+        id: snowflakeGen.unsafeNext(),
+        requestId: Snowflake.Snowflake(envelope.envelope.requestId),
+        defect: error.toString()
+      })).pipe(Effect.forkDaemon, Effect.asVoid);
+    });
+    return Effect.as(Effect.whileLoop({
+      while: () => index < envelopes.length,
+      body: () => decodeMessage,
+      step: message => {
+        const envelope = envelopes[index++];
+        if (!message) return;
+        messages.push(message.envelope._tag === "Request" ? new Message.IncomingRequest({
+          envelope: message.envelope,
+          lastSentReply: envelope.lastSentReply,
+          respond: storage.saveReply
+        }) : new Message.IncomingEnvelope({
+          envelope: message.envelope
+        }));
+      }
+    }), messages);
+  };
+  const decodeReplies = (messages, encodedReplies) => {
+    const replies = [];
+    const ignoredRequests = new Set();
+    let index = 0;
+    const decodeReply = Effect.catchAll(Effect.suspend(() => {
+      const reply = encodedReplies[index];
+      if (ignoredRequests.has(reply.requestId)) return Effect.void;
+      const message = messages.get(reply.requestId);
+      if (!message) return Effect.void;
+      const schema = Reply.Reply(message.rpc);
+      return Schema.decode(schema)(reply).pipe(Effect.locally(FiberRef.currentContext, message.context));
+    }), error => {
+      const reply = encodedReplies[index];
+      ignoredRequests.add(reply.requestId);
+      return Effect.succeed(new Reply.WithExit({
+        id: snowflakeGen.unsafeNext(),
+        requestId: Snowflake.Snowflake(reply.requestId),
+        exit: Exit.die(error)
+      }));
+    });
+    return Effect.as(Effect.whileLoop({
+      while: () => index < encodedReplies.length,
+      body: () => decodeReply,
+      step: reply => {
+        index++;
+        if (reply) replies.push(reply);
+      }
+    }), replies);
+  };
+  return storage;
+});
+/**
+ * @since 1.0.0
+ * @category Constructors
+ */
+const noop = exports.noop = /*#__PURE__*/(0, _GlobalValue.globalValue)("@effect/cluster/MessageStorage/noop", () => Effect.runSync(make({
+  saveRequest: () => Effect.succeed(SaveResult.Success()),
+  saveEnvelope: () => Effect.void,
+  saveReply: () => Effect.void,
+  repliesFor: () => Effect.succeed([]),
+  unprocessedMessages: () => Effect.succeed([]),
+  unprocessedMessagesById: () => Effect.succeed([]),
+  resetAddress: () => Effect.void
+})));
+/**
+ * @since 1.0.0
+ * @category Memory
+ */
+class MemoryDriver extends /*#__PURE__*/Effect.Service()("@effect/cluster/MessageStorage/MemoryDriver", {
+  dependencies: [Snowflake.layerGenerator],
+  effect: /*#__PURE__*/Effect.gen(function* () {
+    const requests = new Map();
+    const requestsByPrimaryKey = new Map();
+    const unprocessed = new Set();
+    const replyIds = new Set();
+    const journal = [];
+    const cursors = new WeakMap();
+    const unprocessedWith = predicate => {
+      const messages = [];
+      for (const envelope of unprocessed) {
+        if (!predicate(envelope)) {
+          continue;
+        }
+        if (envelope._tag === "Request") {
+          const entry = requests.get(envelope.requestId);
+          messages.push({
+            envelope,
+            lastSentReply: Option.fromNullable(entry?.replies[entry.replies.length - 1])
+          });
+        } else {
+          messages.push({
+            envelope,
+            lastSentReply: Option.none()
+          });
+        }
+      }
+      return messages;
+    };
+    const replyLatch = yield* Effect.makeLatch();
+    const encoded = {
+      saveEnvelope: ({
+        envelope,
+        primaryKey
+      }) => Effect.sync(() => {
+        const existing = primaryKey ? requestsByPrimaryKey.get(primaryKey) : envelope._tag === "Request" && requests.get(envelope.requestId);
+        if (existing) {
+          return SaveResultEncoded.Duplicate({
+            originalId: Snowflake.Snowflake(existing.envelope.requestId),
+            lastReceivedReply: existing.lastReceivedChunk
+          });
+        }
+        if (envelope._tag === "Request") {
+          const entry = {
+            envelope,
+            replies: [],
+            lastReceivedChunk: Option.none()
+          };
+          requests.set(envelope.requestId, entry);
+          if (primaryKey) {
+            requestsByPrimaryKey.set(primaryKey, entry);
+          }
+          unprocessed.add(envelope);
+        } else if (envelope._tag === "AckChunk") {
+          const entry = requests.get(envelope.requestId);
+          if (entry) {
+            entry.lastReceivedChunk = Arr.findFirst(entry.replies, r => r._tag === "Chunk" && r.id === envelope.replyId).pipe(Option.orElse(() => entry.lastReceivedChunk));
+          }
+        }
+        journal.push(envelope);
+        return SaveResultEncoded.Success();
+      }),
+      saveReply: reply => Effect.sync(() => {
+        const entry = requests.get(reply.requestId);
+        if (!entry || replyIds.has(reply.id)) return;
+        if (reply._tag === "WithExit") {
+          unprocessed.delete(entry.envelope);
+        }
+        entry.replies.push(reply);
+        replyIds.add(reply.id);
+        replyLatch.unsafeOpen();
+      }),
+      repliesFor: requestIds => Effect.sync(() => {
+        const replies = Arr.empty();
+        for (const requestId of requestIds) {
+          const request = requests.get(requestId);
+          if (!request) continue;else if (Option.isNone(request.lastReceivedChunk)) {
+            // eslint-disable-next-line no-restricted-syntax
+            replies.push(...request.replies);
+            continue;
+          }
+          const sequence = request.lastReceivedChunk.value.sequence;
+          for (const reply of request.replies) {
+            if (reply._tag === "Chunk" && reply.sequence <= sequence) {
+              continue;
+            }
+            replies.push(reply);
+          }
+        }
+        return replies;
+      }),
+      unprocessedMessages: shardIds => Effect.sync(() => {
+        if (unprocessed.size === 0) return [];
+        const messages = Arr.empty();
+        let index = journal.indexOf(Iterable.unsafeHead(unprocessed));
+        for (; index < journal.length; index++) {
+          const envelope = journal[index];
+          if (!shardIds.includes(envelope.address.shardId)) {
+            continue;
+          }
+          if (envelope._tag === "Request") {
+            const entry = requests.get(envelope.requestId);
+            messages.push({
+              envelope,
+              lastSentReply: Arr.last(entry.replies)
+            });
+          } else {
+            messages.push({
+              envelope,
+              lastSentReply: Option.none()
+            });
+          }
+        }
+        return messages;
+      }),
+      unprocessedMessagesById: ids => Effect.sync(() => {
+        const envelopeIds = new Set();
+        for (const id of ids) {
+          envelopeIds.add(String(id));
+        }
+        return unprocessedWith(envelope => envelopeIds.has(envelope.requestId));
+      }),
+      resetAddress: () => Effect.void
+    };
+    const storage = yield* makeEncoded(encoded);
+    return {
+      storage,
+      encoded,
+      requests,
+      requestsByPrimaryKey,
+      unprocessed,
+      replyIds,
+      journal,
+      cursors
+    };
+  })
+}) {}
+/**
+ * @since 1.0.0
+ * @category layers
+ */
+exports.MemoryDriver = MemoryDriver;
+const layerNoop = exports.layerNoop = /*#__PURE__*/Layer.succeed(MessageStorage, noop);
+/**
+ * @since 1.0.0
+ * @category layers
+ */
+const layerMemory = exports.layerMemory = /*#__PURE__*/Layer.effect(MessageStorage, Effect.map(MemoryDriver, _ => _.storage)).pipe( /*#__PURE__*/Layer.provideMerge(MemoryDriver.Default));
+// --- internal ---
+const EnvelopeWithReply = /*#__PURE__*/Schema.Struct({
+  envelope: Envelope.PartialEncoded,
+  lastSentReply: /*#__PURE__*/Schema.OptionFromSelf(Reply.Encoded)
+});
+const decodeEnvelopeWithReply = /*#__PURE__*/Schema.decode(EnvelopeWithReply);
+//# sourceMappingURL=MessageStorage.js.map
\ No newline at end of file
diff --git a/dist/cjs/MessageStorage.js.map b/dist/cjs/MessageStorage.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..965ed0d57412933e8b3a4cc5ed551992e79b98a9
--- /dev/null
+++ b/dist/cjs/MessageStorage.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"MessageStorage.js","names":["Arr","_interopRequireWildcard","require","Context","Data","Effect","Exit","FiberRef","_GlobalValue","Iterable","Layer","Option","Schema","_ClusterError","DeliverAt","Envelope","Message","Reply","Snowflake","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","MessageStorage","Tag","exports","SaveResult","taggedEnum","SaveResultEncoded","make","storage","sync","replyHandlers","Map","of","registerReplyHandler","message","envelope","requestId","respond","saveReply","reply","flatMap","handler","void","_tag","delete","makeEncoded","fnUntraced","encoded","snowflakeGen","Generator","clock","saveRequest","serializeEnvelope","pipe","saveEnvelope","primaryKey","deliverAt","toMillis","payload","result","lastReceivedReply","succeed","duplicate","schema","rpc","decode","value","locally","currentContext","context","MalformedMessage","refail","map","Duplicate","originalId","some","asVoid","serialize","repliesFor","messages","requestIds","empty","id","String","push","length","encodedReplies","decodeReplies","unprocessedMessages","shardIds","shards","Array","from","suspend","unsafeCurrentTimeMillis","decodeMessages","unprocessedMessagesById","messageIds","ids","resetAddress","address","envelopes","index","decodeMessage","catchAll","undefined","decodeEnvelopeWithReply","error","ReplyWithContext","fromDefect","unsafeNext","defect","toString","forkDaemon","as","whileLoop","while","body","step","IncomingRequest","lastSentReply","IncomingEnvelope","replies","ignoredRequests","Set","decodeReply","add","WithExit","exit","die","noop","globalValue","runSync","Success","MemoryDriver","Service","dependencies","layerGenerator","effect","gen","requests","requestsByPrimaryKey","unprocessed","replyIds","journal","cursors","unprocessedWith","predicate","entry","fromNullable","none","replyLatch","makeLatch","existing","lastReceivedChunk","findFirst","replyId","orElse","unsafeOpen","request","isNone","sequence","size","indexOf","unsafeHead","includes","shardId","last","envelopeIds","layerNoop","layerMemory","_","provideMerge","Default","EnvelopeWithReply","Struct","PartialEncoded","OptionFromSelf","Encoded"],"sources":["../../src/MessageStorage.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/cjs/Reply.js b/dist/cjs/Reply.js
new file mode 100644
index 0000000000000000000000000000000000000000..8b1f5e842334f0a550897e3b1faef1fc7803c17f
--- /dev/null
+++ b/dist/cjs/Reply.js
@@ -0,0 +1,200 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.serializeLastReceived = exports.serialize = exports.isReply = exports.WithExit = exports.TypeId = exports.ReplyWithContext = exports.Reply = exports.Encoded = exports.Chunk = void 0;
+var Rpc = _interopRequireWildcard(require("@effect/rpc/Rpc"));
+var Context = _interopRequireWildcard(require("effect/Context"));
+var Data = _interopRequireWildcard(require("effect/Data"));
+var Effect = _interopRequireWildcard(require("effect/Effect"));
+var Exit = _interopRequireWildcard(require("effect/Exit"));
+var FiberRef = _interopRequireWildcard(require("effect/FiberRef"));
+var _Function = require("effect/Function");
+var _Predicate = require("effect/Predicate");
+var Schema = _interopRequireWildcard(require("effect/Schema"));
+var _ClusterError = require("./ClusterError.js");
+var _Snowflake = require("./Snowflake.js");
+function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
+function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
+/**
+ * @since 1.0.0
+ */
+
+/**
+ * @since 1.0.0
+ * @category type ids
+ */
+const TypeId = exports.TypeId = /*#__PURE__*/Symbol.for("@effect/cluster/Reply");
+/**
+ * @since 1.0.0
+ * @category guards
+ */
+const isReply = u => (0, _Predicate.hasProperty)(u, TypeId);
+/**
+ * @since 1.0.0
+ * @category models
+ */
+exports.isReply = isReply;
+class ReplyWithContext extends /*#__PURE__*/Data.TaggedClass("ReplyWithContext") {
+  /**
+   * @since 1.0.0
+   */
+  static fromDefect(options) {
+    return new ReplyWithContext({
+      reply: new WithExit({
+        requestId: options.requestId,
+        id: options.id,
+        exit: Exit.die(Schema.encodeSync(Schema.Defect)(options.defect))
+      }),
+      context: Context.empty(),
+      rpc: neverRpc
+    });
+  }
+}
+exports.ReplyWithContext = ReplyWithContext;
+const neverRpc = /*#__PURE__*/Rpc.make("Never", {
+  success: Schema.Never,
+  error: Schema.Never,
+  payload: {}
+});
+const schemaCache = /*#__PURE__*/new WeakMap();
+/**
+ * @since 1.0.0
+ * @category schemas
+ */
+const Reply = rpc => {
+  if (schemaCache.has(rpc)) {
+    return schemaCache.get(rpc);
+  }
+  const schema = Schema.Union(WithExit.schema(rpc), Chunk.schema(rpc));
+  schemaCache.set(rpc, schema);
+  return schema;
+};
+/**
+ * @since 1.0.0
+ * @category schemas
+ */
+exports.Reply = Reply;
+const Encoded = exports.Encoded = /*#__PURE__*/Schema.Union( /*#__PURE__*/Schema.Struct({
+  _tag: /*#__PURE__*/Schema.Literal("WithExit"),
+  requestId: Schema.String,
+  id: Schema.String,
+  exit: Schema.Unknown
+}), /*#__PURE__*/Schema.Struct({
+  _tag: /*#__PURE__*/Schema.Literal("Chunk"),
+  requestId: Schema.String,
+  id: Schema.String,
+  sequence: Schema.Number,
+  values: /*#__PURE__*/Schema.Array(Schema.Unknown)
+}));
+/**
+ * @since 1.0.0
+ * @category models
+ */
+class Chunk extends /*#__PURE__*/Data.TaggedClass("Chunk") {
+  /**
+   * @since 1.0.0
+   */
+  [TypeId] = TypeId;
+  /**
+   * @since 1.0.0
+   */
+  static emptyFrom(requestId) {
+    return new Chunk({
+      requestId,
+      id: (0, _Snowflake.Snowflake)(BigInt(0)),
+      sequence: 0,
+      values: [undefined]
+    });
+  }
+  /**
+   * @since 1.0.0
+   */
+  static schemaFromSelf = /*#__PURE__*/Schema.declare(u => isReply(u) && u._tag === "Chunk");
+  /**
+   * @since 1.0.0
+   */
+  static schema(rpc) {
+    const successSchema = rpc.successSchema.success;
+    if (!successSchema) {
+      return Schema.Never;
+    }
+    return Schema.transform(Schema.Struct({
+      _tag: Schema.Literal("Chunk"),
+      requestId: _Snowflake.SnowflakeFromString,
+      id: _Snowflake.SnowflakeFromString,
+      sequence: Schema.Number,
+      values: Schema.NonEmptyArray(successSchema)
+    }), Chunk.schemaFromSelf, {
+      decode: encoded => new Chunk(encoded),
+      encode: _Function.identity
+    });
+  }
+  /**
+   * @since 1.0.0
+   */
+  withRequestId(requestId) {
+    return new Chunk({
+      ...this,
+      requestId
+    });
+  }
+}
+/**
+ * @since 1.0.0
+ * @category models
+ */
+exports.Chunk = Chunk;
+class WithExit extends /*#__PURE__*/Data.TaggedClass("WithExit") {
+  /**
+   * @since 1.0.0
+   */
+  [TypeId] = TypeId;
+  /**
+   * @since 1.0.0
+   */
+  static schema(rpc) {
+    return Schema.transform(Schema.Struct({
+      _tag: Schema.Literal("WithExit"),
+      requestId: _Snowflake.SnowflakeFromString,
+      id: _Snowflake.SnowflakeFromString,
+      exit: Rpc.exitSchema(rpc)
+    }), Schema.declare(u => isReply(u) && u._tag === "WithExit"), {
+      decode: encoded => new WithExit(encoded),
+      encode: _Function.identity
+    });
+  }
+  /**
+   * @since 1.0.0
+   */
+  withRequestId(requestId) {
+    return new WithExit({
+      ...this,
+      requestId
+    });
+  }
+}
+/**
+ * @since 1.0.0
+ * @category serialization / deserialization
+ */
+exports.WithExit = WithExit;
+const serialize = self => {
+  const schema = Reply(self.rpc);
+  return _ClusterError.MalformedMessage.refail(Effect.locally(Schema.encode(schema)(self.reply), FiberRef.currentContext, self.context));
+};
+/**
+ * @since 1.0.0
+ * @category serialization / deserialization
+ */
+exports.serialize = serialize;
+const serializeLastReceived = self => {
+  if (self.lastReceivedReply._tag === "None") {
+    return Effect.succeedNone;
+  }
+  const schema = Reply(self.rpc);
+  return Effect.asSome(_ClusterError.MalformedMessage.refail(Effect.locally(Schema.encode(schema)(self.lastReceivedReply.value), FiberRef.currentContext, self.context)));
+};
+exports.serializeLastReceived = serializeLastReceived;
+//# sourceMappingURL=Reply.js.map
\ No newline at end of file
diff --git a/dist/cjs/Reply.js.map b/dist/cjs/Reply.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..3ac3c1b1574a03435fb3fcc240c1aff607256b83
--- /dev/null
+++ b/dist/cjs/Reply.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"Reply.js","names":["Rpc","_interopRequireWildcard","require","Context","Data","Effect","Exit","FiberRef","_Function","_Predicate","Schema","_ClusterError","_Snowflake","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","TypeId","exports","Symbol","for","isReply","hasProperty","ReplyWithContext","TaggedClass","fromDefect","options","reply","WithExit","requestId","id","exit","die","encodeSync","Defect","defect","context","empty","rpc","neverRpc","make","success","Never","error","payload","schemaCache","Reply","schema","Union","Chunk","Encoded","Struct","_tag","Literal","String","Unknown","sequence","Number","values","Array","emptyFrom","Snowflake","BigInt","undefined","schemaFromSelf","declare","successSchema","transform","SnowflakeFromString","NonEmptyArray","decode","encoded","encode","identity","withRequestId","exitSchema","serialize","self","MalformedMessage","refail","locally","currentContext","serializeLastReceived","lastReceivedReply","succeedNone","asSome","value"],"sources":["../../src/Reply.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/cjs/Runner.js b/dist/cjs/Runner.js
new file mode 100644
index 0000000000000000000000000000000000000000..66437c48ed0c5fb1359422304592566259b0b63b
--- /dev/null
+++ b/dist/cjs/Runner.js
@@ -0,0 +1,79 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.make = exports.TypeId = exports.Runner = void 0;
+var _Inspectable = require("effect/Inspectable");
+var Pretty = _interopRequireWildcard(require("effect/Pretty"));
+var Schema = _interopRequireWildcard(require("effect/Schema"));
+var _RunnerAddress = require("./RunnerAddress.js");
+function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
+function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
+/**
+ * @since 1.0.0
+ */
+
+const SymbolKey = "@effect/cluster/Runner";
+/**
+ * @since 1.0.0
+ * @category type ids
+ */
+const TypeId = exports.TypeId = /*#__PURE__*/Symbol.for(SymbolKey);
+/**
+ * A `Runner` represents a physical application server that is capable of running
+ * entities.
+ *
+ * Because a Runner represents a physical application server, a Runner must have a
+ * unique `address` which can be used to communicate with the server.
+ *
+ * The version of a Runner is used during rebalancing to give priority to newer
+ * application servers and slowly decommission older ones.
+ *
+ * @since 1.0.0
+ * @category models
+ */
+class Runner extends /*#__PURE__*/Schema.Class(SymbolKey)({
+  address: _RunnerAddress.RunnerAddress,
+  version: Schema.Int
+}) {
+  /**
+   * @since 1.0.0
+   */
+  static pretty = /*#__PURE__*/Pretty.make(this);
+  /**
+   * @since 1.0.0
+   */
+  [TypeId] = TypeId;
+  /**
+   * @since 1.0.0
+   */
+  static decodeSync = /*#__PURE__*/Schema.decodeSync( /*#__PURE__*/Schema.parseJson(Runner));
+  /**
+   * @since 1.0.0
+   */
+  static encodeSync = /*#__PURE__*/Schema.encodeSync( /*#__PURE__*/Schema.parseJson(Runner));
+  /**
+   * @since 1.0.0
+   */
+  [_Inspectable.NodeInspectSymbol]() {
+    return this.toString();
+  }
+}
+/**
+ * A `Runner` represents a physical application server that is capable of running
+ * entities.
+ *
+ * Because a Runner represents a physical application server, a Runner must have a
+ * unique `address` which can be used to communicate with the server.
+ *
+ * The version of a Runner is used during rebalancing to give priority to newer
+ * application servers and slowly decommission older ones.
+ *
+ * @since 1.0.0
+ * @category Constructors
+ */
+exports.Runner = Runner;
+const make = props => new Runner(props);
+exports.make = make;
+//# sourceMappingURL=Runner.js.map
\ No newline at end of file
diff --git a/dist/cjs/Runner.js.map b/dist/cjs/Runner.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..6bb681242bf6947f5031695aa7ba4d3951d8bae7
--- /dev/null
+++ b/dist/cjs/Runner.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"Runner.js","names":["_Inspectable","require","Pretty","_interopRequireWildcard","Schema","_RunnerAddress","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","SymbolKey","TypeId","exports","Symbol","for","Runner","Class","address","RunnerAddress","version","Int","pretty","make","decodeSync","parseJson","encodeSync","NodeInspectSymbol","toString","props"],"sources":["../../src/Runner.ts"],"sourcesContent":[null],"mappings":";;;;;;AAGA,IAAAA,YAAA,GAAAC,OAAA;AACA,IAAAC,MAAA,GAAAC,uBAAA,CAAAF,OAAA;AACA,IAAAG,MAAA,GAAAD,uBAAA,CAAAF,OAAA;AACA,IAAAI,cAAA,GAAAJ,OAAA;AAAkD,SAAAK,yBAAAC,CAAA,6BAAAC,OAAA,mBAAAC,CAAA,OAAAD,OAAA,IAAAE,CAAA,OAAAF,OAAA,YAAAF,wBAAA,YAAAA,CAAAC,CAAA,WAAAA,CAAA,GAAAG,CAAA,GAAAD,CAAA,KAAAF,CAAA;AAAA,SAAAJ,wBAAAI,CAAA,EAAAE,CAAA,SAAAA,CAAA,IAAAF,CAAA,IAAAA,CAAA,CAAAI,UAAA,SAAAJ,CAAA,eAAAA,CAAA,uBAAAA,CAAA,yBAAAA,CAAA,WAAAK,OAAA,EAAAL,CAAA,QAAAG,CAAA,GAAAJ,wBAAA,CAAAG,CAAA,OAAAC,CAAA,IAAAA,CAAA,CAAAG,GAAA,CAAAN,CAAA,UAAAG,CAAA,CAAAI,GAAA,CAAAP,CAAA,OAAAQ,CAAA,KAAAC,SAAA,UAAAC,CAAA,GAAAC,MAAA,CAAAC,cAAA,IAAAD,MAAA,CAAAE,wBAAA,WAAAC,CAAA,IAAAd,CAAA,oBAAAc,CAAA,OAAAC,cAAA,CAAAC,IAAA,CAAAhB,CAAA,EAAAc,CAAA,SAAAG,CAAA,GAAAP,CAAA,GAAAC,MAAA,CAAAE,wBAAA,CAAAb,CAAA,EAAAc,CAAA,UAAAG,CAAA,KAAAA,CAAA,CAAAV,GAAA,IAAAU,CAAA,CAAAC,GAAA,IAAAP,MAAA,CAAAC,cAAA,CAAAJ,CAAA,EAAAM,CAAA,EAAAG,CAAA,IAAAT,CAAA,CAAAM,CAAA,IAAAd,CAAA,CAAAc,CAAA,YAAAN,CAAA,CAAAH,OAAA,GAAAL,CAAA,EAAAG,CAAA,IAAAA,CAAA,CAAAe,GAAA,CAAAlB,CAAA,EAAAQ,CAAA,GAAAA,CAAA;AANlD;;;;AAQA,MAAMW,SAAS,GAAG,wBAAwB;AAE1C;;;;AAIO,MAAMC,MAAM,GAAAC,OAAA,CAAAD,MAAA,gBAAkBE,MAAM,CAACC,GAAG,CAACJ,SAAS,CAAC;AAQ1D;;;;;;;;;;;;;AAaM,MAAOK,MAAO,sBAAQ3B,MAAM,CAAC4B,KAAK,CAASN,SAAS,CAAC,CAAC;EAC1DO,OAAO,EAAEC,4BAAa;EACtBC,OAAO,EAAE/B,MAAM,CAACgC;CACjB,CAAC;EACA;;;EAGA,OAAOC,MAAM,gBAAGnC,MAAM,CAACoC,IAAI,CAAC,IAAI,CAAC;EAEjC;;;EAGS,CAACX,MAAM,IAAIA,MAAM;EAE1B;;;EAGA,OAAgBY,UAAU,gBAAGnC,MAAM,CAACmC,UAAU,eAACnC,MAAM,CAACoC,SAAS,CAACT,MAAM,CAAC,CAAC;EAExE;;;EAGA,OAAgBU,UAAU,gBAAGrC,MAAM,CAACqC,UAAU,eAACrC,MAAM,CAACoC,SAAS,CAACT,MAAM,CAAC,CAAC;EAExE;;;EAGA,CAACW,8BAAiB,IAAC;IACjB,OAAO,IAAI,CAACC,QAAQ,EAAE;EACxB;;AAGF;;;;;;;;;;;;;AAAAf,OAAA,CAAAG,MAAA,GAAAA,MAAA;AAaO,MAAMO,IAAI,GAAIM,KAGpB,IAAa,IAAIb,MAAM,CAACa,KAAK,CAAC;AAAAhB,OAAA,CAAAU,IAAA,GAAAA,IAAA","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/cjs/RunnerAddress.js b/dist/cjs/RunnerAddress.js
new file mode 100644
index 0000000000000000000000000000000000000000..1c8256390dd7bc4077d520953d0cf545787ece18
--- /dev/null
+++ b/dist/cjs/RunnerAddress.js
@@ -0,0 +1,63 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.make = exports.TypeId = exports.RunnerAddress = void 0;
+var Hash = _interopRequireWildcard(require("effect/Hash"));
+var _Inspectable = require("effect/Inspectable");
+var Schema = _interopRequireWildcard(require("effect/Schema"));
+function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
+function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
+/**
+ * @since 1.0.0
+ */
+
+const SymbolKey = "@effect/cluster/RunnerAddress";
+/**
+ * @since 1.0.0
+ * @category type ids
+ */
+const TypeId = exports.TypeId = /*#__PURE__*/Symbol.for(SymbolKey);
+/**
+ * @since 1.0.0
+ * @category models
+ */
+class RunnerAddress extends /*#__PURE__*/Schema.Class(SymbolKey)({
+  host: Schema.NonEmptyString,
+  port: Schema.Int
+}) {
+  /**
+   * @since 1.0.0
+   */
+  [TypeId] = TypeId;
+  /**
+   * @since 1.0.0
+   */
+  [Hash.symbol]() {
+    return Hash.cached(this)(Hash.string(this.toString()));
+  }
+  /**
+   * @since 1.0.0
+   */
+  toString() {
+    return `RunnerAddress(${this.host}:${this.port})`;
+  }
+  /**
+   * @since 1.0.0
+   */
+  [_Inspectable.NodeInspectSymbol]() {
+    return this.toString();
+  }
+}
+/**
+ * @since 1.0.0
+ * @category constructors
+ */
+exports.RunnerAddress = RunnerAddress;
+const make = (host, port) => new RunnerAddress({
+  host,
+  port
+});
+exports.make = make;
+//# sourceMappingURL=RunnerAddress.js.map
\ No newline at end of file
diff --git a/dist/cjs/RunnerAddress.js.map b/dist/cjs/RunnerAddress.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..b759f29a0964ce6d3542d297c0b310a1cb30ae8a
--- /dev/null
+++ b/dist/cjs/RunnerAddress.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"RunnerAddress.js","names":["Hash","_interopRequireWildcard","require","_Inspectable","Schema","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","SymbolKey","TypeId","exports","Symbol","for","RunnerAddress","Class","host","NonEmptyString","port","Int","symbol","cached","string","toString","NodeInspectSymbol","make"],"sources":["../../src/RunnerAddress.ts"],"sourcesContent":[null],"mappings":";;;;;;AAGA,IAAAA,IAAA,GAAAC,uBAAA,CAAAC,OAAA;AACA,IAAAC,YAAA,GAAAD,OAAA;AACA,IAAAE,MAAA,GAAAH,uBAAA,CAAAC,OAAA;AAAuC,SAAAG,yBAAAC,CAAA,6BAAAC,OAAA,mBAAAC,CAAA,OAAAD,OAAA,IAAAE,CAAA,OAAAF,OAAA,YAAAF,wBAAA,YAAAA,CAAAC,CAAA,WAAAA,CAAA,GAAAG,CAAA,GAAAD,CAAA,KAAAF,CAAA;AAAA,SAAAL,wBAAAK,CAAA,EAAAE,CAAA,SAAAA,CAAA,IAAAF,CAAA,IAAAA,CAAA,CAAAI,UAAA,SAAAJ,CAAA,eAAAA,CAAA,uBAAAA,CAAA,yBAAAA,CAAA,WAAAK,OAAA,EAAAL,CAAA,QAAAG,CAAA,GAAAJ,wBAAA,CAAAG,CAAA,OAAAC,CAAA,IAAAA,CAAA,CAAAG,GAAA,CAAAN,CAAA,UAAAG,CAAA,CAAAI,GAAA,CAAAP,CAAA,OAAAQ,CAAA,KAAAC,SAAA,UAAAC,CAAA,GAAAC,MAAA,CAAAC,cAAA,IAAAD,MAAA,CAAAE,wBAAA,WAAAC,CAAA,IAAAd,CAAA,oBAAAc,CAAA,OAAAC,cAAA,CAAAC,IAAA,CAAAhB,CAAA,EAAAc,CAAA,SAAAG,CAAA,GAAAP,CAAA,GAAAC,MAAA,CAAAE,wBAAA,CAAAb,CAAA,EAAAc,CAAA,UAAAG,CAAA,KAAAA,CAAA,CAAAV,GAAA,IAAAU,CAAA,CAAAC,GAAA,IAAAP,MAAA,CAAAC,cAAA,CAAAJ,CAAA,EAAAM,CAAA,EAAAG,CAAA,IAAAT,CAAA,CAAAM,CAAA,IAAAd,CAAA,CAAAc,CAAA,YAAAN,CAAA,CAAAH,OAAA,GAAAL,CAAA,EAAAG,CAAA,IAAAA,CAAA,CAAAe,GAAA,CAAAlB,CAAA,EAAAQ,CAAA,GAAAA,CAAA;AALvC;;;;AAOA,MAAMW,SAAS,GAAG,+BAA+B;AAEjD;;;;AAIO,MAAMC,MAAM,GAAAC,OAAA,CAAAD,MAAA,gBAAkBE,MAAM,CAACC,GAAG,CAACJ,SAAS,CAAC;AAQ1D;;;;AAIM,MAAOK,aAAc,sBAAQ1B,MAAM,CAAC2B,KAAK,CAAgBN,SAAS,CAAC,CAAC;EACxEO,IAAI,EAAE5B,MAAM,CAAC6B,cAAc;EAC3BC,IAAI,EAAE9B,MAAM,CAAC+B;CACd,CAAC;EACA;;;EAGS,CAACT,MAAM,IAAIA,MAAM;EAE1B;;;EAGA,CAAC1B,IAAI,CAACoC,MAAM,IAAC;IACX,OAAOpC,IAAI,CAACqC,MAAM,CAAC,IAAI,CAAC,CAACrC,IAAI,CAACsC,MAAM,CAAC,IAAI,CAACC,QAAQ,EAAE,CAAC,CAAC;EACxD;EAEA;;;EAGAA,QAAQA,CAAA;IACN,OAAO,iBAAiB,IAAI,CAACP,IAAI,IAAI,IAAI,CAACE,IAAI,GAAG;EACnD;EAEA;;;EAGA,CAACM,8BAAiB,IAAC;IACjB,OAAO,IAAI,CAACD,QAAQ,EAAE;EACxB;;AAGF;;;;AAAAZ,OAAA,CAAAG,aAAA,GAAAA,aAAA;AAIO,MAAMW,IAAI,GAAGA,CAACT,IAAY,EAAEE,IAAY,KAAoB,IAAIJ,aAAa,CAAC;EAAEE,IAAI;EAAEE;AAAI,CAAE,CAAC;AAAAP,OAAA,CAAAc,IAAA,GAAAA,IAAA","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/cjs/RunnerHealth.js b/dist/cjs/RunnerHealth.js
new file mode 100644
index 0000000000000000000000000000000000000000..24512a66e396ba36a3845b42e3f7e09c4f43e826
--- /dev/null
+++ b/dist/cjs/RunnerHealth.js
@@ -0,0 +1,68 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.make = exports.layerRpc = exports.layerNoop = exports.layer = exports.RunnerHealth = void 0;
+var Context = _interopRequireWildcard(require("effect/Context"));
+var Effect = _interopRequireWildcard(require("effect/Effect"));
+var Layer = _interopRequireWildcard(require("effect/Layer"));
+var MessageStorage = _interopRequireWildcard(require("./MessageStorage.js"));
+var Runners = _interopRequireWildcard(require("./Runners.js"));
+function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
+function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
+/**
+ * @since 1.0.0
+ */
+
+/**
+ * Represents the service used to check if a Runner is healthy.
+ *
+ * If a Runner is responsive, shards will not be re-assigned because the Runner may
+ * still be processing messages. If a Runner is not responsive, then its
+ * associated shards can and will be re-assigned to a different Runner.
+ *
+ * @since 1.0.0
+ * @category models
+ */
+class RunnerHealth extends /*#__PURE__*/Context.Tag("@effect/cluster/RunnerHealth")() {}
+/**
+ * A layer which will **always** consider a Runner healthy.
+ *
+ * This is useful for testing.
+ *
+ * @since 1.0.0
+ * @category layers
+ */
+exports.RunnerHealth = RunnerHealth;
+const layerNoop = exports.layerNoop = /*#__PURE__*/Layer.succeed(RunnerHealth, /*#__PURE__*/RunnerHealth.of({
+  isAlive: () => Effect.succeed(true)
+}));
+/**
+ * @since 1.0.0
+ * @category Constructors
+ */
+const make = exports.make = /*#__PURE__*/Effect.gen(function* () {
+  const runners = yield* Runners.Runners;
+  function isAlive(address) {
+    return Effect.isSuccess(Effect.timeout(runners.ping(address), 3000));
+  }
+  return RunnerHealth.of({
+    isAlive
+  });
+});
+/**
+ * A layer which will ping a Runner directly to check if it is healthy.
+ *
+ * @since 1.0.0
+ * @category layers
+ */
+const layer = exports.layer = /*#__PURE__*/Layer.effect(RunnerHealth, make);
+/**
+ * A layer which will ping a Runner directly to check if it is healthy.
+ *
+ * @since 1.0.0
+ * @category layers
+ */
+const layerRpc = exports.layerRpc = /*#__PURE__*/layer.pipe( /*#__PURE__*/Layer.provide(Runners.layerRpc), /*#__PURE__*/Layer.provide(MessageStorage.layerNoop));
+//# sourceMappingURL=RunnerHealth.js.map
\ No newline at end of file
diff --git a/dist/cjs/RunnerHealth.js.map b/dist/cjs/RunnerHealth.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..8fc72dcfed2114a3aae76b9758520fb8e1c9c78d
--- /dev/null
+++ b/dist/cjs/RunnerHealth.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"RunnerHealth.js","names":["Context","_interopRequireWildcard","require","Effect","Layer","MessageStorage","Runners","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","RunnerHealth","Tag","exports","layerNoop","succeed","of","isAlive","make","gen","runners","address","isSuccess","timeout","ping","layer","effect","layerRpc","pipe","provide"],"sources":["../../src/RunnerHealth.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/cjs/RunnerServer.js b/dist/cjs/RunnerServer.js
new file mode 100644
index 0000000000000000000000000000000000000000..e4b132c9b5019f589f6a28b2a76725d498e22762
--- /dev/null
+++ b/dist/cjs/RunnerServer.js
@@ -0,0 +1,125 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.layerWithClients = exports.layerHandlers = exports.layerClientOnly = exports.layer = void 0;
+var RpcServer = _interopRequireWildcard(require("@effect/rpc/RpcServer"));
+var Effect = _interopRequireWildcard(require("effect/Effect"));
+var _Function = require("effect/Function");
+var Layer = _interopRequireWildcard(require("effect/Layer"));
+var Mailbox = _interopRequireWildcard(require("effect/Mailbox"));
+var Option = _interopRequireWildcard(require("effect/Option"));
+var Message = _interopRequireWildcard(require("./Message.js"));
+var Reply = _interopRequireWildcard(require("./Reply.js"));
+var Runners = _interopRequireWildcard(require("./Runners.js"));
+var Sharding = _interopRequireWildcard(require("./Sharding.js"));
+var _ShardingConfig = require("./ShardingConfig.js");
+var ShardManager = _interopRequireWildcard(require("./ShardManager.js"));
+var ShardStorage = _interopRequireWildcard(require("./ShardStorage.js"));
+var SynchronizedClock = _interopRequireWildcard(require("./SynchronizedClock.js"));
+function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
+function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
+/**
+ * @since 1.0.0
+ */
+
+const constVoid = /*#__PURE__*/(0, _Function.constant)(Effect.void);
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+const layerHandlers = exports.layerHandlers = /*#__PURE__*/Runners.Rpcs.toLayer( /*#__PURE__*/Effect.gen(function* () {
+  const sharding = yield* Sharding.Sharding;
+  return {
+    Ping: () => Effect.void,
+    Notify: ({
+      envelope
+    }) => sharding.notify(envelope._tag === "Request" ? new Message.IncomingRequest({
+      envelope,
+      respond: constVoid,
+      lastSentReply: Option.none()
+    }) : new Message.IncomingEnvelope({
+      envelope
+    })),
+    Effect: ({
+      request
+    }) => {
+      let resume;
+      let replyEncoded;
+      const message = new Message.IncomingRequest({
+        envelope: request,
+        lastSentReply: Option.none(),
+        respond(reply) {
+          return Effect.flatMap(Reply.serialize(reply), reply => {
+            if (resume) {
+              resume(Effect.succeed(reply));
+            } else {
+              replyEncoded = reply;
+            }
+            return Effect.void;
+          });
+        }
+      });
+      return Effect.zipRight(sharding.send(message), Effect.async(resume_ => {
+        if (replyEncoded) {
+          resume_(Effect.succeed(replyEncoded));
+        } else {
+          resume = resume_;
+        }
+      }));
+    },
+    Stream: ({
+      request
+    }) => Effect.flatMap(Mailbox.make(), mailbox => Effect.as(sharding.send(new Message.IncomingRequest({
+      envelope: request,
+      lastSentReply: Option.none(),
+      respond(reply) {
+        return Effect.flatMap(Reply.serialize(reply), reply => {
+          mailbox.unsafeOffer(reply);
+          return Effect.void;
+        });
+      }
+    })), mailbox)),
+    Envelope: ({
+      envelope
+    }) => sharding.send(new Message.IncomingEnvelope({
+      envelope
+    }))
+  };
+}));
+/**
+ * The `RunnerServer` recieves messages from other Runners and forwards them to the
+ * `Sharding` layer.
+ *
+ * It also responds to `Ping` requests.
+ *
+ * @since 1.0.0
+ * @category Layers
+ */
+const layer = exports.layer = /*#__PURE__*/RpcServer.layer(Runners.Rpcs, {
+  spanPrefix: "RunnerServer",
+  disableTracing: true
+}).pipe( /*#__PURE__*/Layer.provide(layerHandlers));
+/**
+ * A `RunnerServer` layer that includes the `Runners` & `Sharding` clients.
+ *
+ * @since 1.0.0
+ * @category Layers
+ */
+const layerWithClients = exports.layerWithClients = /*#__PURE__*/layer.pipe( /*#__PURE__*/Layer.provideMerge(Sharding.layer), /*#__PURE__*/Layer.provideMerge(Runners.layerRpc), /*#__PURE__*/Layer.provideMerge(SynchronizedClock.layer), /*#__PURE__*/Layer.provide(ShardManager.layerClientRpc));
+/**
+ * A `Runners` layer that is client only.
+ *
+ * It will not register with the ShardManager and recieve shard assignments,
+ * so this layer can be used to embed a cluster client inside another effect
+ * application.
+ *
+ * @since 1.0.0
+ * @category Layers
+ */
+const layerClientOnly = exports.layerClientOnly = /*#__PURE__*/Sharding.layer.pipe( /*#__PURE__*/Layer.provideMerge(Runners.layerRpc), /*#__PURE__*/Layer.provide(ShardManager.layerClientRpc), /*#__PURE__*/Layer.provide(ShardStorage.layerNoop), /*#__PURE__*/Layer.updateService(_ShardingConfig.ShardingConfig, config => ({
+  ...config,
+  runnerAddress: Option.none()
+})));
+//# sourceMappingURL=RunnerServer.js.map
\ No newline at end of file
diff --git a/dist/cjs/RunnerServer.js.map b/dist/cjs/RunnerServer.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..1fa665c3d5368297b7fdfe7741f99aa79cd06c94
--- /dev/null
+++ b/dist/cjs/RunnerServer.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"RunnerServer.js","names":["RpcServer","_interopRequireWildcard","require","Effect","_Function","Layer","Mailbox","Option","Message","Reply","Runners","Sharding","_ShardingConfig","ShardManager","ShardStorage","SynchronizedClock","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","constVoid","constant","void","layerHandlers","exports","Rpcs","toLayer","gen","sharding","Ping","Notify","envelope","notify","_tag","IncomingRequest","respond","lastSentReply","none","IncomingEnvelope","request","resume","replyEncoded","message","reply","flatMap","serialize","succeed","zipRight","send","async","resume_","Stream","make","mailbox","as","unsafeOffer","Envelope","layer","spanPrefix","disableTracing","pipe","provide","layerWithClients","provideMerge","layerRpc","layerClientRpc","layerClientOnly","layerNoop","updateService","ShardingConfig","config","runnerAddress"],"sources":["../../src/RunnerServer.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/cjs/Runners.js b/dist/cjs/Runners.js
new file mode 100644
index 0000000000000000000000000000000000000000..f946640130a7fbc782925eab556fd1780a2f725e
--- /dev/null
+++ b/dist/cjs/Runners.js
@@ -0,0 +1,340 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.makeRpcClient = exports.makeRpc = exports.makeNoop = exports.make = exports.layerRpc = exports.layerNoop = exports.Runners = exports.Rpcs = exports.RpcClientProtocol = void 0;
+var Rpc = _interopRequireWildcard(require("@effect/rpc/Rpc"));
+var RpcClient_ = _interopRequireWildcard(require("@effect/rpc/RpcClient"));
+var RpcGroup = _interopRequireWildcard(require("@effect/rpc/RpcGroup"));
+var RpcSchema = _interopRequireWildcard(require("@effect/rpc/RpcSchema"));
+var Cause = _interopRequireWildcard(require("effect/Cause"));
+var Context = _interopRequireWildcard(require("effect/Context"));
+var Effect = _interopRequireWildcard(require("effect/Effect"));
+var Exit = _interopRequireWildcard(require("effect/Exit"));
+var FiberRef = _interopRequireWildcard(require("effect/FiberRef"));
+var Layer = _interopRequireWildcard(require("effect/Layer"));
+var RcMap = _interopRequireWildcard(require("effect/RcMap"));
+var Schema = _interopRequireWildcard(require("effect/Schema"));
+var _ClusterError = require("./ClusterError.js");
+var _ClusterSchema = require("./ClusterSchema.js");
+var Envelope = _interopRequireWildcard(require("./Envelope.js"));
+var Message = _interopRequireWildcard(require("./Message.js"));
+var MessageStorage = _interopRequireWildcard(require("./MessageStorage.js"));
+var Reply = _interopRequireWildcard(require("./Reply.js"));
+var _ShardingConfig = require("./ShardingConfig.js");
+var Snowflake = _interopRequireWildcard(require("./Snowflake.js"));
+function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
+function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
+/**
+ * @since 1.0.0
+ */
+
+/**
+ * @since 1.0.0
+ * @category context
+ */
+class Runners extends /*#__PURE__*/Context.Tag("@effect/cluster/Runners")() {}
+/**
+ * @since 1.0.0
+ * @category Constructors
+ */
+exports.Runners = Runners;
+const make = exports.make = /*#__PURE__*/Effect.fnUntraced(function* (options) {
+  const storage = yield* MessageStorage.MessageStorage;
+  const snowflakeGen = yield* Snowflake.Generator;
+  const config = yield* _ShardingConfig.ShardingConfig;
+  const requestIdRewrites = new Map();
+  function notifyWith(message, afterPersist) {
+    const rpc = message.rpc;
+    const persisted = Context.get(rpc.annotations, _ClusterSchema.Persisted);
+    if (!persisted) {
+      return Effect.dieMessage("Runners.notify only supports persisted messages");
+    }
+    if (message._tag === "OutgoingEnvelope") {
+      const rewriteId = requestIdRewrites.get(message.envelope.requestId);
+      const requestId = rewriteId ?? message.envelope.requestId;
+      const entry = storageRequests.get(requestId);
+      if (rewriteId) {
+        message = new Message.OutgoingEnvelope({
+          ...message,
+          envelope: message.envelope.withRequestId(rewriteId)
+        });
+      }
+      return storage.saveEnvelope(message).pipe(Effect.orDie, Effect.zipRight(entry ? Effect.zipRight(entry.latch.open, afterPersist(message, false)) : afterPersist(message, false)));
+    }
+    // For requests, after persisting the request, we need to check if the
+    // request is a duplicate. If it is, we need to resume from the last
+    // received reply.
+    //
+    // Otherwise, we notify the remote entity and then reply from storage.
+    return Effect.flatMap(Effect.orDie(storage.saveRequest(message)), MessageStorage.SaveResult.$match({
+      Success: () => afterPersist(message, false),
+      Duplicate: ({
+        lastReceivedReply,
+        originalId
+      }) => {
+        requestIdRewrites.set(message.envelope.requestId, originalId);
+        return afterPersist(new Message.OutgoingRequest({
+          ...message,
+          lastReceivedReply,
+          envelope: Envelope.makeRequest({
+            ...message.envelope,
+            requestId: originalId
+          }),
+          respond(reply) {
+            if (reply._tag === "WithExit") {
+              requestIdRewrites.delete(message.envelope.requestId);
+            }
+            return message.respond(reply.withRequestId(message.envelope.requestId));
+          }
+        }), true);
+      }
+    }));
+  }
+  const storageRequests = new Map();
+  const waitingStorageRequests = new Map();
+  const replyFromStorage = Effect.fnUntraced(function* (message) {
+    const entry = {
+      latch: Effect.unsafeMakeLatch(false),
+      replies: []
+    };
+    storageRequests.set(message.envelope.requestId, entry);
+    while (true) {
+      // wait for the storage loop to notify us
+      entry.latch.unsafeClose();
+      waitingStorageRequests.set(message.envelope.requestId, message);
+      yield* storageLatch.open;
+      yield* entry.latch.await;
+      // send the replies back
+      for (const reply of entry.replies) {
+        // we have reached the end
+        if (reply._tag === "WithExit") {
+          return yield* message.respond(reply);
+        }
+        entry.latch.unsafeClose();
+        yield* message.respond(reply);
+        yield* entry.latch.await;
+      }
+      entry.replies = [];
+    }
+  }, (effect, message) => Effect.ensuring(effect, Effect.sync(() => {
+    storageRequests.delete(message.envelope.requestId);
+    waitingStorageRequests.delete(message.envelope.requestId);
+  })));
+  const storageLatch = Effect.unsafeMakeLatch(false);
+  if (storage !== MessageStorage.noop) {
+    yield* Effect.gen(function* () {
+      while (true) {
+        yield* storageLatch.await;
+        storageLatch.unsafeClose();
+        const replies = yield* storage.repliesFor(waitingStorageRequests.values()).pipe(Effect.catchAllCause(cause => Effect.as(Effect.annotateLogs(Effect.logDebug(cause), {
+          package: "@effect/cluster",
+          module: "Runners",
+          fiber: "Read replies loop"
+        }), [])));
+        const foundRequests = new Set();
+        // put the replies into the storage requests and then open the latches
+        for (const reply of replies) {
+          const entry = storageRequests.get(reply.requestId);
+          if (!entry) continue;
+          entry.replies.push(reply);
+          waitingStorageRequests.delete(reply.requestId);
+          foundRequests.add(entry);
+        }
+        for (const entry of foundRequests) {
+          entry.latch.unsafeOpen();
+        }
+      }
+    }).pipe(Effect.interruptible, Effect.forkScoped);
+    yield* Effect.suspend(() => {
+      if (waitingStorageRequests.size === 0) {
+        return storageLatch.await;
+      }
+      return storageLatch.open;
+    }).pipe(Effect.delay(config.entityReplyPollInterval), Effect.forever, Effect.interruptible, Effect.forkScoped);
+  }
+  return Runners.of({
+    ...options,
+    sendLocal(options) {
+      const message = options.message;
+      if (!options.simulateRemoteSerialization) {
+        return options.send(Message.incomingLocalFromOutgoing(message));
+      }
+      return Message.serialize(message).pipe(Effect.flatMap(encoded => Message.deserializeLocal(message, encoded)), Effect.flatMap(options.send), Effect.catchTag("MalformedMessage", error => {
+        if (message._tag === "OutgoingEnvelope") {
+          return Effect.die(error);
+        }
+        return Effect.orDie(message.respond(new Reply.WithExit({
+          id: snowflakeGen.unsafeNext(),
+          requestId: message.envelope.requestId,
+          exit: Exit.die(error)
+        })));
+      }));
+    },
+    notify(options_) {
+      const {
+        discard,
+        message
+      } = options_;
+      return notifyWith(message, message => {
+        if (message._tag === "OutgoingEnvelope") {
+          return options.notify(options_);
+        }
+        return discard ? options.notify(options_) : options.notify(options_).pipe(Effect.fork, Effect.andThen(Effect.orDie(replyFromStorage(message))));
+      });
+    },
+    notifyLocal(options) {
+      return notifyWith(options.message, (message, duplicate) => {
+        if (options.discard || message._tag === "OutgoingEnvelope") {
+          return Effect.orDie(options.notify(Message.incomingLocalFromOutgoing(message)));
+        } else if (!duplicate) {
+          return storage.registerReplyHandler(message).pipe(Effect.andThen(Effect.orDie(options.notify(Message.incomingLocalFromOutgoing(message)))));
+        }
+        return Effect.orDie(options.notify(Message.incomingLocalFromOutgoing(message))).pipe(Effect.fork, Effect.andThen(Effect.orDie(replyFromStorage(message))));
+      });
+    }
+  });
+});
+/**
+ * @since 1.0.0
+ * @category No-op
+ */
+const makeNoop = exports.makeNoop = /*#__PURE__*/make({
+  send: ({
+    message
+  }) => Effect.fail(new _ClusterError.EntityNotManagedByRunner({
+    address: message.envelope.address
+  })),
+  notify: () => Effect.void,
+  ping: () => Effect.void
+});
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+const layerNoop = exports.layerNoop = /*#__PURE__*/Layer.scoped(Runners, makeNoop).pipe( /*#__PURE__*/Layer.provide([Snowflake.layerGenerator]));
+const rpcErrors = /*#__PURE__*/Schema.Union(_ClusterError.EntityNotManagedByRunner, _ClusterError.MailboxFull, _ClusterError.AlreadyProcessingMessage, _ClusterError.PersistenceError);
+/**
+ * @since 1.0.0
+ * @category Rpcs
+ */
+class Rpcs extends /*#__PURE__*/RpcGroup.make( /*#__PURE__*/Rpc.make("Ping"), /*#__PURE__*/Rpc.make("Notify", {
+  payload: {
+    envelope: Envelope.PartialEncoded
+  },
+  success: Schema.Void,
+  error: _ClusterError.EntityNotManagedByRunner
+}), /*#__PURE__*/Rpc.make("Effect", {
+  payload: {
+    request: Envelope.PartialEncodedRequest
+  },
+  success: Schema.Object,
+  error: rpcErrors
+}), /*#__PURE__*/Rpc.make("Stream", {
+  payload: {
+    request: Envelope.PartialEncodedRequest
+  },
+  error: rpcErrors,
+  success: Schema.Object,
+  stream: true
+}), /*#__PURE__*/Rpc.make("Envelope", {
+  payload: {
+    envelope: /*#__PURE__*/Schema.Union(Envelope.AckChunk, Envelope.Interrupt)
+  },
+  error: rpcErrors
+})) {}
+/**
+ * @since 1.0.0
+ * @category Rpcs
+ */
+exports.Rpcs = Rpcs;
+const makeRpcClient = exports.makeRpcClient = /*#__PURE__*/RpcClient_.make(Rpcs, {
+  spanPrefix: "Runners",
+  disableTracing: true
+});
+/**
+ * @since 1.0.0
+ * @category constructors
+ */
+const makeRpc = exports.makeRpc = /*#__PURE__*/Effect.gen(function* () {
+  const makeClientProtocol = yield* RpcClientProtocol;
+  const snowflakeGen = yield* Snowflake.Generator;
+  const clients = yield* RcMap.make({
+    lookup: address => Effect.flatMap(makeClientProtocol(address), protocol => Effect.provideService(makeRpcClient, RpcClient_.Protocol, protocol)),
+    idleTimeToLive: "1 minute"
+  });
+  return yield* make({
+    ping(address) {
+      return RcMap.get(clients, address).pipe(Effect.flatMap(client => client.Ping()), Effect.catchAllCause(() => Effect.fail(new _ClusterError.RunnerUnavailable({
+        address
+      }))), Effect.scoped);
+    },
+    send({
+      address,
+      message
+    }) {
+      if (message._tag === "OutgoingEnvelope") {
+        return RcMap.get(clients, address).pipe(Effect.flatMap(client => client.Envelope({
+          envelope: message.envelope
+        })), Effect.scoped, Effect.catchAllDefect(() => Effect.fail(new _ClusterError.RunnerUnavailable({
+          address
+        }))));
+      }
+      const rpc = message.rpc;
+      const isStream = RpcSchema.isStreamSchema(rpc.successSchema);
+      if (!isStream) {
+        return Effect.matchEffect(Message.serializeRequest(message), {
+          onSuccess: request => RcMap.get(clients, address).pipe(Effect.flatMap(client => client.Effect({
+            request
+          })), Effect.flatMap(reply => Schema.decode(Reply.Reply(message.rpc))(reply).pipe(Effect.locally(FiberRef.currentContext, message.context), Effect.orDie)), Effect.flatMap(message.respond), Effect.scoped, Effect.catchAllDefect(() => Effect.fail(new _ClusterError.RunnerUnavailable({
+            address
+          })))),
+          onFailure: error => message.respond(new Reply.WithExit({
+            id: snowflakeGen.unsafeNext(),
+            requestId: message.envelope.requestId,
+            exit: Exit.die(error)
+          }))
+        });
+      }
+      return Effect.matchEffect(Message.serializeRequest(message), {
+        onSuccess: request => RcMap.get(clients, address).pipe(Effect.flatMap(client => client.Stream({
+          request
+        }, {
+          asMailbox: true
+        })), Effect.flatMap(mailbox => {
+          const decode = Schema.decode(Reply.Reply(message.rpc));
+          return mailbox.take.pipe(Effect.flatMap(reply => Effect.orDie(decode(reply))), Effect.flatMap(message.respond), Effect.forever, Effect.locally(FiberRef.currentContext, message.context), Effect.catchIf(Cause.isNoSuchElementException, () => Effect.void), Effect.catchAllDefect(() => Effect.fail(new _ClusterError.RunnerUnavailable({
+            address
+          }))));
+        }), Effect.scoped),
+        onFailure: error => message.respond(new Reply.WithExit({
+          id: snowflakeGen.unsafeNext(),
+          requestId: message.envelope.requestId,
+          exit: Exit.die(error)
+        }))
+      });
+    },
+    notify({
+      address,
+      message
+    }) {
+      const envelope = message.envelope;
+      return RcMap.get(clients, address).pipe(Effect.flatMap(client => client.Notify({
+        envelope
+      })), Effect.scoped, Effect.ignore);
+    }
+  });
+});
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+const layerRpc = exports.layerRpc = /*#__PURE__*/Layer.scoped(Runners, makeRpc).pipe( /*#__PURE__*/Layer.provide(Snowflake.layerGenerator));
+/**
+ * @since 1.0.0
+ * @category Client
+ */
+class RpcClientProtocol extends /*#__PURE__*/Context.Tag("@effect/cluster/Runners/RpcClientProtocol")() {}
+exports.RpcClientProtocol = RpcClientProtocol;
+//# sourceMappingURL=Runners.js.map
\ No newline at end of file
diff --git a/dist/cjs/Runners.js.map b/dist/cjs/Runners.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..38b54502ba4c9370c73574bec51ce0f30682b5d7
--- /dev/null
+++ b/dist/cjs/Runners.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"Runners.js","names":["Rpc","_interopRequireWildcard","require","RpcClient_","RpcGroup","RpcSchema","Cause","Context","Effect","Exit","FiberRef","Layer","RcMap","Schema","_ClusterError","_ClusterSchema","Envelope","Message","MessageStorage","Reply","_ShardingConfig","Snowflake","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","Runners","Tag","exports","make","fnUntraced","options","storage","snowflakeGen","Generator","config","ShardingConfig","requestIdRewrites","Map","notifyWith","message","afterPersist","rpc","persisted","annotations","Persisted","dieMessage","_tag","rewriteId","envelope","requestId","entry","storageRequests","OutgoingEnvelope","withRequestId","saveEnvelope","pipe","orDie","zipRight","latch","open","flatMap","saveRequest","SaveResult","$match","Success","Duplicate","lastReceivedReply","originalId","OutgoingRequest","makeRequest","respond","reply","delete","waitingStorageRequests","replyFromStorage","unsafeMakeLatch","replies","unsafeClose","storageLatch","await","effect","ensuring","sync","noop","gen","repliesFor","values","catchAllCause","cause","as","annotateLogs","logDebug","package","module","fiber","foundRequests","Set","push","add","unsafeOpen","interruptible","forkScoped","suspend","size","delay","entityReplyPollInterval","forever","of","sendLocal","simulateRemoteSerialization","send","incomingLocalFromOutgoing","serialize","encoded","deserializeLocal","catchTag","error","die","WithExit","id","unsafeNext","exit","notify","options_","discard","fork","andThen","notifyLocal","duplicate","registerReplyHandler","makeNoop","fail","EntityNotManagedByRunner","address","void","ping","layerNoop","scoped","provide","layerGenerator","rpcErrors","Union","MailboxFull","AlreadyProcessingMessage","PersistenceError","Rpcs","payload","PartialEncoded","success","Void","request","PartialEncodedRequest","stream","AckChunk","Interrupt","makeRpcClient","spanPrefix","disableTracing","makeRpc","makeClientProtocol","RpcClientProtocol","clients","lookup","protocol","provideService","Protocol","idleTimeToLive","client","Ping","RunnerUnavailable","catchAllDefect","isStream","isStreamSchema","successSchema","matchEffect","serializeRequest","onSuccess","decode","locally","currentContext","context","onFailure","Stream","asMailbox","mailbox","take","catchIf","isNoSuchElementException","Notify","ignore","layerRpc"],"sources":["../../src/Runners.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/cjs/ShardId.js b/dist/cjs/ShardId.js
index d8d79d88a8c8d5d959c72c3d0ee46ae087341ac7..e93844c7aff625f6c05fc724ff9b88970e2bba54 100644
--- a/dist/cjs/ShardId.js
+++ b/dist/cjs/ShardId.js
@@ -3,64 +3,25 @@
 Object.defineProperty(exports, "__esModule", {
   value: true
 });
-exports.ShardIdTypeId = exports.ShardId = void 0;
-exports.make = make;
-exports.schema = void 0;
+exports.make = exports.ShardId = void 0;
 var Schema = _interopRequireWildcard(require("effect/Schema"));
-var _utils = require("./internal/utils.js");
 function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
 function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
 /**
  * @since 1.0.0
  */
 
-/** @internal */
-const ShardIdSymbolKey = "@effect/cluster/ShardId";
-/**
- * @since 1.0.0
- * @category symbols
- */
-const ShardIdTypeId = exports.ShardIdTypeId = /*#__PURE__*/Symbol.for(ShardIdSymbolKey);
-/** @internal */
-const ShardIdTypeIdSchema = /*#__PURE__*/(0, _utils.TypeIdSchema)(ShardIdSymbolKey, ShardIdTypeId);
 /**
- * A shard is a logical grouping of multiple entities. There could be thousands of entities in your system,
- * so instead of managing every single entity id, the shard manager group them by shard id, and when they are assigned
- * or moved around, we always move all the entities with the same shard id.
- *
- * @since 1.0.0
- * @category models
- */
-class ShardId extends /*#__PURE__*/Schema.Class(ShardIdSymbolKey)({
-  [ShardIdTypeId]: /*#__PURE__*/Schema.propertySignature(ShardIdTypeIdSchema).pipe( /*#__PURE__*/Schema.fromKey(ShardIdSymbolKey)),
-  value: Schema.Number
-}) {
-  /**
-   * @since 1.0.0
-   */
-  toString() {
-    return `ShardId(${this.value})`;
-  }
-}
-/**
- * Constructs a shard id from its numerical value.
- * The shard id is currently built up by making the hash of the entity id, and then modulo the max amount of shards configured in ManagerConfig.
- *
  * @since 1.0.0
  * @category constructors
  */
-exports.ShardId = ShardId;
-function make(value) {
-  return new ShardId({
-    [ShardIdTypeId]: ShardIdTypeId,
-    value
-  });
-}
+const ShardId = exports.ShardId = /*#__PURE__*/Schema.Int.pipe( /*#__PURE__*/Schema.brand("ShardId"), /*#__PURE__*/Schema.annotations({
+  pretty: () => shardId => `ShardId(${shardId})`
+}));
 /**
- * This is the schema for a ShardId.
- *
  * @since 1.0.0
- * @category schema
+ * @category Constructors
  */
-const schema = exports.schema = /*#__PURE__*/Schema.asSchema(ShardId);
+const make = shardId => ShardId.make(shardId);
+exports.make = make;
 //# sourceMappingURL=ShardId.js.map
\ No newline at end of file
diff --git a/dist/cjs/ShardId.js.map b/dist/cjs/ShardId.js.map
index 9becf70ff9b59e382668180650a25216766b5620..4a6de0490dbc99c8b049873eec01a43278799017 100644
--- a/dist/cjs/ShardId.js.map
+++ b/dist/cjs/ShardId.js.map
@@ -1 +1 @@
-{"version":3,"file":"ShardId.js","names":["Schema","_interopRequireWildcard","require","_utils","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","ShardIdSymbolKey","ShardIdTypeId","exports","Symbol","for","ShardIdTypeIdSchema","TypeIdSchema","ShardId","Class","propertySignature","pipe","fromKey","value","Number","toString","make","schema","asSchema"],"sources":["../../src/ShardId.ts"],"sourcesContent":[null],"mappings":";;;;;;;;AAGA,IAAAA,MAAA,GAAAC,uBAAA,CAAAC,OAAA;AACA,IAAAC,MAAA,GAAAD,OAAA;AAAkD,SAAAE,yBAAAC,CAAA,6BAAAC,OAAA,mBAAAC,CAAA,OAAAD,OAAA,IAAAE,CAAA,OAAAF,OAAA,YAAAF,wBAAA,YAAAA,CAAAC,CAAA,WAAAA,CAAA,GAAAG,CAAA,GAAAD,CAAA,KAAAF,CAAA;AAAA,SAAAJ,wBAAAI,CAAA,EAAAE,CAAA,SAAAA,CAAA,IAAAF,CAAA,IAAAA,CAAA,CAAAI,UAAA,SAAAJ,CAAA,eAAAA,CAAA,uBAAAA,CAAA,yBAAAA,CAAA,WAAAK,OAAA,EAAAL,CAAA,QAAAG,CAAA,GAAAJ,wBAAA,CAAAG,CAAA,OAAAC,CAAA,IAAAA,CAAA,CAAAG,GAAA,CAAAN,CAAA,UAAAG,CAAA,CAAAI,GAAA,CAAAP,CAAA,OAAAQ,CAAA,KAAAC,SAAA,UAAAC,CAAA,GAAAC,MAAA,CAAAC,cAAA,IAAAD,MAAA,CAAAE,wBAAA,WAAAC,CAAA,IAAAd,CAAA,oBAAAc,CAAA,OAAAC,cAAA,CAAAC,IAAA,CAAAhB,CAAA,EAAAc,CAAA,SAAAG,CAAA,GAAAP,CAAA,GAAAC,MAAA,CAAAE,wBAAA,CAAAb,CAAA,EAAAc,CAAA,UAAAG,CAAA,KAAAA,CAAA,CAAAV,GAAA,IAAAU,CAAA,CAAAC,GAAA,IAAAP,MAAA,CAAAC,cAAA,CAAAJ,CAAA,EAAAM,CAAA,EAAAG,CAAA,IAAAT,CAAA,CAAAM,CAAA,IAAAd,CAAA,CAAAc,CAAA,YAAAN,CAAA,CAAAH,OAAA,GAAAL,CAAA,EAAAG,CAAA,IAAAA,CAAA,CAAAe,GAAA,CAAAlB,CAAA,EAAAQ,CAAA,GAAAA,CAAA;AAJlD;;;;AAMA;AACA,MAAMW,gBAAgB,GAAG,yBAAyB;AAElD;;;;AAIO,MAAMC,aAAa,GAAAC,OAAA,CAAAD,aAAA,gBAAkBE,MAAM,CAACC,GAAG,CAACJ,gBAAgB,CAAC;AAQxE;AACA,MAAMK,mBAAmB,gBAAG,IAAAC,mBAAY,EAACN,gBAAgB,EAAEC,aAAa,CAAC;AAEzE;;;;;;;;AAQM,MAAOM,OAAQ,sBAAQ/B,MAAM,CAACgC,KAAK,CAAUR,gBAAgB,CAAC,CAAC;EACnE,CAACC,aAAa,gBAAGzB,MAAM,CAACiC,iBAAiB,CAACJ,mBAAmB,CAAC,CAACK,IAAI,eAAClC,MAAM,CAACmC,OAAO,CAACX,gBAAgB,CAAC,CAAC;EACrGY,KAAK,EAAEpC,MAAM,CAACqC;CACf,CAAC;EACA;;;EAGAC,QAAQA,CAAA;IACN,OAAO,WAAW,IAAI,CAACF,KAAK,GAAG;EACjC;;AAiBF;;;;;;;AAAAV,OAAA,CAAAK,OAAA,GAAAA,OAAA;AAOM,SAAUQ,IAAIA,CAACH,KAAa;EAChC,OAAO,IAAIL,OAAO,CAAC;IAAE,CAACN,aAAa,GAAGA,aAAa;IAAEW;EAAK,CAAE,CAAC;AAC/D;AAEA;;;;;;AAMO,MAAMI,MAAM,GAAAd,OAAA,CAAAc,MAAA,gBAGfxC,MAAM,CAACyC,QAAQ,CAACV,OAAO,CAAC","ignoreList":[]}
\ No newline at end of file
+{"version":3,"file":"ShardId.js","names":["Schema","_interopRequireWildcard","require","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","ShardId","exports","Int","pipe","brand","annotations","pretty","shardId","make"],"sources":["../../src/ShardId.ts"],"sourcesContent":[null],"mappings":";;;;;;AAGA,IAAAA,MAAA,GAAAC,uBAAA,CAAAC,OAAA;AAAuC,SAAAC,yBAAAC,CAAA,6BAAAC,OAAA,mBAAAC,CAAA,OAAAD,OAAA,IAAAE,CAAA,OAAAF,OAAA,YAAAF,wBAAA,YAAAA,CAAAC,CAAA,WAAAA,CAAA,GAAAG,CAAA,GAAAD,CAAA,KAAAF,CAAA;AAAA,SAAAH,wBAAAG,CAAA,EAAAE,CAAA,SAAAA,CAAA,IAAAF,CAAA,IAAAA,CAAA,CAAAI,UAAA,SAAAJ,CAAA,eAAAA,CAAA,uBAAAA,CAAA,yBAAAA,CAAA,WAAAK,OAAA,EAAAL,CAAA,QAAAG,CAAA,GAAAJ,wBAAA,CAAAG,CAAA,OAAAC,CAAA,IAAAA,CAAA,CAAAG,GAAA,CAAAN,CAAA,UAAAG,CAAA,CAAAI,GAAA,CAAAP,CAAA,OAAAQ,CAAA,KAAAC,SAAA,UAAAC,CAAA,GAAAC,MAAA,CAAAC,cAAA,IAAAD,MAAA,CAAAE,wBAAA,WAAAC,CAAA,IAAAd,CAAA,oBAAAc,CAAA,OAAAC,cAAA,CAAAC,IAAA,CAAAhB,CAAA,EAAAc,CAAA,SAAAG,CAAA,GAAAP,CAAA,GAAAC,MAAA,CAAAE,wBAAA,CAAAb,CAAA,EAAAc,CAAA,UAAAG,CAAA,KAAAA,CAAA,CAAAV,GAAA,IAAAU,CAAA,CAAAC,GAAA,IAAAP,MAAA,CAAAC,cAAA,CAAAJ,CAAA,EAAAM,CAAA,EAAAG,CAAA,IAAAT,CAAA,CAAAM,CAAA,IAAAd,CAAA,CAAAc,CAAA,YAAAN,CAAA,CAAAH,OAAA,GAAAL,CAAA,EAAAG,CAAA,IAAAA,CAAA,CAAAe,GAAA,CAAAlB,CAAA,EAAAQ,CAAA,GAAAA,CAAA;AAHvC;;;;AAKA;;;;AAIO,MAAMW,OAAO,GAAAC,OAAA,CAAAD,OAAA,gBAAGvB,MAAM,CAACyB,GAAG,CAACC,IAAI,eACpC1B,MAAM,CAAC2B,KAAK,CAAC,SAAS,CAAC,eACvB3B,MAAM,CAAC4B,WAAW,CAAC;EACjBC,MAAM,EAAEA,CAAA,KAAOC,OAAO,IAAK,WAAWA,OAAO;CAC9C,CAAC,CACH;AAQD;;;;AAIO,MAAMC,IAAI,GAAID,OAAe,IAAcP,OAAO,CAACQ,IAAI,CAACD,OAAO,CAAC;AAAAN,OAAA,CAAAO,IAAA,GAAAA,IAAA","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/cjs/ShardManager.js b/dist/cjs/ShardManager.js
index 01b2d0e1d25e54e93a320f50c34afae85dc38bff..afd5487d092a998f53526b9c9f54d7c0bb528503 100644
--- a/dist/cjs/ShardManager.js
+++ b/dist/cjs/ShardManager.js
@@ -3,23 +3,508 @@
 Object.defineProperty(exports, "__esModule", {
   value: true
 });
-exports.live = exports.ShardManagerTypeId = exports.ShardManager = void 0;
-var internal = _interopRequireWildcard(require("./internal/shardManager.js"));
+exports.makeClientRpc = exports.makeClientLocal = exports.make = exports.layerServerHandlers = exports.layerServer = exports.layerConfigFromEnv = exports.layerConfig = exports.layerClientRpc = exports.layerClientLocal = exports.layer = exports.configFromEnv = exports.configConfig = exports.ShardingEventSchema = exports.ShardingEvent = exports.ShardManagerClient = exports.ShardManager = exports.Rpcs = exports.Config = void 0;
+var Rpc = _interopRequireWildcard(require("@effect/rpc/Rpc"));
+var RpcClient = _interopRequireWildcard(require("@effect/rpc/RpcClient"));
+var RpcGroup = _interopRequireWildcard(require("@effect/rpc/RpcGroup"));
+var RpcServer = _interopRequireWildcard(require("@effect/rpc/RpcServer"));
+var Arr = _interopRequireWildcard(require("effect/Array"));
+var Clock = _interopRequireWildcard(require("effect/Clock"));
+var Config_ = _interopRequireWildcard(require("effect/Config"));
+var ConfigProvider = _interopRequireWildcard(require("effect/ConfigProvider"));
+var Context = _interopRequireWildcard(require("effect/Context"));
+var Data = _interopRequireWildcard(require("effect/Data"));
+var Deferred = _interopRequireWildcard(require("effect/Deferred"));
+var Duration = _interopRequireWildcard(require("effect/Duration"));
+var Effect = _interopRequireWildcard(require("effect/Effect"));
+var Equal = _interopRequireWildcard(require("effect/Equal"));
+var FiberSet = _interopRequireWildcard(require("effect/FiberSet"));
+var _Function = require("effect/Function");
+var Iterable = _interopRequireWildcard(require("effect/Iterable"));
+var Layer = _interopRequireWildcard(require("effect/Layer"));
+var Mailbox = _interopRequireWildcard(require("effect/Mailbox"));
+var Metric = _interopRequireWildcard(require("effect/Metric"));
+var MutableHashMap = _interopRequireWildcard(require("effect/MutableHashMap"));
+var MutableHashSet = _interopRequireWildcard(require("effect/MutableHashSet"));
+var Option = _interopRequireWildcard(require("effect/Option"));
+var PubSub = _interopRequireWildcard(require("effect/PubSub"));
+var Queue = _interopRequireWildcard(require("effect/Queue"));
+var Schedule = _interopRequireWildcard(require("effect/Schedule"));
+var Schema = _interopRequireWildcard(require("effect/Schema"));
+var _ClusterError = require("./ClusterError.js");
+var ClusterMetrics = _interopRequireWildcard(require("./ClusterMetrics.js"));
+var _shardManager = require("./internal/shardManager.js");
+var MachineId = _interopRequireWildcard(require("./MachineId.js"));
+var _Runner = require("./Runner.js");
+var _RunnerAddress = require("./RunnerAddress.js");
+var _RunnerHealth = require("./RunnerHealth.js");
+var _Runners = require("./Runners.js");
+var _ShardId = require("./ShardId.js");
+var _ShardingConfig = require("./ShardingConfig.js");
+var _ShardStorage = require("./ShardStorage.js");
 function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
 function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
 /**
  * @since 1.0.0
- * @category symbols
  */
-const ShardManagerTypeId = exports.ShardManagerTypeId = internal.ShardManagerTypeId;
+
+/**
+ * @since 1.0.0
+ * @category models
+ */
+class ShardManager extends /*#__PURE__*/Context.Tag("@effect/cluster/ShardManager")() {}
+/**
+ * @since 1.0.0
+ * @category Config
+ */
+exports.ShardManager = ShardManager;
+class Config extends /*#__PURE__*/Context.Tag("@effect/cluster/ShardManager/Config")() {
+  /**
+   * @since 1.0.0
+   */
+  static defaults = {
+    rebalanceDebounce: /*#__PURE__*/Duration.millis(500),
+    rebalanceInterval: /*#__PURE__*/Duration.seconds(20),
+    rebalanceRetryInterval: /*#__PURE__*/Duration.seconds(10),
+    rebalanceRate: 2 / 100,
+    persistRetryCount: 100,
+    persistRetryInterval: /*#__PURE__*/Duration.seconds(3),
+    runnerHealthCheckInterval: /*#__PURE__*/Duration.minutes(1),
+    runnerPingTimeout: /*#__PURE__*/Duration.seconds(3)
+  };
+}
+/**
+ * @since 1.0.0
+ * @category Config
+ */
+exports.Config = Config;
+const configConfig = exports.configConfig = /*#__PURE__*/Config_.all({
+  rebalanceDebounce: /*#__PURE__*/Config_.duration("rebalanceDebounce").pipe( /*#__PURE__*/Config_.withDefault(Config.defaults.rebalanceDebounce), /*#__PURE__*/Config_.withDescription("The duration to wait before rebalancing shards after a change.")),
+  rebalanceInterval: /*#__PURE__*/Config_.duration("rebalanceInterval").pipe( /*#__PURE__*/Config_.withDefault(Config.defaults.rebalanceInterval), /*#__PURE__*/Config_.withDescription("The interval on which regular rebalancing of shards will occur.")),
+  rebalanceRetryInterval: /*#__PURE__*/Config_.duration("rebalanceRetryInterval").pipe( /*#__PURE__*/Config_.withDefault(Config.defaults.rebalanceRetryInterval), /*#__PURE__*/Config_.withDescription("The interval on which rebalancing of shards which failed to be rebalanced will be retried.")),
+  rebalanceRate: /*#__PURE__*/Config_.number("rebalanceRate").pipe( /*#__PURE__*/Config_.withDefault(Config.defaults.rebalanceRate), /*#__PURE__*/Config_.withDescription("The maximum ratio of shards to rebalance at once.")),
+  persistRetryCount: /*#__PURE__*/Config_.integer("persistRetryCount").pipe( /*#__PURE__*/Config_.withDefault(Config.defaults.persistRetryCount), /*#__PURE__*/Config_.withDescription("The number of times persistence of runners will be retried if it fails.")),
+  persistRetryInterval: /*#__PURE__*/Config_.duration("persistRetryInterval").pipe( /*#__PURE__*/Config_.withDefault(Config.defaults.persistRetryInterval), /*#__PURE__*/Config_.withDescription("The interval on which persistence of runners will be retried if it fails.")),
+  runnerHealthCheckInterval: /*#__PURE__*/Config_.duration("runnerHealthCheckInterval").pipe( /*#__PURE__*/Config_.withDefault(Config.defaults.runnerHealthCheckInterval), /*#__PURE__*/Config_.withDescription("The interval on which runner health will be checked.")),
+  runnerPingTimeout: /*#__PURE__*/Config_.duration("runnerPingTimeout").pipe( /*#__PURE__*/Config_.withDefault(Config.defaults.runnerPingTimeout), /*#__PURE__*/Config_.withDescription("The length of time to wait for a runner to respond to a ping."))
+});
+/**
+ * @since 1.0.0
+ * @category Config
+ */
+const configFromEnv = exports.configFromEnv = /*#__PURE__*/configConfig.pipe( /*#__PURE__*/Effect.withConfigProvider( /*#__PURE__*/ConfigProvider.fromEnv().pipe(ConfigProvider.constantCase)));
+/**
+ * @since 1.0.0
+ * @category Config
+ */
+const layerConfig = config => Layer.succeed(Config, {
+  ...Config.defaults,
+  ...config
+});
+/**
+ * @since 1.0.0
+ * @category Config
+ */
+exports.layerConfig = layerConfig;
+const layerConfigFromEnv = exports.layerConfigFromEnv = /*#__PURE__*/Layer.effect(Config, configFromEnv);
+/**
+ * Represents a client which can be used to communicate with the
+ * `ShardManager`.
+ *
+ * @since 1.0.0
+ * @category Client
+ */
+class ShardManagerClient extends /*#__PURE__*/Context.Tag("@effect/cluster/ShardManager/ShardManagerClient")() {}
+/**
+ * @since 1.0.0
+ * @category models
+ */
+exports.ShardManagerClient = ShardManagerClient;
+const ShardingEventSchema = exports.ShardingEventSchema = /*#__PURE__*/Schema.Union( /*#__PURE__*/Schema.TaggedStruct("StreamStarted", {}), /*#__PURE__*/Schema.TaggedStruct("ShardsAssigned", {
+  address: _RunnerAddress.RunnerAddress,
+  shards: /*#__PURE__*/Schema.Array(_ShardId.ShardId)
+}), /*#__PURE__*/Schema.TaggedStruct("ShardsUnassigned", {
+  address: _RunnerAddress.RunnerAddress,
+  shards: /*#__PURE__*/Schema.Array(_ShardId.ShardId)
+}), /*#__PURE__*/Schema.TaggedStruct("RunnerRegistered", {
+  address: _RunnerAddress.RunnerAddress
+}), /*#__PURE__*/Schema.TaggedStruct("RunnerUnregistered", {
+  address: _RunnerAddress.RunnerAddress
+}));
+/**
+ * The messaging protocol for the `ShardManager`.
+ *
+ * @since 1.0.0
+ * @category Rpcs
+ */
+class Rpcs extends /*#__PURE__*/RpcGroup.make( /*#__PURE__*/Rpc.make("Register", {
+  payload: {
+    runner: _Runner.Runner
+  },
+  success: MachineId.MachineId
+}), /*#__PURE__*/Rpc.make("Unregister", {
+  payload: {
+    address: _RunnerAddress.RunnerAddress
+  }
+}), /*#__PURE__*/Rpc.make("NotifyUnhealthyRunner", {
+  payload: {
+    address: _RunnerAddress.RunnerAddress
+  }
+}), /*#__PURE__*/Rpc.make("GetAssignments", {
+  success: /*#__PURE__*/Schema.ReadonlyMap({
+    key: _ShardId.ShardId,
+    value: /*#__PURE__*/Schema.Option(_RunnerAddress.RunnerAddress)
+  })
+}), /*#__PURE__*/Rpc.make("ShardingEvents", {
+  success: ShardingEventSchema,
+  stream: true
+}), /*#__PURE__*/Rpc.make("GetTime", {
+  success: Schema.Number
+})) {}
+/**
+ * @since 1.0.0
+ * @category models
+ */
+exports.Rpcs = Rpcs;
+const ShardingEvent = exports.ShardingEvent = /*#__PURE__*/Data.taggedEnum();
+/**
+ * @since 1.0.0
+ * @category Client
+ */
+const makeClientLocal = exports.makeClientLocal = /*#__PURE__*/Effect.gen(function* () {
+  const runnerAddress = yield* _ShardingConfig.ShardingConfig;
+  const clock = yield* Effect.clock;
+  const shards = new Map();
+  for (let n = 1; n <= runnerAddress.numberOfShards; n++) {
+    shards.set(_ShardId.ShardId.make(n), runnerAddress.runnerAddress);
+  }
+  let machineId = 0;
+  return ShardManagerClient.of({
+    register: () => Effect.sync(() => MachineId.make(++machineId)),
+    unregister: () => Effect.void,
+    notifyUnhealthyRunner: () => Effect.void,
+    getAssignments: Effect.succeed(shards),
+    shardingEvents: Effect.gen(function* () {
+      const mailbox = yield* Mailbox.make();
+      yield* mailbox.offer(ShardingEvent.StreamStarted());
+      return mailbox;
+    }),
+    getTime: clock.currentTimeMillis
+  });
+});
+/**
+ * @since 1.0.0
+ * @category Client
+ */
+const makeClientRpc = exports.makeClientRpc = /*#__PURE__*/Effect.gen(function* () {
+  const config = yield* _ShardingConfig.ShardingConfig;
+  const client = yield* RpcClient.make(Rpcs, {
+    spanPrefix: "ShardManagerClient",
+    disableTracing: true
+  });
+  return ShardManagerClient.of({
+    register: address => client.Register({
+      runner: _Runner.Runner.make({
+        address,
+        version: config.serverVersion
+      })
+    }),
+    unregister: address => client.Unregister({
+      address
+    }),
+    notifyUnhealthyRunner: address => client.NotifyUnhealthyRunner({
+      address
+    }),
+    getAssignments: client.GetAssignments(),
+    shardingEvents: client.ShardingEvents({}, {
+      asMailbox: true
+    }),
+    getTime: client.GetTime()
+  });
+});
+/**
+ * @since 1.0.0
+ * @category Client
+ */
+const layerClientLocal = exports.layerClientLocal = /*#__PURE__*/Layer.effect(ShardManagerClient, makeClientLocal);
+/**
+ * @since 1.0.0
+ * @category Client
+ */
+const layerClientRpc = exports.layerClientRpc = /*#__PURE__*/Layer.scoped(ShardManagerClient, makeClientRpc).pipe( /*#__PURE__*/Layer.provide( /*#__PURE__*/Layer.scoped(RpcClient.Protocol, /*#__PURE__*/Effect.gen(function* () {
+  const config = yield* _ShardingConfig.ShardingConfig;
+  const clientProtocol = yield* _Runners.RpcClientProtocol;
+  return yield* clientProtocol(config.shardManagerAddress);
+}))));
+/**
+ * @since 1.0.0
+ * @category Constructors
+ */
+const make = exports.make = /*#__PURE__*/Effect.gen(function* () {
+  const storage = yield* _ShardStorage.ShardStorage;
+  const runnersApi = yield* _Runners.Runners;
+  const runnerHealthApi = yield* _RunnerHealth.RunnerHealth;
+  const clock = yield* Effect.clock;
+  const config = yield* Config;
+  const shardingConfig = yield* _ShardingConfig.ShardingConfig;
+  const state = yield* Effect.orDie(_shardManager.State.fromStorage(shardingConfig.numberOfShards));
+  const scope = yield* Effect.scope;
+  const events = yield* PubSub.unbounded();
+  yield* Metric.incrementBy(ClusterMetrics.runners, MutableHashMap.size(state.runners));
+  for (const address of state.shards.values()) {
+    const metric = Option.isSome(address) ? Metric.tagged(ClusterMetrics.assignedShards, "address", address.toString()) : ClusterMetrics.unassignedShards;
+    yield* Metric.increment(metric);
+  }
+  function withRetry(effect) {
+    return effect.pipe(Effect.retry({
+      schedule: Schedule.spaced(config.persistRetryCount),
+      times: config.persistRetryCount
+    }), Effect.ignore);
+  }
+  const persistRunners = Effect.unsafeMakeSemaphore(1).withPermits(1)(withRetry(Effect.suspend(() => storage.saveRunners(Iterable.map(state.runners, ([address, runner]) => [address, runner.runner])))));
+  const persistAssignments = Effect.unsafeMakeSemaphore(1).withPermits(1)(withRetry(Effect.suspend(() => storage.saveAssignments(state.shards))));
+  const notifyUnhealthyRunner = Effect.fnUntraced(function* (address) {
+    if (!MutableHashMap.has(state.runners, address)) return;
+    yield* Metric.increment(Metric.tagged(ClusterMetrics.runnerHealthChecked, "runner_address", address.toString()));
+    if (!(yield* runnerHealthApi.isAlive(address))) {
+      yield* Effect.logWarning(`Runner at address '${address.toString()}' is not alive`);
+      yield* unregister(address);
+    }
+  });
+  function updateShardsState(shards, address) {
+    return Effect.suspend(() => {
+      if (Option.isSome(address) && !MutableHashMap.has(state.runners, address.value)) {
+        return Effect.fail(new _ClusterError.RunnerNotRegistered({
+          address: address.value
+        }));
+      }
+      for (const shardId of shards) {
+        if (!state.shards.has(shardId)) continue;
+        state.shards.set(shardId, address);
+      }
+      return Effect.void;
+    });
+  }
+  const getAssignments = Effect.sync(() => state.shards);
+  let machineId = 0;
+  const register = Effect.fnUntraced(function* (runner) {
+    yield* Effect.logInfo(`Registering runner ${_Runner.Runner.pretty(runner)}`);
+    const now = clock.unsafeCurrentTimeMillis();
+    MutableHashMap.set(state.runners, runner.address, (0, _shardManager.RunnerWithMetadata)({
+      runner,
+      registeredAt: now
+    }));
+    yield* Metric.increment(ClusterMetrics.runners);
+    yield* PubSub.publish(events, ShardingEvent.RunnerRegistered({
+      address: runner.address
+    }));
+    if (state.unassignedShards.length > 0) {
+      yield* rebalance(false);
+    }
+    yield* Effect.forkIn(persistRunners, scope);
+    return MachineId.make(++machineId);
+  });
+  const unregister = Effect.fnUntraced(function* (address) {
+    if (!MutableHashMap.has(state.runners, address)) return;
+    yield* Effect.logInfo("Unregistering runner at address:", address);
+    const unassignments = Arr.empty();
+    for (const [shard, runner] of state.shards) {
+      if (Option.isSome(runner) && Equal.equals(runner.value, address)) {
+        unassignments.push(shard);
+        state.shards.set(shard, Option.none());
+      }
+    }
+    MutableHashMap.remove(state.runners, address);
+    yield* Metric.incrementBy(ClusterMetrics.runners, -1);
+    if (unassignments.length > 0) {
+      yield* Metric.incrementBy(Metric.tagged(ClusterMetrics.unassignedShards, "runner_address", address.toString()), unassignments.length);
+      yield* PubSub.publish(events, ShardingEvent.RunnerUnregistered({
+        address
+      }));
+    }
+    yield* Effect.forkIn(persistRunners, scope);
+    yield* Effect.forkIn(rebalance(true), scope);
+  });
+  let rebalancing = false;
+  let nextRebalanceImmediate = false;
+  let rebalanceDeferred;
+  const rebalanceFibers = yield* FiberSet.make();
+  const rebalance = immmediate => Effect.withFiberRuntime(fiber => {
+    if (!rebalancing) {
+      rebalancing = true;
+      return rebalanceLoop(immmediate);
+    }
+    if (immmediate) {
+      nextRebalanceImmediate = true;
+    }
+    if (!rebalanceDeferred) {
+      rebalanceDeferred = Deferred.unsafeMake(fiber.id());
+    }
+    return Deferred.await(rebalanceDeferred);
+  });
+  const rebalanceLoop = immediate => Effect.suspend(() => {
+    const deferred = rebalanceDeferred;
+    rebalanceDeferred = undefined;
+    if (!immediate) {
+      immediate = nextRebalanceImmediate;
+      nextRebalanceImmediate = false;
+    }
+    return runRebalance(immediate).pipe(deferred ? Effect.intoDeferred(deferred) : _Function.identity, Effect.onExit(() => {
+      if (!rebalanceDeferred) {
+        rebalancing = false;
+        return Effect.void;
+      }
+      return Effect.forkIn(rebalanceLoop(), scope);
+    }));
+  });
+  const runRebalance = Effect.fn("ShardManager.rebalance")(function* (immediate) {
+    yield* Effect.annotateCurrentSpan("immmediate", immediate);
+    yield* Effect.sleep(config.rebalanceDebounce);
+    // Determine which shards to assign and unassign
+    const [assignments, unassignments, changes] = immediate || state.unassignedShards.length > 0 ? (0, _shardManager.decideAssignmentsForUnassignedShards)(state) : (0, _shardManager.decideAssignmentsForUnbalancedShards)(state, config.rebalanceRate);
+    yield* Effect.logDebug(`Rebalancing shards (immediate = ${immediate})`);
+    if (MutableHashSet.size(changes) === 0) return;
+    yield* Metric.increment(ClusterMetrics.rebalances);
+    // Ping runners first and remove unhealthy ones
+    const failedRunners = MutableHashSet.empty();
+    for (const address of changes) {
+      yield* FiberSet.run(rebalanceFibers, runnersApi.ping(address).pipe(Effect.timeout(config.runnerPingTimeout), Effect.catchAll(() => {
+        MutableHashSet.add(failedRunners, address);
+        MutableHashMap.remove(assignments, address);
+        MutableHashMap.remove(unassignments, address);
+        return Effect.void;
+      })));
+    }
+    yield* FiberSet.awaitEmpty(rebalanceFibers);
+    const failedUnassignments = new Set();
+    for (const [address, shards] of unassignments) {
+      yield* FiberSet.run(rebalanceFibers, updateShardsState(shards, Option.none()).pipe(Effect.matchEffect({
+        onFailure: () => {
+          MutableHashSet.add(failedRunners, address);
+          for (const shard of shards) {
+            failedUnassignments.add(shard);
+          }
+          // Remove failed runners from the assignments
+          MutableHashMap.remove(assignments, address);
+          return Effect.void;
+        },
+        onSuccess: () => {
+          const shardCount = shards.size;
+          return Metric.incrementBy(Metric.tagged(ClusterMetrics.assignedShards, "runner_address", address.toString()), -shardCount).pipe(Effect.zipRight(Metric.incrementBy(ClusterMetrics.unassignedShards, shardCount)), Effect.zipRight(PubSub.publish(events, ShardingEvent.ShardsUnassigned({
+            address,
+            shards: Array.from(shards)
+          }))));
+        }
+      })));
+    }
+    yield* FiberSet.awaitEmpty(rebalanceFibers);
+    // Remove failed shard unassignments from the assignments
+    MutableHashMap.forEach(assignments, (shards, address) => {
+      for (const shard of failedUnassignments) {
+        shards.delete(shard);
+      }
+      if (shards.size === 0) {
+        MutableHashMap.remove(assignments, address);
+      }
+    });
+    // Perform the assignments
+    for (const [address, shards] of assignments) {
+      yield* FiberSet.run(rebalanceFibers, updateShardsState(shards, Option.some(address)).pipe(Effect.matchEffect({
+        onFailure: () => {
+          MutableHashSet.add(failedRunners, address);
+          return Effect.void;
+        },
+        onSuccess: () => {
+          const shardCount = shards.size;
+          return Metric.incrementBy(Metric.tagged(ClusterMetrics.assignedShards, "runner_address", address.toString()), -shardCount).pipe(Effect.zipRight(Metric.incrementBy(ClusterMetrics.unassignedShards, -shardCount)), Effect.zipRight(PubSub.publish(events, ShardingEvent.ShardsAssigned({
+            address,
+            shards: Array.from(shards)
+          }))));
+        }
+      })));
+    }
+    yield* FiberSet.awaitEmpty(rebalanceFibers);
+    const wereFailures = MutableHashSet.size(failedRunners) > 0;
+    if (wereFailures) {
+      // Check if the failing runners are still reachable
+      yield* Effect.forEach(failedRunners, notifyUnhealthyRunner, {
+        discard: true
+      }).pipe(Effect.forkIn(scope));
+      yield* Effect.logWarning("Failed to rebalance runners: ", failedRunners);
+    }
+    if (wereFailures && immediate) {
+      // Try rebalancing again later if there were any failures
+      yield* Clock.sleep(config.rebalanceRetryInterval).pipe(Effect.zipRight(rebalance(immediate)), Effect.forkIn(scope));
+    }
+    yield* persistAssignments;
+  });
+  const checkRunnerHealth = Effect.suspend(() => Effect.forEach(MutableHashMap.keys(state.runners), notifyUnhealthyRunner, {
+    concurrency: "inherit",
+    discard: true
+  })).pipe(Effect.withConcurrency(4), Effect.asVoid);
+  yield* Effect.addFinalizer(() => persistAssignments.pipe(Effect.catchAllCause(cause => Effect.logWarning("Failed to persist assignments on shutdown", cause)), Effect.zipRight(persistRunners.pipe(Effect.catchAllCause(cause => Effect.logWarning("Failed to persist runners on shutdown", cause))))));
+  yield* Effect.forkIn(persistRunners, scope);
+  // Rebalance immediately if there are unassigned shards
+  yield* Effect.forkIn(rebalance(state.unassignedShards.length > 0), scope);
+  // Start a regular cluster rebalance at the configured interval
+  yield* rebalance(false).pipe(Effect.andThen(Effect.sleep(config.rebalanceInterval)), Effect.forever, Effect.forkIn(scope));
+  yield* checkRunnerHealth.pipe(Effect.andThen(Effect.sleep(config.runnerHealthCheckInterval)), Effect.forever, Effect.forkIn(scope));
+  yield* Effect.gen(function* () {
+    const queue = yield* PubSub.subscribe(events);
+    while (true) {
+      yield* Effect.logInfo("Shard manager event:", yield* Queue.take(queue));
+    }
+  }).pipe(Effect.forkIn(scope));
+  yield* Effect.logInfo("Shard manager initialized");
+  return ShardManager.of({
+    getAssignments,
+    shardingEvents: PubSub.subscribe(events),
+    register,
+    unregister,
+    rebalance,
+    notifyUnhealthyRunner,
+    checkRunnerHealth
+  });
+});
+/**
+ * @since 1.0.0
+ * @category layer
+ */
+const layer = exports.layer = /*#__PURE__*/Layer.scoped(ShardManager, make);
 /**
  * @since 1.0.0
- * @category context
+ * @category Server
  */
-const ShardManager = exports.ShardManager = internal.shardManagerTag;
+const layerServerHandlers = exports.layerServerHandlers = /*#__PURE__*/Rpcs.toLayer( /*#__PURE__*/Effect.gen(function* () {
+  const shardManager = yield* ShardManager;
+  const clock = yield* Effect.clock;
+  return {
+    Register: ({
+      runner
+    }) => shardManager.register(runner),
+    Unregister: ({
+      address
+    }) => shardManager.unregister(address),
+    NotifyUnhealthyRunner: ({
+      address
+    }) => shardManager.notifyUnhealthyRunner(address),
+    GetAssignments: () => shardManager.getAssignments,
+    ShardingEvents: Effect.fnUntraced(function* () {
+      const queue = yield* shardManager.shardingEvents;
+      const mailbox = yield* Mailbox.make();
+      yield* mailbox.offer(ShardingEvent.StreamStarted());
+      yield* Queue.takeBetween(queue, 1, Number.MAX_SAFE_INTEGER).pipe(Effect.flatMap(events => mailbox.offerAll(events)), Effect.forever, Effect.forkScoped);
+      return mailbox;
+    }),
+    GetTime: () => clock.currentTimeMillis
+  };
+}));
 /**
  * @since 1.0.0
- * @category layers
+ * @category Server
  */
-const live = exports.live = internal.live;
+const layerServer = exports.layerServer = /*#__PURE__*/RpcServer.layer(Rpcs, {
+  spanPrefix: "ShardManager",
+  disableTracing: true
+}).pipe( /*#__PURE__*/Layer.provide(layerServerHandlers));
 //# sourceMappingURL=ShardManager.js.map
\ No newline at end of file
diff --git a/dist/cjs/ShardManager.js.map b/dist/cjs/ShardManager.js.map
index f5e7ff43557cb059ea0f586e11d7816f7f785947..469fb3eaa567a4f211969f242f25658cf04de018 100644
--- a/dist/cjs/ShardManager.js.map
+++ b/dist/cjs/ShardManager.js.map
@@ -1 +1 @@
-{"version":3,"file":"ShardManager.js","names":["internal","_interopRequireWildcard","require","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","ShardManagerTypeId","exports","ShardManager","shardManagerTag","live"],"sources":["../../src/ShardManager.ts"],"sourcesContent":[null],"mappings":";;;;;;AAOA,IAAAA,QAAA,GAAAC,uBAAA,CAAAC,OAAA;AAAsD,SAAAC,yBAAAC,CAAA,6BAAAC,OAAA,mBAAAC,CAAA,OAAAD,OAAA,IAAAE,CAAA,OAAAF,OAAA,YAAAF,wBAAA,YAAAA,CAAAC,CAAA,WAAAA,CAAA,GAAAG,CAAA,GAAAD,CAAA,KAAAF,CAAA;AAAA,SAAAH,wBAAAG,CAAA,EAAAE,CAAA,SAAAA,CAAA,IAAAF,CAAA,IAAAA,CAAA,CAAAI,UAAA,SAAAJ,CAAA,eAAAA,CAAA,uBAAAA,CAAA,yBAAAA,CAAA,WAAAK,OAAA,EAAAL,CAAA,QAAAG,CAAA,GAAAJ,wBAAA,CAAAG,CAAA,OAAAC,CAAA,IAAAA,CAAA,CAAAG,GAAA,CAAAN,CAAA,UAAAG,CAAA,CAAAI,GAAA,CAAAP,CAAA,OAAAQ,CAAA,KAAAC,SAAA,UAAAC,CAAA,GAAAC,MAAA,CAAAC,cAAA,IAAAD,MAAA,CAAAE,wBAAA,WAAAC,CAAA,IAAAd,CAAA,oBAAAc,CAAA,OAAAC,cAAA,CAAAC,IAAA,CAAAhB,CAAA,EAAAc,CAAA,SAAAG,CAAA,GAAAP,CAAA,GAAAC,MAAA,CAAAE,wBAAA,CAAAb,CAAA,EAAAc,CAAA,UAAAG,CAAA,KAAAA,CAAA,CAAAV,GAAA,IAAAU,CAAA,CAAAC,GAAA,IAAAP,MAAA,CAAAC,cAAA,CAAAJ,CAAA,EAAAM,CAAA,EAAAG,CAAA,IAAAT,CAAA,CAAAM,CAAA,IAAAd,CAAA,CAAAc,CAAA,YAAAN,CAAA,CAAAH,OAAA,GAAAL,CAAA,EAAAG,CAAA,IAAAA,CAAA,CAAAe,GAAA,CAAAlB,CAAA,EAAAQ,CAAA,GAAAA,CAAA;AAMtD;;;;AAIO,MAAMW,kBAAkB,GAAAC,OAAA,CAAAD,kBAAA,GAAkBvB,QAAQ,CAACuB,kBAAkB;AAQ5E;;;;AAIO,MAAME,YAAY,GAAAD,OAAA,CAAAC,YAAA,GAAGzB,QAAQ,CAAC0B,eAAe;AAmBpD;;;;AAIO,MAAMC,IAAI,GAAAH,OAAA,CAAAG,IAAA,GAAG3B,QAAQ,CAAC2B,IAAI","ignoreList":[]}
\ No newline at end of file
+{"version":3,"file":"ShardManager.js","names":["Rpc","_interopRequireWildcard","require","RpcClient","RpcGroup","RpcServer","Arr","Clock","Config_","ConfigProvider","Context","Data","Deferred","Duration","Effect","Equal","FiberSet","_Function","Iterable","Layer","Mailbox","Metric","MutableHashMap","MutableHashSet","Option","PubSub","Queue","Schedule","Schema","_ClusterError","ClusterMetrics","_shardManager","MachineId","_Runner","_RunnerAddress","_RunnerHealth","_Runners","_ShardId","_ShardingConfig","_ShardStorage","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","ShardManager","Tag","exports","Config","defaults","rebalanceDebounce","millis","rebalanceInterval","seconds","rebalanceRetryInterval","rebalanceRate","persistRetryCount","persistRetryInterval","runnerHealthCheckInterval","minutes","runnerPingTimeout","configConfig","all","duration","pipe","withDefault","withDescription","number","integer","configFromEnv","withConfigProvider","fromEnv","constantCase","layerConfig","config","succeed","layerConfigFromEnv","effect","ShardManagerClient","ShardingEventSchema","Union","TaggedStruct","address","RunnerAddress","shards","Array","ShardId","Rpcs","make","payload","runner","Runner","success","ReadonlyMap","key","value","stream","Number","ShardingEvent","taggedEnum","makeClientLocal","gen","runnerAddress","ShardingConfig","clock","Map","numberOfShards","machineId","of","register","sync","unregister","void","notifyUnhealthyRunner","getAssignments","shardingEvents","mailbox","offer","StreamStarted","getTime","currentTimeMillis","makeClientRpc","client","spanPrefix","disableTracing","Register","version","serverVersion","Unregister","NotifyUnhealthyRunner","GetAssignments","ShardingEvents","asMailbox","GetTime","layerClientLocal","layerClientRpc","scoped","provide","Protocol","clientProtocol","RpcClientProtocol","shardManagerAddress","storage","ShardStorage","runnersApi","Runners","runnerHealthApi","RunnerHealth","shardingConfig","state","orDie","State","fromStorage","scope","events","unbounded","incrementBy","runners","size","values","metric","isSome","tagged","assignedShards","toString","unassignedShards","increment","withRetry","retry","schedule","spaced","times","ignore","persistRunners","unsafeMakeSemaphore","withPermits","suspend","saveRunners","map","persistAssignments","saveAssignments","fnUntraced","runnerHealthChecked","isAlive","logWarning","updateShardsState","fail","RunnerNotRegistered","shardId","logInfo","pretty","now","unsafeCurrentTimeMillis","RunnerWithMetadata","registeredAt","publish","RunnerRegistered","length","rebalance","forkIn","unassignments","empty","shard","equals","push","none","remove","RunnerUnregistered","rebalancing","nextRebalanceImmediate","rebalanceDeferred","rebalanceFibers","immmediate","withFiberRuntime","fiber","rebalanceLoop","unsafeMake","id","await","immediate","deferred","undefined","runRebalance","intoDeferred","identity","onExit","fn","annotateCurrentSpan","sleep","assignments","changes","decideAssignmentsForUnassignedShards","decideAssignmentsForUnbalancedShards","logDebug","rebalances","failedRunners","run","ping","timeout","catchAll","add","awaitEmpty","failedUnassignments","Set","matchEffect","onFailure","onSuccess","shardCount","zipRight","ShardsUnassigned","from","forEach","delete","some","ShardsAssigned","wereFailures","discard","checkRunnerHealth","keys","concurrency","withConcurrency","asVoid","addFinalizer","catchAllCause","cause","andThen","forever","queue","subscribe","take","layer","layerServerHandlers","toLayer","shardManager","takeBetween","MAX_SAFE_INTEGER","flatMap","offerAll","forkScoped","layerServer"],"sources":["../../src/ShardManager.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/cjs/ShardStorage.js b/dist/cjs/ShardStorage.js
new file mode 100644
index 0000000000000000000000000000000000000000..f5a980c5e02c8b833be38b675b3a5e58ddc20471
--- /dev/null
+++ b/dist/cjs/ShardStorage.js
@@ -0,0 +1,139 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.makeMemory = exports.makeEncoded = exports.layerNoop = exports.layerMemory = exports.ShardStorage = void 0;
+var Context = _interopRequireWildcard(require("effect/Context"));
+var Effect = _interopRequireWildcard(require("effect/Effect"));
+var Layer = _interopRequireWildcard(require("effect/Layer"));
+var MutableHashMap = _interopRequireWildcard(require("effect/MutableHashMap"));
+var Option = _interopRequireWildcard(require("effect/Option"));
+var _Runner = require("./Runner.js");
+var _RunnerAddress = require("./RunnerAddress.js");
+var _ShardId = require("./ShardId.js");
+function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
+function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
+/**
+ * @since 1.0.0
+ */
+
+/**
+ * Represents a generic interface to the persistent storage required by the
+ * cluster.
+ *
+ * @since 1.0.0
+ * @category models
+ */
+class ShardStorage extends /*#__PURE__*/Context.Tag("@effect/cluster/ShardStorage")() {}
+/**
+ * @since 1.0.0
+ * @category layers
+ */
+exports.ShardStorage = ShardStorage;
+const makeEncoded = exports.makeEncoded = /*#__PURE__*/Effect.fnUntraced(function* (encoded) {
+  const activeShards = new Set();
+  return ShardStorage.of({
+    getAssignments: Effect.map(encoded.getAssignments, assignments => {
+      const map = new Map();
+      for (const [shardId, runnerAddress] of assignments) {
+        map.set(_ShardId.ShardId.make(shardId), runnerAddress === null ? Option.none() : Option.some(decodeRunnerAddress(runnerAddress)));
+      }
+      return map;
+    }),
+    saveAssignments: assignments => encoded.saveAssignments(Array.from(assignments, ([shardId, runnerAddress]) => [shardId, Option.isNone(runnerAddress) ? null : encodeRunnerAddress(runnerAddress.value)])),
+    getRunners: Effect.gen(function* () {
+      const runners = yield* encoded.getRunners;
+      const results = new Array(runners.length);
+      for (let i = 0; i < runners.length; i++) {
+        const [address, runner] = runners[i];
+        results[i] = [decodeRunnerAddress(address), _Runner.Runner.decodeSync(runner)];
+      }
+      return results;
+    }),
+    saveRunners: runners => Effect.suspend(() => encoded.saveRunners(Array.from(runners, ([address, runner]) => [encodeRunnerAddress(address), _Runner.Runner.encodeSync(runner)]))),
+    acquire: (address, shardIds) => encoded.acquire(encodeRunnerAddress(address), Array.from(shardIds)),
+    refresh: (address, shardIds) => encoded.refresh(encodeRunnerAddress(address), Array.from(shardIds)),
+    release: Effect.fnUntraced(function* (address, shardId) {
+      activeShards.delete(shardId);
+      yield* encoded.release(encodeRunnerAddress(address), shardId).pipe(Effect.onError(() => Effect.sync(() => activeShards.add(shardId))));
+    }),
+    releaseAll: Effect.fnUntraced(function* (address) {
+      activeShards.clear();
+      yield* encoded.releaseAll(encodeRunnerAddress(address));
+    })
+  });
+});
+/**
+ * @since 1.0.0
+ * @category layers
+ */
+const layerNoop = exports.layerNoop = /*#__PURE__*/Layer.sync(ShardStorage, () => {
+  let acquired = [];
+  return ShardStorage.of({
+    getAssignments: Effect.succeed(new Map()),
+    saveAssignments: () => Effect.void,
+    getRunners: Effect.sync(() => []),
+    saveRunners: () => Effect.void,
+    acquire: (_address, shards) => {
+      acquired = Array.from(shards);
+      return Effect.succeed(Array.from(shards));
+    },
+    refresh: () => Effect.sync(() => acquired),
+    release: () => Effect.void,
+    releaseAll: () => Effect.void
+  });
+});
+/**
+ * @since 1.0.0
+ * @category constructors
+ */
+const makeMemory = exports.makeMemory = /*#__PURE__*/Effect.gen(function* () {
+  const assignments = new Map();
+  const runners = MutableHashMap.empty();
+  function saveAssignments(value) {
+    return Effect.sync(() => {
+      for (const [shardId, runnerAddress] of value) {
+        assignments.set(shardId, runnerAddress);
+      }
+    });
+  }
+  function saveRunners(value) {
+    return Effect.sync(() => {
+      for (const [address, runner] of value) {
+        MutableHashMap.set(runners, address, runner);
+      }
+    });
+  }
+  let acquired = [];
+  return ShardStorage.of({
+    getAssignments: Effect.sync(() => new Map(assignments)),
+    saveAssignments,
+    getRunners: Effect.sync(() => Array.from(runners)),
+    saveRunners,
+    acquire: (_address, shardIds) => {
+      acquired = Array.from(shardIds);
+      return Effect.succeed(Array.from(shardIds));
+    },
+    refresh: () => Effect.sync(() => acquired),
+    release: () => Effect.void,
+    releaseAll: () => Effect.void
+  });
+});
+/**
+ * @since 1.0.0
+ * @category layers
+ */
+const layerMemory = exports.layerMemory = /*#__PURE__*/Layer.effect(ShardStorage, makeMemory);
+// -------------------------------------------------------------------------------------
+// internal
+// -------------------------------------------------------------------------------------
+const encodeRunnerAddress = runnerAddress => `${runnerAddress.host}:${runnerAddress.port}`;
+const decodeRunnerAddress = runnerAddress => {
+  const [host, port] = runnerAddress.split(":");
+  return new _RunnerAddress.RunnerAddress({
+    host,
+    port: Number(port)
+  });
+};
+//# sourceMappingURL=ShardStorage.js.map
\ No newline at end of file
diff --git a/dist/cjs/ShardStorage.js.map b/dist/cjs/ShardStorage.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..3cc84452311157ce8e0087fd8e738c8d9fbeeb07
--- /dev/null
+++ b/dist/cjs/ShardStorage.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"ShardStorage.js","names":["Context","_interopRequireWildcard","require","Effect","Layer","MutableHashMap","Option","_Runner","_RunnerAddress","_ShardId","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","ShardStorage","Tag","exports","makeEncoded","fnUntraced","encoded","activeShards","Set","of","getAssignments","map","assignments","Map","shardId","runnerAddress","ShardId","make","none","some","decodeRunnerAddress","saveAssignments","Array","from","isNone","encodeRunnerAddress","value","getRunners","gen","runners","results","length","address","runner","Runner","decodeSync","saveRunners","suspend","encodeSync","acquire","shardIds","refresh","release","delete","pipe","onError","sync","add","releaseAll","clear","layerNoop","acquired","succeed","void","_address","shards","makeMemory","empty","layerMemory","effect","host","port","split","RunnerAddress","Number"],"sources":["../../src/ShardStorage.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/cjs/Sharding.js b/dist/cjs/Sharding.js
index 26df010f09b7cebe024d4a15135e858561e2c765..e7e7cd6bb83a4cc058c6e8103f047f001188dfb3 100644
--- a/dist/cjs/Sharding.js
+++ b/dist/cjs/Sharding.js
@@ -3,104 +3,749 @@
 Object.defineProperty(exports, "__esModule", {
   value: true
 });
-exports.unregister = exports.sendMessageToLocalEntityManagerWithoutRetries = exports.registerTopic = exports.registerSingleton = exports.registerScoped = exports.registerEntity = exports.register = exports.messenger = exports.live = exports.getPods = exports.getAssignedShardIds = exports.broadcaster = exports.Tag = exports.ShardingTypeId = void 0;
-var internal = _interopRequireWildcard(require("./internal/sharding.js"));
+exports.make = exports.layer = exports.Sharding = void 0;
+var RpcClient = _interopRequireWildcard(require("@effect/rpc/RpcClient"));
+var _RpcMessage = require("@effect/rpc/RpcMessage");
+var Arr = _interopRequireWildcard(require("effect/Array"));
+var Cause = _interopRequireWildcard(require("effect/Cause"));
+var Context = _interopRequireWildcard(require("effect/Context"));
+var Effect = _interopRequireWildcard(require("effect/Effect"));
+var Equal = _interopRequireWildcard(require("effect/Equal"));
+var Fiber = _interopRequireWildcard(require("effect/Fiber"));
+var FiberHandle = _interopRequireWildcard(require("effect/FiberHandle"));
+var FiberMap = _interopRequireWildcard(require("effect/FiberMap"));
+var FiberRef = _interopRequireWildcard(require("effect/FiberRef"));
+var _Function = require("effect/Function");
+var HashMap = _interopRequireWildcard(require("effect/HashMap"));
+var Iterable = _interopRequireWildcard(require("effect/Iterable"));
+var Layer = _interopRequireWildcard(require("effect/Layer"));
+var MutableHashMap = _interopRequireWildcard(require("effect/MutableHashMap"));
+var MutableRef = _interopRequireWildcard(require("effect/MutableRef"));
+var Option = _interopRequireWildcard(require("effect/Option"));
+var Predicate = _interopRequireWildcard(require("effect/Predicate"));
+var PubSub = _interopRequireWildcard(require("effect/PubSub"));
+var Schedule = _interopRequireWildcard(require("effect/Schedule"));
+var Scope = _interopRequireWildcard(require("effect/Scope"));
+var Stream = _interopRequireWildcard(require("effect/Stream"));
+var _ClusterError = require("./ClusterError.js");
+var _ClusterSchema = require("./ClusterSchema.js");
+var _EntityAddress = require("./EntityAddress.js");
+var _EntityId = require("./EntityId.js");
+var Envelope = _interopRequireWildcard(require("./Envelope.js"));
+var EntityManager = _interopRequireWildcard(require("./internal/entityManager.js"));
+var _entityReaper = require("./internal/entityReaper.js");
+var _hash = require("./internal/hash.js");
+var _interruptors = require("./internal/interruptors.js");
+var _resourceMap = require("./internal/resourceMap.js");
+var Message = _interopRequireWildcard(require("./Message.js"));
+var MessageStorage = _interopRequireWildcard(require("./MessageStorage.js"));
+var Reply = _interopRequireWildcard(require("./Reply.js"));
+var _Runners = require("./Runners.js");
+var _ShardId = require("./ShardId.js");
+var _ShardingConfig = require("./ShardingConfig.js");
+var _ShardingRegistrationEvent = require("./ShardingRegistrationEvent.js");
+var _ShardManager = require("./ShardManager.js");
+var _ShardStorage = require("./ShardStorage.js");
+var _SingletonAddress = require("./SingletonAddress.js");
+var Snowflake = _interopRequireWildcard(require("./Snowflake.js"));
 function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
 function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
 /**
  * @since 1.0.0
- * @category symbols
+ * @category models
  */
-const ShardingTypeId = exports.ShardingTypeId = internal.ShardingTypeId;
+class Sharding extends /*#__PURE__*/Context.Tag("@effect/cluster/Sharding")() {}
 /**
  * @since 1.0.0
- * @category context
+ * @category constructors
  */
-const Tag = exports.Tag = internal.shardingTag;
+exports.Sharding = Sharding;
+const make = exports.make = /*#__PURE__*/Effect.gen(function* () {
+  const config = yield* _ShardingConfig.ShardingConfig;
+  const runners = yield* _Runners.Runners;
+  const shardManager = yield* _ShardManager.ShardManagerClient;
+  const snowflakeGen = yield* Snowflake.Generator;
+  const shardingScope = yield* Effect.scope;
+  const isShutdown = MutableRef.make(false);
+  const storage = yield* MessageStorage.MessageStorage;
+  const storageEnabled = storage !== MessageStorage.noop;
+  const shardStorage = yield* _ShardStorage.ShardStorage;
+  const entityManagers = new Map();
+  const shardAssignments = MutableHashMap.empty();
+  const selfShards = new Set();
+  // the active shards are the ones that we have acquired the lock for
+  const acquiredShards = new Set();
+  const activeShardsLatch = yield* Effect.makeLatch(false);
+  const events = yield* PubSub.unbounded();
+  const getRegistrationEvents = Stream.fromPubSub(events);
+  const isLocalRunner = address => Option.isSome(config.runnerAddress) && Equal.equals(address, config.runnerAddress.value);
+  function getShardId(entityId) {
+    return _ShardId.ShardId.make(Math.abs((0, _hash.hashString)(entityId) % config.numberOfShards) + 1);
+  }
+  function isEntityOnLocalShards(address) {
+    return acquiredShards.has(address.shardId);
+  }
+  // --- Shard acquisition ---
+  if (Option.isSome(config.runnerAddress)) {
+    const selfAddress = config.runnerAddress.value;
+    yield* Scope.addFinalizerExit(shardingScope, () => {
+      // the locks expire over time, so if this fails we ignore it
+      return Effect.ignore(shardStorage.releaseAll(selfAddress));
+    });
+    const releasingShards = new Set();
+    yield* Effect.gen(function* () {
+      while (true) {
+        yield* activeShardsLatch.await;
+        // if a shard is no longer assigned to this runner, we release it
+        for (const shardId of acquiredShards) {
+          if (selfShards.has(shardId)) continue;
+          acquiredShards.delete(shardId);
+          releasingShards.add(shardId);
+        }
+        // if a shard has been assigned to this runner, we acquire it
+        const unacquiredShards = new Set();
+        for (const shardId of selfShards) {
+          if (acquiredShards.has(shardId) || releasingShards.has(shardId)) continue;
+          unacquiredShards.add(shardId);
+        }
+        if (releasingShards.size > 0) {
+          yield* Effect.forkIn(syncSingletons, shardingScope);
+          yield* releaseShards;
+        }
+        if (unacquiredShards.size === 0) {
+          yield* activeShardsLatch.close;
+          continue;
+        }
+        const acquired = yield* shardStorage.acquire(selfAddress, unacquiredShards);
+        for (const shardId of acquired) {
+          acquiredShards.add(shardId);
+        }
+        if (acquired.length > 0) {
+          yield* storageReadLatch.open;
+          yield* Effect.forkIn(syncSingletons, shardingScope);
+        }
+        yield* Effect.sleep(1000);
+      }
+    }).pipe(Effect.catchAllCause(cause => Effect.logWarning("Could not acquire/release shards", cause)), Effect.repeat(Schedule.spaced(config.entityMessagePollInterval)), Effect.annotateLogs({
+      package: "@effect/cluster",
+      module: "Sharding",
+      fiber: "Shard acquisition loop",
+      runner: selfAddress
+    }), Effect.interruptible, Effect.forkIn(shardingScope));
+    // refresh the shard locks every minute
+    yield* Effect.suspend(() => shardStorage.refresh(selfAddress, [...acquiredShards, ...releasingShards])).pipe(Effect.flatMap(acquired => {
+      for (const shardId of acquiredShards) {
+        if (!acquired.includes(shardId)) {
+          acquiredShards.delete(shardId);
+          releasingShards.add(shardId);
+        }
+      }
+      return releasingShards.size > 0 ? Effect.andThen(Effect.forkIn(syncSingletons, shardingScope), releaseShards) : Effect.void;
+    }), Effect.retry({
+      times: 5,
+      schedule: Schedule.spaced(250)
+    }), Effect.catchAllCause(cause => Effect.logError("Could not refresh shard locks", cause).pipe(Effect.andThen(clearSelfShards))), Effect.delay("1 minute"), Effect.forever, Effect.interruptible, Effect.forkIn(shardingScope));
+    const releaseShardsLock = Effect.unsafeMakeSemaphore(1).withPermits(1);
+    const releaseShards = releaseShardsLock(Effect.suspend(() => Effect.forEach(releasingShards, shardId => Effect.forEach(entityManagers.values(), state => state.manager.interruptShard(shardId), {
+      concurrency: "unbounded",
+      discard: true
+    }).pipe(Effect.andThen(shardStorage.release(selfAddress, shardId)), Effect.annotateLogs({
+      runner: selfAddress
+    }), Effect.andThen(() => {
+      releasingShards.delete(shardId);
+    })), {
+      concurrency: "unbounded",
+      discard: true
+    })));
+  }
+  const clearSelfShards = Effect.suspend(() => {
+    selfShards.clear();
+    return activeShardsLatch.open;
+  });
+  // --- Singletons ---
+  const singletons = new Map();
+  const singletonFibers = yield* FiberMap.make();
+  const withSingletonLock = Effect.unsafeMakeSemaphore(1).withPermits(1);
+  const registerSingleton = Effect.fnUntraced(function* (name, run) {
+    const address = new _SingletonAddress.SingletonAddress({
+      shardId: getShardId(_EntityId.EntityId.make(name)),
+      name
+    });
+    let map = singletons.get(address.shardId);
+    if (!map) {
+      map = MutableHashMap.empty();
+      singletons.set(address.shardId, map);
+    }
+    if (MutableHashMap.has(map, address)) {
+      return yield* Effect.dieMessage(`Singleton '${name}' is already registered`);
+    }
+    const context = yield* Effect.context();
+    const wrappedRun = run.pipe(Effect.locally(FiberRef.currentLogAnnotations, HashMap.empty()), Effect.andThen(Effect.never), Effect.scoped, Effect.provide(context), Effect.orDie, Effect.interruptible);
+    MutableHashMap.set(map, address, wrappedRun);
+    yield* PubSub.publish(events, (0, _ShardingRegistrationEvent.SingletonRegistered)({
+      address
+    }));
+    // start if we are on the right shard
+    if (acquiredShards.has(address.shardId)) {
+      yield* Effect.logDebug("Starting singleton", address);
+      yield* FiberMap.run(singletonFibers, address, wrappedRun);
+    }
+  }, withSingletonLock);
+  const syncSingletons = withSingletonLock(Effect.gen(function* () {
+    for (const [shardId, map] of singletons) {
+      for (const [address, run] of map) {
+        const running = FiberMap.unsafeHas(singletonFibers, address);
+        const shouldBeRunning = acquiredShards.has(shardId);
+        if (running && !shouldBeRunning) {
+          yield* Effect.logDebug("Stopping singleton", address);
+          _interruptors.internalInterruptors.add(yield* Effect.fiberId);
+          yield* FiberMap.remove(singletonFibers, address);
+        } else if (!running && shouldBeRunning) {
+          yield* Effect.logDebug("Starting singleton", address);
+          yield* FiberMap.run(singletonFibers, address, run);
+        }
+      }
+    }
+  }));
+  // --- Storage inbox ---
+  const storageReadLatch = yield* Effect.makeLatch(true);
+  const openStorageReadLatch = (0, _Function.constant)(storageReadLatch.open);
+  const storageReadLock = Effect.unsafeMakeSemaphore(1);
+  const withStorageReadLock = storageReadLock.withPermits(1);
+  if (storageEnabled && Option.isSome(config.runnerAddress)) {
+    const selfAddress = config.runnerAddress.value;
+    yield* Effect.gen(function* () {
+      yield* Effect.logDebug("Starting");
+      yield* Effect.addFinalizer(() => Effect.logDebug("Shutting down"));
+      // keep track of the last sent request ids to avoid duplicates
+      // we only keep the last 30 sets to avoid memory leaks
+      const sentRequestIds = new Set();
+      const sentRequestIdSets = new Set();
+      while (true) {
+        // wait for the next poll interval, or if we get notified of a change
+        yield* storageReadLatch.await;
+        // if we get notified of a change, ensure we start a read immediately
+        // next iteration
+        storageReadLatch.unsafeClose();
+        // the lock is used to ensure resuming entities have a garantee that no
+        // more items are added to the unprocessed set while the semaphore is
+        // acquired.
+        yield* storageReadLock.take(1);
+        const messages = yield* storage.unprocessedMessages(acquiredShards);
+        const currentSentRequestIds = new Set();
+        sentRequestIdSets.add(currentSentRequestIds);
+        const send = Effect.catchAllCause(Effect.suspend(() => {
+          const message = messages[index];
+          if (message._tag === "IncomingRequest") {
+            if (sentRequestIds.has(message.envelope.requestId)) {
+              return Effect.void;
+            }
+            sentRequestIds.add(message.envelope.requestId);
+            currentSentRequestIds.add(message.envelope.requestId);
+          }
+          const address = message.envelope.address;
+          const state = entityManagers.get(address.entityType);
+          if (!state || !acquiredShards.has(address.shardId)) {
+            return Effect.void;
+          }
+          const isProcessing = state.manager.isProcessingFor(message);
+          // If the message might affect a currently processing request, we
+          // send it to the entity manager to be processed.
+          if (message._tag === "IncomingEnvelope" && isProcessing) {
+            return state.manager.send(message);
+          } else if (isProcessing) {
+            return Effect.void;
+          }
+          // If the entity was resuming in another fiber, we add the message
+          // id to the unprocessed set.
+          const resumptionState = MutableHashMap.get(entityResumptionState, address);
+          if (Option.isSome(resumptionState)) {
+            resumptionState.value.unprocessed.add(message.envelope.requestId);
+            if (message.envelope._tag === "Interrupt") {
+              resumptionState.value.interrupts.set(message.envelope.requestId, message);
+            }
+            return Effect.void;
+          }
+          return state.manager.send(message);
+        }), cause => {
+          const message = messages[index];
+          const error = Cause.failureOption(cause);
+          // if we get a defect, then update storage
+          if (Option.isNone(error)) {
+            return storage.saveReply(Reply.ReplyWithContext.fromDefect({
+              id: snowflakeGen.unsafeNext(),
+              requestId: message.envelope.requestId,
+              defect: Cause.squash(cause)
+            }));
+          }
+          if (error.value._tag === "MailboxFull") {
+            // MailboxFull can only happen for requests, so this cast is safe
+            return resumeEntityFromStorage(message);
+          }
+          return Effect.void;
+        });
+        let index = 0;
+        yield* Effect.whileLoop({
+          while: () => index < messages.length,
+          step: () => index++,
+          body: (0, _Function.constant)(send)
+        });
+        // let the resuming entities check if they are done
+        yield* storageReadLock.release(1);
+        while (sentRequestIdSets.size > 30) {
+          const oldest = Iterable.unsafeHead(sentRequestIdSets);
+          sentRequestIdSets.delete(oldest);
+          for (const id of oldest) {
+            sentRequestIds.delete(id);
+          }
+        }
+      }
+    }).pipe(Effect.scoped, Effect.ensuring(storageReadLock.releaseAll), Effect.catchAllCause(cause => Effect.logWarning("Could not read messages from storage", cause)), Effect.repeat(Schedule.spaced(config.entityMessagePollInterval)), Effect.annotateLogs({
+      package: "@effect/cluster",
+      module: "Sharding",
+      fiber: "Storage read loop",
+      runner: selfAddress
+    }), Effect.interruptible, Effect.forkIn(shardingScope));
+    // open the storage latch every poll interval
+    yield* storageReadLatch.open.pipe(Effect.delay(config.entityMessagePollInterval), Effect.forever, Effect.interruptible, Effect.forkIn(shardingScope));
+    // Resume unprocessed messages for entities that reached a full mailbox.
+    const entityResumptionState = MutableHashMap.empty();
+    const resumeEntityFromStorage = lastReceivedMessage => {
+      const address = lastReceivedMessage.envelope.address;
+      const resumptionState = MutableHashMap.get(entityResumptionState, address);
+      if (Option.isSome(resumptionState)) {
+        resumptionState.value.unprocessed.add(lastReceivedMessage.envelope.requestId);
+        return Effect.void;
+      }
+      MutableHashMap.set(entityResumptionState, address, {
+        unprocessed: new Set([lastReceivedMessage.envelope.requestId]),
+        interrupts: new Map()
+      });
+      return resumeEntityFromStorageImpl(address);
+    };
+    const resumeEntityFromStorageImpl = Effect.fnUntraced(function* (address) {
+      const state = entityManagers.get(address.entityType);
+      if (!state) {
+        MutableHashMap.remove(entityResumptionState, address);
+        return;
+      }
+      const resumptionState = Option.getOrThrow(MutableHashMap.get(entityResumptionState, address));
+      let done = false;
+      while (!done) {
+        // if the shard is no longer assigned to this runner, we stop
+        if (!acquiredShards.has(address.shardId)) {
+          return;
+        }
+        // take a batch of unprocessed messages ids
+        const messageIds = Arr.empty();
+        for (const id of resumptionState.unprocessed) {
+          if (messageIds.length === 1024) break;
+          messageIds.push(id);
+        }
+        const messages = yield* storage.unprocessedMessagesById(messageIds);
+        // this should not happen, but we handle it just in case
+        if (messages.length === 0) {
+          yield* Effect.sleep(config.entityMessagePollInterval);
+          continue;
+        }
+        let index = 0;
+        const sendWithRetry = Effect.catchTags(Effect.suspend(() => {
+          if (!acquiredShards.has(address.shardId)) {
+            return Effect.fail(new _ClusterError.EntityNotManagedByRunner({
+              address
+            }));
+          }
+          const message = messages[index];
+          // check if this is a request that was interrupted
+          const interrupt = message._tag === "IncomingRequest" && resumptionState.interrupts.get(message.envelope.requestId);
+          return interrupt ? Effect.flatMap(state.manager.send(message), () => {
+            resumptionState.interrupts.delete(message.envelope.requestId);
+            return state.manager.send(interrupt);
+          }) : state.manager.send(message);
+        }), {
+          MailboxFull: () => Effect.delay(sendWithRetry, config.sendRetryInterval),
+          AlreadyProcessingMessage: () => Effect.void
+        });
+        yield* Effect.whileLoop({
+          while: () => index < messages.length,
+          body: (0, _Function.constant)(sendWithRetry),
+          step: () => index++
+        });
+        for (const id of messageIds) {
+          resumptionState.unprocessed.delete(id);
+        }
+        if (resumptionState.unprocessed.size > 0) continue;
+        // if we have caught up to the main storage loop, we let it take over
+        yield* withStorageReadLock(Effect.sync(() => {
+          if (resumptionState.unprocessed.size === 0) {
+            MutableHashMap.remove(entityResumptionState, address);
+            done = true;
+          }
+        }));
+      }
+    }, Effect.retry({
+      while: e => e._tag === "PersistenceError",
+      schedule: Schedule.spaced(config.entityMessagePollInterval)
+    }), Effect.catchAllCause(cause => Effect.logError("Could not resume unprocessed messages", cause)), (effect, address) => Effect.annotateLogs(effect, {
+      package: "@effect/cluster",
+      module: "Sharding",
+      fiber: "Resuming unprocessed messages",
+      runner: selfAddress,
+      entity: address
+    }), (effect, address) => Effect.ensuring(effect, Effect.sync(() => MutableHashMap.remove(entityResumptionState, address))), Effect.interruptible, Effect.forkIn(shardingScope));
+  }
+  // --- Sending messages ---
+  const sendLocal = message => Effect.suspend(() => {
+    const address = message.envelope.address;
+    if (!isEntityOnLocalShards(address)) {
+      return Effect.fail(new _ClusterError.EntityNotManagedByRunner({
+        address
+      }));
+    }
+    const state = entityManagers.get(address.entityType);
+    if (!state) {
+      return Effect.fail(new _ClusterError.EntityNotManagedByRunner({
+        address
+      }));
+    }
+    return message._tag === "IncomingRequest" || message._tag === "IncomingEnvelope" ? state.manager.send(message) : runners.sendLocal({
+      message,
+      send: state.manager.sendLocal,
+      simulateRemoteSerialization: config.simulateRemoteSerialization
+    });
+  });
+  const notifyLocal = (message, discard) => Effect.suspend(() => {
+    const address = message.envelope.address;
+    if (!isEntityOnLocalShards(address)) {
+      return Effect.fail(new _ClusterError.EntityNotManagedByRunner({
+        address
+      }));
+    }
+    const notify = storageEnabled ? openStorageReadLatch : () => Effect.dieMessage("Sharding.notifyLocal: storage is disabled");
+    return message._tag === "IncomingRequest" || message._tag === "IncomingEnvelope" ? notify() : runners.notifyLocal({
+      message,
+      notify,
+      discard
+    });
+  });
+  const isTransientError = Predicate.or(_ClusterError.RunnerUnavailable.is, _ClusterError.EntityNotManagedByRunner.is);
+  function sendOutgoing(message, discard, retries) {
+    return Effect.catchIf(Effect.suspend(() => {
+      const address = message.envelope.address;
+      const maybeRunner = MutableHashMap.get(shardAssignments, address.shardId);
+      if (Option.isNone(maybeRunner)) {
+        return Effect.fail(new _ClusterError.EntityNotManagedByRunner({
+          address
+        }));
+      }
+      const runner = maybeRunner.value;
+      const rpc = message.rpc;
+      if (storageEnabled && Context.get(rpc.annotations, _ClusterSchema.Persisted)) {
+        return isLocalRunner(runner) ? notifyLocal(message, discard) : runners.notify({
+          address: runner,
+          message,
+          discard
+        });
+      }
+      return isLocalRunner(runner) ? sendLocal(message) : runners.send({
+        address: runner,
+        message
+      });
+    }), isTransientError, error => {
+      if (retries === 0) {
+        return Effect.die(error);
+      }
+      return Effect.delay(sendOutgoing(message, discard, retries && retries - 1), config.sendRetryInterval);
+    });
+  }
+  // --- Shard Manager sync ---
+  const shardManagerTimeoutFiber = yield* FiberHandle.make().pipe(Scope.extend(shardingScope));
+  const startShardManagerTimeout = FiberHandle.run(shardManagerTimeoutFiber, Effect.flatMap(Effect.sleep(config.shardManagerUnavailableTimeout), () => {
+    MutableHashMap.clear(shardAssignments);
+    return clearSelfShards;
+  }), {
+    onlyIfMissing: true
+  });
+  const stopShardManagerTimeout = FiberHandle.clear(shardManagerTimeoutFiber);
+  // Every time the link to the shard manager is lost, we re-register the runner
+  // and re-subscribe to sharding events
+  yield* Effect.gen(function* () {
+    yield* Effect.logDebug("Registering with shard manager");
+    if (Option.isSome(config.runnerAddress)) {
+      const machineId = yield* shardManager.register(config.runnerAddress.value);
+      yield* snowflakeGen.setMachineId(machineId);
+    }
+    yield* stopShardManagerTimeout;
+    yield* Effect.logDebug("Subscribing to sharding events");
+    const mailbox = yield* shardManager.shardingEvents;
+    const startedLatch = yield* Effect.makeLatch(false);
+    const eventsFiber = yield* Effect.gen(function* () {
+      while (true) {
+        const [events] = yield* mailbox.takeAll;
+        for (const event of events) {
+          yield* Effect.logDebug("Received sharding event", event);
+          switch (event._tag) {
+            case "StreamStarted":
+              {
+                yield* startedLatch.open;
+                break;
+              }
+            case "ShardsAssigned":
+              {
+                for (const shard of event.shards) {
+                  MutableHashMap.set(shardAssignments, shard, event.address);
+                }
+                if (!MutableRef.get(isShutdown) && isLocalRunner(event.address)) {
+                  for (const shardId of event.shards) {
+                    if (selfShards.has(shardId)) continue;
+                    selfShards.add(shardId);
+                  }
+                  yield* activeShardsLatch.open;
+                }
+                break;
+              }
+            case "ShardsUnassigned":
+              {
+                for (const shard of event.shards) {
+                  MutableHashMap.remove(shardAssignments, shard);
+                }
+                if (isLocalRunner(event.address)) {
+                  for (const shard of event.shards) {
+                    selfShards.delete(shard);
+                  }
+                  yield* activeShardsLatch.open;
+                }
+                break;
+              }
+          }
+        }
+      }
+    }).pipe(Effect.forkScoped);
+    // Wait for the stream to be established
+    yield* startedLatch.await;
+    // perform a full sync every config.refreshAssignmentsInterval
+    const syncFiber = yield* syncAssignments.pipe(Effect.andThen(Effect.sleep(config.refreshAssignmentsInterval)), Effect.forever, Effect.forkScoped);
+    yield* Fiber.joinAll([eventsFiber, syncFiber]);
+  }).pipe(Effect.scoped, Effect.catchAllCause(cause => Effect.logDebug(cause)), Effect.zipRight(startShardManagerTimeout), Effect.repeat(Schedule.exponential(1000).pipe(Schedule.union(Schedule.spaced(10_000)))), Effect.annotateLogs({
+    package: "@effect/cluster",
+    module: "Sharding",
+    fiber: "ShardManager sync",
+    runner: config.runnerAddress
+  }), Effect.interruptible, Effect.forkIn(shardingScope));
+  const syncAssignments = Effect.gen(function* () {
+    const assignments = yield* shardManager.getAssignments;
+    yield* Effect.logDebug("Received shard assignments", assignments);
+    for (const [shardId, runner] of assignments) {
+      if (Option.isNone(runner)) {
+        MutableHashMap.remove(shardAssignments, shardId);
+        selfShards.delete(shardId);
+        continue;
+      }
+      MutableHashMap.set(shardAssignments, shardId, runner.value);
+      if (!isLocalRunner(runner.value)) {
+        selfShards.delete(shardId);
+        continue;
+      }
+      if (MutableRef.get(isShutdown) || selfShards.has(shardId)) {
+        continue;
+      }
+      selfShards.add(shardId);
+    }
+    yield* activeShardsLatch.open;
+  });
+  const clientRequests = new Map();
+  const clients = yield* _resourceMap.ResourceMap.make(Effect.fnUntraced(function* (entity) {
+    const client = yield* RpcClient.makeNoSerialization(entity.protocol, {
+      supportsAck: true,
+      generateRequestId: () => (0, _RpcMessage.RequestId)(snowflakeGen.unsafeNext()),
+      onFromClient(options) {
+        const address = Context.unsafeGet(options.context, ClientAddressTag);
+        switch (options.message._tag) {
+          case "Request":
+            {
+              const fiber = Option.getOrThrow(Fiber.getCurrentFiber());
+              const id = Snowflake.Snowflake(options.message.id);
+              const rpc = entity.protocol.requests.get(options.message.tag);
+              let respond;
+              if (!options.discard) {
+                const entry = {
+                  rpc: rpc,
+                  context: fiber.currentContext
+                };
+                clientRequests.set(id, entry);
+                respond = makeClientRespond(entry, client.write);
+              } else {
+                respond = clientRespondDiscard;
+              }
+              return sendOutgoing(new Message.OutgoingRequest({
+                envelope: Envelope.makeRequest({
+                  requestId: id,
+                  address,
+                  tag: options.message.tag,
+                  payload: options.message.payload,
+                  headers: options.message.headers,
+                  traceId: options.message.traceId,
+                  spanId: options.message.spanId,
+                  sampled: options.message.sampled
+                }),
+                lastReceivedReply: Option.none(),
+                rpc,
+                context: fiber.currentContext,
+                respond
+              }), options.discard);
+            }
+          case "Ack":
+            {
+              const requestId = Snowflake.Snowflake(options.message.requestId);
+              const entry = clientRequests.get(requestId);
+              if (!entry) return Effect.void;
+              return sendOutgoing(new Message.OutgoingEnvelope({
+                envelope: new Envelope.AckChunk({
+                  id: snowflakeGen.unsafeNext(),
+                  address,
+                  requestId,
+                  replyId: entry.lastChunkId
+                }),
+                rpc: entry.rpc
+              }), false);
+            }
+          case "Interrupt":
+            {
+              const requestId = Snowflake.Snowflake(options.message.requestId);
+              const entry = clientRequests.get(requestId);
+              if (!entry) return Effect.void;
+              clientRequests.delete(requestId);
+              // for durable messages, we ignore interrupts on shutdown or as a
+              // result of a shard being resassigned
+              const isTransientInterrupt = MutableRef.get(isShutdown) || options.message.interruptors.some(id => _interruptors.internalInterruptors.has(id));
+              if (isTransientInterrupt && storageEnabled && Context.get(entry.rpc.annotations, _ClusterSchema.Persisted)) {
+                return Effect.void;
+              }
+              return Effect.ignore(sendOutgoing(new Message.OutgoingEnvelope({
+                envelope: new Envelope.Interrupt({
+                  id: snowflakeGen.unsafeNext(),
+                  address,
+                  requestId
+                }),
+                rpc: entry.rpc
+              }), false, 3));
+            }
+        }
+        return Effect.void;
+      }
+    });
+    const wrappedClient = {};
+    for (const method of Object.keys(client.client)) {
+      wrappedClient[method] = function (payload, options) {
+        return client.client[method](payload, {
+          ...options,
+          context: options?.context ? Context.merge(options.context, this[currentClientAddress]) : this[currentClientAddress]
+        });
+      };
+    }
+    yield* Scope.addFinalizer(yield* Effect.scope, Effect.withFiberRuntime(fiber => {
+      _interruptors.internalInterruptors.add(fiber.id());
+      return Effect.void;
+    }));
+    return entityId => {
+      const id = _EntityId.EntityId.make(entityId);
+      return {
+        ...wrappedClient,
+        [currentClientAddress]: ClientAddressTag.context(_EntityAddress.EntityAddress.make({
+          shardId: getShardId(id),
+          entityId: id,
+          entityType: entity.type
+        }))
+      };
+    };
+  }));
+  const makeClient = entity => clients.get(entity);
+  const clientRespondDiscard = _reply => Effect.void;
+  const makeClientRespond = (entry, write) => reply => {
+    switch (reply._tag) {
+      case "Chunk":
+        {
+          entry.lastChunkId = reply.id;
+          return write({
+            _tag: "Chunk",
+            clientId: 0,
+            requestId: (0, _RpcMessage.RequestId)(reply.requestId),
+            values: reply.values
+          });
+        }
+      case "WithExit":
+        {
+          clientRequests.delete(reply.requestId);
+          return write({
+            _tag: "Exit",
+            clientId: 0,
+            requestId: (0, _RpcMessage.RequestId)(reply.requestId),
+            exit: reply.exit
+          });
+        }
+    }
+  };
+  // --- Entities ---
+  const context = yield* Effect.context();
+  const reaper = yield* _entityReaper.EntityReaper;
+  const registerEntity = Effect.fnUntraced(function* (entity, build, options) {
+    if (entityManagers.has(entity.type)) return;
+    const scope = yield* Scope.make();
+    const manager = yield* EntityManager.make(entity, build, {
+      ...options,
+      storage,
+      runnerAddress: Option.getOrThrow(config.runnerAddress),
+      sharding
+    }).pipe(Effect.provide(context.pipe(Context.add(_entityReaper.EntityReaper, reaper), Context.add(Scope.Scope, scope), Context.add(Snowflake.Generator, snowflakeGen))));
+    entityManagers.set(entity.type, {
+      entity,
+      scope,
+      manager
+    });
+    yield* Scope.addFinalizer(scope, Effect.sync(() => entityManagers.delete(entity.type)));
+    yield* PubSub.publish(events, (0, _ShardingRegistrationEvent.EntityRegistered)({
+      entity
+    }));
+  });
+  yield* Scope.addFinalizerExit(shardingScope, exit => Effect.forEach(entityManagers.values(), state => Effect.catchAllCause(Scope.close(state.scope, exit), cause => Effect.annotateLogs(Effect.logError("Error closing entity manager", cause), {
+    entity: state.entity.type
+  })), {
+    concurrency: "unbounded",
+    discard: true
+  }));
+  // --- Finalization ---
+  if (Option.isSome(config.runnerAddress)) {
+    const selfAddress = config.runnerAddress.value;
+    // Unregister runner from shard manager when scope is closed
+    yield* Scope.addFinalizer(shardingScope, Effect.gen(function* () {
+      yield* Effect.logDebug("Unregistering runner from shard manager", selfAddress);
+      yield* shardManager.unregister(selfAddress).pipe(Effect.catchAllCause(cause => Effect.logError("Error calling unregister with shard manager", cause)));
+      yield* clearSelfShards;
+    }));
+  }
+  yield* Scope.addFinalizer(shardingScope, Effect.withFiberRuntime(fiber => {
+    MutableRef.set(isShutdown, true);
+    _interruptors.internalInterruptors.add(fiber.id());
+    return Effect.void;
+  }));
+  const sharding = Sharding.of({
+    getRegistrationEvents,
+    getShardId,
+    isShutdown: Effect.sync(() => MutableRef.get(isShutdown)),
+    registerEntity,
+    registerSingleton,
+    makeClient,
+    send: sendLocal,
+    notify: message => notifyLocal(message, false)
+  });
+  return sharding;
+});
 /**
  * @since 1.0.0
  * @category layers
  */
-const live = exports.live = internal.live;
-/**
- * Notify the shard manager that shards can now be assigned to this pod.
- *
- * @since 1.0.0
- * @category utils
- */
-const register = exports.register = internal.register;
-/**
- * Notify the shard manager that shards must be unassigned from this pod.
- *
- * @since 1.0.0
- * @category utils
- */
-const unregister = exports.unregister = internal.unregister;
-/**
- * Same as `register`, but will automatically call `unregister` when the `Scope` is terminated.
- *
- * @since 1.0.0
- * @category utils
- */
-const registerScoped = exports.registerScoped = internal.registerScoped;
-/**
- * Start a computation that is guaranteed to run only on a single pod.
- * Each pod should call `registerSingleton` but only a single pod will actually run it at any given time.
- *
- * @since 1.0.0
- * @category utils
- */
-const registerSingleton = exports.registerSingleton = internal.registerSingleton;
-/**
- * Register a new entity type, allowing pods to send messages to entities of this type.
- *
- * @since 1.0.0
- * @category utils
- */
-const registerEntity = exports.registerEntity = internal.registerEntity;
-/**
- * Register a new topic type, allowing pods to broadcast messages to subscribers.
- *
- * @since 1.0.0
- * @category utils
- */
-const registerTopic = exports.registerTopic = internal.registerTopic;
-/**
- * Get an object that allows sending messages to a given entity type.
- * You can provide a custom send timeout to override the one globally defined.
- *
- * @since 1.0.0
- * @category utils
- */
-const messenger = exports.messenger = internal.messenger;
-/**
- * Get an object that allows broadcasting messages to a given topic type.
- * You can provide a custom send timeout to override the one globally defined.
- *
- * @since 1.0.0
- * @category utils
- */
-const broadcaster = exports.broadcaster = internal.broadcaster;
-/**
- * Get the list of pods currently registered to the Shard Manager
- *
- * @since 1.0.0
- * @category utils
- */
-const getPods = exports.getPods = internal.getPods;
-/**
- * Sends a raw message to the local entity manager without performing reties.
- * Those are up to the caller.
- *
- * @since 1.0.0
- * @category utils
- */
-const sendMessageToLocalEntityManagerWithoutRetries = exports.sendMessageToLocalEntityManagerWithoutRetries = internal.sendMessageToLocalEntityManagerWithoutRetries;
-/**
- * Gets the list of shardIds assigned to the current Pod
- *
- * @since 1.0.0
- * @category utils
- */
-const getAssignedShardIds = exports.getAssignedShardIds = internal.getAssignedShardIds;
+const layer = exports.layer = /*#__PURE__*/Layer.scoped(Sharding, make).pipe( /*#__PURE__*/Layer.provide([Snowflake.layerGenerator, _entityReaper.EntityReaper.Default]));
+// Utilities
+const ClientAddressTag = /*#__PURE__*/Context.GenericTag("@effect/cluster/Sharding/ClientAddress");
+const currentClientAddress = /*#__PURE__*/Symbol.for(ClientAddressTag.key);
 //# sourceMappingURL=Sharding.js.map
\ No newline at end of file
diff --git a/dist/cjs/Sharding.js.map b/dist/cjs/Sharding.js.map
index f14b20a5320c507b3e9129f8f7c0d2af87b043c1..c5432f906e907dcea3861ced5ce390d7d106419d 100644
--- a/dist/cjs/Sharding.js.map
+++ b/dist/cjs/Sharding.js.map
@@ -1 +1 @@
-{"version":3,"file":"Sharding.js","names":["internal","_interopRequireWildcard","require","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","ShardingTypeId","exports","Tag","shardingTag","live","register","unregister","registerScoped","registerSingleton","registerEntity","registerTopic","messenger","broadcaster","getPods","sendMessageToLocalEntityManagerWithoutRetries","getAssignedShardIds"],"sources":["../../src/Sharding.ts"],"sourcesContent":[null],"mappings":";;;;;;AAQA,IAAAA,QAAA,GAAAC,uBAAA,CAAAC,OAAA;AAAkD,SAAAC,yBAAAC,CAAA,6BAAAC,OAAA,mBAAAC,CAAA,OAAAD,OAAA,IAAAE,CAAA,OAAAF,OAAA,YAAAF,wBAAA,YAAAA,CAAAC,CAAA,WAAAA,CAAA,GAAAG,CAAA,GAAAD,CAAA,KAAAF,CAAA;AAAA,SAAAH,wBAAAG,CAAA,EAAAE,CAAA,SAAAA,CAAA,IAAAF,CAAA,IAAAA,CAAA,CAAAI,UAAA,SAAAJ,CAAA,eAAAA,CAAA,uBAAAA,CAAA,yBAAAA,CAAA,WAAAK,OAAA,EAAAL,CAAA,QAAAG,CAAA,GAAAJ,wBAAA,CAAAG,CAAA,OAAAC,CAAA,IAAAA,CAAA,CAAAG,GAAA,CAAAN,CAAA,UAAAG,CAAA,CAAAI,GAAA,CAAAP,CAAA,OAAAQ,CAAA,KAAAC,SAAA,UAAAC,CAAA,GAAAC,MAAA,CAAAC,cAAA,IAAAD,MAAA,CAAAE,wBAAA,WAAAC,CAAA,IAAAd,CAAA,oBAAAc,CAAA,OAAAC,cAAA,CAAAC,IAAA,CAAAhB,CAAA,EAAAc,CAAA,SAAAG,CAAA,GAAAP,CAAA,GAAAC,MAAA,CAAAE,wBAAA,CAAAb,CAAA,EAAAc,CAAA,UAAAG,CAAA,KAAAA,CAAA,CAAAV,GAAA,IAAAU,CAAA,CAAAC,GAAA,IAAAP,MAAA,CAAAC,cAAA,CAAAJ,CAAA,EAAAM,CAAA,EAAAG,CAAA,IAAAT,CAAA,CAAAM,CAAA,IAAAd,CAAA,CAAAc,CAAA,YAAAN,CAAA,CAAAH,OAAA,GAAAL,CAAA,EAAAG,CAAA,IAAAA,CAAA,CAAAe,GAAA,CAAAlB,CAAA,EAAAQ,CAAA,GAAAA,CAAA;AAelD;;;;AAIO,MAAMW,cAAc,GAAAC,OAAA,CAAAD,cAAA,GAAkBvB,QAAQ,CAACuB,cAAc;AA0DpE;;;;AAIO,MAAME,GAAG,GAAAD,OAAA,CAAAC,GAAA,GAAGzB,QAAQ,CAAC0B,WAAW;AAEvC;;;;AAIO,MAAMC,IAAI,GAAAH,OAAA,CAAAG,IAAA,GAAG3B,QAAQ,CAAC2B,IAAI;AAEjC;;;;;;AAMO,MAAMC,QAAQ,GAAAJ,OAAA,CAAAI,QAAA,GAAyC5B,QAAQ,CAAC4B,QAAQ;AAE/E;;;;;;AAMO,MAAMC,UAAU,GAAAL,OAAA,CAAAK,UAAA,GAAyC7B,QAAQ,CAAC6B,UAAU;AAEnF;;;;;;AAMO,MAAMC,cAAc,GAAAN,OAAA,CAAAM,cAAA,GAAuD9B,QAAQ,CAAC8B,cAAc;AAEzG;;;;;;;AAOO,MAAMC,iBAAiB,GAAAP,OAAA,CAAAO,iBAAA,GAGkB/B,QAAQ,CAAC+B,iBAAiB;AAE1E;;;;;;AAMO,MAAMC,cAAc,GAAAR,OAAA,CAAAQ,cAAA,GAMzBhC,QAAQ,CAACgC,cAAc;AAEzB;;;;;;AAMO,MAAMC,aAAa,GAAAT,OAAA,CAAAS,aAAA,GAMxBjC,QAAQ,CAACiC,aAAa;AAExB;;;;;;;AAOO,MAAMC,SAAS,GAAAV,OAAA,CAAAU,SAAA,GAEgClC,QAAQ,CAACkC,SAAS;AAExE;;;;;;;AAOO,MAAMC,WAAW,GAAAX,OAAA,CAAAW,WAAA,GAEgCnC,QAAQ,CAACmC,WAAW;AAE5E;;;;;;AAMO,MAAMC,OAAO,GAAAZ,OAAA,CAAAY,OAAA,GAA2EpC,QAAQ,CAACoC,OAAO;AAE/G;;;;;;;AAOO,MAAMC,6CAA6C,GAAAb,OAAA,CAAAa,6CAAA,GAMtDrC,QAAQ,CAACqC,6CAA6C;AAE1D;;;;;;AAMO,MAAMC,mBAAmB,GAAAd,OAAA,CAAAc,mBAAA,GAC9BtC,QAAQ,CAACsC,mBAAmB","ignoreList":[]}
\ No newline at end of file
+{"version":3,"file":"Sharding.js","names":["RpcClient","_interopRequireWildcard","require","_RpcMessage","Arr","Cause","Context","Effect","Equal","Fiber","FiberHandle","FiberMap","FiberRef","_Function","HashMap","Iterable","Layer","MutableHashMap","MutableRef","Option","Predicate","PubSub","Schedule","Scope","Stream","_ClusterError","_ClusterSchema","_EntityAddress","_EntityId","Envelope","EntityManager","_entityReaper","_hash","_interruptors","_resourceMap","Message","MessageStorage","Reply","_Runners","_ShardId","_ShardingConfig","_ShardingRegistrationEvent","_ShardManager","_ShardStorage","_SingletonAddress","Snowflake","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","Sharding","Tag","exports","make","gen","config","ShardingConfig","runners","Runners","shardManager","ShardManagerClient","snowflakeGen","Generator","shardingScope","scope","isShutdown","storage","storageEnabled","noop","shardStorage","ShardStorage","entityManagers","Map","shardAssignments","empty","selfShards","Set","acquiredShards","activeShardsLatch","makeLatch","events","unbounded","getRegistrationEvents","fromPubSub","isLocalRunner","address","isSome","runnerAddress","equals","value","getShardId","entityId","ShardId","Math","abs","hashString","numberOfShards","isEntityOnLocalShards","shardId","selfAddress","addFinalizerExit","ignore","releaseAll","releasingShards","await","delete","add","unacquiredShards","size","forkIn","syncSingletons","releaseShards","close","acquired","acquire","length","storageReadLatch","open","sleep","pipe","catchAllCause","cause","logWarning","repeat","spaced","entityMessagePollInterval","annotateLogs","package","module","fiber","runner","interruptible","suspend","refresh","flatMap","includes","andThen","void","retry","times","schedule","logError","clearSelfShards","delay","forever","releaseShardsLock","unsafeMakeSemaphore","withPermits","forEach","values","state","manager","interruptShard","concurrency","discard","release","clear","singletons","singletonFibers","withSingletonLock","registerSingleton","fnUntraced","name","run","SingletonAddress","EntityId","map","dieMessage","context","wrappedRun","locally","currentLogAnnotations","never","scoped","provide","orDie","publish","SingletonRegistered","logDebug","running","unsafeHas","shouldBeRunning","internalInterruptors","fiberId","remove","openStorageReadLatch","constant","storageReadLock","withStorageReadLock","addFinalizer","sentRequestIds","sentRequestIdSets","unsafeClose","take","messages","unprocessedMessages","currentSentRequestIds","send","message","index","_tag","envelope","requestId","entityType","isProcessing","isProcessingFor","resumptionState","entityResumptionState","unprocessed","interrupts","error","failureOption","isNone","saveReply","ReplyWithContext","fromDefect","id","unsafeNext","defect","squash","resumeEntityFromStorage","whileLoop","while","step","body","oldest","unsafeHead","ensuring","lastReceivedMessage","resumeEntityFromStorageImpl","getOrThrow","done","messageIds","push","unprocessedMessagesById","sendWithRetry","catchTags","fail","EntityNotManagedByRunner","interrupt","MailboxFull","sendRetryInterval","AlreadyProcessingMessage","sync","effect","entity","sendLocal","simulateRemoteSerialization","notifyLocal","notify","isTransientError","or","RunnerUnavailable","is","sendOutgoing","retries","catchIf","maybeRunner","rpc","annotations","Persisted","die","shardManagerTimeoutFiber","extend","startShardManagerTimeout","shardManagerUnavailableTimeout","onlyIfMissing","stopShardManagerTimeout","machineId","register","setMachineId","mailbox","shardingEvents","startedLatch","eventsFiber","takeAll","event","shard","shards","forkScoped","syncFiber","syncAssignments","refreshAssignmentsInterval","joinAll","zipRight","exponential","union","assignments","getAssignments","clientRequests","clients","ResourceMap","client","makeNoSerialization","protocol","supportsAck","generateRequestId","RequestId","onFromClient","options","unsafeGet","ClientAddressTag","getCurrentFiber","requests","tag","respond","entry","currentContext","makeClientRespond","write","clientRespondDiscard","OutgoingRequest","makeRequest","payload","headers","traceId","spanId","sampled","lastReceivedReply","none","OutgoingEnvelope","AckChunk","replyId","lastChunkId","isTransientInterrupt","interruptors","some","Interrupt","wrappedClient","method","keys","merge","currentClientAddress","withFiberRuntime","EntityAddress","type","makeClient","_reply","reply","clientId","exit","reaper","EntityReaper","registerEntity","build","sharding","EntityRegistered","unregister","of","layer","layerGenerator","Default","GenericTag","Symbol","for","key"],"sources":["../../src/Sharding.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/cjs/ShardingConfig.js b/dist/cjs/ShardingConfig.js
index 6726ff8a6f58d49573c909e6dbffb5117a55c74f..b44207f90846b6bfe3a6ab9157bfbabf889f38cc 100644
--- a/dist/cjs/ShardingConfig.js
+++ b/dist/cjs/ShardingConfig.js
@@ -3,39 +3,106 @@
 Object.defineProperty(exports, "__esModule", {
   value: true
 });
-exports.withDefaults = exports.fromConfig = exports.defaults = exports.ShardingConfigTypeId = exports.ShardingConfig = void 0;
-var internal = _interopRequireWildcard(require("./internal/shardingConfig.js"));
+exports.layerFromEnv = exports.layerDefaults = exports.layer = exports.defaults = exports.configFromEnv = exports.config = exports.ShardingConfig = void 0;
+var Config = _interopRequireWildcard(require("effect/Config"));
+var ConfigProvider = _interopRequireWildcard(require("effect/ConfigProvider"));
+var Context = _interopRequireWildcard(require("effect/Context"));
+var Duration = _interopRequireWildcard(require("effect/Duration"));
+var Effect = _interopRequireWildcard(require("effect/Effect"));
+var Layer = _interopRequireWildcard(require("effect/Layer"));
+var Option = _interopRequireWildcard(require("effect/Option"));
+var _RunnerAddress = require("./RunnerAddress.js");
 function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
 function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
 /**
  * @since 1.0.0
- * @category symbols
  */
-const ShardingConfigTypeId = exports.ShardingConfigTypeId = internal.ShardingConfigTypeId;
+
 /**
+ * Represents the configuration for the `Sharding` service on a given runner.
+ *
  * @since 1.0.0
- * @category context
+ * @category models
  */
-const ShardingConfig = exports.ShardingConfig = internal.shardingConfigTag;
+class ShardingConfig extends /*#__PURE__*/Context.Tag("@effect/cluster/ShardingConfig")() {}
+exports.ShardingConfig = ShardingConfig;
+const defaultRunnerAddress = /*#__PURE__*/_RunnerAddress.RunnerAddress.make({
+  host: "localhost",
+  port: 34431
+});
 /**
- * Provides the default values for the ShardingConfig.
- *
  * @since 1.0.0
- * @category layers
+ * @category defaults
  */
-const defaults = exports.defaults = internal.defaults;
+const defaults = exports.defaults = {
+  runnerAddress: /*#__PURE__*/Option.some(defaultRunnerAddress),
+  serverVersion: 1,
+  numberOfShards: 300,
+  shardManagerAddress: /*#__PURE__*/_RunnerAddress.RunnerAddress.make({
+    host: "localhost",
+    port: 8080
+  }),
+  shardManagerUnavailableTimeout: /*#__PURE__*/Duration.minutes(10),
+  entityMailboxCapacity: 4096,
+  entityMaxIdleTime: /*#__PURE__*/Duration.minutes(1),
+  entityTerminationTimeout: /*#__PURE__*/Duration.seconds(15),
+  entityMessagePollInterval: /*#__PURE__*/Duration.seconds(10),
+  entityReplyPollInterval: /*#__PURE__*/Duration.millis(200),
+  sendRetryInterval: /*#__PURE__*/Duration.millis(100),
+  refreshAssignmentsInterval: /*#__PURE__*/Duration.minutes(5),
+  simulateRemoteSerialization: true
+};
 /**
- * Provides the ShardingConfig, values that are omitted will be read from the defaults
- *
  * @since 1.0.0
- * @category layers
+ * @category Layers
  */
-const withDefaults = exports.withDefaults = internal.withDefaults;
+const layer = options => Layer.succeed(ShardingConfig, {
+  ...defaults,
+  ...options
+});
+/**
+ * @since 1.0.0
+ * @category defaults
+ */
+exports.layer = layer;
+const layerDefaults = exports.layerDefaults = /*#__PURE__*/layer();
+/**
+ * @since 1.0.0
+ * @category Config
+ */
+const config = exports.config = /*#__PURE__*/Config.all({
+  runnerAddress: /*#__PURE__*/Config.all({
+    host: Config.string("host").pipe(Config.withDefault(defaultRunnerAddress.host), Config.withDescription("The hostname or IP address of the runner.")),
+    port: Config.integer("port").pipe(Config.withDefault(defaultRunnerAddress.port), Config.withDescription("The port used for inter-runner communication."))
+  }).pipe( /*#__PURE__*/Config.map(options => _RunnerAddress.RunnerAddress.make(options)), Config.option),
+  serverVersion: /*#__PURE__*/Config.integer("serverVersion").pipe( /*#__PURE__*/Config.withDefault(defaults.serverVersion), /*#__PURE__*/Config.withDescription("The version of the current runner.")),
+  numberOfShards: /*#__PURE__*/Config.integer("numberOfShards").pipe( /*#__PURE__*/Config.withDefault(defaults.numberOfShards), /*#__PURE__*/Config.withDescription("The number of shards to allocate to a runner.")),
+  shardManagerAddress: /*#__PURE__*/Config.all({
+    host: Config.string("shardManagerHost").pipe(Config.withDefault(defaults.shardManagerAddress.host), Config.withDescription("The host of the shard manager.")),
+    port: Config.integer("shardManagerPort").pipe(Config.withDefault(defaults.shardManagerAddress.port), Config.withDescription("The port of the shard manager."))
+  }).pipe( /*#__PURE__*/Config.map(options => _RunnerAddress.RunnerAddress.make(options))),
+  shardManagerUnavailableTimeout: /*#__PURE__*/Config.duration("shardManagerUnavailableTimeout").pipe( /*#__PURE__*/Config.withDefault(defaults.shardManagerUnavailableTimeout), /*#__PURE__*/Config.withDescription("If the shard is unavilable for this duration, all the shard assignments will be reset.")),
+  entityMailboxCapacity: /*#__PURE__*/Config.integer("entityMailboxCapacity").pipe( /*#__PURE__*/Config.withDefault(defaults.entityMailboxCapacity), /*#__PURE__*/Config.withDescription("The default capacity of the mailbox for entities.")),
+  entityMaxIdleTime: /*#__PURE__*/Config.duration("entityMaxIdleTime").pipe( /*#__PURE__*/Config.withDefault(defaults.entityMaxIdleTime), /*#__PURE__*/Config.withDescription("The maximum duration of inactivity (i.e. without receiving a message) after which an entity will be interrupted.")),
+  entityTerminationTimeout: /*#__PURE__*/Config.duration("entityTerminationTimeout").pipe( /*#__PURE__*/Config.withDefault(defaults.entityTerminationTimeout), /*#__PURE__*/Config.withDescription("The maximum duration of time to wait for an entity to terminate.")),
+  entityMessagePollInterval: /*#__PURE__*/Config.duration("entityMessagePollInterval").pipe( /*#__PURE__*/Config.withDefault(defaults.entityMessagePollInterval), /*#__PURE__*/Config.withDescription("The interval at which to poll for unprocessed messages from storage.")),
+  entityReplyPollInterval: /*#__PURE__*/Config.duration("entityReplyPollInterval").pipe( /*#__PURE__*/Config.withDefault(defaults.entityReplyPollInterval), /*#__PURE__*/Config.withDescription("The interval at which to poll for client replies from storage.")),
+  sendRetryInterval: /*#__PURE__*/Config.duration("sendRetryInterval").pipe( /*#__PURE__*/Config.withDefault(defaults.sendRetryInterval), /*#__PURE__*/Config.withDescription("The interval to retry a send if EntityNotManagedByRunner is returned.")),
+  refreshAssignmentsInterval: /*#__PURE__*/Config.duration("refreshAssignmentsInterval").pipe( /*#__PURE__*/Config.withDefault(defaults.refreshAssignmentsInterval), /*#__PURE__*/Config.withDescription("The interval at which to refresh shard assignments.")),
+  simulateRemoteSerialization: /*#__PURE__*/Config.boolean("simulateRemoteSerialization").pipe( /*#__PURE__*/Config.withDefault(defaults.simulateRemoteSerialization), /*#__PURE__*/Config.withDescription("Simulate serialization and deserialization to remote runners for local entities."))
+});
+/**
+ * @since 1.0.0
+ * @category Config
+ */
+const configFromEnv = exports.configFromEnv = /*#__PURE__*/config.pipe( /*#__PURE__*/Effect.withConfigProvider( /*#__PURE__*/ConfigProvider.fromEnv().pipe(ConfigProvider.constantCase)));
 /**
- * Reads the ShardingConfig from the effect/ConfigProvider
- *
  * @since 1.0.0
- * @category layers
+ * @category Layers
  */
-const fromConfig = exports.fromConfig = internal.fromConfig;
+const layerFromEnv = options => Layer.effect(ShardingConfig, options ? Effect.map(configFromEnv, config => ({
+  ...config,
+  ...options
+})) : configFromEnv);
+exports.layerFromEnv = layerFromEnv;
 //# sourceMappingURL=ShardingConfig.js.map
\ No newline at end of file
diff --git a/dist/cjs/ShardingConfig.js.map b/dist/cjs/ShardingConfig.js.map
index ae5b89a58b67d2c6802f2af598bb757ef8c92e4a..ba2c197fc46532d26a7f4cb89e441492997fadb3 100644
--- a/dist/cjs/ShardingConfig.js.map
+++ b/dist/cjs/ShardingConfig.js.map
@@ -1 +1 @@
-{"version":3,"file":"ShardingConfig.js","names":["internal","_interopRequireWildcard","require","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","ShardingConfigTypeId","exports","ShardingConfig","shardingConfigTag","defaults","withDefaults","fromConfig"],"sources":["../../src/ShardingConfig.ts"],"sourcesContent":[null],"mappings":";;;;;;AAOA,IAAAA,QAAA,GAAAC,uBAAA,CAAAC,OAAA;AAAwD,SAAAC,yBAAAC,CAAA,6BAAAC,OAAA,mBAAAC,CAAA,OAAAD,OAAA,IAAAE,CAAA,OAAAF,OAAA,YAAAF,wBAAA,YAAAA,CAAAC,CAAA,WAAAA,CAAA,GAAAG,CAAA,GAAAD,CAAA,KAAAF,CAAA;AAAA,SAAAH,wBAAAG,CAAA,EAAAE,CAAA,SAAAA,CAAA,IAAAF,CAAA,IAAAA,CAAA,CAAAI,UAAA,SAAAJ,CAAA,eAAAA,CAAA,uBAAAA,CAAA,yBAAAA,CAAA,WAAAK,OAAA,EAAAL,CAAA,QAAAG,CAAA,GAAAJ,wBAAA,CAAAG,CAAA,OAAAC,CAAA,IAAAA,CAAA,CAAAG,GAAA,CAAAN,CAAA,UAAAG,CAAA,CAAAI,GAAA,CAAAP,CAAA,OAAAQ,CAAA,KAAAC,SAAA,UAAAC,CAAA,GAAAC,MAAA,CAAAC,cAAA,IAAAD,MAAA,CAAAE,wBAAA,WAAAC,CAAA,IAAAd,CAAA,oBAAAc,CAAA,OAAAC,cAAA,CAAAC,IAAA,CAAAhB,CAAA,EAAAc,CAAA,SAAAG,CAAA,GAAAP,CAAA,GAAAC,MAAA,CAAAE,wBAAA,CAAAb,CAAA,EAAAc,CAAA,UAAAG,CAAA,KAAAA,CAAA,CAAAV,GAAA,IAAAU,CAAA,CAAAC,GAAA,IAAAP,MAAA,CAAAC,cAAA,CAAAJ,CAAA,EAAAM,CAAA,EAAAG,CAAA,IAAAT,CAAA,CAAAM,CAAA,IAAAd,CAAA,CAAAc,CAAA,YAAAN,CAAA,CAAAH,OAAA,GAAAL,CAAA,EAAAG,CAAA,IAAAA,CAAA,CAAAe,GAAA,CAAAlB,CAAA,EAAAQ,CAAA,GAAAA,CAAA;AAExD;;;;AAIO,MAAMW,oBAAoB,GAAAC,OAAA,CAAAD,oBAAA,GAAkBvB,QAAQ,CAACuB,oBAAoB;AAkChF;;;;AAIO,MAAME,cAAc,GAAAD,OAAA,CAAAC,cAAA,GAAgDzB,QAAQ,CAAC0B,iBAAiB;AAErG;;;;;;AAMO,MAAMC,QAAQ,GAAAH,OAAA,CAAAG,QAAA,GAAgC3B,QAAQ,CAAC2B,QAAQ;AAEtE;;;;;;AAMO,MAAMC,YAAY,GAAAJ,OAAA,CAAAI,YAAA,GAAsE5B,QAAQ,CAAC4B,YAAY;AAEpH;;;;;;AAMO,MAAMC,UAAU,GAAAL,OAAA,CAAAK,UAAA,GAAyD7B,QAAQ,CAAC6B,UAAU","ignoreList":[]}
\ No newline at end of file
+{"version":3,"file":"ShardingConfig.js","names":["Config","_interopRequireWildcard","require","ConfigProvider","Context","Duration","Effect","Layer","Option","_RunnerAddress","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","ShardingConfig","Tag","exports","defaultRunnerAddress","RunnerAddress","make","host","port","defaults","runnerAddress","some","serverVersion","numberOfShards","shardManagerAddress","shardManagerUnavailableTimeout","minutes","entityMailboxCapacity","entityMaxIdleTime","entityTerminationTimeout","seconds","entityMessagePollInterval","entityReplyPollInterval","millis","sendRetryInterval","refreshAssignmentsInterval","simulateRemoteSerialization","layer","options","succeed","layerDefaults","config","all","string","pipe","withDefault","withDescription","integer","map","option","duration","boolean","configFromEnv","withConfigProvider","fromEnv","constantCase","layerFromEnv","effect"],"sources":["../../src/ShardingConfig.ts"],"sourcesContent":[null],"mappings":";;;;;;AAGA,IAAAA,MAAA,GAAAC,uBAAA,CAAAC,OAAA;AAEA,IAAAC,cAAA,GAAAF,uBAAA,CAAAC,OAAA;AACA,IAAAE,OAAA,GAAAH,uBAAA,CAAAC,OAAA;AAEA,IAAAG,QAAA,GAAAJ,uBAAA,CAAAC,OAAA;AACA,IAAAI,MAAA,GAAAL,uBAAA,CAAAC,OAAA;AACA,IAAAK,KAAA,GAAAN,uBAAA,CAAAC,OAAA;AACA,IAAAM,MAAA,GAAAP,uBAAA,CAAAC,OAAA;AACA,IAAAO,cAAA,GAAAP,OAAA;AAAkD,SAAAQ,yBAAAC,CAAA,6BAAAC,OAAA,mBAAAC,CAAA,OAAAD,OAAA,IAAAE,CAAA,OAAAF,OAAA,YAAAF,wBAAA,YAAAA,CAAAC,CAAA,WAAAA,CAAA,GAAAG,CAAA,GAAAD,CAAA,KAAAF,CAAA;AAAA,SAAAV,wBAAAU,CAAA,EAAAE,CAAA,SAAAA,CAAA,IAAAF,CAAA,IAAAA,CAAA,CAAAI,UAAA,SAAAJ,CAAA,eAAAA,CAAA,uBAAAA,CAAA,yBAAAA,CAAA,WAAAK,OAAA,EAAAL,CAAA,QAAAG,CAAA,GAAAJ,wBAAA,CAAAG,CAAA,OAAAC,CAAA,IAAAA,CAAA,CAAAG,GAAA,CAAAN,CAAA,UAAAG,CAAA,CAAAI,GAAA,CAAAP,CAAA,OAAAQ,CAAA,KAAAC,SAAA,UAAAC,CAAA,GAAAC,MAAA,CAAAC,cAAA,IAAAD,MAAA,CAAAE,wBAAA,WAAAC,CAAA,IAAAd,CAAA,oBAAAc,CAAA,OAAAC,cAAA,CAAAC,IAAA,CAAAhB,CAAA,EAAAc,CAAA,SAAAG,CAAA,GAAAP,CAAA,GAAAC,MAAA,CAAAE,wBAAA,CAAAb,CAAA,EAAAc,CAAA,UAAAG,CAAA,KAAAA,CAAA,CAAAV,GAAA,IAAAU,CAAA,CAAAC,GAAA,IAAAP,MAAA,CAAAC,cAAA,CAAAJ,CAAA,EAAAM,CAAA,EAAAG,CAAA,IAAAT,CAAA,CAAAM,CAAA,IAAAd,CAAA,CAAAc,CAAA,YAAAN,CAAA,CAAAH,OAAA,GAAAL,CAAA,EAAAG,CAAA,IAAAA,CAAA,CAAAe,GAAA,CAAAlB,CAAA,EAAAQ,CAAA,GAAAA,CAAA;AAZlD;;;;AAcA;;;;;;AAMM,MAAOW,cAAe,sBAAQ1B,OAAO,CAAC2B,GAAG,CAAC,gCAAgC,CAAC,EA6D7E;AAAAC,OAAA,CAAAF,cAAA,GAAAA,cAAA;AAEJ,MAAMG,oBAAoB,gBAAGC,4BAAa,CAACC,IAAI,CAAC;EAAEC,IAAI,EAAE,WAAW;EAAEC,IAAI,EAAE;AAAK,CAAE,CAAC;AAEnF;;;;AAIO,MAAMC,QAAQ,GAAAN,OAAA,CAAAM,QAAA,GAA2B;EAC9CC,aAAa,eAAE/B,MAAM,CAACgC,IAAI,CAACP,oBAAoB,CAAC;EAChDQ,aAAa,EAAE,CAAC;EAChBC,cAAc,EAAE,GAAG;EACnBC,mBAAmB,eAAET,4BAAa,CAACC,IAAI,CAAC;IAAEC,IAAI,EAAE,WAAW;IAAEC,IAAI,EAAE;EAAI,CAAE,CAAC;EAC1EO,8BAA8B,eAAEvC,QAAQ,CAACwC,OAAO,CAAC,EAAE,CAAC;EACpDC,qBAAqB,EAAE,IAAI;EAC3BC,iBAAiB,eAAE1C,QAAQ,CAACwC,OAAO,CAAC,CAAC,CAAC;EACtCG,wBAAwB,eAAE3C,QAAQ,CAAC4C,OAAO,CAAC,EAAE,CAAC;EAC9CC,yBAAyB,eAAE7C,QAAQ,CAAC4C,OAAO,CAAC,EAAE,CAAC;EAC/CE,uBAAuB,eAAE9C,QAAQ,CAAC+C,MAAM,CAAC,GAAG,CAAC;EAC7CC,iBAAiB,eAAEhD,QAAQ,CAAC+C,MAAM,CAAC,GAAG,CAAC;EACvCE,0BAA0B,eAAEjD,QAAQ,CAACwC,OAAO,CAAC,CAAC,CAAC;EAC/CU,2BAA2B,EAAE;CAC9B;AAED;;;;AAIO,MAAMC,KAAK,GAAIC,OAAyC,IAC7DlD,KAAK,CAACmD,OAAO,CAAC5B,cAAc,EAAE;EAAE,GAAGQ,QAAQ;EAAE,GAAGmB;AAAO,CAAE,CAAC;AAE5D;;;;AAAAzB,OAAA,CAAAwB,KAAA,GAAAA,KAAA;AAIO,MAAMG,aAAa,GAAA3B,OAAA,CAAA2B,aAAA,gBAAgCH,KAAK,EAAE;AAEjE;;;;AAIO,MAAMI,MAAM,GAAA5B,OAAA,CAAA4B,MAAA,gBAA0C5D,MAAM,CAAC6D,GAAG,CAAC;EACtEtB,aAAa,eAAEvC,MAAM,CAAC6D,GAAG,CAAC;IACxBzB,IAAI,EAAEpC,MAAM,CAAC8D,MAAM,CAAC,MAAM,CAAC,CAACC,IAAI,CAC9B/D,MAAM,CAACgE,WAAW,CAAC/B,oBAAoB,CAACG,IAAI,CAAC,EAC7CpC,MAAM,CAACiE,eAAe,CAAC,2CAA2C,CAAC,CACpE;IACD5B,IAAI,EAAErC,MAAM,CAACkE,OAAO,CAAC,MAAM,CAAC,CAACH,IAAI,CAC/B/D,MAAM,CAACgE,WAAW,CAAC/B,oBAAoB,CAACI,IAAI,CAAC,EAC7CrC,MAAM,CAACiE,eAAe,CAAC,+CAA+C,CAAC;GAE1E,CAAC,CAACF,IAAI,eAAC/D,MAAM,CAACmE,GAAG,CAAEV,OAAO,IAAKvB,4BAAa,CAACC,IAAI,CAACsB,OAAO,CAAC,CAAC,EAAEzD,MAAM,CAACoE,MAAM,CAAC;EAC5E3B,aAAa,eAAEzC,MAAM,CAACkE,OAAO,CAAC,eAAe,CAAC,CAACH,IAAI,eACjD/D,MAAM,CAACgE,WAAW,CAAC1B,QAAQ,CAACG,aAAa,CAAC,eAC1CzC,MAAM,CAACiE,eAAe,CAAC,oCAAoC,CAAC,CAC7D;EACDvB,cAAc,eAAE1C,MAAM,CAACkE,OAAO,CAAC,gBAAgB,CAAC,CAACH,IAAI,eACnD/D,MAAM,CAACgE,WAAW,CAAC1B,QAAQ,CAACI,cAAc,CAAC,eAC3C1C,MAAM,CAACiE,eAAe,CAAC,+CAA+C,CAAC,CACxE;EACDtB,mBAAmB,eAAE3C,MAAM,CAAC6D,GAAG,CAAC;IAC9BzB,IAAI,EAAEpC,MAAM,CAAC8D,MAAM,CAAC,kBAAkB,CAAC,CAACC,IAAI,CAC1C/D,MAAM,CAACgE,WAAW,CAAC1B,QAAQ,CAACK,mBAAmB,CAACP,IAAI,CAAC,EACrDpC,MAAM,CAACiE,eAAe,CAAC,gCAAgC,CAAC,CACzD;IACD5B,IAAI,EAAErC,MAAM,CAACkE,OAAO,CAAC,kBAAkB,CAAC,CAACH,IAAI,CAC3C/D,MAAM,CAACgE,WAAW,CAAC1B,QAAQ,CAACK,mBAAmB,CAACN,IAAI,CAAC,EACrDrC,MAAM,CAACiE,eAAe,CAAC,gCAAgC,CAAC;GAE3D,CAAC,CAACF,IAAI,eAAC/D,MAAM,CAACmE,GAAG,CAAEV,OAAO,IAAKvB,4BAAa,CAACC,IAAI,CAACsB,OAAO,CAAC,CAAC,CAAC;EAC7Db,8BAA8B,eAAE5C,MAAM,CAACqE,QAAQ,CAAC,gCAAgC,CAAC,CAACN,IAAI,eACpF/D,MAAM,CAACgE,WAAW,CAAC1B,QAAQ,CAACM,8BAA8B,CAAC,eAC3D5C,MAAM,CAACiE,eAAe,CACpB,wFAAwF,CACzF,CACF;EACDnB,qBAAqB,eAAE9C,MAAM,CAACkE,OAAO,CAAC,uBAAuB,CAAC,CAACH,IAAI,eACjE/D,MAAM,CAACgE,WAAW,CAAC1B,QAAQ,CAACQ,qBAAqB,CAAC,eAClD9C,MAAM,CAACiE,eAAe,CAAC,mDAAmD,CAAC,CAC5E;EACDlB,iBAAiB,eAAE/C,MAAM,CAACqE,QAAQ,CAAC,mBAAmB,CAAC,CAACN,IAAI,eAC1D/D,MAAM,CAACgE,WAAW,CAAC1B,QAAQ,CAACS,iBAAiB,CAAC,eAC9C/C,MAAM,CAACiE,eAAe,CACpB,kHAAkH,CACnH,CACF;EACDjB,wBAAwB,eAAEhD,MAAM,CAACqE,QAAQ,CAAC,0BAA0B,CAAC,CAACN,IAAI,eACxE/D,MAAM,CAACgE,WAAW,CAAC1B,QAAQ,CAACU,wBAAwB,CAAC,eACrDhD,MAAM,CAACiE,eAAe,CAAC,kEAAkE,CAAC,CAC3F;EACDf,yBAAyB,eAAElD,MAAM,CAACqE,QAAQ,CAAC,2BAA2B,CAAC,CAACN,IAAI,eAC1E/D,MAAM,CAACgE,WAAW,CAAC1B,QAAQ,CAACY,yBAAyB,CAAC,eACtDlD,MAAM,CAACiE,eAAe,CAAC,sEAAsE,CAAC,CAC/F;EACDd,uBAAuB,eAAEnD,MAAM,CAACqE,QAAQ,CAAC,yBAAyB,CAAC,CAACN,IAAI,eACtE/D,MAAM,CAACgE,WAAW,CAAC1B,QAAQ,CAACa,uBAAuB,CAAC,eACpDnD,MAAM,CAACiE,eAAe,CAAC,gEAAgE,CAAC,CACzF;EACDZ,iBAAiB,eAAErD,MAAM,CAACqE,QAAQ,CAAC,mBAAmB,CAAC,CAACN,IAAI,eAC1D/D,MAAM,CAACgE,WAAW,CAAC1B,QAAQ,CAACe,iBAAiB,CAAC,eAC9CrD,MAAM,CAACiE,eAAe,CAAC,uEAAuE,CAAC,CAChG;EACDX,0BAA0B,eAAEtD,MAAM,CAACqE,QAAQ,CAAC,4BAA4B,CAAC,CAACN,IAAI,eAC5E/D,MAAM,CAACgE,WAAW,CAAC1B,QAAQ,CAACgB,0BAA0B,CAAC,eACvDtD,MAAM,CAACiE,eAAe,CAAC,qDAAqD,CAAC,CAC9E;EACDV,2BAA2B,eAAEvD,MAAM,CAACsE,OAAO,CAAC,6BAA6B,CAAC,CAACP,IAAI,eAC7E/D,MAAM,CAACgE,WAAW,CAAC1B,QAAQ,CAACiB,2BAA2B,CAAC,eACxDvD,MAAM,CAACiE,eAAe,CAAC,kFAAkF,CAAC;CAE7G,CAAC;AAEF;;;;AAIO,MAAMM,aAAa,GAAAvC,OAAA,CAAAuC,aAAA,gBAAGX,MAAM,CAACG,IAAI,eACtCzD,MAAM,CAACkE,kBAAkB,eACvBrE,cAAc,CAACsE,OAAO,EAAE,CAACV,IAAI,CAC3B5D,cAAc,CAACuE,YAAY,CAC5B,CACF,CACF;AAED;;;;AAIO,MAAMC,YAAY,GAAIlB,OAAqD,IAIhFlD,KAAK,CAACqE,MAAM,CACV9C,cAAc,EACd2B,OAAO,GAAGnD,MAAM,CAAC6D,GAAG,CAACI,aAAa,EAAGX,MAAM,KAAM;EAAE,GAAGA,MAAM;EAAE,GAAGH;AAAO,CAAE,CAAC,CAAC,GAAGc,aAAa,CAC7F;AAAAvC,OAAA,CAAA2C,YAAA,GAAAA,YAAA","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/cjs/ShardingRegistrationEvent.js b/dist/cjs/ShardingRegistrationEvent.js
index 956825a247e8aa2adcd45671ffefde686689c7c1..e71dc9631139c95058dc5a7fc6789f0938613d3a 100644
--- a/dist/cjs/ShardingRegistrationEvent.js
+++ b/dist/cjs/ShardingRegistrationEvent.js
@@ -3,42 +3,36 @@
 Object.defineProperty(exports, "__esModule", {
   value: true
 });
-exports.EntityRegistered = EntityRegistered;
-exports.SingletonRegistered = SingletonRegistered;
-exports.TopicRegistered = TopicRegistered;
-/**
- * Constructs and event that occurs when a new EntityType gets registered.
- *
- * @since 1.0.0
- * @category constructors
- */
-function EntityRegistered(entityType) {
-  return {
-    _tag: "EntityRegistered",
-    entityType
-  };
-}
+exports.match = exports.SingletonRegistered = exports.EntityRegistered = void 0;
+var Data = _interopRequireWildcard(require("effect/Data"));
+function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
+function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
 /**
- * Constructs a new event that occurs when a new Singleton is registered.
- *
  * @since 1.0.0
- * @category constructors
  */
-function SingletonRegistered(name) {
-  return {
-    _tag: "SingletonRegistered",
-    name
-  };
-}
+
 /**
- * Constructs a new event that occurs when a topic is Registered.
  * @since 1.0.0
- * @category constructors
+ * @category pattern matching
  */
-function TopicRegistered(topicType) {
-  return {
-    _tag: "TopicRegistered",
-    topicType
-  };
-}
+const {
+  /**
+   * @since 1.0.0
+   * @category pattern matching
+   */
+  $match: match,
+  /**
+   * @since 1.0.0
+   * @category constructors
+   */
+  EntityRegistered,
+  /**
+   * @since 1.0.0
+   * @category constructors
+   */
+  SingletonRegistered
+} = /*#__PURE__*/Data.taggedEnum();
+exports.SingletonRegistered = SingletonRegistered;
+exports.EntityRegistered = EntityRegistered;
+exports.match = match;
 //# sourceMappingURL=ShardingRegistrationEvent.js.map
\ No newline at end of file
diff --git a/dist/cjs/ShardingRegistrationEvent.js.map b/dist/cjs/ShardingRegistrationEvent.js.map
index dcd34776e5fae4e4a29fe843f08a06e014903dca..43d8725533e2b69fab8c8b9ff316d838d5f5482c 100644
--- a/dist/cjs/ShardingRegistrationEvent.js.map
+++ b/dist/cjs/ShardingRegistrationEvent.js.map
@@ -1 +1 @@
-{"version":3,"file":"ShardingRegistrationEvent.js","names":["EntityRegistered","entityType","_tag","SingletonRegistered","name","TopicRegistered","topicType"],"sources":["../../src/ShardingRegistrationEvent.ts"],"sourcesContent":[null],"mappings":";;;;;;;;AAWA;;;;;;AAMM,SAAUA,gBAAgBA,CAC9BC,UAAyC;EAEzC,OAAQ;IAAEC,IAAI,EAAE,kBAAkB;IAAED;EAAU,CAAE;AAClD;AAOA;;;;;;AAMM,SAAUE,mBAAmBA,CAACC,IAAY;EAC9C,OAAQ;IAAEF,IAAI,EAAE,qBAAqB;IAAEE;EAAI,CAAE;AAC/C;AAOA;;;;;AAKM,SAAUC,eAAeA,CAC7BC,SAAuC;EAEvC,OAAQ;IAAEJ,IAAI,EAAE,iBAAiB;IAAEI;EAAS,CAAE;AAChD","ignoreList":[]}
\ No newline at end of file
+{"version":3,"file":"ShardingRegistrationEvent.js","names":["Data","_interopRequireWildcard","require","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","$match","match","EntityRegistered","SingletonRegistered","taggedEnum","exports"],"sources":["../../src/ShardingRegistrationEvent.ts"],"sourcesContent":[null],"mappings":";;;;;;AAGA,IAAAA,IAAA,GAAAC,uBAAA,CAAAC,OAAA;AAAmC,SAAAC,yBAAAC,CAAA,6BAAAC,OAAA,mBAAAC,CAAA,OAAAD,OAAA,IAAAE,CAAA,OAAAF,OAAA,YAAAF,wBAAA,YAAAA,CAAAC,CAAA,WAAAA,CAAA,GAAAG,CAAA,GAAAD,CAAA,KAAAF,CAAA;AAAA,SAAAH,wBAAAG,CAAA,EAAAE,CAAA,SAAAA,CAAA,IAAAF,CAAA,IAAAA,CAAA,CAAAI,UAAA,SAAAJ,CAAA,eAAAA,CAAA,uBAAAA,CAAA,yBAAAA,CAAA,WAAAK,OAAA,EAAAL,CAAA,QAAAG,CAAA,GAAAJ,wBAAA,CAAAG,CAAA,OAAAC,CAAA,IAAAA,CAAA,CAAAG,GAAA,CAAAN,CAAA,UAAAG,CAAA,CAAAI,GAAA,CAAAP,CAAA,OAAAQ,CAAA,KAAAC,SAAA,UAAAC,CAAA,GAAAC,MAAA,CAAAC,cAAA,IAAAD,MAAA,CAAAE,wBAAA,WAAAC,CAAA,IAAAd,CAAA,oBAAAc,CAAA,OAAAC,cAAA,CAAAC,IAAA,CAAAhB,CAAA,EAAAc,CAAA,SAAAG,CAAA,GAAAP,CAAA,GAAAC,MAAA,CAAAE,wBAAA,CAAAb,CAAA,EAAAc,CAAA,UAAAG,CAAA,KAAAA,CAAA,CAAAV,GAAA,IAAAU,CAAA,CAAAC,GAAA,IAAAP,MAAA,CAAAC,cAAA,CAAAJ,CAAA,EAAAM,CAAA,EAAAG,CAAA,IAAAT,CAAA,CAAAM,CAAA,IAAAd,CAAA,CAAAc,CAAA,YAAAN,CAAA,CAAAH,OAAA,GAAAL,CAAA,EAAAG,CAAA,IAAAA,CAAA,CAAAe,GAAA,CAAAlB,CAAA,EAAAQ,CAAA,GAAAA,CAAA;AAHnC;;;;AAwCA;;;;AAIO,MAAM;EACX;;;;EAIAW,MAAM,EAAEC,KAAK;EACb;;;;EAIAC,gBAAgB;EAChB;;;;EAIAC;AAAmB,CACpB,gBAAG1B,IAAI,CAAC2B,UAAU,EAA6B;AAAAC,OAAA,CAAAF,mBAAA,GAAAA,mBAAA;AAAAE,OAAA,CAAAH,gBAAA,GAAAA,gBAAA;AAAAG,OAAA,CAAAJ,KAAA,GAAAA,KAAA","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/cjs/Singleton.js b/dist/cjs/Singleton.js
new file mode 100644
index 0000000000000000000000000000000000000000..11fad1bfd002f7609494308ceadab1f75def91cf
--- /dev/null
+++ b/dist/cjs/Singleton.js
@@ -0,0 +1,25 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.make = void 0;
+var Effect = _interopRequireWildcard(require("effect/Effect"));
+var Layer = _interopRequireWildcard(require("effect/Layer"));
+var _Sharding = require("./Sharding.js");
+function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
+function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
+/**
+ * @since 1.0.0
+ */
+
+/**
+ * @since 1.0.0
+ * @category constructors
+ */
+const make = (name, run) => Layer.effectDiscard(Effect.gen(function* () {
+  const sharding = yield* _Sharding.Sharding;
+  yield* sharding.registerSingleton(name, run);
+}));
+exports.make = make;
+//# sourceMappingURL=Singleton.js.map
\ No newline at end of file
diff --git a/dist/cjs/Singleton.js.map b/dist/cjs/Singleton.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..57f28aeb2d15f5b14a1746ef183844eb05426e26
--- /dev/null
+++ b/dist/cjs/Singleton.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"Singleton.js","names":["Effect","_interopRequireWildcard","require","Layer","_Sharding","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","make","name","run","effectDiscard","gen","sharding","Sharding","registerSingleton","exports"],"sources":["../../src/Singleton.ts"],"sourcesContent":[null],"mappings":";;;;;;AAGA,IAAAA,MAAA,GAAAC,uBAAA,CAAAC,OAAA;AACA,IAAAC,KAAA,GAAAF,uBAAA,CAAAC,OAAA;AAEA,IAAAE,SAAA,GAAAF,OAAA;AAAwC,SAAAG,yBAAAC,CAAA,6BAAAC,OAAA,mBAAAC,CAAA,OAAAD,OAAA,IAAAE,CAAA,OAAAF,OAAA,YAAAF,wBAAA,YAAAA,CAAAC,CAAA,WAAAA,CAAA,GAAAG,CAAA,GAAAD,CAAA,KAAAF,CAAA;AAAA,SAAAL,wBAAAK,CAAA,EAAAE,CAAA,SAAAA,CAAA,IAAAF,CAAA,IAAAA,CAAA,CAAAI,UAAA,SAAAJ,CAAA,eAAAA,CAAA,uBAAAA,CAAA,yBAAAA,CAAA,WAAAK,OAAA,EAAAL,CAAA,QAAAG,CAAA,GAAAJ,wBAAA,CAAAG,CAAA,OAAAC,CAAA,IAAAA,CAAA,CAAAG,GAAA,CAAAN,CAAA,UAAAG,CAAA,CAAAI,GAAA,CAAAP,CAAA,OAAAQ,CAAA,KAAAC,SAAA,UAAAC,CAAA,GAAAC,MAAA,CAAAC,cAAA,IAAAD,MAAA,CAAAE,wBAAA,WAAAC,CAAA,IAAAd,CAAA,oBAAAc,CAAA,OAAAC,cAAA,CAAAC,IAAA,CAAAhB,CAAA,EAAAc,CAAA,SAAAG,CAAA,GAAAP,CAAA,GAAAC,MAAA,CAAAE,wBAAA,CAAAb,CAAA,EAAAc,CAAA,UAAAG,CAAA,KAAAA,CAAA,CAAAV,GAAA,IAAAU,CAAA,CAAAC,GAAA,IAAAP,MAAA,CAAAC,cAAA,CAAAJ,CAAA,EAAAM,CAAA,EAAAG,CAAA,IAAAT,CAAA,CAAAM,CAAA,IAAAd,CAAA,CAAAc,CAAA,YAAAN,CAAA,CAAAH,OAAA,GAAAL,CAAA,EAAAG,CAAA,IAAAA,CAAA,CAAAe,GAAA,CAAAlB,CAAA,EAAAQ,CAAA,GAAAA,CAAA;AANxC;;;;AAQA;;;;AAIO,MAAMW,IAAI,GAAGA,CAClBC,IAAY,EACZC,GAA8B,KAE9BxB,KAAK,CAACyB,aAAa,CAAC5B,MAAM,CAAC6B,GAAG,CAAC,aAAS;EACtC,MAAMC,QAAQ,GAAG,OAAOC,kBAAQ;EAChC,OAAOD,QAAQ,CAACE,iBAAiB,CAACN,IAAI,EAAEC,GAAG,CAAC;AAC9C,CAAC,CAAC,CAAC;AAAAM,OAAA,CAAAR,IAAA,GAAAA,IAAA","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/cjs/SingletonAddress.js b/dist/cjs/SingletonAddress.js
new file mode 100644
index 0000000000000000000000000000000000000000..6e6f1135599871834e1950652127adb6716e1769
--- /dev/null
+++ b/dist/cjs/SingletonAddress.js
@@ -0,0 +1,50 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.TypeId = exports.SingletonAddress = void 0;
+var Equal = _interopRequireWildcard(require("effect/Equal"));
+var Hash = _interopRequireWildcard(require("effect/Hash"));
+var Schema = _interopRequireWildcard(require("effect/Schema"));
+var _ShardId = require("./ShardId.js");
+function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
+function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
+/**
+ * @since 1.0.0
+ */
+
+/**
+ * @since 1.0.0
+ * @category Address
+ */
+const TypeId = exports.TypeId = /*#__PURE__*/Symbol.for("@effect/cluster/SingletonAddress");
+/**
+ * Represents the unique address of an singleton within the cluster.
+ *
+ * @since 1.0.0
+ * @category Address
+ */
+class SingletonAddress extends /*#__PURE__*/Schema.Class("@effect/cluster/SingletonAddress")({
+  shardId: _ShardId.ShardId,
+  name: Schema.NonEmptyTrimmedString
+}) {
+  /**
+   * @since 1.0.0
+   */
+  [TypeId] = TypeId;
+  /**
+   * @since 1.0.0
+   */
+  [Hash.symbol]() {
+    return Hash.cached(this)(Hash.string(`${this.shardId}:${this.name}`));
+  }
+  /**
+   * @since 1.0.0
+   */
+  [Equal.symbol](that) {
+    return this.shardId === that.shardId && this.name === that.name;
+  }
+}
+exports.SingletonAddress = SingletonAddress;
+//# sourceMappingURL=SingletonAddress.js.map
\ No newline at end of file
diff --git a/dist/cjs/SingletonAddress.js.map b/dist/cjs/SingletonAddress.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..7f9696850bc1e976cd90cf74c37c5d8a7a9f9b40
--- /dev/null
+++ b/dist/cjs/SingletonAddress.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"SingletonAddress.js","names":["Equal","_interopRequireWildcard","require","Hash","Schema","_ShardId","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","TypeId","exports","Symbol","for","SingletonAddress","Class","shardId","ShardId","name","NonEmptyTrimmedString","symbol","cached","string","that"],"sources":["../../src/SingletonAddress.ts"],"sourcesContent":[null],"mappings":";;;;;;AAGA,IAAAA,KAAA,GAAAC,uBAAA,CAAAC,OAAA;AACA,IAAAC,IAAA,GAAAF,uBAAA,CAAAC,OAAA;AACA,IAAAE,MAAA,GAAAH,uBAAA,CAAAC,OAAA;AACA,IAAAG,QAAA,GAAAH,OAAA;AAAsC,SAAAI,yBAAAC,CAAA,6BAAAC,OAAA,mBAAAC,CAAA,OAAAD,OAAA,IAAAE,CAAA,OAAAF,OAAA,YAAAF,wBAAA,YAAAA,CAAAC,CAAA,WAAAA,CAAA,GAAAG,CAAA,GAAAD,CAAA,KAAAF,CAAA;AAAA,SAAAN,wBAAAM,CAAA,EAAAE,CAAA,SAAAA,CAAA,IAAAF,CAAA,IAAAA,CAAA,CAAAI,UAAA,SAAAJ,CAAA,eAAAA,CAAA,uBAAAA,CAAA,yBAAAA,CAAA,WAAAK,OAAA,EAAAL,CAAA,QAAAG,CAAA,GAAAJ,wBAAA,CAAAG,CAAA,OAAAC,CAAA,IAAAA,CAAA,CAAAG,GAAA,CAAAN,CAAA,UAAAG,CAAA,CAAAI,GAAA,CAAAP,CAAA,OAAAQ,CAAA,KAAAC,SAAA,UAAAC,CAAA,GAAAC,MAAA,CAAAC,cAAA,IAAAD,MAAA,CAAAE,wBAAA,WAAAC,CAAA,IAAAd,CAAA,oBAAAc,CAAA,OAAAC,cAAA,CAAAC,IAAA,CAAAhB,CAAA,EAAAc,CAAA,SAAAG,CAAA,GAAAP,CAAA,GAAAC,MAAA,CAAAE,wBAAA,CAAAb,CAAA,EAAAc,CAAA,UAAAG,CAAA,KAAAA,CAAA,CAAAV,GAAA,IAAAU,CAAA,CAAAC,GAAA,IAAAP,MAAA,CAAAC,cAAA,CAAAJ,CAAA,EAAAM,CAAA,EAAAG,CAAA,IAAAT,CAAA,CAAAM,CAAA,IAAAd,CAAA,CAAAc,CAAA,YAAAN,CAAA,CAAAH,OAAA,GAAAL,CAAA,EAAAG,CAAA,IAAAA,CAAA,CAAAe,GAAA,CAAAlB,CAAA,EAAAQ,CAAA,GAAAA,CAAA;AANtC;;;;AAQA;;;;AAIO,MAAMW,MAAM,GAAAC,OAAA,CAAAD,MAAA,gBAAkBE,MAAM,CAACC,GAAG,CAAC,kCAAkC,CAAC;AAQnF;;;;;;AAMM,MAAOC,gBAAiB,sBAAQ1B,MAAM,CAAC2B,KAAK,CAAmB,kCAAkC,CAAC,CAAC;EACvGC,OAAO,EAAEC,gBAAO;EAChBC,IAAI,EAAE9B,MAAM,CAAC+B;CACd,CAAC;EACA;;;EAGS,CAACT,MAAM,IAAIA,MAAM;EAC1B;;;EAGA,CAACvB,IAAI,CAACiC,MAAM,IAAC;IACX,OAAOjC,IAAI,CAACkC,MAAM,CAAC,IAAI,CAAC,CAAClC,IAAI,CAACmC,MAAM,CAAC,GAAG,IAAI,CAACN,OAAO,IAAI,IAAI,CAACE,IAAI,EAAE,CAAC,CAAC;EACvE;EACA;;;EAGA,CAAClC,KAAK,CAACoC,MAAM,EAAEG,IAAsB;IACnC,OAAO,IAAI,CAACP,OAAO,KAAKO,IAAI,CAACP,OAAO,IAAI,IAAI,CAACE,IAAI,KAAKK,IAAI,CAACL,IAAI;EACjE","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/cjs/Snowflake.js b/dist/cjs/Snowflake.js
new file mode 100644
index 0000000000000000000000000000000000000000..c318aaa7b0b6c8c88eabdee6978ceba875f53d2b
--- /dev/null
+++ b/dist/cjs/Snowflake.js
@@ -0,0 +1,133 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.toParts = exports.timestamp = exports.sequence = exports.makeGenerator = exports.make = exports.machineId = exports.layerGenerator = exports.dateTime = exports.constEpochMillis = exports.TypeId = exports.SnowflakeFromString = exports.SnowflakeFromBigInt = exports.Snowflake = exports.Generator = void 0;
+var Context = _interopRequireWildcard(require("effect/Context"));
+var DateTime = _interopRequireWildcard(require("effect/DateTime"));
+var Effect = _interopRequireWildcard(require("effect/Effect"));
+var _Function = require("effect/Function");
+var Layer = _interopRequireWildcard(require("effect/Layer"));
+var Schema = _interopRequireWildcard(require("effect/Schema"));
+function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
+function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
+/**
+ * @since 1.0.0
+ * @category Symbols
+ */
+const TypeId = exports.TypeId = /*#__PURE__*/Symbol.for("@effect/cluster/Snowflake");
+/**
+ * @since 1.0.0
+ * @category Models
+ */
+const Snowflake = input => typeof input === "string" ? BigInt(input) : input;
+/**
+ * @since 1.0.0
+ * @category Schemas
+ */
+exports.Snowflake = Snowflake;
+const SnowflakeFromBigInt = exports.SnowflakeFromBigInt = /*#__PURE__*/Schema.BigIntFromSelf.pipe( /*#__PURE__*/Schema.brand(TypeId));
+/**
+ * @since 1.0.0
+ * @category Schemas
+ */
+const SnowflakeFromString = exports.SnowflakeFromString = /*#__PURE__*/Schema.BigInt.pipe( /*#__PURE__*/Schema.brand(TypeId));
+/**
+ * @since 1.0.0
+ * @category Epoch
+ */
+const constEpochMillis = exports.constEpochMillis = /*#__PURE__*/Date.UTC(2025, 0, 1);
+const sinceUnixEpoch = constEpochMillis - /*#__PURE__*/Date.UTC(1970, 0, 1);
+const constBigInt12 = /*#__PURE__*/BigInt(12);
+const constBigInt22 = /*#__PURE__*/BigInt(22);
+const constBigInt1024 = /*#__PURE__*/BigInt(1024);
+const constBigInt4096 = /*#__PURE__*/BigInt(4096);
+/**
+ * @since 1.0.0
+ * @category constructors
+ */
+const make = options => BigInt(options.timestamp - constEpochMillis) << constBigInt22 | BigInt(options.machineId % 1024) << constBigInt12 | BigInt(options.sequence % 4096);
+/**
+ * @since 1.0.0
+ * @category Parts
+ */
+exports.make = make;
+const timestamp = snowflake => Number(snowflake >> constBigInt22) + sinceUnixEpoch;
+/**
+ * @since 1.0.0
+ * @category Parts
+ */
+exports.timestamp = timestamp;
+const dateTime = snowflake => DateTime.unsafeMake(timestamp(snowflake));
+/**
+ * @since 1.0.0
+ * @category Parts
+ */
+exports.dateTime = dateTime;
+const machineId = snowflake => Number((snowflake >> constBigInt12) % constBigInt1024);
+/**
+ * @since 1.0.0
+ * @category Parts
+ */
+exports.machineId = machineId;
+const sequence = snowflake => Number(snowflake % constBigInt4096);
+/**
+ * @since 1.0.0
+ * @category Parts
+ */
+exports.sequence = sequence;
+const toParts = snowflake => ({
+  timestamp: timestamp(snowflake),
+  machineId: machineId(snowflake),
+  sequence: sequence(snowflake)
+});
+/**
+ * @since 1.0.0
+ * @category Generator
+ */
+exports.toParts = toParts;
+const makeGenerator = exports.makeGenerator = /*#__PURE__*/Effect.gen(function* () {
+  let machineId = Math.floor(Math.random() * 1024);
+  const clock = yield* Effect.clock;
+  let sequence = 0;
+  let sequenceAt = clock.unsafeCurrentTimeMillis();
+  return (0, _Function.identity)({
+    setMachineId: newMachineId => Effect.sync(() => {
+      machineId = newMachineId;
+    }),
+    unsafeNext() {
+      let now = clock.unsafeCurrentTimeMillis();
+      // account for clock drift, only allow time to move forward
+      if (now < sequenceAt) {
+        now = sequenceAt;
+      } else if (now > sequenceAt) {
+        // reset sequence if we're in a new millisecond
+        sequence = 0;
+        sequenceAt = now;
+      } else if (sequence >= 1024) {
+        // if we've hit the max sequence for this millisecond, go to the next
+        // millisecond
+        sequenceAt++;
+        sequence = 0;
+      }
+      return make({
+        machineId,
+        sequence: sequence++,
+        timestamp: sequenceAt
+      });
+    }
+  });
+});
+/**
+ * @since 1.0.0
+ * @category Generator
+ */
+class Generator extends /*#__PURE__*/Context.Tag("@effect/cluster/Snowflake/Generator")() {}
+/**
+ * @since 1.0.0
+ * @category Generator
+ */
+exports.Generator = Generator;
+const layerGenerator = exports.layerGenerator = /*#__PURE__*/Layer.effect(Generator, makeGenerator);
+//# sourceMappingURL=Snowflake.js.map
\ No newline at end of file
diff --git a/dist/cjs/Snowflake.js.map b/dist/cjs/Snowflake.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..ba3e8a724ca33455881f975c3f725cd25d58e612
--- /dev/null
+++ b/dist/cjs/Snowflake.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"Snowflake.js","names":["Context","_interopRequireWildcard","require","DateTime","Effect","_Function","Layer","Schema","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","TypeId","exports","Symbol","for","Snowflake","input","BigInt","SnowflakeFromBigInt","BigIntFromSelf","pipe","brand","SnowflakeFromString","constEpochMillis","Date","UTC","sinceUnixEpoch","constBigInt12","constBigInt22","constBigInt1024","constBigInt4096","make","options","timestamp","machineId","sequence","snowflake","Number","dateTime","unsafeMake","toParts","makeGenerator","gen","Math","floor","random","clock","sequenceAt","unsafeCurrentTimeMillis","identity","setMachineId","newMachineId","sync","unsafeNext","now","Generator","Tag","layerGenerator","effect"],"sources":["../../src/Snowflake.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/cjs/SocketRunner.js b/dist/cjs/SocketRunner.js
new file mode 100644
index 0000000000000000000000000000000000000000..fe246ecae97286158067298b921cfc44f59409eb
--- /dev/null
+++ b/dist/cjs/SocketRunner.js
@@ -0,0 +1,40 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.layerClientOnly = exports.layer = void 0;
+var _SocketServer = require("@effect/platform/SocketServer");
+var RpcServer = _interopRequireWildcard(require("@effect/rpc/RpcServer"));
+var Effect = _interopRequireWildcard(require("effect/Effect"));
+var Layer = _interopRequireWildcard(require("effect/Layer"));
+var Runners = _interopRequireWildcard(require("./Runners.js"));
+var RunnerServer = _interopRequireWildcard(require("./RunnerServer.js"));
+var Sharding = _interopRequireWildcard(require("./Sharding.js"));
+var ShardManager = _interopRequireWildcard(require("./ShardManager.js"));
+var ShardStorage = _interopRequireWildcard(require("./ShardStorage.js"));
+function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
+function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
+/**
+ * @since 1.0.0
+ */
+
+const withLogAddress = layer => Layer.effectDiscard(Effect.gen(function* () {
+  const server = yield* _SocketServer.SocketServer;
+  const address = server.address._tag === "UnixAddress" ? server.address.path : `${server.address.hostname}:${server.address.port}`;
+  yield* Effect.annotateLogs(Effect.logInfo(`Listening on: ${address}`), {
+    package: "@effect/cluster",
+    service: "Runner"
+  });
+})).pipe(Layer.provideMerge(layer));
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+const layer = exports.layer = /*#__PURE__*/RunnerServer.layerWithClients.pipe(withLogAddress, /*#__PURE__*/Layer.provide(RpcServer.layerProtocolSocketServer));
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+const layerClientOnly = exports.layerClientOnly = /*#__PURE__*/Sharding.layer.pipe( /*#__PURE__*/Layer.provideMerge(Runners.layerRpc), /*#__PURE__*/Layer.provide(ShardManager.layerClientRpc), /*#__PURE__*/Layer.provide(ShardStorage.layerNoop));
+//# sourceMappingURL=SocketRunner.js.map
\ No newline at end of file
diff --git a/dist/cjs/SocketRunner.js.map b/dist/cjs/SocketRunner.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..d5031908b3d182d7812d444d98067c1daadf55a5
--- /dev/null
+++ b/dist/cjs/SocketRunner.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"SocketRunner.js","names":["_SocketServer","require","RpcServer","_interopRequireWildcard","Effect","Layer","Runners","RunnerServer","Sharding","ShardManager","ShardStorage","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","withLogAddress","layer","effectDiscard","gen","server","SocketServer","address","_tag","path","hostname","port","annotateLogs","logInfo","package","service","pipe","provideMerge","exports","layerWithClients","provide","layerProtocolSocketServer","layerClientOnly","layerRpc","layerClientRpc","layerNoop"],"sources":["../../src/SocketRunner.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/cjs/SocketShardManager.js b/dist/cjs/SocketShardManager.js
new file mode 100644
index 0000000000000000000000000000000000000000..2bd628a2a1fff859afc2d34b5447c8c61cb002b3
--- /dev/null
+++ b/dist/cjs/SocketShardManager.js
@@ -0,0 +1,33 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.layer = void 0;
+var _SocketServer = require("@effect/platform/SocketServer");
+var RpcServer = _interopRequireWildcard(require("@effect/rpc/RpcServer"));
+var Effect = _interopRequireWildcard(require("effect/Effect"));
+var Layer = _interopRequireWildcard(require("effect/Layer"));
+var MessageStorage = _interopRequireWildcard(require("./MessageStorage.js"));
+var Runners = _interopRequireWildcard(require("./Runners.js"));
+var ShardManager = _interopRequireWildcard(require("./ShardManager.js"));
+function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
+function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
+/**
+ * @since 1.0.0
+ */
+
+const withLogAddress = layer => Layer.effectDiscard(Effect.gen(function* () {
+  const server = yield* _SocketServer.SocketServer;
+  const address = server.address._tag === "UnixAddress" ? server.address.path : `${server.address.hostname}:${server.address.port}`;
+  yield* Effect.annotateLogs(Effect.logInfo(`Listening on: ${address}`), {
+    package: "@effect/cluster",
+    service: "ShardManager"
+  });
+})).pipe(Layer.provideMerge(layer));
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+const layer = exports.layer = /*#__PURE__*/ShardManager.layerServer.pipe(withLogAddress, /*#__PURE__*/Layer.provide(RpcServer.layerProtocolSocketServer), /*#__PURE__*/Layer.provideMerge(ShardManager.layer), /*#__PURE__*/Layer.provide(Runners.layerRpc), /*#__PURE__*/Layer.provide(MessageStorage.layerNoop));
+//# sourceMappingURL=SocketShardManager.js.map
\ No newline at end of file
diff --git a/dist/cjs/SocketShardManager.js.map b/dist/cjs/SocketShardManager.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..e95145eb7f3fab1b260e521af7fda88b4daec8d2
--- /dev/null
+++ b/dist/cjs/SocketShardManager.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"SocketShardManager.js","names":["_SocketServer","require","RpcServer","_interopRequireWildcard","Effect","Layer","MessageStorage","Runners","ShardManager","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","withLogAddress","layer","effectDiscard","gen","server","SocketServer","address","_tag","path","hostname","port","annotateLogs","logInfo","package","service","pipe","provideMerge","exports","layerServer","provide","layerProtocolSocketServer","layerRpc","layerNoop"],"sources":["../../src/SocketShardManager.ts"],"sourcesContent":[null],"mappings":";;;;;;AAGA,IAAAA,aAAA,GAAAC,OAAA;AAEA,IAAAC,SAAA,GAAAC,uBAAA,CAAAF,OAAA;AACA,IAAAG,MAAA,GAAAD,uBAAA,CAAAF,OAAA;AACA,IAAAI,KAAA,GAAAF,uBAAA,CAAAF,OAAA;AACA,IAAAK,cAAA,GAAAH,uBAAA,CAAAF,OAAA;AAEA,IAAAM,OAAA,GAAAJ,uBAAA,CAAAF,OAAA;AAEA,IAAAO,YAAA,GAAAL,uBAAA,CAAAF,OAAA;AAAiD,SAAAQ,yBAAAC,CAAA,6BAAAC,OAAA,mBAAAC,CAAA,OAAAD,OAAA,IAAAE,CAAA,OAAAF,OAAA,YAAAF,wBAAA,YAAAA,CAAAC,CAAA,WAAAA,CAAA,GAAAG,CAAA,GAAAD,CAAA,KAAAF,CAAA;AAAA,SAAAP,wBAAAO,CAAA,EAAAE,CAAA,SAAAA,CAAA,IAAAF,CAAA,IAAAA,CAAA,CAAAI,UAAA,SAAAJ,CAAA,eAAAA,CAAA,uBAAAA,CAAA,yBAAAA,CAAA,WAAAK,OAAA,EAAAL,CAAA,QAAAG,CAAA,GAAAJ,wBAAA,CAAAG,CAAA,OAAAC,CAAA,IAAAA,CAAA,CAAAG,GAAA,CAAAN,CAAA,UAAAG,CAAA,CAAAI,GAAA,CAAAP,CAAA,OAAAQ,CAAA,KAAAC,SAAA,UAAAC,CAAA,GAAAC,MAAA,CAAAC,cAAA,IAAAD,MAAA,CAAAE,wBAAA,WAAAC,CAAA,IAAAd,CAAA,oBAAAc,CAAA,OAAAC,cAAA,CAAAC,IAAA,CAAAhB,CAAA,EAAAc,CAAA,SAAAG,CAAA,GAAAP,CAAA,GAAAC,MAAA,CAAAE,wBAAA,CAAAb,CAAA,EAAAc,CAAA,UAAAG,CAAA,KAAAA,CAAA,CAAAV,GAAA,IAAAU,CAAA,CAAAC,GAAA,IAAAP,MAAA,CAAAC,cAAA,CAAAJ,CAAA,EAAAM,CAAA,EAAAG,CAAA,IAAAT,CAAA,CAAAM,CAAA,IAAAd,CAAA,CAAAc,CAAA,YAAAN,CAAA,CAAAH,OAAA,GAAAL,CAAA,EAAAG,CAAA,IAAAA,CAAA,CAAAe,GAAA,CAAAlB,CAAA,EAAAQ,CAAA,GAAAA,CAAA;AAZjD;;;;AAeA,MAAMW,cAAc,GAAaC,KAA2B,IAC1DzB,KAAK,CAAC0B,aAAa,CAAC3B,MAAM,CAAC4B,GAAG,CAAC,aAAS;EACtC,MAAMC,MAAM,GAAG,OAAOC,0BAAY;EAClC,MAAMC,OAAO,GAAGF,MAAM,CAACE,OAAO,CAACC,IAAI,KAAK,aAAa,GACjDH,MAAM,CAACE,OAAO,CAACE,IAAI,GACnB,GAAGJ,MAAM,CAACE,OAAO,CAACG,QAAQ,IAAIL,MAAM,CAACE,OAAO,CAACI,IAAI,EAAE;EACvD,OAAOnC,MAAM,CAACoC,YAAY,CAACpC,MAAM,CAACqC,OAAO,CAAC,iBAAiBN,OAAO,EAAE,CAAC,EAAE;IACrEO,OAAO,EAAE,iBAAiB;IAC1BC,OAAO,EAAE;GACV,CAAC;AACJ,CAAC,CAAC,CAAC,CAACC,IAAI,CAACvC,KAAK,CAACwC,YAAY,CAACf,KAAK,CAAC,CAAC;AAErC;;;;AAIO,MAAMA,KAAK,GAAAgB,OAAA,CAAAhB,KAAA,gBAUdtB,YAAY,CAACuC,WAAW,CAACH,IAAI,CAC/Bf,cAAc,eACdxB,KAAK,CAAC2C,OAAO,CAAC9C,SAAS,CAAC+C,yBAAyB,CAAC,eAClD5C,KAAK,CAACwC,YAAY,CAACrC,YAAY,CAACsB,KAAK,CAAC,eACtCzB,KAAK,CAAC2C,OAAO,CAACzC,OAAO,CAAC2C,QAAQ,CAAC,eAC/B7C,KAAK,CAAC2C,OAAO,CAAC1C,cAAc,CAAC6C,SAAS,CAAC,CACxC","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/cjs/SqlMessageStorage.js b/dist/cjs/SqlMessageStorage.js
new file mode 100644
index 0000000000000000000000000000000000000000..21dcb572d92ca060e5ac0f5ec9cf64e5f7a6e146
--- /dev/null
+++ b/dist/cjs/SqlMessageStorage.js
@@ -0,0 +1,668 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.make = exports.layerWith = exports.layer = void 0;
+var SqlClient = _interopRequireWildcard(require("@effect/sql/SqlClient"));
+var Arr = _interopRequireWildcard(require("effect/Array"));
+var Effect = _interopRequireWildcard(require("effect/Effect"));
+var Layer = _interopRequireWildcard(require("effect/Layer"));
+var Option = _interopRequireWildcard(require("effect/Option"));
+var Schedule = _interopRequireWildcard(require("effect/Schedule"));
+var _ClusterError = require("./ClusterError.js");
+var _MessageStorage = _interopRequireWildcard(require("./MessageStorage.js"));
+var MessageStorage = _MessageStorage;
+var Snowflake = _interopRequireWildcard(require("./Snowflake.js"));
+function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
+function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
+/**
+ * @since 1.0.0
+ */
+
+/**
+ * @since 1.0.0
+ * @category Constructors
+ */
+const make = exports.make = /*#__PURE__*/Effect.fnUntraced(function* (options) {
+  const sql = (yield* SqlClient.SqlClient).withoutTransforms();
+  const prefix = options?.prefix ?? "cluster";
+  const table = name => `${prefix}_${name}`;
+  const messageKindAckChunk = sql.literal(String(messageKind.AckChunk));
+  const replyKindWithExit = sql.literal(String(replyKind.WithExit));
+  const messagesTable = table("messages");
+  const messagesTableSql = sql(messagesTable);
+  const repliesTable = table("replies");
+  const repliesTableSql = sql(repliesTable);
+  yield* sql.onDialectOrElse({
+    mssql: () => sql`
+        IF OBJECT_ID(N'${messagesTableSql}', N'U') IS NULL
+        CREATE TABLE ${messagesTableSql} (
+          id BIGINT PRIMARY KEY,
+          rowid BIGINT IDENTITY(1,1),
+          message_id VARCHAR(255),
+          shard_id INT NOT NULL,
+          entity_type VARCHAR(255) NOT NULL,
+          entity_id VARCHAR(255) NOT NULL,
+          kind INT NOT NULL,
+          tag VARCHAR(255),
+          payload TEXT,
+          headers TEXT,
+          trace_id VARCHAR(255),
+          span_id VARCHAR(255),
+          sampled BIT,
+          processed BIT NOT NULL DEFAULT 0,
+          request_id BIGINT NOT NULL,
+          reply_id BIGINT,
+          last_reply_id BIGINT,
+          last_read DATETIME,
+          deliver_at BIGINT,
+          UNIQUE (message_id),
+          FOREIGN KEY (request_id) REFERENCES ${messagesTableSql} (id) ON DELETE CASCADE
+        )
+      `,
+    mysql: () => sql`
+        CREATE TABLE IF NOT EXISTS ${messagesTableSql} (
+          id BIGINT NOT NULL,
+          rowid BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,
+          message_id VARCHAR(255),
+          shard_id INT NOT NULL,
+          entity_type VARCHAR(255) NOT NULL,
+          entity_id VARCHAR(255) NOT NULL,
+          kind INT NOT NULL,
+          tag VARCHAR(255),
+          payload TEXT,
+          headers TEXT,
+          trace_id VARCHAR(255),
+          span_id VARCHAR(255),
+          sampled BOOLEAN,
+          processed BOOLEAN NOT NULL DEFAULT FALSE,
+          request_id BIGINT NOT NULL,
+          reply_id BIGINT,
+          last_reply_id BIGINT,
+          last_read DATETIME,
+          deliver_at BIGINT,
+          UNIQUE (id),
+          UNIQUE (message_id),
+          FOREIGN KEY (request_id) REFERENCES ${messagesTableSql} (id) ON DELETE CASCADE
+        )
+      `,
+    pg: () => sql`
+        CREATE TABLE IF NOT EXISTS ${messagesTableSql} (
+          id BIGINT PRIMARY KEY,
+          rowid BIGSERIAL,
+          message_id VARCHAR(255),
+          shard_id INT NOT NULL,
+          entity_type VARCHAR(255) NOT NULL,
+          entity_id VARCHAR(255) NOT NULL,
+          kind INT NOT NULL,
+          tag VARCHAR(255),
+          payload TEXT,
+          headers TEXT,
+          trace_id VARCHAR(255),
+          span_id VARCHAR(255),
+          sampled BOOLEAN,
+          processed BOOLEAN NOT NULL DEFAULT FALSE,
+          request_id BIGINT NOT NULL,
+          reply_id BIGINT,
+          last_reply_id BIGINT,
+          last_read TIMESTAMP,
+          deliver_at BIGINT,
+          UNIQUE (message_id),
+          FOREIGN KEY (request_id) REFERENCES ${messagesTableSql} (id) ON DELETE CASCADE
+        )
+      `.pipe(Effect.ignore),
+    orElse: () =>
+    // sqlite
+    sql`
+        CREATE TABLE IF NOT EXISTS ${messagesTableSql} (
+          id INTEGER PRIMARY KEY,
+          message_id TEXT,
+          shard_id INTEGER NOT NULL,
+          entity_type TEXT NOT NULL,
+          entity_id TEXT NOT NULL,
+          kind INTEGER NOT NULL,
+          tag TEXT,
+          payload TEXT,
+          headers TEXT,
+          trace_id TEXT,
+          span_id TEXT,
+          sampled BOOLEAN,
+          processed BOOLEAN NOT NULL DEFAULT FALSE,
+          request_id INTEGER NOT NULL,
+          reply_id INTEGER,
+          last_reply_id INTEGER,
+          last_read TEXT,
+          deliver_at INTEGER,
+          UNIQUE (message_id),
+          FOREIGN KEY (request_id) REFERENCES ${messagesTableSql} (id) ON DELETE CASCADE
+        )
+      `
+  });
+  // Add message indexes optimized for the specific query patterns
+  const shardLookupIndex = `${messagesTable}_shard_idx`;
+  const requestIdLookupIndex = `${messagesTable}_request_id_idx`;
+  yield* sql.onDialectOrElse({
+    mssql: () => sql`
+        IF NOT EXISTS (SELECT * FROM sys.indexes WHERE name = ${shardLookupIndex})
+        CREATE INDEX ${sql(shardLookupIndex)} 
+        ON ${messagesTableSql} (shard_id, processed, last_read, deliver_at);
+
+        IF NOT EXISTS (SELECT * FROM sys.indexes WHERE name = ${requestIdLookupIndex})
+        CREATE INDEX ${sql(requestIdLookupIndex)}
+        ON ${messagesTableSql} (request_id);
+      `,
+    mysql: () => sql`
+        CREATE INDEX ${sql(shardLookupIndex)}
+        ON ${messagesTableSql} (shard_id, processed, last_read, deliver_at);
+
+        CREATE INDEX ${sql(requestIdLookupIndex)}
+        ON ${messagesTableSql} (request_id);
+      `.unprepared.pipe(Effect.ignore),
+    pg: () => sql`
+        CREATE INDEX IF NOT EXISTS ${sql(shardLookupIndex)}
+        ON ${messagesTableSql} (shard_id, processed, last_read, deliver_at);
+
+        CREATE INDEX IF NOT EXISTS ${sql(requestIdLookupIndex)}
+        ON ${messagesTableSql} (request_id);
+      `.pipe(Effect.tapDefect(error => Effect.annotateLogs(Effect.logDebug("Failed to create indexes", error), {
+      package: "@effect/cluster",
+      module: "SqlMessageStorage"
+    })), Effect.retry({
+      schedule: Schedule.spaced(1000)
+    })),
+    orElse: () =>
+    // sqlite
+    Effect.all([sql`
+          CREATE INDEX IF NOT EXISTS ${sql(shardLookupIndex)}
+          ON ${messagesTableSql} (shard_id, processed, last_read, deliver_at)
+        `, sql`
+          CREATE INDEX IF NOT EXISTS ${sql(requestIdLookupIndex)}
+          ON ${messagesTableSql} (request_id)
+        `]).pipe(sql.withTransaction)
+  });
+  yield* sql.onDialectOrElse({
+    mssql: () => sql`
+        IF OBJECT_ID(N'${repliesTableSql}', N'U') IS NULL
+        CREATE TABLE ${repliesTableSql} (
+          id BIGINT PRIMARY KEY,
+          rowid BIGINT IDENTITY(1,1),
+          kind INT,
+          request_id BIGINT NOT NULL,
+          payload TEXT NOT NULL,
+          sequence INT,
+          acked BIT NOT NULL DEFAULT 0,
+          CONSTRAINT ${sql(repliesTable + "_one_exit")} UNIQUE (request_id, kind),
+          CONSTRAINT ${sql(repliesTable + "_sequence")} UNIQUE (request_id, sequence),
+          FOREIGN KEY (request_id) REFERENCES ${messagesTableSql} (id) ON DELETE CASCADE
+        )
+      `,
+    mysql: () => sql`
+        CREATE TABLE IF NOT EXISTS ${repliesTableSql} (
+          id BIGINT NOT NULL,
+          rowid BIGINT AUTO_INCREMENT PRIMARY KEY,
+          kind INT,
+          request_id BIGINT NOT NULL,
+          payload TEXT NOT NULL,
+          sequence INT,
+          acked BOOLEAN NOT NULL DEFAULT FALSE,
+          UNIQUE (id),
+          UNIQUE (request_id, kind),
+          UNIQUE (request_id, sequence),
+          FOREIGN KEY (request_id) REFERENCES ${messagesTableSql} (id) ON DELETE CASCADE
+        )
+      `,
+    pg: () => sql`
+        CREATE TABLE IF NOT EXISTS ${repliesTableSql} (
+          id BIGINT PRIMARY KEY,
+          rowid BIGSERIAL,
+          kind INT,
+          request_id BIGINT NOT NULL,
+          payload TEXT NOT NULL,
+          sequence INT,
+          acked BOOLEAN NOT NULL DEFAULT FALSE,
+          UNIQUE (request_id, kind),
+          UNIQUE (request_id, sequence),
+          FOREIGN KEY (request_id) REFERENCES ${messagesTableSql} (id) ON DELETE CASCADE
+        )
+      `,
+    orElse: () =>
+    // sqlite
+    sql`
+        CREATE TABLE IF NOT EXISTS ${repliesTableSql} (
+          id INTEGER PRIMARY KEY,
+          kind INTEGER,
+          request_id INTEGER NOT NULL,
+          payload TEXT NOT NULL,
+          sequence INTEGER,
+          acked BOOLEAN NOT NULL DEFAULT FALSE,
+          UNIQUE (request_id, kind),
+          UNIQUE (request_id, sequence),
+          FOREIGN KEY (request_id) REFERENCES ${messagesTableSql} (id) ON DELETE CASCADE
+        )
+      `
+  });
+  // Add reply indexes optimized for request_id lookups
+  const replyLookupIndex = `${repliesTable}_request_lookup_idx`;
+  yield* sql.onDialectOrElse({
+    mssql: () => sql`
+        IF NOT EXISTS (SELECT * FROM sys.indexes WHERE name = ${replyLookupIndex})
+        CREATE INDEX ${sql(replyLookupIndex)}
+        ON ${repliesTableSql} (request_id, kind, acked);
+      `,
+    mysql: () => sql`
+        CREATE INDEX ${sql(replyLookupIndex)}
+        ON ${repliesTableSql} (request_id, kind, acked);
+      `.unprepared.pipe(Effect.ignore),
+    pg: () => sql`
+        CREATE INDEX IF NOT EXISTS ${sql(replyLookupIndex)}
+        ON ${repliesTableSql} (request_id, kind, acked);
+`.pipe(Effect.tapDefect(error => Effect.annotateLogs(Effect.logDebug("Failed to create indexes", error), {
+      package: "@effect/cluster",
+      module: "SqlMessageStorage"
+    })), Effect.retry({
+      schedule: Schedule.spaced(1000)
+    })),
+    orElse: () =>
+    // sqlite
+    sql`
+        CREATE INDEX IF NOT EXISTS ${sql(replyLookupIndex)}
+        ON ${repliesTableSql} (request_id, kind, acked);
+      `
+  });
+  const envelopeToRow = (envelope, message_id, deliver_at) => {
+    switch (envelope._tag) {
+      case "Request":
+        return {
+          id: envelope.requestId,
+          message_id,
+          shard_id: envelope.address.shardId,
+          entity_type: envelope.address.entityType,
+          entity_id: envelope.address.entityId,
+          kind: messageKind.Request,
+          tag: envelope.tag,
+          payload: JSON.stringify(envelope.payload),
+          headers: JSON.stringify(envelope.headers),
+          trace_id: envelope.traceId,
+          span_id: envelope.spanId,
+          sampled: supportsBooleans ? envelope.sampled : envelope.sampled ? 1 : 0,
+          request_id: envelope.requestId,
+          reply_id: null,
+          deliver_at
+        };
+      case "AckChunk":
+        return {
+          id: envelope.id,
+          message_id,
+          shard_id: envelope.address.shardId,
+          entity_type: envelope.address.entityType,
+          entity_id: envelope.address.entityId,
+          kind: messageKind.AckChunk,
+          tag: null,
+          payload: null,
+          headers: null,
+          trace_id: null,
+          span_id: null,
+          sampled: null,
+          request_id: envelope.requestId,
+          reply_id: envelope.replyId,
+          deliver_at
+        };
+      case "Interrupt":
+        return {
+          id: envelope.id,
+          message_id,
+          shard_id: envelope.address.shardId,
+          entity_type: envelope.address.entityType,
+          entity_id: envelope.address.entityId,
+          kind: messageKind.Interrupt,
+          payload: null,
+          tag: null,
+          headers: null,
+          trace_id: null,
+          span_id: null,
+          sampled: null,
+          request_id: envelope.requestId,
+          reply_id: null,
+          deliver_at
+        };
+    }
+  };
+  const replyToRow = reply => ({
+    id: reply.id,
+    kind: replyKind[reply._tag],
+    request_id: reply.requestId,
+    payload: reply._tag === "WithExit" ? JSON.stringify(reply.exit) : JSON.stringify(reply.values),
+    sequence: reply._tag === "Chunk" ? reply.sequence : null
+  });
+  const supportsBooleans = sql.onDialectOrElse({
+    mssql: () => false,
+    sqlite: () => false,
+    orElse: () => true
+  });
+  const messageFromRow = row => {
+    switch (Number(row.kind)) {
+      case 0:
+        return {
+          envelope: {
+            _tag: "Request",
+            requestId: String(row.id),
+            address: {
+              shardId: Number(row.shard_id),
+              entityType: row.entity_type,
+              entityId: row.entity_id
+            },
+            tag: row.tag,
+            payload: JSON.parse(row.payload),
+            headers: JSON.parse(row.headers),
+            traceId: row.trace_id,
+            spanId: row.span_id,
+            sampled: !!row.sampled
+          },
+          lastSentReply: row.reply_reply_id ? Option.some({
+            _tag: "Chunk",
+            id: String(row.reply_reply_id),
+            requestId: String(row.request_id),
+            sequence: Number(row.reply_sequence),
+            values: JSON.parse(row.reply_payload)
+          }) : Option.none()
+        };
+      case 1:
+        return {
+          envelope: {
+            _tag: "AckChunk",
+            id: String(row.id),
+            requestId: String(row.request_id),
+            replyId: String(row.reply_id),
+            address: {
+              shardId: Number(row.shard_id),
+              entityType: row.entity_type,
+              entityId: row.entity_id
+            }
+          },
+          lastSentReply: Option.none()
+        };
+      case 2:
+        return {
+          envelope: {
+            _tag: "Interrupt",
+            id: String(row.id),
+            requestId: String(row.request_id),
+            address: {
+              shardId: Number(row.shard_id),
+              entityType: row.entity_type,
+              entityId: row.entity_id
+            }
+          },
+          lastSentReply: Option.none()
+        };
+    }
+  };
+  const sqlFalse = sql.literal(supportsBooleans ? "FALSE" : "0");
+  const sqlTrue = sql.literal(supportsBooleans ? "TRUE" : "1");
+  const insertEnvelope = sql.onDialectOrElse({
+    pg: () => (row, message_id) => sql`
+        WITH inserted AS (
+          INSERT INTO ${messagesTableSql} ${sql.insert(row)}
+          ON CONFLICT (message_id) DO NOTHING
+          RETURNING id
+        ),
+        existing AS (
+          SELECT m.id, r.id as reply_id, r.kind as reply_kind, r.payload as reply_payload, r.sequence as reply_sequence
+          FROM ${messagesTableSql} m
+          LEFT JOIN ${repliesTableSql} r ON r.id = m.last_reply_id
+          WHERE m.message_id = ${message_id}
+          AND NOT EXISTS (SELECT 1 FROM inserted)
+        )
+        SELECT * FROM existing
+      `,
+    mysql: () => (row, message_id) => sql`
+        SELECT m.id, r.id as reply_id, r.kind as reply_kind, r.payload as reply_payload, r.sequence as reply_sequence
+        FROM ${messagesTableSql} m
+        LEFT JOIN ${repliesTableSql} r ON r.id = m.last_reply_id
+        WHERE m.message_id = ${message_id};
+        INSERT INTO ${messagesTableSql} ${sql.insert(row)}
+        ON DUPLICATE KEY UPDATE id = id;
+      `.unprepared.pipe(
+    // we need 2 queries for mysql, so we need to run them in a
+    // transaction with retries
+    sql.withTransaction, Effect.retry({
+      times: 3
+    }), Effect.map(([rows]) => rows)),
+    mssql: () => (row, message_id) => sql`
+        MERGE ${messagesTableSql} WITH (HOLDLOCK) AS target
+        USING (SELECT ${message_id} as message_id) AS source
+        ON target.message_id = source.message_id
+        WHEN NOT MATCHED THEN
+          INSERT ${sql.insert(row)}
+        OUTPUT
+          inserted.id,
+          CASE
+            WHEN inserted.id IS NULL THEN (
+              SELECT r.id, r.kind, r.payload
+              FROM ${repliesTableSql} r
+              WHERE r.id = target.last_reply_id
+            )
+          END as reply_id,
+          CASE
+            WHEN inserted.id IS NULL THEN (
+              SELECT r.kind
+              FROM ${repliesTableSql} r
+              WHERE r.id = target.last_reply_id
+            )
+          END as reply_kind,
+          CASE
+            WHEN inserted.id IS NULL THEN (
+              SELECT r.payload
+              FROM ${repliesTableSql} r
+              WHERE r.id = target.last_reply_id
+            )
+          END as reply_payload,
+          CASE
+            WHEN inserted.id IS NULL THEN (
+              SELECT r.sequence
+              FROM ${repliesTableSql} r
+              WHERE r.id = target.last_reply_id
+            )
+          END as reply_sequence;
+      `,
+    orElse: () => (row, message_id) => sql`
+        SELECT m.id, r.id as reply_id, r.kind as reply_kind, r.payload as reply_payload, r.sequence as reply_sequence
+        FROM ${messagesTableSql} m
+        LEFT JOIN ${repliesTableSql} r ON r.id = m.last_reply_id
+        WHERE m.message_id = ${message_id}
+      `.pipe(Effect.tap(sql`INSERT OR IGNORE INTO ${messagesTableSql} ${sql.insert(row)}`), sql.withTransaction, Effect.retry({
+      times: 3
+    }))
+  });
+  const fiveMinutesAgo = sql.onDialectOrElse({
+    mssql: () => sql.literal(`DATEADD(MINUTE, -5, GETDATE())`),
+    mysql: () => sql.literal(`NOW() - INTERVAL 5 MINUTE`),
+    pg: () => sql.literal(`NOW() - INTERVAL '5 minutes'`),
+    orElse: () => sql.literal(`DATETIME('now', '-5 minute')`)
+  });
+  const sqlNowString = sql.onDialectOrElse({
+    pg: () => "NOW()",
+    mysql: () => "NOW()",
+    mssql: () => "GETDATE()",
+    orElse: () => "CURRENT_TIMESTAMP"
+  });
+  const sqlNow = sql.literal(sqlNowString);
+  const getUnprocessedMessages = sql.onDialectOrElse({
+    pg: () => (shardIds, now) => sql`
+        UPDATE ${messagesTableSql} m
+        SET last_read = ${sqlNow}
+        FROM (
+          SELECT m.*
+          FROM ${messagesTableSql} m
+          WHERE m.shard_id IN (${sql.literal(shardIds.map(String).join(","))})
+          AND NOT EXISTS (
+            SELECT 1 FROM ${repliesTableSql}
+            WHERE request_id = m.request_id
+            AND (kind = ${replyKindWithExit} OR acked = ${sqlFalse})
+          )
+          AND m.processed = ${sqlFalse}
+          AND (m.last_read IS NULL OR m.last_read < ${fiveMinutesAgo})
+          AND (m.deliver_at IS NULL OR m.deliver_at <= ${sql.literal(String(now))})
+          ORDER BY m.rowid ASC
+          FOR UPDATE
+        ) AS ids
+        LEFT JOIN ${repliesTableSql} r ON r.id = ids.last_reply_id
+        WHERE m.id = ids.id
+        RETURNING ids.*, r.id as reply_reply_id, r.kind as reply_kind, r.payload as reply_payload, r.sequence as reply_sequence
+      `,
+    orElse: () => (shardIds, now) => sql`
+        SELECT m.*, r.id as reply_reply_id, r.kind as reply_kind, r.payload as reply_payload, r.sequence as reply_sequence
+        FROM ${messagesTableSql} m
+        LEFT JOIN ${repliesTableSql} r ON r.id = m.last_reply_id
+        WHERE m.shard_id IN (${sql.literal(shardIds.map(String).join(","))})
+        AND NOT EXISTS (
+          SELECT 1 FROM ${repliesTableSql}
+          WHERE request_id = m.request_id
+          AND (kind = ${replyKindWithExit} OR acked = ${sqlFalse})
+        )
+        AND processed = ${sqlFalse}
+        AND (m.last_read IS NULL OR m.last_read < ${fiveMinutesAgo})
+        AND (m.deliver_at IS NULL OR m.deliver_at <= ${sql.literal(String(now))})
+        ORDER BY m.rowid ASC
+      `.unprepared.pipe(Effect.tap(rows => {
+      if (rows.length === 0) {
+        return Effect.void;
+      }
+      return sql`
+            UPDATE ${messagesTableSql}
+            SET last_read = ${sqlNow}
+            WHERE id IN (${sql.literal(rows.map(row => row.id).join(","))})
+          `.unprepared;
+    }), sql.withTransaction)
+  });
+  return yield* MessageStorage.makeEncoded({
+    saveEnvelope: ({
+      deliverAt,
+      envelope,
+      primaryKey
+    }) => Effect.suspend(() => {
+      const row = envelopeToRow(envelope, primaryKey, deliverAt);
+      let insert = primaryKey ? insertEnvelope(row, primaryKey) : Effect.as(sql`INSERT INTO ${messagesTableSql} ${sql.insert(row)}`.unprepared, []);
+      if (envelope._tag === "AckChunk") {
+        insert = sql`UPDATE ${repliesTableSql} SET acked = ${sqlTrue} WHERE id = ${envelope.replyId}`.pipe(Effect.andThen(sql`UPDATE ${messagesTableSql} SET processed = ${sqlTrue} WHERE processed = ${sqlFalse} AND request_id = ${envelope.requestId} AND kind = ${messageKindAckChunk}`), Effect.andThen(insert), sql.withTransaction);
+      }
+      return insert.pipe(Effect.map(rows => {
+        if (rows.length === 0) {
+          return _MessageStorage.SaveResultEncoded.Success();
+        }
+        const row = rows[0];
+        return _MessageStorage.SaveResultEncoded.Duplicate({
+          originalId: Snowflake.Snowflake(row.id),
+          lastReceivedReply: row.reply_id ? Option.some({
+            id: String(row.reply_id),
+            requestId: String(row.id),
+            _tag: row.reply_kind === replyKind.WithExit ? "WithExit" : "Chunk",
+            ...(row.reply_kind === replyKind.WithExit ? {
+              exit: JSON.parse(row.reply_payload)
+            } : {
+              sequence: Number(row.reply_sequence),
+              values: JSON.parse(row.reply_payload)
+            })
+          }) : Option.none()
+        });
+      }));
+    }).pipe(Effect.provideService(SqlClient.SafeIntegers, true), _ClusterError.PersistenceError.refail),
+    saveReply: reply => Effect.suspend(() => {
+      const row = replyToRow(reply);
+      const update = reply._tag === "Chunk" ? sql`UPDATE ${messagesTableSql} SET last_reply_id = ${reply.id} WHERE id = ${reply.requestId}` : sql`UPDATE ${messagesTableSql} SET processed = ${sqlTrue}, last_reply_id = NULL WHERE request_id = ${reply.requestId}`;
+      return update.unprepared.pipe(Effect.andThen(sql`INSERT INTO ${repliesTableSql} ${sql.insert(row)}`), sql.withTransaction);
+    }).pipe(Effect.asVoid, _ClusterError.PersistenceError.refail),
+    repliesFor: requestIds =>
+    // replies where:
+    // - the request is in the list
+    // - the kind is WithExit
+    // - or the kind is Chunk and has not been acked yet
+    sql`
+        SELECT id, kind, request_id, payload, sequence
+        FROM ${repliesTableSql}
+        WHERE request_id IN (${sql.literal(requestIds.join(","))})
+        AND (
+          kind = ${replyKindWithExit}
+          OR (
+            kind IS NULL
+            AND acked = ${sqlFalse}
+          )
+        )
+        ORDER BY rowid ASC
+      `.unprepared.pipe(Effect.provideService(SqlClient.SafeIntegers, true), Effect.map(Arr.map(row => row.kind === replyKind.WithExit ? {
+      _tag: "WithExit",
+      id: String(row.id),
+      requestId: String(row.request_id),
+      exit: JSON.parse(row.payload)
+    } : {
+      _tag: "Chunk",
+      id: String(row.id),
+      requestId: String(row.request_id),
+      values: JSON.parse(row.payload),
+      sequence: Number(row.sequence)
+    })), _ClusterError.PersistenceError.refail),
+    unprocessedMessages: Effect.fnUntraced(function* (shardIds, now) {
+      const rows = yield* getUnprocessedMessages(shardIds, now);
+      if (rows.length === 0) {
+        return [];
+      }
+      const messages = new Array(rows.length);
+      const ids = new Array(rows.length);
+      for (let i = 0; i < rows.length; i++) {
+        messages[i] = messageFromRow(rows[i]);
+        ids[i] = String(rows[i].id);
+      }
+      return messages;
+    }, Effect.provideService(SqlClient.SafeIntegers, true), _ClusterError.PersistenceError.refail),
+    unprocessedMessagesById(ids, now) {
+      const idArr = Array.from(ids, id => String(id));
+      return sql`
+        SELECT m.*, r.id as reply_id, r.kind as reply_kind, r.payload as reply_payload, r.sequence as reply_sequence
+        FROM ${messagesTableSql} m
+        LEFT JOIN ${repliesTableSql} r ON r.id = m.last_reply_id
+        WHERE m.id IN (${sql.literal(idArr.join(","))})
+        AND NOT EXISTS (
+          SELECT 1 FROM ${repliesTableSql}
+          WHERE request_id = m.request_id
+          AND (kind = ${replyKindWithExit} OR acked = ${sqlFalse})
+        )
+        AND m.processed = ${sqlFalse}
+        AND (m.deliver_at IS NULL OR m.deliver_at <= ${sql.literal(String(now))})
+        ORDER BY m.rowid ASC
+      `.unprepared.pipe(Effect.map(Arr.map(messageFromRow)), Effect.provideService(SqlClient.SafeIntegers, true), _ClusterError.PersistenceError.refail);
+    },
+    resetAddress: address => sql`
+        UPDATE ${messagesTableSql}
+        SET last_read = NULL
+        WHERE processed = ${sqlFalse}
+        AND shard_id = ${address.shardId}
+        AND entity_type = ${address.entityType}
+        AND entity_id = ${address.entityId}
+`.pipe(Effect.asVoid, _ClusterError.PersistenceError.refail)
+  });
+});
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+const layer = exports.layer = /*#__PURE__*/Layer.scoped(MessageStorage.MessageStorage, make()).pipe( /*#__PURE__*/Layer.provide(Snowflake.layerGenerator));
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+const layerWith = options => Layer.scoped(MessageStorage.MessageStorage, make(options)).pipe(Layer.provide(Snowflake.layerGenerator));
+// -------------------------------------------------------------------------------------------------
+// internal
+// -------------------------------------------------------------------------------------------------
+exports.layerWith = layerWith;
+const messageKind = {
+  "Request": 0,
+  "AckChunk": 1,
+  "Interrupt": 2
+};
+const replyKind = {
+  "WithExit": 0,
+  "Chunk": null
+};
+//# sourceMappingURL=SqlMessageStorage.js.map
\ No newline at end of file
diff --git a/dist/cjs/SqlMessageStorage.js.map b/dist/cjs/SqlMessageStorage.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..6fd7882280cd724d994837b055503e2669b349b5
--- /dev/null
+++ b/dist/cjs/SqlMessageStorage.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"SqlMessageStorage.js","names":["SqlClient","_interopRequireWildcard","require","Arr","Effect","Layer","Option","Schedule","_ClusterError","_MessageStorage","MessageStorage","Snowflake","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","make","exports","fnUntraced","options","sql","withoutTransforms","prefix","table","name","messageKindAckChunk","literal","String","messageKind","AckChunk","replyKindWithExit","replyKind","WithExit","messagesTable","messagesTableSql","repliesTable","repliesTableSql","onDialectOrElse","mssql","mysql","pg","pipe","ignore","orElse","shardLookupIndex","requestIdLookupIndex","unprepared","tapDefect","error","annotateLogs","logDebug","package","module","retry","schedule","spaced","all","withTransaction","replyLookupIndex","envelopeToRow","envelope","message_id","deliver_at","_tag","id","requestId","shard_id","address","shardId","entity_type","entityType","entity_id","entityId","kind","Request","tag","payload","JSON","stringify","headers","trace_id","traceId","span_id","spanId","sampled","supportsBooleans","request_id","reply_id","replyId","Interrupt","replyToRow","reply","exit","values","sequence","sqlite","messageFromRow","row","Number","parse","lastSentReply","reply_reply_id","some","reply_sequence","reply_payload","none","sqlFalse","sqlTrue","insertEnvelope","insert","times","map","rows","tap","fiveMinutesAgo","sqlNowString","sqlNow","getUnprocessedMessages","shardIds","now","join","length","void","makeEncoded","saveEnvelope","deliverAt","primaryKey","suspend","as","andThen","SaveResultEncoded","Success","Duplicate","originalId","lastReceivedReply","reply_kind","provideService","SafeIntegers","PersistenceError","refail","saveReply","update","asVoid","repliesFor","requestIds","unprocessedMessages","messages","Array","ids","unprocessedMessagesById","idArr","from","resetAddress","layer","scoped","provide","layerGenerator","layerWith"],"sources":["../../src/SqlMessageStorage.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/cjs/SqlShardStorage.js b/dist/cjs/SqlShardStorage.js
new file mode 100644
index 0000000000000000000000000000000000000000..d96db28d293f63d3d49cc08c3438f82ce82d255c
--- /dev/null
+++ b/dist/cjs/SqlShardStorage.js
@@ -0,0 +1,228 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.make = exports.layerWith = exports.layer = void 0;
+var SqlClient = _interopRequireWildcard(require("@effect/sql/SqlClient"));
+var Arr = _interopRequireWildcard(require("effect/Array"));
+var Effect = _interopRequireWildcard(require("effect/Effect"));
+var Layer = _interopRequireWildcard(require("effect/Layer"));
+var _ClusterError = require("./ClusterError.js");
+var ShardStorage = _interopRequireWildcard(require("./ShardStorage.js"));
+function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
+function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
+/**
+ * @since 1.0.0
+ */
+
+/**
+ * @since 1.0.0
+ * @category Constructors
+ */
+const make = exports.make = /*#__PURE__*/Effect.fnUntraced(function* (options) {
+  const sql = (yield* SqlClient.SqlClient).withoutTransforms();
+  const prefix = options?.prefix ?? "cluster";
+  const table = name => `${prefix}_${name}`;
+  const runnersTable = table("runners");
+  const runnersTableSql = sql(runnersTable);
+  yield* sql.onDialectOrElse({
+    mssql: () => sql`
+        IF OBJECT_ID(N'${runnersTableSql}', N'U') IS NULL
+        CREATE TABLE ${runnersTableSql} (
+          address VARCHAR(255) PRIMARY KEY,
+          runner TEXT NOT NULL
+        )
+      `,
+    mysql: () => sql`
+        CREATE TABLE IF NOT EXISTS ${runnersTableSql} (
+          address VARCHAR(255) PRIMARY KEY,
+          runner TEXT NOT NULL
+        )
+      `,
+    pg: () => sql`
+        CREATE TABLE IF NOT EXISTS ${runnersTableSql} (
+          address VARCHAR(255) PRIMARY KEY,
+          runner TEXT NOT NULL
+        )
+      `,
+    orElse: () =>
+    // sqlite
+    sql`
+        CREATE TABLE IF NOT EXISTS ${runnersTableSql} (
+          address TEXT PRIMARY KEY,
+          runner TEXT NOT NULL
+        )
+      `
+  });
+  const shardsTable = table("shards");
+  const shardsTableSql = sql(shardsTable);
+  yield* sql.onDialectOrElse({
+    mssql: () => sql`
+        IF OBJECT_ID(N'${shardsTableSql}', N'U') IS NULL
+        CREATE TABLE ${shardsTableSql} (
+          shard_id INT PRIMARY KEY,
+          address VARCHAR(255)
+        )
+      `,
+    mysql: () => sql`
+        CREATE TABLE IF NOT EXISTS ${shardsTableSql} (
+          shard_id INT PRIMARY KEY,
+          address VARCHAR(255)
+        )
+      `,
+    pg: () => sql`
+        CREATE TABLE IF NOT EXISTS ${shardsTableSql} (
+          shard_id INT PRIMARY KEY,
+          address VARCHAR(255)
+        )
+      `,
+    orElse: () =>
+    // sqlite
+    sql`
+        CREATE TABLE IF NOT EXISTS ${shardsTableSql} (
+          shard_id INTEGER PRIMARY KEY,
+          address TEXT
+        )
+      `
+  });
+  const locksTable = table("locks");
+  const locksTableSql = sql(locksTable);
+  yield* sql.onDialectOrElse({
+    mssql: () => sql`
+        IF OBJECT_ID(N'${locksTableSql}', N'U') IS NULL
+        CREATE TABLE ${locksTableSql} (
+          shard_id INT PRIMARY KEY,
+          address VARCHAR(255) NOT NULL,
+          acquired_at DATETIME NOT NULL
+        )
+      `,
+    mysql: () => sql`
+        CREATE TABLE IF NOT EXISTS ${locksTableSql} (
+          shard_id INT PRIMARY KEY,
+          address VARCHAR(255) NOT NULL,
+          acquired_at DATETIME NOT NULL
+        )
+      `,
+    pg: () => sql`
+        CREATE TABLE IF NOT EXISTS ${locksTableSql} (
+          shard_id INT PRIMARY KEY,
+          address VARCHAR(255) NOT NULL,
+          acquired_at TIMESTAMP NOT NULL
+        )
+      `,
+    orElse: () =>
+    // sqlite
+    sql`
+        CREATE TABLE IF NOT EXISTS ${locksTableSql} (
+          shard_id INTEGER PRIMARY KEY,
+          address TEXT NOT NULL,
+          acquired_at DATETIME NOT NULL
+        )
+      `
+  });
+  const sqlNowString = sql.onDialectOrElse({
+    pg: () => "NOW()",
+    mysql: () => "NOW()",
+    mssql: () => "GETDATE()",
+    orElse: () => "CURRENT_TIMESTAMP"
+  });
+  const sqlNow = sql.literal(sqlNowString);
+  const lockExpiresAt = sql.onDialectOrElse({
+    pg: () => sql`${sqlNow} - INTERVAL '120 seconds'`,
+    mysql: () => sql`DATE_SUB(${sqlNow}, INTERVAL 120 SECOND)`,
+    mssql: () => sql`DATEADD(SECOND, -120, ${sqlNow})`,
+    orElse: () => sql`datetime(${sqlNow}, '-120 seconds')`
+  });
+  const acquireLock = sql.onDialectOrElse({
+    pg: () => (address, values) => sql`
+        INSERT INTO ${locksTableSql} (shard_id, address, acquired_at) VALUES ${sql.csv(values)}
+        ON CONFLICT (shard_id) DO UPDATE
+        SET address = ${address}, acquired_at = ${sqlNow}
+        WHERE ${locksTableSql}.address = ${address}
+          OR ${locksTableSql}.acquired_at < ${lockExpiresAt}
+      `,
+    mysql: () => (_address, values) => sql`
+        INSERT INTO ${locksTableSql} (shard_id, address, acquired_at) VALUES ${sql.csv(values)}
+        ON DUPLICATE KEY UPDATE
+        address = IF(address = VALUES(address) OR acquired_at < ${lockExpiresAt}, VALUES(address), address),
+        acquired_at = IF(address = VALUES(address) OR acquired_at < ${lockExpiresAt}, VALUES(acquired_at), acquired_at)
+      `.unprepared,
+    mssql: () => (_address, values) => sql`
+        MERGE ${locksTableSql} WITH (HOLDLOCK) AS target
+        USING (SELECT * FROM (VALUES ${sql.csv(values)})) AS source (shard_id, address, acquired_at)
+        ON target.shard_id = source.shard_id
+        WHEN MATCHED AND (target.address = source.address OR DATEDIFF(SECOND, target.acquired_at, ${sqlNow}) > 120) THEN
+          UPDATE SET address = source.address, acquired_at = source.acquired_at
+        WHEN NOT MATCHED THEN
+          INSERT (shard_id, address, acquired_at)
+          VALUES (source.shard_id, source.address, source.acquired_at);
+      `,
+    orElse: () => (address, values) =>
+    // sqlite
+    sql`
+        WITH source(shard_id, address, acquired_at) AS (VALUES ${sql.csv(values)})
+        INSERT INTO ${locksTableSql} (shard_id, address, acquired_at)
+        SELECT source.shard_id, source.address, source.acquired_at
+        FROM source
+        WHERE NOT EXISTS (
+          SELECT 1 FROM ${locksTableSql}
+          WHERE shard_id = source.shard_id
+          AND address != ${address}
+          AND (strftime('%s', ${sqlNow}) - strftime('%s', acquired_at)) <= 120
+        )
+        ON CONFLICT(shard_id) DO UPDATE
+        SET address = ${address}, acquired_at = ${sqlNow}
+      `
+  });
+  const forUpdate = sql.onDialectOrElse({
+    sqlite: () => sql.literal(""),
+    orElse: () => sql.literal("FOR UPDATE")
+  });
+  return yield* ShardStorage.makeEncoded({
+    getAssignments: sql`SELECT shard_id, address FROM ${shardsTableSql} ORDER BY shard_id`.values.pipe(_ClusterError.PersistenceError.refail),
+    saveAssignments: assignments => {
+      const remove = sql`DELETE FROM ${shardsTableSql}`;
+      if (assignments.length === 0) {
+        return _ClusterError.PersistenceError.refail(remove);
+      }
+      const values = assignments.map(([shardId, address]) => sql`(${shardId}, ${address})`);
+      return remove.pipe(Effect.andThen(sql`INSERT INTO ${shardsTableSql} (shard_id, address) VALUES ${sql.csv(values)}`.unprepared), sql.withTransaction, _ClusterError.PersistenceError.refail);
+    },
+    getRunners: sql`SELECT address, runner FROM ${runnersTableSql}`.values.pipe(_ClusterError.PersistenceError.refail, Effect.map(Arr.map(([address, runner]) => [String(address), String(runner)]))),
+    saveRunners: runners => {
+      const remove = sql`DELETE FROM ${runnersTableSql}`;
+      if (runners.length === 0) {
+        return _ClusterError.PersistenceError.refail(remove);
+      }
+      const values = runners.map(([address, runner]) => sql`(${address}, ${runner})`);
+      const insert = sql`INSERT INTO ${runnersTableSql} (address, runner) VALUES ${sql.csv(values)}`.unprepared;
+      return remove.pipe(Effect.andThen(insert), sql.withTransaction, _ClusterError.PersistenceError.refail);
+    },
+    acquire: Effect.fnUntraced(function* (address, shardIds) {
+      const values = shardIds.map(shardId => sql`(${shardId}, ${address}, ${sqlNow})`);
+      yield* acquireLock(address, values);
+      const currentLocks = yield* sql`
+          SELECT shard_id FROM ${sql(locksTable)}
+          WHERE address = ${address} AND ${sql.in("shard_id", shardIds)}
+          ${forUpdate}
+        `;
+      return currentLocks.map(row => row.shard_id);
+    }, sql.withTransaction, _ClusterError.PersistenceError.refail),
+    refresh: (address, shardIds) => sql`UPDATE ${locksTableSql} SET acquired_at = ${sqlNow} WHERE address = ${address} AND ${sql.in("shard_id", shardIds)}`.pipe(Effect.andThen(sql`SELECT shard_id FROM ${locksTableSql} WHERE address = ${address} AND acquired_at >= ${lockExpiresAt} ${forUpdate}`.values), Effect.map(rows => rows.map(row => Number(row[0]))), _ClusterError.PersistenceError.refail),
+    release: (address, shardId) => sql`DELETE FROM ${locksTableSql} WHERE address = ${address} AND shard_id = ${shardId}`.pipe(_ClusterError.PersistenceError.refail),
+    releaseAll: address => sql`DELETE FROM ${locksTableSql} WHERE address = ${address}`.pipe(_ClusterError.PersistenceError.refail)
+  });
+});
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+const layer = exports.layer = /*#__PURE__*/Layer.effect(ShardStorage.ShardStorage, /*#__PURE__*/make());
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+const layerWith = options => Layer.scoped(ShardStorage.ShardStorage, make(options));
+exports.layerWith = layerWith;
+//# sourceMappingURL=SqlShardStorage.js.map
\ No newline at end of file
diff --git a/dist/cjs/SqlShardStorage.js.map b/dist/cjs/SqlShardStorage.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..0797affb9f1078b44d8131ebcd4feab5a2fa84b4
--- /dev/null
+++ b/dist/cjs/SqlShardStorage.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"SqlShardStorage.js","names":["SqlClient","_interopRequireWildcard","require","Arr","Effect","Layer","_ClusterError","ShardStorage","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","make","exports","fnUntraced","options","sql","withoutTransforms","prefix","table","name","runnersTable","runnersTableSql","onDialectOrElse","mssql","mysql","pg","orElse","shardsTable","shardsTableSql","locksTable","locksTableSql","sqlNowString","sqlNow","literal","lockExpiresAt","acquireLock","address","values","csv","_address","unprepared","forUpdate","sqlite","makeEncoded","getAssignments","pipe","PersistenceError","refail","saveAssignments","assignments","remove","length","map","shardId","andThen","withTransaction","getRunners","runner","String","saveRunners","runners","insert","acquire","shardIds","currentLocks","in","row","shard_id","refresh","rows","Number","release","releaseAll","layer","effect","layerWith","scoped"],"sources":["../../src/SqlShardStorage.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/cjs/SynchronizedClock.js b/dist/cjs/SynchronizedClock.js
new file mode 100644
index 0000000000000000000000000000000000000000..9fed585b85a11ac9d819665d58c9b36d0a26e8db
--- /dev/null
+++ b/dist/cjs/SynchronizedClock.js
@@ -0,0 +1,66 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.make = exports.layer = void 0;
+var Clock = _interopRequireWildcard(require("effect/Clock"));
+var Duration = _interopRequireWildcard(require("effect/Duration"));
+var Effect = _interopRequireWildcard(require("effect/Effect"));
+var Layer = _interopRequireWildcard(require("effect/Layer"));
+var Schedule = _interopRequireWildcard(require("effect/Schedule"));
+var _ShardManager = require("./ShardManager.js");
+function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
+function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
+/**
+ * @since 1.0.0
+ */
+
+/**
+ * @since 1.0.0
+ * @category Constructors
+ */
+const make = exports.make = /*#__PURE__*/Effect.fnUntraced(function* (getRemoteTime) {
+  const clock = yield* Effect.clock;
+  let driftMillis = 0;
+  let driftNanos = BigInt(0);
+  yield* getRemoteTime.pipe(Effect.timed, Effect.map(([duration, shardManagerTime]) => {
+    const halfTrip = Duration.unsafeDivide(duration, 2);
+    shardManagerTime = shardManagerTime + Duration.toMillis(halfTrip) + 1;
+    const selfTime = clock.unsafeCurrentTimeMillis();
+    return shardManagerTime - selfTime;
+  }), Effect.replicateEffect(5), Effect.flatMap(drifts => {
+    drifts.sort();
+    const drift = (driftMillis + drifts[2]) / 2;
+    driftMillis = Math.round(drift);
+    driftNanos = BigInt(Math.round(drift * 1_000_000));
+    return Effect.logDebug("Current drift", driftMillis);
+  }), Effect.andThen(Effect.sleep(Duration.minutes(5))), Effect.forever, Effect.sandbox, Effect.retry(Schedule.spaced(Duration.minutes(1))), Effect.annotateLogs({
+    package: "@effect/cluster",
+    service: "SynchronizedClock"
+  }), Effect.forkScoped);
+  function unsafeCurrentTimeMillis() {
+    return clock.unsafeCurrentTimeMillis() + driftMillis;
+  }
+  function unsafeCurrentTimeNanos() {
+    return clock.unsafeCurrentTimeNanos() + driftNanos;
+  }
+  return Clock.Clock.of({
+    [Clock.ClockTypeId]: Clock.ClockTypeId,
+    sleep: clock.sleep,
+    unsafeCurrentTimeMillis,
+    unsafeCurrentTimeNanos,
+    currentTimeMillis: Effect.sync(unsafeCurrentTimeMillis),
+    currentTimeNanos: Effect.sync(unsafeCurrentTimeNanos)
+  });
+});
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+const layer = exports.layer = /*#__PURE__*/Layer.unwrapScoped( /*#__PURE__*/Effect.gen(function* () {
+  const shardManager = yield* _ShardManager.ShardManagerClient;
+  const clock = yield* make(shardManager.getTime);
+  return Layer.setClock(clock);
+}));
+//# sourceMappingURL=SynchronizedClock.js.map
\ No newline at end of file
diff --git a/dist/cjs/SynchronizedClock.js.map b/dist/cjs/SynchronizedClock.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..76515b6d9f07e4a10e157da5f1033ef1f8398bbc
--- /dev/null
+++ b/dist/cjs/SynchronizedClock.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"SynchronizedClock.js","names":["Clock","_interopRequireWildcard","require","Duration","Effect","Layer","Schedule","_ShardManager","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","make","exports","fnUntraced","getRemoteTime","clock","driftMillis","driftNanos","BigInt","pipe","timed","map","duration","shardManagerTime","halfTrip","unsafeDivide","toMillis","selfTime","unsafeCurrentTimeMillis","replicateEffect","flatMap","drifts","sort","drift","Math","round","logDebug","andThen","sleep","minutes","forever","sandbox","retry","spaced","annotateLogs","package","service","forkScoped","unsafeCurrentTimeNanos","of","ClockTypeId","currentTimeMillis","sync","currentTimeNanos","layer","unwrapScoped","gen","shardManager","ShardManagerClient","getTime","setClock"],"sources":["../../src/SynchronizedClock.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/cjs/index.js b/dist/cjs/index.js
index 212a0f317ff10cd7bca2c816197bcb1b4efd52af..45713c1035e7179067100750817f534cd370d1dd 100644
--- a/dist/cjs/index.js
+++ b/dist/cjs/index.js
@@ -3,63 +3,75 @@
 Object.defineProperty(exports, "__esModule", {
   value: true
 });
-exports.Storage = exports.ShardingRegistrationEvent = exports.ShardingException = exports.ShardingEvent = exports.ShardingConfig = exports.Sharding = exports.ShardManagerClient = exports.ShardManager = exports.ShardId = exports.SerializedMessage = exports.SerializedEnvelope = exports.Serialization = exports.RecipientType = exports.RecipientBehaviourContext = exports.RecipientBehaviour = exports.RecipientAddress = exports.PoisonPill = exports.PodsHealth = exports.Pods = exports.PodAddress = exports.Pod = exports.Messenger = exports.MessageState = exports.Message = exports.ManagerConfig = exports.Broadcaster = exports.AtLeastOnceStorage = exports.AtLeastOnce = void 0;
-var _AtLeastOnce = _interopRequireWildcard(require("./AtLeastOnce.js"));
-exports.AtLeastOnce = _AtLeastOnce;
-var _AtLeastOnceStorage = _interopRequireWildcard(require("./AtLeastOnceStorage.js"));
-exports.AtLeastOnceStorage = _AtLeastOnceStorage;
-var _Broadcaster = _interopRequireWildcard(require("./Broadcaster.js"));
-exports.Broadcaster = _Broadcaster;
-var _ManagerConfig = _interopRequireWildcard(require("./ManagerConfig.js"));
-exports.ManagerConfig = _ManagerConfig;
+exports.SynchronizedClock = exports.SqlShardStorage = exports.SqlMessageStorage = exports.SocketShardManager = exports.SocketRunner = exports.Snowflake = exports.SingletonAddress = exports.Singleton = exports.ShardingRegistrationEvent = exports.ShardingConfig = exports.Sharding = exports.ShardStorage = exports.ShardManager = exports.ShardId = exports.Runners = exports.RunnerServer = exports.RunnerHealth = exports.RunnerAddress = exports.Runner = exports.Reply = exports.MessageStorage = exports.Message = exports.HttpShardManager = exports.HttpRunner = exports.HttpCommon = exports.Envelope = exports.EntityType = exports.EntityId = exports.EntityAddress = exports.Entity = exports.DeliverAt = exports.ClusterSchema = exports.ClusterMetrics = exports.ClusterError = void 0;
+var _ClusterError = _interopRequireWildcard(require("./ClusterError.js"));
+exports.ClusterError = _ClusterError;
+var _ClusterMetrics = _interopRequireWildcard(require("./ClusterMetrics.js"));
+exports.ClusterMetrics = _ClusterMetrics;
+var _ClusterSchema = _interopRequireWildcard(require("./ClusterSchema.js"));
+exports.ClusterSchema = _ClusterSchema;
+var _DeliverAt = _interopRequireWildcard(require("./DeliverAt.js"));
+exports.DeliverAt = _DeliverAt;
+var _Entity = _interopRequireWildcard(require("./Entity.js"));
+exports.Entity = _Entity;
+var _EntityAddress = _interopRequireWildcard(require("./EntityAddress.js"));
+exports.EntityAddress = _EntityAddress;
+var _EntityId = _interopRequireWildcard(require("./EntityId.js"));
+exports.EntityId = _EntityId;
+var _EntityType = _interopRequireWildcard(require("./EntityType.js"));
+exports.EntityType = _EntityType;
+var _Envelope = _interopRequireWildcard(require("./Envelope.js"));
+exports.Envelope = _Envelope;
+var _HttpCommon = _interopRequireWildcard(require("./HttpCommon.js"));
+exports.HttpCommon = _HttpCommon;
+var _HttpRunner = _interopRequireWildcard(require("./HttpRunner.js"));
+exports.HttpRunner = _HttpRunner;
+var _HttpShardManager = _interopRequireWildcard(require("./HttpShardManager.js"));
+exports.HttpShardManager = _HttpShardManager;
 var _Message = _interopRequireWildcard(require("./Message.js"));
 exports.Message = _Message;
-var _MessageState = _interopRequireWildcard(require("./MessageState.js"));
-exports.MessageState = _MessageState;
-var _Messenger = _interopRequireWildcard(require("./Messenger.js"));
-exports.Messenger = _Messenger;
-var _Pod = _interopRequireWildcard(require("./Pod.js"));
-exports.Pod = _Pod;
-var _PodAddress = _interopRequireWildcard(require("./PodAddress.js"));
-exports.PodAddress = _PodAddress;
-var _Pods = _interopRequireWildcard(require("./Pods.js"));
-exports.Pods = _Pods;
-var _PodsHealth = _interopRequireWildcard(require("./PodsHealth.js"));
-exports.PodsHealth = _PodsHealth;
-var _PoisonPill = _interopRequireWildcard(require("./PoisonPill.js"));
-exports.PoisonPill = _PoisonPill;
-var _RecipientAddress = _interopRequireWildcard(require("./RecipientAddress.js"));
-exports.RecipientAddress = _RecipientAddress;
-var _RecipientBehaviour = _interopRequireWildcard(require("./RecipientBehaviour.js"));
-exports.RecipientBehaviour = _RecipientBehaviour;
-var _RecipientBehaviourContext = _interopRequireWildcard(require("./RecipientBehaviourContext.js"));
-exports.RecipientBehaviourContext = _RecipientBehaviourContext;
-var _RecipientType = _interopRequireWildcard(require("./RecipientType.js"));
-exports.RecipientType = _RecipientType;
-var _Serialization = _interopRequireWildcard(require("./Serialization.js"));
-exports.Serialization = _Serialization;
-var _SerializedEnvelope = _interopRequireWildcard(require("./SerializedEnvelope.js"));
-exports.SerializedEnvelope = _SerializedEnvelope;
-var _SerializedMessage = _interopRequireWildcard(require("./SerializedMessage.js"));
-exports.SerializedMessage = _SerializedMessage;
+var _MessageStorage = _interopRequireWildcard(require("./MessageStorage.js"));
+exports.MessageStorage = _MessageStorage;
+var _Reply = _interopRequireWildcard(require("./Reply.js"));
+exports.Reply = _Reply;
+var _Runner = _interopRequireWildcard(require("./Runner.js"));
+exports.Runner = _Runner;
+var _RunnerAddress = _interopRequireWildcard(require("./RunnerAddress.js"));
+exports.RunnerAddress = _RunnerAddress;
+var _RunnerHealth = _interopRequireWildcard(require("./RunnerHealth.js"));
+exports.RunnerHealth = _RunnerHealth;
+var _RunnerServer = _interopRequireWildcard(require("./RunnerServer.js"));
+exports.RunnerServer = _RunnerServer;
+var _Runners = _interopRequireWildcard(require("./Runners.js"));
+exports.Runners = _Runners;
 var _ShardId = _interopRequireWildcard(require("./ShardId.js"));
 exports.ShardId = _ShardId;
 var _ShardManager = _interopRequireWildcard(require("./ShardManager.js"));
 exports.ShardManager = _ShardManager;
-var _ShardManagerClient = _interopRequireWildcard(require("./ShardManagerClient.js"));
-exports.ShardManagerClient = _ShardManagerClient;
+var _ShardStorage = _interopRequireWildcard(require("./ShardStorage.js"));
+exports.ShardStorage = _ShardStorage;
 var _Sharding = _interopRequireWildcard(require("./Sharding.js"));
 exports.Sharding = _Sharding;
 var _ShardingConfig = _interopRequireWildcard(require("./ShardingConfig.js"));
 exports.ShardingConfig = _ShardingConfig;
-var _ShardingEvent = _interopRequireWildcard(require("./ShardingEvent.js"));
-exports.ShardingEvent = _ShardingEvent;
-var _ShardingException = _interopRequireWildcard(require("./ShardingException.js"));
-exports.ShardingException = _ShardingException;
 var _ShardingRegistrationEvent = _interopRequireWildcard(require("./ShardingRegistrationEvent.js"));
 exports.ShardingRegistrationEvent = _ShardingRegistrationEvent;
-var _Storage = _interopRequireWildcard(require("./Storage.js"));
-exports.Storage = _Storage;
+var _Singleton = _interopRequireWildcard(require("./Singleton.js"));
+exports.Singleton = _Singleton;
+var _SingletonAddress = _interopRequireWildcard(require("./SingletonAddress.js"));
+exports.SingletonAddress = _SingletonAddress;
+var _Snowflake = _interopRequireWildcard(require("./Snowflake.js"));
+exports.Snowflake = _Snowflake;
+var _SocketRunner = _interopRequireWildcard(require("./SocketRunner.js"));
+exports.SocketRunner = _SocketRunner;
+var _SocketShardManager = _interopRequireWildcard(require("./SocketShardManager.js"));
+exports.SocketShardManager = _SocketShardManager;
+var _SqlMessageStorage = _interopRequireWildcard(require("./SqlMessageStorage.js"));
+exports.SqlMessageStorage = _SqlMessageStorage;
+var _SqlShardStorage = _interopRequireWildcard(require("./SqlShardStorage.js"));
+exports.SqlShardStorage = _SqlShardStorage;
+var _SynchronizedClock = _interopRequireWildcard(require("./SynchronizedClock.js"));
+exports.SynchronizedClock = _SynchronizedClock;
 function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
 function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
 //# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/dist/cjs/internal/entityManager.js b/dist/cjs/internal/entityManager.js
index fe51495789e4b8f930772c76dbac27be8bce0446..ebc548e59896d099735c0d0223fe43b3101267f8 100644
--- a/dist/cjs/internal/entityManager.js
+++ b/dist/cjs/internal/entityManager.js
@@ -3,166 +3,334 @@
 Object.defineProperty(exports, "__esModule", {
   value: true
 });
-exports.EntityManagerTypeId = void 0;
-exports.make = make;
-var Clock = _interopRequireWildcard(require("effect/Clock"));
+exports.make = void 0;
+var _RpcMessage = require("@effect/rpc/RpcMessage");
+var RpcServer = _interopRequireWildcard(require("@effect/rpc/RpcServer"));
+var Arr = _interopRequireWildcard(require("effect/Array"));
+var Cause = _interopRequireWildcard(require("effect/Cause"));
+var Context = _interopRequireWildcard(require("effect/Context"));
 var Duration = _interopRequireWildcard(require("effect/Duration"));
 var Effect = _interopRequireWildcard(require("effect/Effect"));
 var Exit = _interopRequireWildcard(require("effect/Exit"));
-var Fiber = _interopRequireWildcard(require("effect/Fiber"));
+var FiberRef = _interopRequireWildcard(require("effect/FiberRef"));
 var _Function = require("effect/Function");
 var HashMap = _interopRequireWildcard(require("effect/HashMap"));
-var HashSet = _interopRequireWildcard(require("effect/HashSet"));
+var Metric = _interopRequireWildcard(require("effect/Metric"));
 var Option = _interopRequireWildcard(require("effect/Option"));
+var Schedule = _interopRequireWildcard(require("effect/Schedule"));
+var Schema = _interopRequireWildcard(require("effect/Schema"));
 var Scope = _interopRequireWildcard(require("effect/Scope"));
-var RefSynchronized = _interopRequireWildcard(require("effect/SynchronizedRef"));
+var _ClusterError = require("../ClusterError.js");
+var ClusterMetrics = _interopRequireWildcard(require("../ClusterMetrics.js"));
+var _ClusterSchema = require("../ClusterSchema.js");
+var _Entity = require("../Entity.js");
+var Envelope = _interopRequireWildcard(require("../Envelope.js"));
 var Message = _interopRequireWildcard(require("../Message.js"));
-var MessageState = _interopRequireWildcard(require("../MessageState.js"));
-var RecipientBehaviourContext = _interopRequireWildcard(require("../RecipientBehaviourContext.js"));
-var ShardingException = _interopRequireWildcard(require("../ShardingException.js"));
-var EntityState = _interopRequireWildcard(require("./entityState.js"));
+var MessageStorage = _interopRequireWildcard(require("../MessageStorage.js"));
+var Reply = _interopRequireWildcard(require("../Reply.js"));
+var _ShardingConfig = require("../ShardingConfig.js");
+var Snowflake = _interopRequireWildcard(require("../Snowflake.js"));
+var _entityReaper = require("./entityReaper.js");
+var _interruptors = require("./interruptors.js");
+var _resourceMap = require("./resourceMap.js");
+var _resourceRef = require("./resourceRef.js");
 function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
 function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
 /** @internal */
-const EntityManagerSymbolKey = "@effect/cluster/EntityManager";
-/** @internal */
-const EntityManagerTypeId = exports.EntityManagerTypeId = /*#__PURE__*/Symbol.for(EntityManagerSymbolKey);
-/** @internal */
-function make(recipientType, recipientBehaviour, sharding, config, serialization, options = {}) {
-  return Effect.gen(function* () {
-    const entityMaxIdle = options.entityMaxIdleTime || Option.none();
-    const env = yield* Effect.context();
-    const entityStates = yield* RefSynchronized.make(HashMap.empty());
-    function startExpirationFiber(recipientAddress) {
-      const maxIdleMillis = (0, _Function.pipe)(entityMaxIdle, Option.getOrElse(() => config.entityMaxIdleTime), Duration.toMillis);
-      function sleep(duration) {
-        return (0, _Function.pipe)(Effect.Do, Effect.zipLeft(Clock.sleep(Duration.millis(duration))), Effect.bind("cdt", () => Clock.currentTimeMillis), Effect.bind("map", () => RefSynchronized.get(entityStates)), Effect.let("lastReceivedAt", ({
-          map
-        }) => (0, _Function.pipe)(HashMap.get(map, recipientAddress), Option.map(_ => _.lastReceivedAt), Option.getOrElse(() => 0))), Effect.let("remaining", ({
-          cdt,
-          lastReceivedAt
-        }) => maxIdleMillis - cdt + lastReceivedAt), Effect.tap(_ => _.remaining > 0 ? sleep(_.remaining) : Effect.void));
-      }
-      return (0, _Function.pipe)(sleep(maxIdleMillis), Effect.zipRight(forkEntityTermination(recipientAddress)), Effect.asVoid, Effect.interruptible, Effect.annotateLogs("entityId", recipientAddress), Effect.annotateLogs("recipientType", recipientType.name), Effect.forkDaemon);
+const make = exports.make = /*#__PURE__*/Effect.fnUntraced(function* (entity, buildHandlers, options) {
+  const config = yield* _ShardingConfig.ShardingConfig;
+  const snowflakeGen = yield* Snowflake.Generator;
+  const managerScope = yield* Effect.scope;
+  const storageEnabled = options.storage !== MessageStorage.noop;
+  const mailboxCapacity = options.mailboxCapacity ?? config.entityMailboxCapacity;
+  const clock = yield* Effect.clock;
+  const context = yield* Effect.context();
+  const activeServers = new Map();
+  const entities = yield* _resourceMap.ResourceMap.make(Effect.fnUntraced(function* (address) {
+    if (yield* options.sharding.isShutdown) {
+      return yield* new _ClusterError.EntityNotManagedByRunner({
+        address
+      });
     }
-    /**
-     * Performs proper termination of the entity, interrupting the expiration timer, closing the scope and failing pending replies
-     */
-    function terminateEntity(recipientAddress) {
-      return (0, _Function.pipe)(
-      // get the things to cleanup
-      RefSynchronized.get(entityStates), Effect.map(HashMap.get(recipientAddress)), Effect.flatMap(Option.match({
-        // there is no entity state to cleanup
-        onNone: () => Effect.void,
-        // found it!
-        onSome: entityState => (0, _Function.pipe)(
-        // interrupt the expiration timer
-        Fiber.interrupt(entityState.expirationFiber),
-        // close the scope of the entity,
-        Effect.ensuring(Scope.close(entityState.executionScope, Exit.void)),
-        // remove the entry from the map
-        Effect.ensuring(RefSynchronized.update(entityStates, HashMap.remove(recipientAddress))),
-        // log error if happens
-        Effect.catchAllCause(Effect.logError), Effect.asVoid, Effect.annotateLogs("entityId", recipientAddress.entityId), Effect.annotateLogs("recipientType", recipientAddress.recipientTypeName))
-      })));
-    }
-    /**
-     * Begins entity termination (if needed) and return the fiber to wait for completed termination (if any)
-     */
-    function forkEntityTermination(recipientAddress) {
-      return RefSynchronized.modifyEffect(entityStates, entityStatesMap => (0, _Function.pipe)(HashMap.get(entityStatesMap, recipientAddress), Option.match({
-        // if no entry is found, the entity has succefully shut down
-        onNone: () => Effect.succeed([Option.none(), entityStatesMap]),
-        // there is an entry, so we should begin termination
-        onSome: entityState => (0, _Function.pipe)(entityState.terminationFiber, Option.match({
-          // termination has already begun, keep everything as-is
-          onSome: () => Effect.succeed([entityState.terminationFiber, entityStatesMap]),
-          // begin to terminate the queue
-          onNone: () => (0, _Function.pipe)(terminateEntity(recipientAddress), Effect.forkDaemon, Effect.map(terminationFiber => [Option.some(terminationFiber), HashMap.modify(entityStatesMap, recipientAddress, EntityState.withTerminationFiber(terminationFiber))]))
-        }))
-      })));
-    }
-    function getOrCreateEntityState(recipientAddress) {
-      return RefSynchronized.modifyEffect(entityStates, map => (0, _Function.pipe)(HashMap.get(map, recipientAddress), Option.match({
-        onSome: entityState => (0, _Function.pipe)(entityState.terminationFiber, Option.match({
-          // offer exists, delay the interruption fiber and return the offer
-          onNone: () => (0, _Function.pipe)(Clock.currentTimeMillis, Effect.map(cdt => [Option.some(entityState), HashMap.modify(map, recipientAddress, EntityState.withLastReceivedAd(cdt))])),
-          // the queue is shutting down, stash and retry
-          onSome: () => Effect.succeed([Option.none(), map])
-        })),
-        onNone: () => Effect.flatMap(sharding.isShuttingDown, isGoingDown => {
-          if (isGoingDown) {
-            // don't start any fiber while sharding is shutting down
-            return Effect.fail(new ShardingException.EntityNotManagedByThisPodException({
-              recipientAddress
-            }));
-          } else {
-            // offer doesn't exist, create a new one
-            return Effect.gen(function* () {
-              const executionScope = yield* Scope.make();
-              const expirationFiber = yield* startExpirationFiber(recipientAddress);
-              const cdt = yield* Clock.currentTimeMillis;
-              const forkShutdown = (0, _Function.pipe)(forkEntityTermination(recipientAddress), Effect.asVoid);
-              const shardId = sharding.getShardId(recipientAddress);
-              const sendAndGetState = yield* (0, _Function.pipe)(recipientBehaviour, Effect.map(offer => envelope => (0, _Function.pipe)(serialization.decode(recipientType.schema, envelope.body), Effect.flatMap(message => (0, _Function.pipe)(offer(message), Effect.flatMap(_ => MessageState.mapEffect(_, value => serialization.encode(Message.exitSchema(message), value))))))), Scope.extend(executionScope), Effect.provideService(RecipientBehaviourContext.RecipientBehaviourContext, RecipientBehaviourContext.make({
-                recipientAddress,
-                shardId,
-                recipientType: recipientType,
-                forkShutdown
-              })), Effect.provide(env));
-              const entityState = EntityState.make({
-                sendAndGetState,
-                expirationFiber,
-                executionScope,
-                terminationFiber: Option.none(),
-                lastReceivedAt: cdt
-              });
-              return [Option.some(entityState), HashMap.set(map, recipientAddress, entityState)];
-            });
+    const scope = yield* Effect.scope;
+    const endLatch = yield* Effect.makeLatch();
+    // on shutdown, reset the storage for the entity
+    yield* Scope.addFinalizer(scope, Effect.ignore(options.storage.resetAddress(address)));
+    const activeRequests = new Map();
+    let defectRequestIds = [];
+    // the server is stored in a ref, so if there is a defect, we can
+    // swap the server without losing the active requests
+    const writeRef = yield* _resourceRef.ResourceRef.from(scope, Effect.fnUntraced(function* (scope) {
+      let isShuttingDown = false;
+      // Initiate the behavior for the entity
+      const handlers = yield* entity.protocol.toHandlersContext(buildHandlers).pipe(Effect.provide(context.pipe(Context.add(_Entity.CurrentAddress, address), Context.add(_Entity.CurrentRunnerAddress, options.runnerAddress), Context.add(Scope.Scope, scope))), Effect.locally(FiberRef.currentLogAnnotations, HashMap.empty()));
+      const server = yield* RpcServer.makeNoSerialization(entity.protocol, {
+        spanPrefix: `${entity.type}(${address.entityId})`,
+        concurrency: options.concurrency ?? 1,
+        onFromServer(response) {
+          switch (response._tag) {
+            case "Exit":
+              {
+                const request = activeRequests.get(response.requestId);
+                if (!request) return Effect.void;
+                // For durable messages, ignore interrupts during shutdown.
+                // They will be retried when the entity is restarted.
+                if (storageEnabled && isShuttingDown && Context.get(request.rpc.annotations, _ClusterSchema.Persisted) && Exit.isInterrupted(response.exit)) {
+                  return Effect.void;
+                }
+                return retryRespond(4, Effect.suspend(() => request.message.respond(new Reply.WithExit({
+                  requestId: Snowflake.Snowflake(response.requestId),
+                  id: snowflakeGen.unsafeNext(),
+                  exit: response.exit
+                })))).pipe(Effect.flatMap(() => {
+                  activeRequests.delete(response.requestId);
+                  // ensure that the reaper does not remove the entity as we haven't
+                  // been "idle" yet
+                  if (activeRequests.size === 0) {
+                    state.lastActiveCheck = clock.unsafeCurrentTimeMillis();
+                  }
+                  return Effect.void;
+                }), Effect.orDie);
+              }
+            case "Chunk":
+              {
+                const request = activeRequests.get(response.requestId);
+                if (!request) return Effect.void;
+                const sequence = request.sequence;
+                request.sequence++;
+                return Effect.orDie(retryRespond(4, Effect.suspend(() => {
+                  const reply = new Reply.Chunk({
+                    requestId: Snowflake.Snowflake(response.requestId),
+                    id: snowflakeGen.unsafeNext(),
+                    sequence,
+                    values: response.values
+                  });
+                  request.lastSentChunk = Option.some(reply);
+                  return request.message.respond(reply);
+                })));
+              }
+            case "Defect":
+              {
+                const effect = writeRef.unsafeRebuild();
+                defectRequestIds = Array.from(activeRequests.keys());
+                return Effect.logError("Defect in entity, restarting", Cause.die(response.defect)).pipe(Effect.andThen(effect.pipe(Effect.tapErrorCause(Effect.logError), Effect.retry(Schedule.spaced(500)))), Effect.annotateLogs({
+                  module: "EntityManager",
+                  address,
+                  runner: options.runnerAddress
+                }));
+              }
+            case "ClientEnd":
+              {
+                return endLatch.open;
+              }
           }
-        })
-      })));
-    }
-    function sendAndGetState(envelope) {
-      return (0, _Function.pipe)(Effect.Do, Effect.tap(() => {
-        // first, verify that this entity should be handled by this pod
-        if (recipientType._tag === "EntityType") {
-          return Effect.asVoid(Effect.unlessEffect(Effect.fail(new ShardingException.EntityNotManagedByThisPodException({
-            recipientAddress: envelope.recipientAddress
-          })), sharding.isEntityOnLocalShards(envelope.recipientAddress)));
-        } else if (recipientType._tag === "TopicType") {
-          return Effect.void;
         }
-        return Effect.die("Unhandled recipientType");
-      }), Effect.bind("maybeEntityState", () => getOrCreateEntityState(envelope.recipientAddress)), Effect.flatMap(_ => (0, _Function.pipe)(_.maybeEntityState, Option.match({
-        onNone: () => (0, _Function.pipe)(Effect.sleep(Duration.millis(100)), Effect.flatMap(() => sendAndGetState(envelope))),
-        onSome: entityState => {
-          return entityState.sendAndGetState(envelope);
+      }).pipe(Scope.extend(scope), Effect.provide(handlers));
+      yield* Scope.addFinalizer(scope, Effect.sync(() => {
+        isShuttingDown = true;
+      }));
+      for (const id of defectRequestIds) {
+        const {
+          lastSentChunk,
+          message
+        } = activeRequests.get(id);
+        yield* server.write(0, {
+          ...message.envelope,
+          id: (0, _RpcMessage.RequestId)(message.envelope.requestId),
+          tag: message.envelope.tag,
+          payload: new _Entity.Request({
+            ...message.envelope,
+            lastSentChunk
+          })
+        });
+      }
+      defectRequestIds = [];
+      return server.write;
+    }));
+    const state = {
+      address,
+      mailboxGauge: ClusterMetrics.mailboxSize.pipe(Metric.tagged("type", entity.type), Metric.tagged("entityId", address.entityId)),
+      write(clientId, message) {
+        if (writeRef.state.current._tag !== "Acquired") {
+          return Effect.flatMap(writeRef.await, write => write(clientId, message));
         }
-      }))));
+        return writeRef.state.current.value(clientId, message);
+      },
+      activeRequests,
+      lastActiveCheck: clock.unsafeCurrentTimeMillis()
+    };
+    // During shutdown, signal that no more messages will be processed
+    // and wait for the fiber to complete.
+    //
+    // If the termination timeout is reached, let the server clean itself up
+    yield* Scope.addFinalizer(scope, Effect.withFiberRuntime(fiber => {
+      activeServers.delete(address.entityId);
+      _interruptors.internalInterruptors.add(fiber.id());
+      return state.write(0, {
+        _tag: "Eof"
+      }).pipe(Effect.andThen(Effect.interruptible(endLatch.await)), Effect.timeoutOption(config.entityTerminationTimeout));
+    }));
+    activeServers.set(address.entityId, state);
+    return state;
+  }, Effect.locally(FiberRef.currentLogAnnotations, HashMap.empty())));
+  const reaper = yield* _entityReaper.EntityReaper;
+  const maxIdleTime = Duration.toMillis(options.maxIdleTime ?? config.entityMaxIdleTime);
+  if (Number.isFinite(maxIdleTime)) {
+    yield* reaper.register({
+      maxIdleTime,
+      servers: activeServers,
+      entities
+    });
+  }
+  // update metrics for active servers
+  const gauge = ClusterMetrics.entities.pipe(Metric.tagged("type", entity.type));
+  yield* Effect.sync(() => {
+    gauge.unsafeUpdate(BigInt(activeServers.size), []);
+    for (const state of activeServers.values()) {
+      state.mailboxGauge.unsafeUpdate(BigInt(state.activeRequests.size), []);
     }
-    const terminateAllEntities = (0, _Function.pipe)(RefSynchronized.get(entityStates), Effect.map(HashMap.keySet), Effect.flatMap(terminateEntities));
-    function terminateEntities(entitiesToTerminate) {
-      return (0, _Function.pipe)(entitiesToTerminate, Effect.forEach(recipientAddress => (0, _Function.pipe)(forkEntityTermination(recipientAddress), Effect.flatMap(_ => Option.match(_, {
-        onNone: () => Effect.void,
-        onSome: terminationFiber => (0, _Function.pipe)(Fiber.await(terminationFiber), Effect.timeout(config.entityTerminationTimeout), Effect.match({
-          onFailure: () => Effect.logError(`Entity ${recipientAddress} termination is taking more than expected entityTerminationTimeout (${Duration.toMillis(config.entityTerminationTimeout)}ms).`),
-          onSuccess: () => Effect.logDebug(`Entity ${recipientAddress} cleaned up.`)
-        }), Effect.asVoid)
-      }))), {
-        concurrency: "inherit"
-      }), Effect.asVoid);
+  }).pipe(Effect.andThen(Effect.sleep(1000)), Effect.forever, Effect.forkIn(managerScope));
+  function sendLocal(message) {
+    return Effect.locally(Effect.flatMap(entities.get(message.envelope.address), server => {
+      switch (message._tag) {
+        case "IncomingRequestLocal":
+          {
+            // If the request is already running, then we might have more than
+            // one sender for the same request. In this case, the other senders
+            // should resume from storage only.
+            let entry = server.activeRequests.get(message.envelope.requestId);
+            if (entry) {
+              return Effect.fail(new _ClusterError.AlreadyProcessingMessage({
+                envelopeId: message.envelope.requestId,
+                address: message.envelope.address
+              }));
+            }
+            if (mailboxCapacity !== "unbounded" && server.activeRequests.size >= mailboxCapacity) {
+              return Effect.fail(new _ClusterError.MailboxFull({
+                address: message.envelope.address
+              }));
+            }
+            entry = {
+              rpc: entity.protocol.requests.get(message.envelope.tag),
+              message,
+              lastSentChunk: message.lastSentReply,
+              sequence: Option.match(message.lastSentReply, {
+                onNone: () => 0,
+                onSome: reply => reply._tag === "Chunk" ? reply.sequence + 1 : 0
+              })
+            };
+            server.activeRequests.set(message.envelope.requestId, entry);
+            return server.write(0, {
+              ...message.envelope,
+              id: (0, _RpcMessage.RequestId)(message.envelope.requestId),
+              payload: new _Entity.Request({
+                ...message.envelope,
+                lastSentChunk: message.lastSentReply
+              })
+            });
+          }
+        case "IncomingEnvelope":
+          {
+            const entry = server.activeRequests.get(message.envelope.requestId);
+            if (!entry) {
+              return Effect.fail(new _ClusterError.EntityNotManagedByRunner({
+                address: message.envelope.address
+              }));
+            } else if (message.envelope._tag === "AckChunk" && Option.isSome(entry.lastSentChunk) && message.envelope.replyId !== entry.lastSentChunk.value.id) {
+              return Effect.void;
+            }
+            return server.write(0, message.envelope._tag === "AckChunk" ? {
+              _tag: "Ack",
+              requestId: (0, _RpcMessage.RequestId)(message.envelope.requestId)
+            } : {
+              _tag: "Interrupt",
+              requestId: (0, _RpcMessage.RequestId)(message.envelope.requestId),
+              interruptors: []
+            });
+          }
+      }
+    }), FiberRef.currentLogAnnotations, HashMap.empty());
+  }
+  const interruptShard = shardId => Effect.suspend(function loop() {
+    const toInterrupt = new Set();
+    for (const state of activeServers.values()) {
+      if (shardId === state.address.shardId) {
+        toInterrupt.add(state);
+      }
     }
-    function terminateEntitiesOnShards(shards) {
-      return (0, _Function.pipe)(RefSynchronized.modify(entityStates, entities => [HashMap.filter(entities, (_, recipientAddress) => HashSet.has(shards, sharding.getShardId(recipientAddress))), entities]), Effect.map(HashMap.keySet), Effect.flatMap(terminateEntities));
+    if (toInterrupt.size === 0) {
+      return Effect.void;
     }
-    const self = {
-      [EntityManagerTypeId]: EntityManagerTypeId,
-      sendAndGetState,
-      terminateAllEntities,
-      terminateEntitiesOnShards
-    };
-    return self;
+    return Effect.flatMap(Effect.forEach(toInterrupt, state => entities.removeIgnore(state.address), {
+      concurrency: "unbounded",
+      discard: true
+    }), loop);
   });
-}
+  const decodeMessage = Schema.decode(makeMessageSchema(entity));
+  return (0, _Function.identity)({
+    interruptShard,
+    isProcessingFor(message) {
+      const state = activeServers.get(message.envelope.address.entityId);
+      if (!state) return false;
+      return state.activeRequests.has(message.envelope.requestId);
+    },
+    sendLocal,
+    send: message => decodeMessage(message).pipe(Effect.matchEffect({
+      onFailure: cause => {
+        if (message._tag === "IncomingEnvelope") {
+          return Effect.die(new _ClusterError.MalformedMessage({
+            cause
+          }));
+        }
+        return Effect.orDie(message.respond(new Reply.ReplyWithContext({
+          reply: new Reply.WithExit({
+            id: snowflakeGen.unsafeNext(),
+            requestId: message.envelope.requestId,
+            exit: Exit.die(new _ClusterError.MalformedMessage({
+              cause
+            }))
+          }),
+          rpc: entity.protocol.requests.get(message.envelope.tag),
+          context
+        })));
+      },
+      onSuccess: decoded => {
+        if (decoded._tag === "IncomingEnvelope") {
+          return sendLocal(new Message.IncomingEnvelope(decoded));
+        }
+        const request = message;
+        const rpc = entity.protocol.requests.get(decoded.envelope.tag);
+        return sendLocal(new Message.IncomingRequestLocal({
+          envelope: decoded.envelope,
+          lastSentReply: decoded.lastSentReply,
+          respond: reply => request.respond(new Reply.ReplyWithContext({
+            reply,
+            rpc,
+            context
+          }))
+        }));
+      }
+    }), Effect.provide(context))
+  });
+});
+const makeMessageSchema = entity => {
+  const requests = Arr.empty();
+  for (const rpc of entity.protocol.requests.values()) {
+    requests.push(Schema.TaggedStruct("IncomingRequest", {
+      envelope: Schema.transform(Schema.Struct({
+        ...Envelope.PartialEncodedRequestFromSelf.fields,
+        tag: Schema.Literal(rpc._tag),
+        payload: rpc.payloadSchema
+      }), Envelope.RequestFromSelf, {
+        decode: encoded => Envelope.makeRequest(encoded),
+        encode: _Function.identity
+      }),
+      lastSentReply: Schema.OptionFromSelf(Reply.Reply(rpc))
+    }));
+  }
+  return Schema.Union(...requests, Schema.TaggedStruct("IncomingEnvelope", {
+    envelope: Schema.Union(Schema.typeSchema(Envelope.AckChunk), Schema.typeSchema(Envelope.Interrupt))
+  }));
+};
+const retryRespond = (times, effect) => times === 0 ? effect : Effect.catchAll(effect, () => Effect.delay(retryRespond(times - 1, effect), 200));
 //# sourceMappingURL=entityManager.js.map
\ No newline at end of file
diff --git a/dist/cjs/internal/entityManager.js.map b/dist/cjs/internal/entityManager.js.map
index c5250f5fa7f3fde031b2f80ee6c6fa257ad6f44b..ace539db97030e6f9065a56f2974d2cd86f8351f 100644
--- a/dist/cjs/internal/entityManager.js.map
+++ b/dist/cjs/internal/entityManager.js.map
@@ -1 +1 @@
-{"version":3,"file":"entityManager.js","names":["Clock","_interopRequireWildcard","require","Duration","Effect","Exit","Fiber","_Function","HashMap","HashSet","Option","Scope","RefSynchronized","Message","MessageState","RecipientBehaviourContext","ShardingException","EntityState","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","EntityManagerSymbolKey","EntityManagerTypeId","exports","Symbol","for","make","recipientType","recipientBehaviour","sharding","config","serialization","options","gen","entityMaxIdle","entityMaxIdleTime","none","env","context","entityStates","empty","startExpirationFiber","recipientAddress","maxIdleMillis","pipe","getOrElse","toMillis","sleep","duration","Do","zipLeft","millis","bind","currentTimeMillis","let","map","_","lastReceivedAt","cdt","tap","remaining","void","zipRight","forkEntityTermination","asVoid","interruptible","annotateLogs","name","forkDaemon","terminateEntity","flatMap","match","onNone","onSome","entityState","interrupt","expirationFiber","ensuring","close","executionScope","update","remove","catchAllCause","logError","entityId","recipientTypeName","modifyEffect","entityStatesMap","succeed","terminationFiber","some","modify","withTerminationFiber","getOrCreateEntityState","withLastReceivedAd","isShuttingDown","isGoingDown","fail","EntityNotManagedByThisPodException","forkShutdown","shardId","getShardId","sendAndGetState","offer","envelope","decode","schema","body","message","mapEffect","value","encode","exitSchema","extend","provideService","provide","_tag","unlessEffect","isEntityOnLocalShards","die","maybeEntityState","terminateAllEntities","keySet","terminateEntities","entitiesToTerminate","forEach","await","timeout","entityTerminationTimeout","onFailure","onSuccess","logDebug","concurrency","terminateEntitiesOnShards","shards","entities","filter","self"],"sources":["../../../src/internal/entityManager.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
+{"version":3,"file":"entityManager.js","names":["_RpcMessage","require","RpcServer","_interopRequireWildcard","Arr","Cause","Context","Duration","Effect","Exit","FiberRef","_Function","HashMap","Metric","Option","Schedule","Schema","Scope","_ClusterError","ClusterMetrics","_ClusterSchema","_Entity","Envelope","Message","MessageStorage","Reply","_ShardingConfig","Snowflake","_entityReaper","_interruptors","_resourceMap","_resourceRef","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","make","exports","fnUntraced","entity","buildHandlers","options","config","ShardingConfig","snowflakeGen","Generator","managerScope","scope","storageEnabled","storage","noop","mailboxCapacity","entityMailboxCapacity","clock","context","activeServers","Map","entities","ResourceMap","address","sharding","isShutdown","EntityNotManagedByRunner","endLatch","makeLatch","addFinalizer","ignore","resetAddress","activeRequests","defectRequestIds","writeRef","ResourceRef","from","isShuttingDown","handlers","protocol","toHandlersContext","pipe","provide","add","CurrentAddress","CurrentRunnerAddress","runnerAddress","locally","currentLogAnnotations","empty","server","makeNoSerialization","spanPrefix","type","entityId","concurrency","onFromServer","response","_tag","request","requestId","void","rpc","annotations","Persisted","isInterrupted","exit","retryRespond","suspend","message","respond","WithExit","id","unsafeNext","flatMap","delete","size","state","lastActiveCheck","unsafeCurrentTimeMillis","orDie","sequence","reply","Chunk","values","lastSentChunk","some","effect","unsafeRebuild","Array","keys","logError","die","defect","andThen","tapErrorCause","retry","spaced","annotateLogs","module","runner","open","extend","sync","write","envelope","RequestId","tag","payload","Request","mailboxGauge","mailboxSize","tagged","clientId","current","await","value","withFiberRuntime","fiber","internalInterruptors","interruptible","timeoutOption","entityTerminationTimeout","reaper","EntityReaper","maxIdleTime","toMillis","entityMaxIdleTime","Number","isFinite","register","servers","gauge","unsafeUpdate","BigInt","sleep","forever","forkIn","sendLocal","entry","fail","AlreadyProcessingMessage","envelopeId","MailboxFull","requests","lastSentReply","match","onNone","onSome","isSome","replyId","interruptors","interruptShard","shardId","loop","toInterrupt","Set","forEach","removeIgnore","discard","decodeMessage","decode","makeMessageSchema","identity","isProcessingFor","send","matchEffect","onFailure","cause","MalformedMessage","ReplyWithContext","onSuccess","decoded","IncomingEnvelope","IncomingRequestLocal","push","TaggedStruct","transform","Struct","PartialEncodedRequestFromSelf","fields","Literal","payloadSchema","RequestFromSelf","encoded","makeRequest","encode","OptionFromSelf","Union","typeSchema","AckChunk","Interrupt","times","catchAll","delay"],"sources":["../../../src/internal/entityManager.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/cjs/internal/entityReaper.js b/dist/cjs/internal/entityReaper.js
new file mode 100644
index 0000000000000000000000000000000000000000..7749af0992faf869f2a04a21b3b48e59f18f048e
--- /dev/null
+++ b/dist/cjs/internal/entityReaper.js
@@ -0,0 +1,47 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.EntityReaper = void 0;
+var Effect = _interopRequireWildcard(require("effect/Effect"));
+function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
+function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
+/** @internal */
+class EntityReaper extends /*#__PURE__*/Effect.Service()("@effect/cluster/EntityReaper", {
+  scoped: /*#__PURE__*/Effect.gen(function* () {
+    let currentResolution = 30_000;
+    const registered = [];
+    const latch = yield* Effect.makeLatch();
+    const register = options => Effect.suspend(() => {
+      currentResolution = Math.max(Math.min(currentResolution, options.maxIdleTime), 5000);
+      registered.push(options);
+      return latch.open;
+    });
+    const clock = yield* Effect.clock;
+    yield* Effect.gen(function* () {
+      while (true) {
+        yield* Effect.sleep(currentResolution);
+        const now = clock.unsafeCurrentTimeMillis();
+        for (const {
+          entities,
+          maxIdleTime,
+          servers
+        } of registered) {
+          for (const state of servers.values()) {
+            const duration = now - state.lastActiveCheck;
+            if (state.activeRequests.size > 0 || duration < maxIdleTime) {
+              continue;
+            }
+            yield* Effect.fork(entities.removeIgnore(state.address));
+          }
+        }
+      }
+    }).pipe(latch.whenOpen, Effect.interruptible, Effect.forkScoped);
+    return {
+      register
+    };
+  })
+}) {}
+exports.EntityReaper = EntityReaper;
+//# sourceMappingURL=entityReaper.js.map
\ No newline at end of file
diff --git a/dist/cjs/internal/entityReaper.js.map b/dist/cjs/internal/entityReaper.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..6c545300ad3803e76d22c918ad4ee3706eb548bf
--- /dev/null
+++ b/dist/cjs/internal/entityReaper.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"entityReaper.js","names":["Effect","_interopRequireWildcard","require","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","EntityReaper","Service","scoped","gen","currentResolution","registered","latch","makeLatch","register","options","suspend","Math","max","min","maxIdleTime","push","open","clock","sleep","now","unsafeCurrentTimeMillis","entities","servers","state","values","duration","lastActiveCheck","activeRequests","size","fork","removeIgnore","address","pipe","whenOpen","interruptible","forkScoped","exports"],"sources":["../../../src/internal/entityReaper.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/cjs/internal/hash.js b/dist/cjs/internal/hash.js
new file mode 100644
index 0000000000000000000000000000000000000000..9666157e93ed864853fc465ed84125e9c22d1f6f
--- /dev/null
+++ b/dist/cjs/internal/hash.js
@@ -0,0 +1,20 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.hashString = exports.hashOptimize = void 0;
+/** @internal */
+const hashOptimize = n => n & 0xbfffffff | n >>> 1 & 0x40000000;
+/** @internal */
+exports.hashOptimize = hashOptimize;
+const hashString = str => {
+  let h = 5381,
+    i = str.length;
+  while (i) {
+    h = h * 33 ^ str.charCodeAt(--i);
+  }
+  return hashOptimize(h);
+};
+exports.hashString = hashString;
+//# sourceMappingURL=hash.js.map
\ No newline at end of file
diff --git a/dist/cjs/internal/hash.js.map b/dist/cjs/internal/hash.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..5433b310e5ab54c646ca9ef4f50994579dc1b00e
--- /dev/null
+++ b/dist/cjs/internal/hash.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"hash.js","names":["hashOptimize","n","exports","hashString","str","h","i","length","charCodeAt"],"sources":["../../../src/internal/hash.ts"],"sourcesContent":[null],"mappings":";;;;;;AAAA;AACO,MAAMA,YAAY,GAAIC,CAAS,IAAcA,CAAC,GAAG,UAAU,GAAMA,CAAC,KAAK,CAAC,GAAI,UAAW;AAE9F;AAAAC,OAAA,CAAAF,YAAA,GAAAA,YAAA;AACO,MAAMG,UAAU,GAAIC,GAAW,IAAI;EACxC,IAAIC,CAAC,GAAG,IAAI;IAAEC,CAAC,GAAGF,GAAG,CAACG,MAAM;EAC5B,OAAOD,CAAC,EAAE;IACRD,CAAC,GAAIA,CAAC,GAAG,EAAE,GAAID,GAAG,CAACI,UAAU,CAAC,EAAEF,CAAC,CAAC;EACpC;EACA,OAAON,YAAY,CAACK,CAAC,CAAC;AACxB,CAAC;AAAAH,OAAA,CAAAC,UAAA,GAAAA,UAAA","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/cjs/internal/interruptors.js b/dist/cjs/internal/interruptors.js
new file mode 100644
index 0000000000000000000000000000000000000000..a58a51cc69de630ef0754801b9e692764849d0b2
--- /dev/null
+++ b/dist/cjs/internal/interruptors.js
@@ -0,0 +1,9 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.internalInterruptors = void 0;
+/** @internal */
+const internalInterruptors = exports.internalInterruptors = /*#__PURE__*/new WeakSet();
+//# sourceMappingURL=interruptors.js.map
\ No newline at end of file
diff --git a/dist/cjs/internal/interruptors.js.map b/dist/cjs/internal/interruptors.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..d8d35187d84695c1580d0e7de37f88af7bfac429
--- /dev/null
+++ b/dist/cjs/internal/interruptors.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"interruptors.js","names":["internalInterruptors","exports","WeakSet"],"sources":["../../../src/internal/interruptors.ts"],"sourcesContent":[null],"mappings":";;;;;;AAEA;AACO,MAAMA,oBAAoB,GAAAC,OAAA,CAAAD,oBAAA,gBAAG,IAAIE,OAAO,EAAW","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/cjs/internal/resourceMap.js b/dist/cjs/internal/resourceMap.js
new file mode 100644
index 0000000000000000000000000000000000000000..6f2a4c4c282eea46b7816bdacbe144c6bbb37038
--- /dev/null
+++ b/dist/cjs/internal/resourceMap.js
@@ -0,0 +1,88 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.ResourceMap = void 0;
+var Context = _interopRequireWildcard(require("effect/Context"));
+var Deferred = _interopRequireWildcard(require("effect/Deferred"));
+var Effect = _interopRequireWildcard(require("effect/Effect"));
+var Exit = _interopRequireWildcard(require("effect/Exit"));
+var MutableHashMap = _interopRequireWildcard(require("effect/MutableHashMap"));
+var MutableRef = _interopRequireWildcard(require("effect/MutableRef"));
+var Option = _interopRequireWildcard(require("effect/Option"));
+var Scope = _interopRequireWildcard(require("effect/Scope"));
+function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
+function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
+class ResourceMap {
+  lookup;
+  entries;
+  isClosed;
+  constructor(lookup, entries, isClosed) {
+    this.lookup = lookup;
+    this.entries = entries;
+    this.isClosed = isClosed;
+  }
+  static make = /*#__PURE__*/Effect.fnUntraced(function* (lookup) {
+    const scope = yield* Effect.scope;
+    const context = yield* Effect.context();
+    const isClosed = MutableRef.make(false);
+    const entries = MutableHashMap.empty();
+    yield* Scope.addFinalizerExit(scope, exit => {
+      MutableRef.set(isClosed, true);
+      return Effect.forEach(entries, ([key, {
+        scope
+      }]) => {
+        MutableHashMap.remove(entries, key);
+        return Effect.exit(Scope.close(scope, exit));
+      }, {
+        concurrency: "unbounded",
+        discard: true
+      });
+    });
+    return new ResourceMap((key, scope) => Effect.provide(lookup(key), Context.add(context, Scope.Scope, scope)), entries, isClosed);
+  });
+  get(key) {
+    return Effect.withFiberRuntime(fiber => {
+      if (MutableRef.get(this.isClosed)) {
+        return Effect.interrupt;
+      }
+      const existing = MutableHashMap.get(this.entries, key);
+      if (Option.isSome(existing)) {
+        return Deferred.await(existing.value.deferred);
+      }
+      const scope = Effect.runSync(Scope.make());
+      const deferred = Deferred.unsafeMake(fiber.id());
+      MutableHashMap.set(this.entries, key, {
+        scope,
+        deferred
+      });
+      return Effect.onExit(this.lookup(key, scope), exit => {
+        if (exit._tag === "Success") {
+          return Deferred.done(deferred, exit);
+        }
+        MutableHashMap.remove(this.entries, key);
+        return Deferred.done(deferred, exit);
+      });
+    });
+  }
+  remove(key) {
+    return Effect.suspend(() => {
+      const entry = MutableHashMap.get(this.entries, key);
+      if (Option.isNone(entry)) {
+        return Effect.void;
+      }
+      MutableHashMap.remove(this.entries, key);
+      return Scope.close(entry.value.scope, Exit.void);
+    });
+  }
+  removeIgnore(key) {
+    return Effect.catchAllCause(this.remove(key), cause => Effect.annotateLogs(Effect.logDebug(cause), {
+      module: "ResourceMap",
+      method: "removeIgnore",
+      key
+    }));
+  }
+}
+exports.ResourceMap = ResourceMap;
+//# sourceMappingURL=resourceMap.js.map
\ No newline at end of file
diff --git a/dist/cjs/internal/resourceMap.js.map b/dist/cjs/internal/resourceMap.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..ac473312feaa7d9233dd7bf519c7ce8881fe98f2
--- /dev/null
+++ b/dist/cjs/internal/resourceMap.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"resourceMap.js","names":["Context","_interopRequireWildcard","require","Deferred","Effect","Exit","MutableHashMap","MutableRef","Option","Scope","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","ResourceMap","lookup","entries","isClosed","constructor","make","fnUntraced","scope","context","empty","addFinalizerExit","exit","forEach","key","remove","close","concurrency","discard","provide","add","withFiberRuntime","fiber","interrupt","existing","isSome","await","value","deferred","runSync","unsafeMake","id","onExit","_tag","done","suspend","entry","isNone","void","removeIgnore","catchAllCause","cause","annotateLogs","logDebug","module","method"],"sources":["../../../src/internal/resourceMap.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/cjs/internal/resourceRef.js b/dist/cjs/internal/resourceRef.js
new file mode 100644
index 0000000000000000000000000000000000000000..52dada2ff7d0227cf54bbd22c9ef18bbd667f417
--- /dev/null
+++ b/dist/cjs/internal/resourceRef.js
@@ -0,0 +1,92 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.ResourceRef = void 0;
+var Effect = _interopRequireWildcard(require("effect/Effect"));
+var Exit = _interopRequireWildcard(require("effect/Exit"));
+var MutableRef = _interopRequireWildcard(require("effect/MutableRef"));
+var Option = _interopRequireWildcard(require("effect/Option"));
+var Scope = _interopRequireWildcard(require("effect/Scope"));
+var _interruptors = require("./interruptors.js");
+function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
+function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
+class ResourceRef {
+  state;
+  acquire;
+  static from = /*#__PURE__*/Effect.fnUntraced(function* (parentScope, acquire) {
+    const state = MutableRef.make({
+      _tag: "Closed"
+    });
+    yield* Scope.addFinalizerExit(parentScope, exit => {
+      const s = MutableRef.get(state);
+      if (s._tag === "Closed") {
+        return Effect.void;
+      }
+      const scope = s.scope;
+      MutableRef.set(state, {
+        _tag: "Closed"
+      });
+      return Scope.close(scope, exit);
+    });
+    const scope = yield* Scope.make();
+    MutableRef.set(state, {
+      _tag: "Acquiring",
+      scope
+    });
+    const value = yield* acquire(scope);
+    MutableRef.set(state, {
+      _tag: "Acquired",
+      scope,
+      value
+    });
+    return new ResourceRef(state, acquire);
+  });
+  constructor(state, acquire) {
+    this.state = state;
+    this.acquire = acquire;
+  }
+  latch = /*#__PURE__*/Effect.unsafeMakeLatch(true);
+  unsafeGet() {
+    if (this.state.current._tag === "Acquired") {
+      return Option.some(this.state.current.value);
+    }
+    return Option.none();
+  }
+  unsafeRebuild() {
+    const s = this.state.current;
+    if (s._tag === "Closed") {
+      return Effect.interrupt;
+    }
+    const prevScope = s.scope;
+    const scope = Effect.runSync(Scope.make());
+    this.latch.unsafeClose();
+    MutableRef.set(this.state, {
+      _tag: "Acquiring",
+      scope
+    });
+    return Effect.fiberIdWith(fiberId => {
+      _interruptors.internalInterruptors.add(fiberId);
+      return Scope.close(prevScope, Exit.void);
+    }).pipe(Effect.andThen(this.acquire(scope)), Effect.flatMap(value => {
+      MutableRef.set(this.state, {
+        _tag: "Acquired",
+        scope,
+        value
+      });
+      return this.latch.open;
+    }));
+  }
+  await = /*#__PURE__*/Effect.suspend(() => {
+    const s = this.state.current;
+    if (s._tag === "Closed") {
+      return Effect.interrupt;
+    } else if (s._tag === "Acquired") {
+      return Effect.succeed(s.value);
+    }
+    return Effect.zipRight(this.latch.await, this.await);
+  });
+}
+exports.ResourceRef = ResourceRef;
+//# sourceMappingURL=resourceRef.js.map
\ No newline at end of file
diff --git a/dist/cjs/internal/resourceRef.js.map b/dist/cjs/internal/resourceRef.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..4a6040f7d94403f0b90d740842faefa2126cac2a
--- /dev/null
+++ b/dist/cjs/internal/resourceRef.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"resourceRef.js","names":["Effect","_interopRequireWildcard","require","Exit","MutableRef","Option","Scope","_interruptors","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","ResourceRef","state","acquire","from","fnUntraced","parentScope","make","_tag","addFinalizerExit","exit","s","void","scope","close","value","constructor","latch","unsafeMakeLatch","unsafeGet","current","some","none","unsafeRebuild","interrupt","prevScope","runSync","unsafeClose","fiberIdWith","fiberId","internalInterruptors","add","pipe","andThen","flatMap","open","await","suspend","succeed","zipRight"],"sources":["../../../src/internal/resourceRef.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/cjs/internal/shardManager.js b/dist/cjs/internal/shardManager.js
index 1e414ea98090b259001f375987150579a9a4afc8..edb4caa5446420dffbed2db6d8e265837a311d5e 100644
--- a/dist/cjs/internal/shardManager.js
+++ b/dist/cjs/internal/shardManager.js
@@ -3,266 +3,250 @@
 Object.defineProperty(exports, "__esModule", {
   value: true
 });
-exports.ShardManagerTypeId = void 0;
+exports.State = exports.RunnerWithMetadata = void 0;
 exports.decideAssignmentsForUnassignedShards = decideAssignmentsForUnassignedShards;
 exports.decideAssignmentsForUnbalancedShards = decideAssignmentsForUnbalancedShards;
-exports.shardManagerTag = exports.live = void 0;
-var Chunk = _interopRequireWildcard(require("effect/Chunk"));
+var Arr = _interopRequireWildcard(require("effect/Array"));
 var Clock = _interopRequireWildcard(require("effect/Clock"));
-var _Context = require("effect/Context");
 var Effect = _interopRequireWildcard(require("effect/Effect"));
-var _Equal = require("effect/Equal");
 var _Function = require("effect/Function");
-var HashMap = _interopRequireWildcard(require("effect/HashMap"));
-var HashSet = _interopRequireWildcard(require("effect/HashSet"));
-var Layer = _interopRequireWildcard(require("effect/Layer"));
-var List = _interopRequireWildcard(require("effect/List"));
+var MutableHashMap = _interopRequireWildcard(require("effect/MutableHashMap"));
+var MutableHashSet = _interopRequireWildcard(require("effect/MutableHashSet"));
 var Option = _interopRequireWildcard(require("effect/Option"));
-var PubSub = _interopRequireWildcard(require("effect/PubSub"));
-var Schedule = _interopRequireWildcard(require("effect/Schedule"));
-var Stream = _interopRequireWildcard(require("effect/Stream"));
-var RefSynchronized = _interopRequireWildcard(require("effect/SynchronizedRef"));
-var ManagerConfig = _interopRequireWildcard(require("../ManagerConfig.js"));
-var Pods = _interopRequireWildcard(require("../Pods.js"));
-var PodsHealth = _interopRequireWildcard(require("../PodsHealth.js"));
-var ShardId = _interopRequireWildcard(require("../ShardId.js"));
-var ShardingEvent = _interopRequireWildcard(require("../ShardingEvent.js"));
-var ShardingException = _interopRequireWildcard(require("../ShardingException.js"));
-var Storage = _interopRequireWildcard(require("../Storage.js"));
-var PodWithMetadata = _interopRequireWildcard(require("./podWithMetadata.js"));
-var ShardManagerState = _interopRequireWildcard(require("./shardManagerState.js"));
-var _utils = require("./utils.js");
+var Order = _interopRequireWildcard(require("effect/Order"));
+var _RunnerHealth = require("../RunnerHealth.js");
+var _ShardId = require("../ShardId.js");
+var _ShardStorage = require("../ShardStorage.js");
 function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
 function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
-/**
- * @since 1.0.0
- */
-
-/** @internal */
-const ShardManagerSymbolKey = "@effect/cluster/ShardManager";
-/** @internal */
-const ShardManagerTypeId = exports.ShardManagerTypeId = /*#__PURE__*/Symbol.for(ShardManagerSymbolKey);
 /** @internal */
-const shardManagerTag = exports.shardManagerTag = /*#__PURE__*/(0, _Context.GenericTag)(ShardManagerSymbolKey);
-/** @internal */
-function make(layerScope, stateRef, rebalanceSemaphore, eventsHub, healthApi, podApi, stateRepository, config) {
-  const getAssignments = (0, _Function.pipe)(RefSynchronized.get(stateRef), Effect.map(_ => _.shards));
-  const getShardingEvents = Stream.fromPubSub(eventsHub);
-  function register(pod) {
-    return (0, _Function.pipe)(Effect.logDebug("Registering " + pod.address + "@" + pod.version), Effect.zipRight(RefSynchronized.updateAndGetEffect(stateRef, state => (0, _Function.pipe)(Effect.flatMap(Effect.clock, _ => _.currentTimeMillis), Effect.map(cdt => ShardManagerState.make(HashMap.set(state.pods, pod.address, PodWithMetadata.make(pod, cdt)), state.shards))))), Effect.zipLeft(PubSub.publish(eventsHub, ShardingEvent.PodRegistered(pod.address))), Effect.flatMap(state => Effect.when(rebalance(false), () => HashSet.size(state.unassignedShards) > 0)), Effect.zipRight(Effect.forkIn(layerScope)(persistPods)), Effect.asVoid);
+class State {
+  runners;
+  shards;
+  static fromStorage = /*#__PURE__*/Effect.fnUntraced(function* (numberOfShards) {
+    const storage = yield* _ShardStorage.ShardStorage;
+    const runnerHealth = yield* _RunnerHealth.RunnerHealth;
+    // Fetch registered runners and shard assignments from cluster storage
+    const storedRunners = yield* storage.getRunners;
+    const storedAssignments = yield* storage.getAssignments;
+    // Determine which runners are still alive
+    const deadRunners = Arr.empty();
+    const aliveRunners = MutableHashMap.empty();
+    yield* Effect.forEach(storedRunners, ([address, runner]) => Effect.map(runnerHealth.isAlive(address), isAlive => {
+      if (isAlive) {
+        MutableHashMap.set(aliveRunners, address, runner);
+      } else {
+        deadRunners.push(runner);
+      }
+    }), {
+      concurrency: "unbounded",
+      discard: true
+    });
+    if (deadRunners.length > 0) {
+      yield* Effect.logWarning("Ignoring runners that are no longer considered alive:", deadRunners);
+    }
+    // Determine which shards remain unassigned to a runner
+    const assignedShards = new Map();
+    const invalidAssignments = Arr.empty();
+    for (const [shard, address] of storedAssignments) {
+      if (Option.isSome(address) && MutableHashMap.has(aliveRunners, address.value)) {
+        assignedShards.set(shard, address.value);
+      } else if (Option.isSome(address)) {
+        invalidAssignments.push([shard, address.value]);
+      }
+    }
+    if (invalidAssignments.length > 0) {
+      yield* Effect.logWarning("Ignoring shard assignments for runners that are no longer considered alive: ", invalidAssignments);
+    }
+    // Construct the initial state
+    const now = yield* Clock.currentTimeMillis;
+    const runnerState = MutableHashMap.empty();
+    for (const [address, runner] of aliveRunners) {
+      MutableHashMap.set(runnerState, address, RunnerWithMetadata({
+        runner,
+        registeredAt: now
+      }));
+    }
+    const shardState = new Map();
+    for (let n = 1; n <= numberOfShards; n++) {
+      const shardId = _ShardId.ShardId.make(n);
+      shardState.set(shardId, Option.fromNullable(assignedShards.get(shardId)));
+    }
+    return new State(runnerState, shardState);
+  });
+  constructor(runners, shards) {
+    this.runners = runners;
+    this.shards = shards;
   }
-  function stateHasPod(podAddress) {
-    return (0, _Function.pipe)(RefSynchronized.get(stateRef), Effect.map(_ => HashMap.has(_.pods, podAddress)));
+  get maxVersion() {
+    if (MutableHashMap.size(this.runners) === 0) return Option.none();
+    let version = undefined;
+    for (const [, meta] of this.runners) {
+      if (version === undefined || meta.runner.version > version) {
+        version = meta.runner.version;
+      }
+    }
+    return Option.some(version);
   }
-  function notifyUnhealthyPod(podAddress) {
-    return (0, _Function.pipe)(Effect.whenEffect((0, _Function.pipe)(PubSub.publish(eventsHub, ShardingEvent.PodHealthChecked(podAddress)), Effect.zipRight(Effect.unlessEffect(Effect.zipRight(Effect.logWarning(`${podAddress} is not alive, unregistering`), unregister(podAddress)), healthApi.isAlive(podAddress)))), stateHasPod(podAddress)), Effect.asVoid);
+  allRunnersHaveVersion(version) {
+    return version.pipe(Option.map(max => Arr.every(this.runnerVersions, version => version === max)), Option.getOrElse(_Function.constFalse));
   }
-  const checkAllPodsHealth = (0, _Function.pipe)(RefSynchronized.get(stateRef), Effect.map(_ => HashMap.keySet(_.pods)), Effect.flatMap(_ => Effect.forEach(_, notifyUnhealthyPod, {
-    concurrency: 4,
-    discard: true
-  })));
-  function unregister(podAddress) {
-    const eff = (0, _Function.pipe)(Effect.Do, Effect.zipLeft(Effect.logDebug(`Unregistering ${podAddress}`)), Effect.bind("unassignments", _ => (0, _Function.pipe)(stateRef, RefSynchronized.modify(state => [(0, _Function.pipe)(state.shards, HashMap.filter(pod => (0, _Equal.equals)(pod)(Option.some(podAddress))), HashMap.keySet), {
-      ...state,
-      pods: HashMap.remove(state.pods, podAddress),
-      shards: HashMap.map(state.shards, _ => (0, _Equal.equals)(_)(Option.some(podAddress)) ? Option.none() : _)
-    }]))), Effect.tap(_ => PubSub.publish(eventsHub, ShardingEvent.PodUnregistered(podAddress))), Effect.tap(_ => Effect.when(PubSub.publish(eventsHub, ShardingEvent.ShardsUnassigned(podAddress, _.unassignments)), () => HashSet.size(_.unassignments) > 0)), Effect.zipLeft(Effect.forkIn(layerScope)(persistPods)), Effect.zipLeft(Effect.forkIn(layerScope)(rebalance(true))));
-    return Effect.asVoid(Effect.whenEffect(eff, stateHasPod(podAddress)));
+  get shardsPerRunner() {
+    const shards = MutableHashMap.empty();
+    if (MutableHashMap.isEmpty(this.runners)) return shards;
+    MutableHashMap.forEach(this.runners, (_, address) => {
+      MutableHashMap.set(shards, address, new Set());
+    });
+    for (const [shard, address] of this.shards) {
+      if (Option.isNone(address)) continue;
+      const shardIds = Option.getOrUndefined(MutableHashMap.get(shards, address.value));
+      shardIds.add(shard);
+    }
+    return shards;
   }
-  function withRetry(zio) {
-    return (0, _Function.pipe)(zio, Effect.retry((0, _Function.pipe)(Schedule.spaced(config.persistRetryInterval), Schedule.andThen(Schedule.recurs(config.persistRetryCount)))), Effect.ignore);
+  get averageShardsPerRunner() {
+    const runnerCount = MutableHashMap.size(this.runners);
+    return runnerCount > 0 ? this.shards.size / runnerCount : 0;
   }
-  const persistAssignments = withRetry((0, _Function.pipe)(RefSynchronized.get(stateRef), Effect.flatMap(state => stateRepository.saveAssignments(state.shards))));
-  const persistPods = withRetry((0, _Function.pipe)(RefSynchronized.get(stateRef), Effect.flatMap(state => stateRepository.savePods(HashMap.map(state.pods, v => v.pod)))));
-  function updateShardsState(shards, pod) {
-    return RefSynchronized.updateEffect(stateRef, state => {
-      if (Option.isSome(pod) && !HashMap.has(state.pods, pod.value)) {
-        return Effect.fail(new ShardingException.PodNoLongerRegisteredException({
-          podAddress: pod.value
-        }));
+  get unassignedShards() {
+    const shardIds = [];
+    for (const [shard, address] of this.shards) {
+      if (Option.isNone(address)) {
+        shardIds.push(shard);
       }
-      return Effect.succeed({
-        ...state,
-        shards: (0, _Function.pipe)(state.shards, HashMap.map((assignment, shard) => HashSet.has(shards, shard) ? pod : assignment))
-      });
-    });
+    }
+    return shardIds;
   }
-  function rebalance(rebalanceImmediately) {
-    const algo = Effect.gen(function* () {
-      const state = yield* RefSynchronized.get(stateRef);
-      const [assignments, unassignments] = rebalanceImmediately || HashSet.size(state.unassignedShards) > 0 ? decideAssignmentsForUnassignedShards(state) : decideAssignmentsForUnbalancedShards(state, config.rebalanceRate);
-      const areChanges = HashMap.size(assignments) > 0 || HashMap.size(unassignments) > 0;
-      if (areChanges) {
-        yield* Effect.logDebug("Rebalance (rebalanceImmidiately=" + JSON.stringify(rebalanceImmediately) + ")");
-      }
-      const failedPingedPods = yield* (0, _Function.pipe)(HashSet.union(HashMap.keySet(assignments), HashMap.keySet(unassignments)), Effect.forEach(pod => (0, _Function.pipe)(podApi.ping(pod), Effect.timeout(config.pingTimeout), Effect.match({
-        onFailure: () => Chunk.fromIterable([pod]),
-        onSuccess: () => Chunk.empty()
-      })), {
-        concurrency: "inherit"
-      }), Effect.map(Chunk.fromIterable), Effect.map(_ => Chunk.flatten(_)), Effect.map(HashSet.fromIterable));
-      const shardsToRemove = (0, _Function.pipe)(List.fromIterable(assignments), List.appendAll(List.fromIterable(unassignments)), List.filter(([pod, __]) => HashSet.has(failedPingedPods, pod)), List.map(([_, shards]) => List.fromIterable(shards)), List.flatMap(_ => _),
-      // TODO: List is missing flatMap
-      HashSet.fromIterable);
-      const readyAssignments = (0, _Function.pipe)(assignments, HashMap.map(HashSet.difference(shardsToRemove)), HashMap.filter(__ => HashSet.size(__) > 0));
-      const readyUnassignments = (0, _Function.pipe)(unassignments, HashMap.map(HashSet.difference(shardsToRemove)), HashMap.filter(__ => HashSet.size(__) > 0));
-      const [failedUnassignedPods, failedUnassignedShards] = yield* (0, _Function.pipe)(Effect.forEach(readyUnassignments, ([pod, shards]) => (0, _Function.pipe)(podApi.unassignShards(pod, shards), Effect.zipRight(updateShardsState(shards, Option.none())), Effect.matchEffect({
-        onFailure: () => Effect.succeed([HashSet.fromIterable([pod]), shards]),
-        onSuccess: () => (0, _Function.pipe)(PubSub.publish(eventsHub, ShardingEvent.ShardsUnassigned(pod, shards)), Effect.as([HashSet.empty(), HashSet.empty()]))
-      })), {
-        concurrency: "inherit"
-      }), Effect.map(Chunk.fromIterable), Effect.map(_ => Chunk.unzip(_)), Effect.map(([pods, shards]) => [Chunk.map(pods, Chunk.fromIterable), Chunk.map(shards, Chunk.fromIterable)]), Effect.map(([pods, shards]) => [HashSet.fromIterable(Chunk.flatten(pods)), HashSet.fromIterable(Chunk.flatten(shards))]));
-      // remove assignments of shards that couldn't be unassigned, as well as faulty pods.
-      const filteredAssignments = (0, _Function.pipe)(HashMap.removeMany(readyAssignments, failedUnassignedPods), HashMap.map((shards, __) => HashSet.difference(shards, failedUnassignedShards)));
-      // then do the assignments
-      const failedAssignedPods = yield* (0, _Function.pipe)(Effect.forEach(filteredAssignments, ([pod, shards]) => (0, _Function.pipe)(podApi.assignShards(pod, shards), Effect.zipRight(updateShardsState(shards, Option.some(pod))), Effect.matchEffect({
-        onFailure: () => Effect.succeed(Chunk.fromIterable([pod])),
-        onSuccess: () => (0, _Function.pipe)(PubSub.publish(eventsHub, ShardingEvent.ShardsAssigned(pod, shards)), Effect.as(Chunk.empty()))
-      })), {
-        concurrency: "inherit"
-      }), Effect.map(Chunk.fromIterable), Effect.map(_ => Chunk.flatten(_)), Effect.map(HashSet.fromIterable));
-      const failedPods = HashSet.union(HashSet.union(failedPingedPods, failedUnassignedPods), failedAssignedPods);
-      // check if failing pods are still up
-      yield* Effect.forkIn(layerScope)(Effect.forEach(failedPods, _ => notifyUnhealthyPod(_), {
-        discard: true
-      }));
-      if (HashSet.size(failedPods) > 0) {
-        yield* Effect.logDebug("Failed to rebalance pods: " + failedPods + " failed pinged: " + failedPingedPods + " failed assigned: " + failedAssignedPods + " failed unassigned: " + failedUnassignedPods);
-      }
-      // retry rebalancing later if there was any failure
-      if (HashSet.size(failedPods) > 0 && rebalanceImmediately) {
-        yield* (0, _Function.pipe)(Effect.sleep(config.rebalanceRetryInterval), Effect.zipRight(rebalance(rebalanceImmediately)), Effect.forkIn(layerScope));
-      }
-      // persist state changes to Redis
-      if (areChanges) {
-        yield* Effect.forkIn(layerScope)(persistAssignments);
-      }
-    });
-    return rebalanceSemaphore.withPermits(1)(algo);
+  get runnerVersions() {
+    const runnerVersions = [];
+    for (const [, meta] of this.runners) {
+      runnerVersions.push(meta.runner.version);
+    }
+    return runnerVersions;
   }
-  return {
-    getAssignments,
-    getShardingEvents,
-    register,
-    unregister,
-    persistPods,
-    rebalance,
-    notifyUnhealthyPod,
-    checkAllPodsHealth
-  };
 }
 /** @internal */
+exports.State = State;
+const RunnerWithMetadata = runner => runner;
+/** @internal */
+exports.RunnerWithMetadata = RunnerWithMetadata;
 function decideAssignmentsForUnassignedShards(state) {
-  return pickNewPods(List.fromIterable(state.unassignedShards), state, true, 1);
+  return pickNewRunners(state.unassignedShards, state, true, 1);
 }
+const allocationOrder = /*#__PURE__*/Order.combine( /*#__PURE__*/Order.mapInput(Order.number, ([, shards]) => shards), /*#__PURE__*/Order.mapInput(Order.number, ([,, registeredAt]) => registeredAt));
 /** @internal */
-function decideAssignmentsForUnbalancedShards(state, rebalanceRate) {
-  // don't do regular rebalance in the middle of a rolling update
-  const extraShardsToAllocate = state.allPodsHaveMaxVersion ? (0, _Function.pipe)(state.shardsPerPod, HashMap.flatMap((shards, _) => {
-    // count how many extra shards compared to the average
-    const extraShards = Math.max(HashSet.size(shards) - state.averageShardsPerPod.value, 0);
-    return (0, _Function.pipe)(HashMap.empty(), HashMap.set(_, HashSet.fromIterable(List.take(List.fromIterable(shards), extraShards))));
-  }), HashSet.fromIterable, HashSet.map(_ => _[1]), HashSet.flatMap(_ => _)) : HashSet.empty();
-  /*
-        TODO: port sortBy
-       val sortedShardsToRebalance = extraShardsToAllocate.toList.sortBy { shard =>
-      // handle unassigned shards first, then shards on the pods with most shards, then shards on old pods
-      state.shards.get(shard).flatten.fold((Int.MinValue, OffsetDateTime.MIN)) { pod =>
-        (
-          state.shardsPerPod.get(pod).fold(Int.MinValue)(-_.size),
-          state.pods.get(pod).fold(OffsetDateTime.MIN)(_.registered)
-        )
+function decideAssignmentsForUnbalancedShards(state, rate) {
+  const shardsPerRunner = state.shardsPerRunner;
+  const maxVersion = state.maxVersion;
+  const extraShardsToAllocate = Arr.empty();
+  if (state.allRunnersHaveVersion(maxVersion)) {
+    const averageShardsPerRunner = state.averageShardsPerRunner;
+    MutableHashMap.forEach(shardsPerRunner, shards => {
+      // Count how many extra shards there are compared to the average
+      const extraShards = Math.max(0, shards.size - averageShardsPerRunner);
+      for (const shard of takeRandom(shards, extraShards)) {
+        const maybeAddress = state.shards.get(shard) ?? Option.none();
+        if (Option.isNone(maybeAddress)) {
+          extraShardsToAllocate.push([shard, Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER]);
+          continue;
+        }
+        const address = maybeAddress.value;
+        extraShardsToAllocate.push([shard, Option.match(MutableHashMap.get(shardsPerRunner, address), {
+          onNone: () => Number.MIN_SAFE_INTEGER,
+          onSome: shards => -shards.size
+        }), Option.match(MutableHashMap.get(state.runners, address), {
+          onNone: () => Number.MIN_SAFE_INTEGER,
+          onSome: meta => meta.registeredAt
+        })]);
       }
-    }
-  * */
-  const sortedShardsToRebalance = List.fromIterable(extraShardsToAllocate);
-  return pickNewPods(sortedShardsToRebalance, state, false, rebalanceRate);
+    });
+  }
+  const sortedShardsToRebalance = extraShardsToAllocate.sort(allocationOrder).map(([shard]) => shard);
+  return pickNewRunners(sortedShardsToRebalance, state, false, rate, shardsPerRunner, maxVersion);
 }
-function pickNewPods(shardsToRebalance, state, rebalanceImmediately, rebalanceRate) {
-  const [_, assignments] = (0, _Function.pipe)(List.reduce(shardsToRebalance, [state.shardsPerPod, List.empty()], ([shardsPerPod, assignments], shard) => {
-    const unassignedPods = (0, _Function.pipe)(assignments, List.flatMap(([shard, _]) => (0, _Function.pipe)(HashMap.get(state.shards, shard), Option.flatten, Option.toArray, List.fromIterable)));
-    // find pod with least amount of shards
-    return (0, _Function.pipe)(
-    // keep only pods with the max version
-    HashMap.filter(shardsPerPod, (_, pod) => {
-      const maxVersion = state.maxVersion;
-      if (Option.isNone(maxVersion)) return true;
-      return (0, _Function.pipe)(HashMap.get(state.pods, pod), Option.map(PodWithMetadata.extractVersion), Option.map(_ => PodWithMetadata.compareVersion(_, maxVersion.value) === 0), Option.getOrElse(() => false));
-    }),
-    // don't assign too many shards to the same pods, unless we need rebalance immediately
-    HashMap.filter((_, pod) => {
-      if (rebalanceImmediately) return true;
-      return (0, _Function.pipe)(assignments, List.filter(([_, p]) => (0, _Equal.equals)(p)(pod)), List.size) < HashMap.size(state.shards) * rebalanceRate;
-    }),
-    // don't assign to a pod that was unassigned in the same rebalance
-    HashMap.filter((_, pod) => !Option.isSome(List.findFirst(unassignedPods, (0, _Equal.equals)(pod)))), (0, _utils.minByOption)(([_, pods]) => HashSet.size(pods)), Option.match({
-      onNone: () => [shardsPerPod, assignments],
-      onSome: ([pod, shards]) => {
-        const oldPod = Option.flatten(HashMap.get(state.shards, shard));
-        // if old pod is same as new pod, don't change anything
-        if ((0, _Equal.equals)(oldPod)(pod)) {
-          return [shardsPerPod, assignments];
-          // if the new pod has more, as much, or only 1 less shard than the old pod, don't change anything
-        } else if (Option.match(HashMap.get(shardsPerPod, pod), {
-          onNone: () => 0,
-          onSome: HashSet.size
-        }) + 1 >= Option.match(oldPod, {
-          onNone: () => Number.MAX_SAFE_INTEGER,
-          onSome: _ => Option.match(HashMap.get(shardsPerPod, _), {
-            onNone: () => 0,
-            onSome: HashSet.size
-          })
-        })) {
-          return [shardsPerPod, assignments];
-          // otherwise, create a new assignment
-        } else {
-          const unassigned = Option.match(oldPod, {
-            onNone: () => shardsPerPod,
-            onSome: oldPod => HashMap.modify(shardsPerPod, oldPod, HashSet.remove(shard))
-          });
-          return [HashMap.modify(unassigned, pod, _ => HashSet.add(shards, shard)), List.prepend(assignments, [shard, pod])];
-        }
+function pickNewRunners(shardsToRebalance, state, immediate, rate, shardsPerRunner = state.shardsPerRunner, maybeMaxVersion = state.maxVersion) {
+  const addressAssignments = MutableHashMap.empty();
+  const unassignments = MutableHashMap.empty();
+  const changes = MutableHashSet.empty();
+  if (Option.isNone(maybeMaxVersion)) {
+    return [addressAssignments, unassignments, changes];
+  }
+  const maxVersion = maybeMaxVersion.value;
+  for (const shardId of shardsToRebalance) {
+    // Find the runner with the fewest assigned shards
+    let candidate;
+    let candidateShards;
+    for (const [address, shards] of shardsPerRunner) {
+      // Keep only runners with the maximum version
+      const maybeRunnerMeta = MutableHashMap.get(state.runners, address);
+      if (Option.isNone(maybeRunnerMeta)) continue;
+      const runnerMeta = maybeRunnerMeta.value;
+      if (runnerMeta.runner.version !== maxVersion) continue;
+      // Do not assign to a runner that has unassignments in the same rebalance
+      if (MutableHashMap.has(unassignments, address)) continue;
+      // Do not assign too many shards to each runner unless rebalancing must
+      // occur immediately
+      if (!immediate) {
+        const assignmentCount = Option.getOrUndefined(MutableHashMap.get(addressAssignments, address))?.size ?? 0;
+        if (assignmentCount >= state.shards.size * rate) continue;
+      }
+      if (candidate === undefined || shards.size < candidateShards.size) {
+        candidate = address;
+        candidateShards = shards;
+      }
+    }
+    if (!candidate || !candidateShards) break;
+    // If the old runner is the same as the new runner, do nothing
+    const oldRunner = Option.getOrUndefined(state.shards.get(shardId) ?? Option.none());
+    if (oldRunner && oldRunner.toString() === candidate.toString()) {
+      continue;
+    }
+    const oldShards = oldRunner && Option.getOrUndefined(MutableHashMap.get(shardsPerRunner, oldRunner));
+    // If the new runner has one less, as many, or more shards than the
+    // old runner, do not change anything
+    if (oldShards && candidateShards.size + 1 >= oldShards.size) continue;
+    // Otherwise create a new assignment
+    MutableHashMap.modifyAt(addressAssignments, candidate, Option.match({
+      onNone: () => Option.some(new Set([shardId])),
+      onSome: shards => {
+        shards.add(shardId);
+        return Option.some(shards);
       }
     }));
-  }));
-  const unassignments = List.flatMap(assignments, ([shard, _]) => (0, _Function.pipe)(Option.flatten(HashMap.get(state.shards, shard)), Option.map(_ => [shard, _]), Option.match({
-    onNone: List.empty,
-    onSome: List.of
-  })));
-  const assignmentsPerPod = (0, _Function.pipe)(assignments, (0, _utils.groupBy)(([_, pod]) => pod), HashMap.map(HashSet.map(([shardId, _]) => shardId)));
-  const unassignmentsPerPod = (0, _Function.pipe)(unassignments, (0, _utils.groupBy)(([_, pod]) => pod), HashMap.map(HashSet.map(([shardId, _]) => shardId)));
-  return [assignmentsPerPod, unassignmentsPerPod];
+    if (oldRunner) {
+      MutableHashMap.modifyAt(unassignments, oldRunner, Option.match({
+        onNone: () => Option.some(new Set([shardId])),
+        onSome: shards => {
+          shards.add(shardId);
+          return Option.some(shards);
+        }
+      }));
+    }
+    // Move the shard to the new runner
+    candidateShards.add(shardId);
+    if (oldShards) {
+      oldShards.delete(shardId);
+    }
+    // Track changes
+    MutableHashSet.add(changes, candidate);
+    if (oldRunner) MutableHashSet.add(changes, oldRunner);
+  }
+  return [addressAssignments, unassignments, changes];
+}
+function takeRandom(self, n) {
+  const array = Array.from(self);
+  let currentIndex = array.length;
+  while (currentIndex != 0) {
+    const randomIndex = Math.floor(Math.random() * currentIndex);
+    currentIndex = currentIndex - 1;
+    swap(array, currentIndex, randomIndex);
+  }
+  return n < array.length ? array.slice(0, n) : array;
+}
+function swap(array, i, j) {
+  const tmp = array[i];
+  array[i] = array[j];
+  array[j] = tmp;
+  return array;
 }
-/**
- * @since 1.0.0
- * @category layers
- */
-const live = exports.live = /*#__PURE__*/Effect.gen(function* () {
-  const config = yield* ManagerConfig.ManagerConfig;
-  const stateRepository = yield* Storage.Storage;
-  const healthApi = yield* PodsHealth.PodsHealth;
-  const podsApi = yield* Pods.Pods;
-  const layerScope = yield* Effect.scope;
-  const pods = yield* stateRepository.getPods;
-  const assignments = yield* stateRepository.getAssignments;
-  const filteredPods = yield* (0, _Function.pipe)(Effect.filter(pods, ([podAddress]) => healthApi.isAlive(podAddress), {
-    concurrency: "inherit"
-  }), Effect.map(HashMap.fromIterable));
-  const filteredAssignments = HashMap.filter(assignments, pod => Option.isSome(pod) && HashMap.has(filteredPods, pod.value));
-  const cdt = yield* Clock.currentTimeMillis;
-  const initialState = ShardManagerState.make(HashMap.map(filteredPods, pod => PodWithMetadata.make(pod, cdt)), HashMap.union(filteredAssignments, (0, _Function.pipe)(Chunk.range(1, config.numberOfShards), Chunk.map(n => [ShardId.make(n), Option.none()]), HashMap.fromIterable)));
-  const state = yield* RefSynchronized.make(initialState);
-  const rebalanceSemaphore = yield* Effect.makeSemaphore(1);
-  const eventsHub = yield* PubSub.unbounded();
-  const shardManager = make(layerScope, state, rebalanceSemaphore, eventsHub, healthApi, podsApi, stateRepository, config);
-  yield* Effect.forkIn(layerScope)(shardManager.persistPods);
-  // rebalance immediately if there are unassigned shards
-  yield* shardManager.rebalance(HashSet.size(initialState.unassignedShards) > 0);
-  // start a regular rebalance at the given interval
-  yield* (0, _Function.pipe)(shardManager.rebalance(false), Effect.repeat(Schedule.spaced(config.rebalanceInterval)), Effect.forkIn(layerScope));
-  // log info events
-  yield* (0, _Function.pipe)(shardManager.getShardingEvents, Stream.mapEffect(_ => Effect.logDebug(JSON.stringify(_))), Stream.runDrain, Effect.forkIn(layerScope));
-  yield* Effect.logDebug("Shard Manager loaded");
-  return shardManager;
-}).pipe( /*#__PURE__*/Layer.scoped(shardManagerTag));
 //# sourceMappingURL=shardManager.js.map
\ No newline at end of file
diff --git a/dist/cjs/internal/shardManager.js.map b/dist/cjs/internal/shardManager.js.map
index a849583c266557194dce7b31e24cf6779aec0033..d7c541d15742ffa2fdeb4b33c63fba09b6e94a19 100644
--- a/dist/cjs/internal/shardManager.js.map
+++ b/dist/cjs/internal/shardManager.js.map
@@ -1 +1 @@
-{"version":3,"file":"shardManager.js","names":["Chunk","_interopRequireWildcard","require","Clock","_Context","Effect","_Equal","_Function","HashMap","HashSet","Layer","List","Option","PubSub","Schedule","Stream","RefSynchronized","ManagerConfig","Pods","PodsHealth","ShardId","ShardingEvent","ShardingException","Storage","PodWithMetadata","ShardManagerState","_utils","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","ShardManagerSymbolKey","ShardManagerTypeId","exports","Symbol","for","shardManagerTag","GenericTag","make","layerScope","stateRef","rebalanceSemaphore","eventsHub","healthApi","podApi","stateRepository","config","getAssignments","pipe","map","_","shards","getShardingEvents","fromPubSub","register","pod","logDebug","address","version","zipRight","updateAndGetEffect","state","flatMap","clock","currentTimeMillis","cdt","pods","zipLeft","publish","PodRegistered","when","rebalance","size","unassignedShards","forkIn","persistPods","asVoid","stateHasPod","podAddress","notifyUnhealthyPod","whenEffect","PodHealthChecked","unlessEffect","logWarning","unregister","isAlive","checkAllPodsHealth","keySet","forEach","concurrency","discard","eff","Do","bind","modify","filter","equals","some","remove","none","tap","PodUnregistered","ShardsUnassigned","unassignments","withRetry","zio","retry","spaced","persistRetryInterval","andThen","recurs","persistRetryCount","ignore","persistAssignments","saveAssignments","savePods","v","updateShardsState","updateEffect","isSome","value","fail","PodNoLongerRegisteredException","succeed","assignment","shard","rebalanceImmediately","algo","gen","assignments","decideAssignmentsForUnassignedShards","decideAssignmentsForUnbalancedShards","rebalanceRate","areChanges","JSON","stringify","failedPingedPods","union","ping","timeout","pingTimeout","match","onFailure","fromIterable","onSuccess","empty","flatten","shardsToRemove","appendAll","__","readyAssignments","difference","readyUnassignments","failedUnassignedPods","failedUnassignedShards","unassignShards","matchEffect","as","unzip","filteredAssignments","removeMany","failedAssignedPods","assignShards","ShardsAssigned","failedPods","sleep","rebalanceRetryInterval","withPermits","pickNewPods","extraShardsToAllocate","allPodsHaveMaxVersion","shardsPerPod","extraShards","Math","max","averageShardsPerPod","take","sortedShardsToRebalance","shardsToRebalance","reduce","unassignedPods","toArray","maxVersion","isNone","extractVersion","compareVersion","getOrElse","p","findFirst","minByOption","onNone","onSome","oldPod","Number","MAX_SAFE_INTEGER","unassigned","add","prepend","of","assignmentsPerPod","groupBy","shardId","unassignmentsPerPod","live","podsApi","scope","getPods","filteredPods","initialState","range","numberOfShards","makeSemaphore","unbounded","shardManager","repeat","rebalanceInterval","mapEffect","runDrain","scoped"],"sources":["../../../src/internal/shardManager.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
+{"version":3,"file":"shardManager.js","names":["Arr","_interopRequireWildcard","require","Clock","Effect","_Function","MutableHashMap","MutableHashSet","Option","Order","_RunnerHealth","_ShardId","_ShardStorage","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","State","runners","shards","fromStorage","fnUntraced","numberOfShards","storage","ShardStorage","runnerHealth","RunnerHealth","storedRunners","getRunners","storedAssignments","getAssignments","deadRunners","empty","aliveRunners","forEach","address","runner","map","isAlive","push","concurrency","discard","length","logWarning","assignedShards","Map","invalidAssignments","shard","isSome","value","now","currentTimeMillis","runnerState","RunnerWithMetadata","registeredAt","shardState","shardId","ShardId","make","fromNullable","constructor","maxVersion","size","none","version","undefined","meta","some","allRunnersHaveVersion","pipe","max","every","runnerVersions","getOrElse","constFalse","shardsPerRunner","isEmpty","_","Set","isNone","shardIds","getOrUndefined","add","averageShardsPerRunner","runnerCount","unassignedShards","exports","decideAssignmentsForUnassignedShards","state","pickNewRunners","allocationOrder","combine","mapInput","number","decideAssignmentsForUnbalancedShards","rate","extraShardsToAllocate","extraShards","Math","takeRandom","maybeAddress","Number","MIN_SAFE_INTEGER","match","onNone","onSome","sortedShardsToRebalance","sort","shardsToRebalance","immediate","maybeMaxVersion","addressAssignments","unassignments","changes","candidate","candidateShards","maybeRunnerMeta","runnerMeta","assignmentCount","oldRunner","toString","oldShards","modifyAt","delete","self","array","Array","from","currentIndex","randomIndex","floor","random","swap","slice","j","tmp"],"sources":["../../../src/internal/shardManager.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/dts/ClusterError.d.ts b/dist/dts/ClusterError.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9cfb7c308460c5dd94528a3ff0163a55b8c5e3c8
--- /dev/null
+++ b/dist/dts/ClusterError.d.ts
@@ -0,0 +1,169 @@
+import * as Effect from "effect/Effect";
+import * as Schema from "effect/Schema";
+import { EntityAddress } from "./EntityAddress.js";
+import { RunnerAddress } from "./RunnerAddress.js";
+/**
+ * @since 1.0.0
+ * @category Symbols
+ */
+export declare const TypeId: unique symbol;
+/**
+ * @since 1.0.0
+ * @category Symbols
+ */
+export type TypeId = typeof TypeId;
+declare const EntityNotManagedByRunner_base: Schema.TaggedErrorClass<EntityNotManagedByRunner, "EntityNotManagedByRunner", {
+    readonly _tag: Schema.tag<"EntityNotManagedByRunner">;
+} & {
+    address: typeof EntityAddress;
+}>;
+/**
+ * Represents an error that occurs when a Runner receives a message for an entity
+ * that it is not responsible for managing.
+ *
+ * @since 1.0.0
+ * @category errors
+ */
+export declare class EntityNotManagedByRunner extends EntityNotManagedByRunner_base {
+    /**
+     * @since 1.0.0
+     */
+    readonly [TypeId]: symbol;
+    /**
+     * @since 1.0.0
+     */
+    static is(u: unknown): u is EntityNotManagedByRunner;
+}
+declare const MalformedMessage_base: Schema.TaggedErrorClass<MalformedMessage, "MalformedMessage", {
+    readonly _tag: Schema.tag<"MalformedMessage">;
+} & {
+    cause: typeof Schema.Defect;
+}>;
+/**
+ * Represents an error that occurs when a message fails to be properly
+ * deserialized by an entity.
+ *
+ * @since 1.0.0
+ * @category errors
+ */
+export declare class MalformedMessage extends MalformedMessage_base {
+    /**
+     * @since 1.0.0
+     */
+    readonly [TypeId]: symbol;
+    /**
+     * @since 1.0.0
+     */
+    static is(u: unknown): u is MalformedMessage;
+    /**
+     * @since 1.0.0
+     */
+    static refail: <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, MalformedMessage, R>;
+}
+declare const PersistenceError_base: Schema.TaggedErrorClass<PersistenceError, "PersistenceError", {
+    readonly _tag: Schema.tag<"PersistenceError">;
+} & {
+    cause: typeof Schema.Defect;
+}>;
+/**
+ * Represents an error that occurs when a message fails to be persisted into
+ * cluster's mailbox storage.
+ *
+ * @since 1.0.0
+ * @category errors
+ */
+export declare class PersistenceError extends PersistenceError_base {
+    /**
+     * @since 1.0.0
+     */
+    readonly [TypeId]: symbol;
+    /**
+     * @since 1.0.0
+     */
+    static refail<A, E, R>(effect: Effect.Effect<A, E, R>): Effect.Effect<A, PersistenceError, R>;
+}
+declare const RunnerNotRegistered_base: Schema.TaggedErrorClass<RunnerNotRegistered, "RunnerNotRegistered", {
+    readonly _tag: Schema.tag<"RunnerNotRegistered">;
+} & {
+    address: typeof RunnerAddress;
+}>;
+/**
+ * Represents an error that occurs when a Runner is not registered with the shard
+ * manager.
+ *
+ * @since 1.0.0
+ * @category errors
+ */
+export declare class RunnerNotRegistered extends RunnerNotRegistered_base {
+    /**
+     * @since 1.0.0
+     */
+    readonly [TypeId]: symbol;
+}
+declare const RunnerUnavailable_base: Schema.TaggedErrorClass<RunnerUnavailable, "RunnerUnavailable", {
+    readonly _tag: Schema.tag<"RunnerUnavailable">;
+} & {
+    address: typeof RunnerAddress;
+}>;
+/**
+ * Represents an error that occurs when a Runner is unresponsive.
+ *
+ * @since 1.0.0
+ * @category errors
+ */
+export declare class RunnerUnavailable extends RunnerUnavailable_base {
+    /**
+     * @since 1.0.0
+     */
+    readonly [TypeId]: symbol;
+    /**
+     * @since 1.0.0
+     */
+    static is(u: unknown): u is RunnerUnavailable;
+}
+declare const MailboxFull_base: Schema.TaggedErrorClass<MailboxFull, "MailboxFull", {
+    readonly _tag: Schema.tag<"MailboxFull">;
+} & {
+    address: typeof EntityAddress;
+}>;
+/**
+ * Represents an error that occurs when the entities mailbox is full.
+ *
+ * @since 1.0.0
+ * @category errors
+ */
+export declare class MailboxFull extends MailboxFull_base {
+    /**
+     * @since 1.0.0
+     */
+    readonly [TypeId]: symbol;
+    /**
+     * @since 1.0.0
+     */
+    static is(u: unknown): u is MailboxFull;
+}
+declare const AlreadyProcessingMessage_base: Schema.TaggedErrorClass<AlreadyProcessingMessage, "AlreadyProcessingMessage", {
+    readonly _tag: Schema.tag<"AlreadyProcessingMessage">;
+} & {
+    envelopeId: Schema.Schema<import("./Snowflake.js").Snowflake, string, never>;
+    address: typeof EntityAddress;
+}>;
+/**
+ * Represents an error that occurs when the entity is already processing a
+ * request.
+ *
+ * @since 1.0.0
+ * @category errors
+ */
+export declare class AlreadyProcessingMessage extends AlreadyProcessingMessage_base {
+    /**
+     * @since 1.0.0
+     */
+    readonly [TypeId]: symbol;
+    /**
+     * @since 1.0.0
+     */
+    static is(u: unknown): u is AlreadyProcessingMessage;
+}
+export {};
+//# sourceMappingURL=ClusterError.d.ts.map
\ No newline at end of file
diff --git a/dist/dts/ClusterError.d.ts.map b/dist/dts/ClusterError.d.ts.map
new file mode 100644
index 0000000000000000000000000000000000000000..fef027994ef3431ece5d4daba86e6f1d89b8c852
--- /dev/null
+++ b/dist/dts/ClusterError.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"ClusterError.d.ts","sourceRoot":"","sources":["../../src/ClusterError.ts"],"names":[],"mappings":"AAIA,OAAO,KAAK,MAAM,MAAM,eAAe,CAAA;AAEvC,OAAO,KAAK,MAAM,MAAM,eAAe,CAAA;AACvC,OAAO,EAAE,aAAa,EAAE,MAAM,oBAAoB,CAAA;AAClD,OAAO,EAAE,aAAa,EAAE,MAAM,oBAAoB,CAAA;AAGlD;;;GAGG;AACH,eAAO,MAAM,MAAM,EAAE,OAAO,MAAmD,CAAA;AAE/E;;;GAGG;AACH,MAAM,MAAM,MAAM,GAAG,OAAO,MAAM,CAAA;;;;;;AAElC;;;;;;GAMG;AACH,qBAAa,wBAAyB,SAAQ,6BAG7C;IACC;;OAEG;IACH,QAAQ,CAAC,CAAC,MAAM,CAAC,SAAS;IAE1B;;OAEG;IACH,MAAM,CAAC,EAAE,CAAC,CAAC,EAAE,OAAO,GAAG,CAAC,IAAI,wBAAwB;CAGrD;;;;;;AAED;;;;;;GAMG;AACH,qBAAa,gBAAiB,SAAQ,qBAGrC;IACC;;OAEG;IACH,QAAQ,CAAC,CAAC,MAAM,CAAC,SAAS;IAE1B;;OAEG;IACH,MAAM,CAAC,EAAE,CAAC,CAAC,EAAE,OAAO,GAAG,CAAC,IAAI,gBAAgB;IAI5C;;OAEG;IACH,MAAM,CAAC,MAAM,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,MAAM,EAAE,MAAM,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,KAAK,MAAM,CAAC,MAAM,CACvE,CAAC,EACD,gBAAgB,EAChB,CAAC,CACF,CAA8D;CAChE;;;;;;AAED;;;;;;GAMG;AACH,qBAAa,gBAAiB,SAAQ,qBAGrC;IACC;;OAEG;IACH,QAAQ,CAAC,CAAC,MAAM,CAAC,SAAS;IAE1B;;OAEG;IACH,MAAM,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,MAAM,EAAE,MAAM,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC,EAAE,gBAAgB,EAAE,CAAC,CAAC;CAG9F;;;;;;AAED;;;;;;GAMG;AACH,qBAAa,mBAAoB,SAAQ,wBAGxC;IACC;;OAEG;IACH,QAAQ,CAAC,CAAC,MAAM,CAAC,SAAS;CAC3B;;;;;;AAED;;;;;GAKG;AACH,qBAAa,iBAAkB,SAAQ,sBAGtC;IACC;;OAEG;IACH,QAAQ,CAAC,CAAC,MAAM,CAAC,SAAS;IAE1B;;OAEG;IACH,MAAM,CAAC,EAAE,CAAC,CAAC,EAAE,OAAO,GAAG,CAAC,IAAI,iBAAiB;CAG9C;;;;;;AAED;;;;;GAKG;AACH,qBAAa,WAAY,SAAQ,gBAGhC;IACC;;OAEG;IACH,QAAQ,CAAC,CAAC,MAAM,CAAC,SAAS;IAE1B;;OAEG;IACH,MAAM,CAAC,EAAE,CAAC,CAAC,EAAE,OAAO,GAAG,CAAC,IAAI,WAAW;CAGxC;;;;;;;AAED;;;;;;GAMG;AACH,qBAAa,wBAAyB,SAAQ,6BAM7C;IACC;;OAEG;IACH,QAAQ,CAAC,CAAC,MAAM,CAAC,SAAS;IAE1B;;OAEG;IACH,MAAM,CAAC,EAAE,CAAC,CAAC,EAAE,OAAO,GAAG,CAAC,IAAI,wBAAwB;CAGrD"}
\ No newline at end of file
diff --git a/dist/dts/ClusterMetrics.d.ts b/dist/dts/ClusterMetrics.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e26fc8bf5cbe64ae83c0f2ef01912c39a424eb2e
--- /dev/null
+++ b/dist/dts/ClusterMetrics.d.ts
@@ -0,0 +1,50 @@
+/**
+ * @since 1.0.0
+ */
+import * as Metric from "effect/Metric";
+/**
+ * @since 1.0.0
+ * @category metrics
+ */
+export declare const shards: Metric.Metric.Gauge<number>;
+/**
+ * @since 1.0.0
+ * @category metrics
+ */
+export declare const entities: Metric.Metric.Gauge<bigint>;
+/**
+ * @since 1.0.0
+ * @category metrics
+ */
+export declare const mailboxSize: Metric.Metric.Gauge<bigint>;
+/**
+ * @since 1.0.0
+ * @category metrics
+ */
+export declare const singletons: Metric.Metric.Gauge<number>;
+/**
+ * @since 1.0.0
+ * @category metrics
+ */
+export declare const runners: Metric.Metric.Gauge<number>;
+/**
+ * @since 1.0.0
+ * @category metrics
+ */
+export declare const assignedShards: Metric.Metric.Gauge<number>;
+/**
+ * @since 1.0.0
+ * @category metrics
+ */
+export declare const unassignedShards: Metric.Metric.Gauge<number>;
+/**
+ * @since 1.0.0
+ * @category metrics
+ */
+export declare const rebalances: Metric.Metric.Counter<number>;
+/**
+ * @since 1.0.0
+ * @category metrics
+ */
+export declare const runnerHealthChecked: Metric.Metric.Counter<number>;
+//# sourceMappingURL=ClusterMetrics.d.ts.map
\ No newline at end of file
diff --git a/dist/dts/ClusterMetrics.d.ts.map b/dist/dts/ClusterMetrics.d.ts.map
new file mode 100644
index 0000000000000000000000000000000000000000..dcba452b024cf0c5a932d9a31d15c58e7c2d8186
--- /dev/null
+++ b/dist/dts/ClusterMetrics.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"ClusterMetrics.d.ts","sourceRoot":"","sources":["../../src/ClusterMetrics.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,OAAO,KAAK,MAAM,MAAM,eAAe,CAAA;AAEvC;;;GAGG;AACH,eAAO,MAAM,MAAM,6BAAwC,CAAA;AAE3D;;;GAGG;AACH,eAAO,MAAM,QAAQ,6BAEnB,CAAA;AAEF;;;GAGG;AACH,eAAO,MAAM,WAAW,6BAEtB,CAAA;AAEF;;;GAGG;AACH,eAAO,MAAM,UAAU,6BAA4C,CAAA;AAEnE;;;GAGG;AACH,eAAO,MAAM,OAAO,6BAAyC,CAAA;AAE7D;;;GAGG;AACH,eAAO,MAAM,cAAc,6BAAiD,CAAA;AAE5E;;;GAGG;AACH,eAAO,MAAM,gBAAgB,6BAAmD,CAAA;AAEhF;;;GAGG;AACH,eAAO,MAAM,UAAU,+BAA8C,CAAA;AAErE;;;GAGG;AACH,eAAO,MAAM,mBAAmB,+BAAyD,CAAA"}
\ No newline at end of file
diff --git a/dist/dts/ClusterSchema.d.ts b/dist/dts/ClusterSchema.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b54f84e6660f185f5b116ab3d12ef22c31ce0aa1
--- /dev/null
+++ b/dist/dts/ClusterSchema.d.ts
@@ -0,0 +1,13 @@
+/**
+ * @since 1.0.0
+ */
+import * as Context from "effect/Context";
+declare const Persisted_base: Context.ReferenceClass<Persisted, "@effect/cluster/ClusterSchema/Persisted", boolean>;
+/**
+ * @since 1.0.0
+ * @category Annotations
+ */
+export declare class Persisted extends Persisted_base {
+}
+export {};
+//# sourceMappingURL=ClusterSchema.d.ts.map
\ No newline at end of file
diff --git a/dist/dts/ClusterSchema.d.ts.map b/dist/dts/ClusterSchema.d.ts.map
new file mode 100644
index 0000000000000000000000000000000000000000..1c34860c6699109874b3ef30fd4862fd7f543dce
--- /dev/null
+++ b/dist/dts/ClusterSchema.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"ClusterSchema.d.ts","sourceRoot":"","sources":["../../src/ClusterSchema.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,OAAO,KAAK,OAAO,MAAM,gBAAgB,CAAA;;AAGzC;;;GAGG;AACH,qBAAa,SAAU,SAAQ,cAE7B;CAAG"}
\ No newline at end of file
diff --git a/dist/dts/DeliverAt.d.ts b/dist/dts/DeliverAt.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..94d431de73be597200a655008492dceb729baada
--- /dev/null
+++ b/dist/dts/DeliverAt.d.ts
@@ -0,0 +1,27 @@
+/**
+ * @since 1.0.0
+ */
+import type { DateTime } from "effect/DateTime";
+/**
+ * @since 1.0.0
+ * @category symbols
+ */
+export declare const symbol: unique symbol;
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export interface DeliverAt {
+    [symbol](): DateTime;
+}
+/**
+ * @since 1.0.0
+ * @category guards
+ */
+export declare const isDeliverAt: (self: unknown) => self is DeliverAt;
+/**
+ * @since 1.0.0
+ * @category accessors
+ */
+export declare const toMillis: (self: unknown) => number | null;
+//# sourceMappingURL=DeliverAt.d.ts.map
\ No newline at end of file
diff --git a/dist/dts/DeliverAt.d.ts.map b/dist/dts/DeliverAt.d.ts.map
new file mode 100644
index 0000000000000000000000000000000000000000..1ec06738328eb65f094bc974d6e5677b8724075b
--- /dev/null
+++ b/dist/dts/DeliverAt.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"DeliverAt.d.ts","sourceRoot":"","sources":["../../src/DeliverAt.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,OAAO,KAAK,EAAE,QAAQ,EAAE,MAAM,iBAAiB,CAAA;AAG/C;;;GAGG;AACH,eAAO,MAAM,MAAM,EAAE,OAAO,MAAgD,CAAA;AAE5E;;;GAGG;AACH,MAAM,WAAW,SAAS;IACxB,CAAC,MAAM,CAAC,IAAI,QAAQ,CAAA;CACrB;AAED;;;GAGG;AACH,eAAO,MAAM,WAAW,SAAU,OAAO,KAAG,IAAI,IAAI,SAAsC,CAAA;AAE1F;;;GAGG;AACH,eAAO,MAAM,QAAQ,SAAU,OAAO,KAAG,MAAM,GAAG,IAKjD,CAAA"}
\ No newline at end of file
diff --git a/dist/dts/Entity.d.ts b/dist/dts/Entity.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f19fbf69b2895e624695fff21130d742a1763b10
--- /dev/null
+++ b/dist/dts/Entity.d.ts
@@ -0,0 +1,180 @@
+/**
+ * @since 1.0.0
+ */
+import type * as Rpc from "@effect/rpc/Rpc";
+import type * as RpcClient from "@effect/rpc/RpcClient";
+import * as RpcGroup from "@effect/rpc/RpcGroup";
+import type * as Cause from "effect/Cause";
+import * as Context from "effect/Context";
+import * as Data from "effect/Data";
+import type { DurationInput } from "effect/Duration";
+import * as Effect from "effect/Effect";
+import * as Equal from "effect/Equal";
+import * as Exit from "effect/Exit";
+import * as Layer from "effect/Layer";
+import * as Mailbox from "effect/Mailbox";
+import * as Option from "effect/Option";
+import type { Scope } from "effect/Scope";
+import type * as Stream from "effect/Stream";
+import type { AlreadyProcessingMessage, MailboxFull, PersistenceError } from "./ClusterError.js";
+import type { EntityAddress } from "./EntityAddress.js";
+import { EntityType } from "./EntityType.js";
+import type * as Envelope from "./Envelope.js";
+import type * as Reply from "./Reply.js";
+import type { RunnerAddress } from "./RunnerAddress.js";
+import type { Sharding } from "./Sharding.js";
+/**
+ * @since 1.0.0
+ * @category type ids
+ */
+export declare const TypeId: unique symbol;
+/**
+ * @since 1.0.0
+ * @category type ids
+ */
+export type TypeId = typeof TypeId;
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export interface Entity<in out Rpcs extends Rpc.Any> extends Equal.Equal {
+    readonly [TypeId]: TypeId;
+    /**
+     * The name of the entity type.
+     */
+    readonly type: EntityType;
+    /**
+     * A RpcGroup definition for messages which represents the messaging protocol
+     * that the entity is capable of processing.
+     */
+    readonly protocol: RpcGroup.RpcGroup<Rpcs>;
+    /**
+     * Annotate the entity with a value.
+     */
+    annotate<I, S>(tag: Context.Tag<I, S>, value: S): Entity<Rpcs>;
+    /**
+     * Annotate the Rpc's above this point with a value.
+     */
+    annotateRpcs<I, S>(tag: Context.Tag<I, S>, value: S): Entity<Rpcs>;
+    /**
+     * Annotate the entity with a context object.
+     */
+    annotateContext<S>(context: Context.Context<S>): Entity<Rpcs>;
+    /**
+     * Annotate the Rpc's above this point with a context object.
+     */
+    annotateRpcsContext<S>(context: Context.Context<S>): Entity<Rpcs>;
+    /**
+     * Create a client for this entity.
+     */
+    readonly client: Effect.Effect<(entityId: string) => RpcClient.RpcClient<Rpcs, MailboxFull | AlreadyProcessingMessage | PersistenceError>, never, Sharding>;
+    /**
+     * Create a Layer from an Entity.
+     *
+     * It will register the entity with the Sharding service.
+     */
+    toLayer<Handlers extends HandlersFrom<Rpcs>, RX = never>(build: Handlers | Effect.Effect<Handlers, never, RX>, options?: {
+        readonly maxIdleTime?: DurationInput | undefined;
+        readonly concurrency?: number | "unbounded" | undefined;
+        readonly mailboxCapacity?: number | "unbounded" | undefined;
+    }): Layer.Layer<never, never, Exclude<RX, Scope | CurrentAddress | CurrentRunnerAddress> | RpcGroup.HandlersContext<Rpcs, Handlers> | Rpc.Context<Rpcs> | Rpc.Middleware<Rpcs> | Sharding>;
+    /**
+     * Create a Layer from an Entity.
+     *
+     * It will register the entity with the Sharding service.
+     */
+    toLayerMailbox<R, RX = never>(build: ((mailbox: Mailbox.ReadonlyMailbox<Envelope.Request<Rpcs>>, replier: Replier<Rpcs>) => Effect.Effect<never, never, R>) | Effect.Effect<(mailbox: Mailbox.ReadonlyMailbox<Envelope.Request<Rpcs>>, replier: Replier<Rpcs>) => Effect.Effect<never, never, R>, never, RX>, options?: {
+        readonly maxIdleTime?: DurationInput | undefined;
+        readonly mailboxCapacity?: number | "unbounded" | undefined;
+    }): Layer.Layer<never, never, Exclude<RX, Scope | CurrentAddress> | R | Rpc.Context<Rpcs> | Rpc.Middleware<Rpcs> | Sharding>;
+}
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export type Any = Entity<Rpc.Any>;
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export type HandlersFrom<Rpc extends Rpc.Any> = {
+    readonly [Current in Rpc as Current["_tag"]]: (envelope: Request<Current>) => RpcGroup.ResultFrom<Current> | Rpc.Fork<RpcGroup.ResultFrom<Current>>;
+};
+/**
+ * @since 1.0.0
+ * @category refinements
+ */
+export declare const isEntity: (u: unknown) => u is Any;
+/**
+ * Creates a new `Entity` of the specified `type` which will accept messages
+ * that adhere to the provided `RpcGroup`.
+ *
+ * @since 1.0.0
+ * @category constructors
+ */
+export declare const fromRpcGroup: <Rpcs extends Rpc.Any>(type: string, protocol: RpcGroup.RpcGroup<Rpcs>) => Entity<Rpcs>;
+/**
+ * Creates a new `Entity` of the specified `type` which will accept messages
+ * that adhere to the provided schemas.
+ *
+ * @since 1.0.0
+ * @category constructors
+ */
+export declare const make: <Rpcs extends ReadonlyArray<Rpc.Any>>(type: string, protocol: Rpcs) => Entity<Rpcs[number]>;
+declare const CurrentAddress_base: Context.TagClass<CurrentAddress, "@effect/cluster/Entity/EntityAddress", EntityAddress>;
+/**
+ * A Context.Tag to access the current entity address.
+ *
+ * @since 1.0.0
+ * @category context
+ */
+export declare class CurrentAddress extends CurrentAddress_base {
+}
+declare const CurrentRunnerAddress_base: Context.TagClass<CurrentRunnerAddress, "@effect/cluster/Entity/RunnerAddress", RunnerAddress>;
+/**
+ * A Context.Tag to access the current Runner address.
+ *
+ * @since 1.0.0
+ * @category context
+ */
+export declare class CurrentRunnerAddress extends CurrentRunnerAddress_base {
+}
+/**
+ * @since 1.0.0
+ * @category Replier
+ */
+export interface Replier<Rpcs extends Rpc.Any> {
+    readonly succeed: <R extends Rpcs>(request: Envelope.Request<R>, value: Replier.Success<R>) => Effect.Effect<void>;
+    readonly fail: <R extends Rpcs>(request: Envelope.Request<R>, error: Rpc.Error<R>) => Effect.Effect<void>;
+    readonly failCause: <R extends Rpcs>(request: Envelope.Request<R>, cause: Cause.Cause<Rpc.Error<R>>) => Effect.Effect<void>;
+    readonly complete: <R extends Rpcs>(request: Envelope.Request<R>, exit: Exit.Exit<Replier.Success<R>, Rpc.Error<R>>) => Effect.Effect<void>;
+}
+/**
+ * @since 1.0.0
+ * @category Replier
+ */
+export declare namespace Replier {
+    /**
+     * @since 1.0.0
+     * @category Replier
+     */
+    type Success<R extends Rpc.Any> = Rpc.Success<R> extends Stream.Stream<infer _A, infer _E, infer _R> ? Stream.Stream<_A, _E | Rpc.Error<R>, _R> | Mailbox.ReadonlyMailbox<_A, _E | Rpc.Error<R>> : Rpc.Success<R>;
+}
+/**
+ * @since 1.0.0
+ * @category Request
+ */
+export declare class Request<Rpc extends Rpc.Any> extends Data.Class<Envelope.Request<Rpc> & {
+    readonly lastSentChunk: Option.Option<Reply.Chunk<Rpc>>;
+}> {
+    /**
+     * @since 1.0.0
+     */
+    get lastSentChunkValue(): Option.Option<Rpc.SuccessChunk<Rpc>>;
+    /**
+     * @since 1.0.0
+     */
+    get nextSequence(): number;
+}
+export {};
+//# sourceMappingURL=Entity.d.ts.map
\ No newline at end of file
diff --git a/dist/dts/Entity.d.ts.map b/dist/dts/Entity.d.ts.map
new file mode 100644
index 0000000000000000000000000000000000000000..410b2350d9b5cd878c0c4ddafdc7cadc2b9d3652
--- /dev/null
+++ b/dist/dts/Entity.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"Entity.d.ts","sourceRoot":"","sources":["../../src/Entity.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/dts/EntityAddress.d.ts b/dist/dts/EntityAddress.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..356b119bc674d1aa7d4a5f8750b095edb7c09e44
--- /dev/null
+++ b/dist/dts/EntityAddress.d.ts
@@ -0,0 +1,55 @@
+/**
+ * @since 1.0.0
+ */
+import * as Hash from "effect/Hash";
+import * as Schema from "effect/Schema";
+/**
+ * @since 1.0.0
+ * @category type ids
+ */
+export declare const TypeId: unique symbol;
+/**
+ * @since 1.0.0
+ * @category type ids
+ */
+export type TypeId = typeof TypeId;
+declare const EntityAddress_base: Schema.Class<EntityAddress, {
+    shardId: Schema.brand<typeof Schema.Int, "ShardId">;
+    entityType: Schema.brand<typeof Schema.NonEmptyTrimmedString, "EntityType">;
+    entityId: Schema.brand<typeof Schema.NonEmptyTrimmedString, "EntityId">;
+}, Schema.Struct.Encoded<{
+    shardId: Schema.brand<typeof Schema.Int, "ShardId">;
+    entityType: Schema.brand<typeof Schema.NonEmptyTrimmedString, "EntityType">;
+    entityId: Schema.brand<typeof Schema.NonEmptyTrimmedString, "EntityId">;
+}>, never, {
+    readonly shardId: number & import("effect/Brand").Brand<"ShardId">;
+} & {
+    readonly entityType: string & import("effect/Brand").Brand<"EntityType">;
+} & {
+    readonly entityId: string & import("effect/Brand").Brand<"EntityId">;
+}, {}, {}>;
+/**
+ * Represents the unique address of an entity within the cluster.
+ *
+ * @since 1.0.0
+ * @category models
+ */
+export declare class EntityAddress extends EntityAddress_base {
+    /**
+     * @since 1.0.0
+     */
+    readonly [TypeId]: symbol;
+    /**
+     * @since 1.0.0
+     */
+    [Hash.symbol](): number;
+}
+/**
+ * Represents the unique address of an entity within the cluster.
+ *
+ * @since 1.0.0
+ * @category schemas
+ */
+export declare const EntityAddressFromSelf: Schema.Schema<EntityAddress>;
+export {};
+//# sourceMappingURL=EntityAddress.d.ts.map
\ No newline at end of file
diff --git a/dist/dts/EntityAddress.d.ts.map b/dist/dts/EntityAddress.d.ts.map
new file mode 100644
index 0000000000000000000000000000000000000000..f4cb12ee2353f90c617c529ab57fe27db247a8d5
--- /dev/null
+++ b/dist/dts/EntityAddress.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"EntityAddress.d.ts","sourceRoot":"","sources":["../../src/EntityAddress.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,OAAO,KAAK,IAAI,MAAM,aAAa,CAAA;AACnC,OAAO,KAAK,MAAM,MAAM,eAAe,CAAA;AAOvC;;;GAGG;AACH,eAAO,MAAM,MAAM,EAAE,OAAO,MAA8B,CAAA;AAE1D;;;GAGG;AACH,MAAM,MAAM,MAAM,GAAG,OAAO,MAAM,CAAA;;;;;;;;;;;;;;;;AAElC;;;;;GAKG;AACH,qBAAa,aAAc,SAAQ,kBAIjC;IACA;;OAEG;IACH,QAAQ,CAAC,CAAC,MAAM,CAAC,SAAU;IAC3B;;OAEG;IACH,CAAC,IAAI,CAAC,MAAM,CAAC;CAGd;AAED;;;;;GAKG;AACH,eAAO,MAAM,qBAAqB,EAAE,MAAM,CAAC,MAAM,CAAC,aAAa,CAE9D,CAAA"}
\ No newline at end of file
diff --git a/dist/dts/EntityId.d.ts b/dist/dts/EntityId.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..56b4a988e8f160f8266b47fb76d22568f8ea6d6b
--- /dev/null
+++ b/dist/dts/EntityId.d.ts
@@ -0,0 +1,15 @@
+/**
+ * @since 1.0.0
+ */
+import * as Schema from "effect/Schema";
+/**
+ * @since 1.0.0
+ * @category constructors
+ */
+export declare const EntityId: Schema.brand<typeof Schema.NonEmptyTrimmedString, "EntityId">;
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export type EntityId = typeof EntityId.Type;
+//# sourceMappingURL=EntityId.d.ts.map
\ No newline at end of file
diff --git a/dist/dts/EntityId.d.ts.map b/dist/dts/EntityId.d.ts.map
new file mode 100644
index 0000000000000000000000000000000000000000..0d5ded9dbfaff7a33dc5117f90b74f6af55d58fc
--- /dev/null
+++ b/dist/dts/EntityId.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"EntityId.d.ts","sourceRoot":"","sources":["../../src/EntityId.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,OAAO,KAAK,MAAM,MAAM,eAAe,CAAA;AAEvC;;;GAGG;AACH,eAAO,MAAM,QAAQ,+DAA8D,CAAA;AAEnF;;;GAGG;AACH,MAAM,MAAM,QAAQ,GAAG,OAAO,QAAQ,CAAC,IAAI,CAAA"}
\ No newline at end of file
diff --git a/dist/dts/EntityType.d.ts b/dist/dts/EntityType.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7df5fe562cb75a85eb24dc93c5bb9e5e2ed6fe1d
--- /dev/null
+++ b/dist/dts/EntityType.d.ts
@@ -0,0 +1,15 @@
+/**
+ * @since 1.0.0
+ */
+import * as Schema from "effect/Schema";
+/**
+ * @since 1.0.0
+ * @category constructors
+ */
+export declare const EntityType: Schema.brand<typeof Schema.NonEmptyTrimmedString, "EntityType">;
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export type EntityType = typeof EntityType.Type;
+//# sourceMappingURL=EntityType.d.ts.map
\ No newline at end of file
diff --git a/dist/dts/EntityType.d.ts.map b/dist/dts/EntityType.d.ts.map
new file mode 100644
index 0000000000000000000000000000000000000000..50dd9c5bd6b532701c792b935f2843f240fe9f8c
--- /dev/null
+++ b/dist/dts/EntityType.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"EntityType.d.ts","sourceRoot":"","sources":["../../src/EntityType.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,OAAO,KAAK,MAAM,MAAM,eAAe,CAAA;AAEvC;;;GAGG;AACH,eAAO,MAAM,UAAU,iEAAgE,CAAA;AAEvF;;;GAGG;AACH,MAAM,MAAM,UAAU,GAAG,OAAO,UAAU,CAAC,IAAI,CAAA"}
\ No newline at end of file
diff --git a/dist/dts/Envelope.d.ts b/dist/dts/Envelope.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b391bf0b2ecc483d68f6844a7ec5c16dcae8e36c
--- /dev/null
+++ b/dist/dts/Envelope.d.ts
@@ -0,0 +1,252 @@
+/**
+ * @since 1.0.0
+ */
+import * as Headers from "@effect/platform/Headers";
+import type * as Rpc from "@effect/rpc/Rpc";
+import type { ReadonlyRecord } from "effect/Record";
+import * as Schema from "effect/Schema";
+import { EntityAddress } from "./EntityAddress.js";
+import { type Snowflake } from "./Snowflake.js";
+/**
+ * @since 1.0.0
+ * @category type ids
+ */
+export declare const TypeId: unique symbol;
+/**
+ * @since 1.0.0
+ * @category type ids
+ */
+export type TypeId = typeof TypeId;
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export type Envelope<R extends Rpc.Any> = Request<R> | AckChunk | Interrupt;
+/**
+ * @since 1.0.0
+ */
+export declare namespace Envelope {
+    /**
+     * @since 1.0.0
+     * @category models
+     */
+    type Any = Envelope<any>;
+    /**
+     * @since 1.0.0
+     * @category models
+     */
+    type Encoded = Request.Encoded | typeof AckChunk.Encoded | typeof Interrupt.Encoded;
+    /**
+     * @since 1.0.0
+     * @category models
+     */
+    type PartialEncoded = Request.PartialEncoded | AckChunk | Interrupt;
+}
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export interface Request<in out Rpc extends Rpc.Any> {
+    readonly [TypeId]: TypeId;
+    readonly _tag: "Request";
+    readonly requestId: Snowflake;
+    readonly address: EntityAddress;
+    readonly tag: Rpc.Tag<Rpc>;
+    readonly payload: Rpc.Payload<Rpc>;
+    readonly headers: Headers.Headers;
+    readonly traceId: string;
+    readonly spanId: string;
+    readonly sampled: boolean;
+}
+declare const AckChunk_base: Schema.TaggedClass<AckChunk, "AckChunk", {
+    readonly _tag: Schema.tag<"AckChunk">;
+} & {
+    id: Schema.Schema<Snowflake, string, never>;
+    address: typeof EntityAddress;
+    requestId: Schema.Schema<Snowflake, string, never>;
+    replyId: Schema.Schema<Snowflake, string, never>;
+}>;
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export declare class AckChunk extends AckChunk_base {
+    /**
+     * @since 1.0.0
+     */
+    readonly [TypeId]: TypeId;
+    /**
+     * @since 1.0.0
+     */
+    withRequestId(requestId: Snowflake): AckChunk;
+}
+declare const Interrupt_base: Schema.TaggedClass<Interrupt, "Interrupt", {
+    readonly _tag: Schema.tag<"Interrupt">;
+} & {
+    id: Schema.Schema<Snowflake, string, never>;
+    address: typeof EntityAddress;
+    requestId: Schema.Schema<Snowflake, string, never>;
+}>;
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export declare class Interrupt extends Interrupt_base {
+    /**
+     * @since 1.0.0
+     */
+    readonly [TypeId]: TypeId;
+    /**
+     * @since 1.0.0
+     */
+    withRequestId(requestId: Snowflake): Interrupt;
+}
+/**
+ * @since 1.0.0
+ */
+export declare namespace Request {
+    /**
+     * @since 1.0.0
+     * @category models
+     */
+    type Any = Request<any>;
+    /**
+     * @since 1.0.0
+     * @category models
+     */
+    interface Encoded {
+        readonly _tag: "Request";
+        readonly requestId: string;
+        readonly address: typeof EntityAddress.Encoded;
+        readonly tag: string;
+        readonly payload: unknown;
+        readonly headers: ReadonlyRecord<string, string>;
+        readonly traceId: string;
+        readonly spanId: string;
+        readonly sampled: boolean;
+    }
+    /**
+     * @since 1.0.0
+     * @category models
+     */
+    interface PartialEncoded {
+        readonly _tag: "Request";
+        readonly requestId: Snowflake;
+        readonly address: EntityAddress;
+        readonly tag: string;
+        readonly payload: unknown;
+        readonly headers: Headers.Headers;
+        readonly traceId: string;
+        readonly spanId: string;
+        readonly sampled: boolean;
+    }
+}
+/**
+ * @since 1.0.0
+ * @category refinements
+ */
+export declare const isEnvelope: (u: unknown) => u is Envelope<any>;
+/**
+ * @since 1.0.0
+ * @category constructors
+ */
+export declare const makeRequest: <Rpc extends Rpc.Any>(options: {
+    readonly requestId: Snowflake;
+    readonly address: EntityAddress;
+    readonly tag: Rpc.Tag<Rpc>;
+    readonly payload: Rpc.Payload<Rpc>;
+    readonly headers: Headers.Headers;
+    readonly traceId: string;
+    readonly spanId: string;
+    readonly sampled: boolean;
+}) => Request<Rpc>;
+/**
+ * @since 1.0.0
+ * @category serialization / deserialization
+ */
+export declare const EnvelopeFromSelf: Schema.Schema<Envelope.Any, Envelope.Any>;
+/**
+ * @since 1.0.0
+ * @category serialization / deserialization
+ */
+export declare const RequestFromSelf: Schema.Schema<Request.Any, Request.Any>;
+/**
+ * @since 1.0.0
+ * @category serialization / deserialization
+ */
+export declare const PartialEncodedRequest: Schema.Struct<{
+    _tag: Schema.Literal<["Request"]>;
+    requestId: Schema.Schema<Snowflake, string>;
+    address: typeof EntityAddress;
+    tag: typeof Schema.String;
+    payload: typeof Schema.Unknown;
+    headers: Schema.Schema<Headers.Headers, ReadonlyRecord<string, string>>;
+    traceId: typeof Schema.String;
+    spanId: typeof Schema.String;
+    sampled: typeof Schema.Boolean;
+}>;
+/**
+ * @since 1.0.0
+ * @category serialization / deserialization
+ */
+export declare const PartialEncoded: Schema.Union<[
+    Schema.Struct<{
+        _tag: Schema.Literal<["Request"]>;
+        requestId: Schema.Schema<Snowflake, string>;
+        address: typeof EntityAddress;
+        tag: typeof Schema.String;
+        payload: typeof Schema.Unknown;
+        headers: Schema.Schema<Headers.Headers, ReadonlyRecord<string, string>>;
+        traceId: typeof Schema.String;
+        spanId: typeof Schema.String;
+        sampled: typeof Schema.Boolean;
+    }>,
+    typeof AckChunk,
+    typeof Interrupt
+]>;
+/**
+ * @since 1.0.0
+ * @category serialization / deserialization
+ */
+export declare const PartialEncodedArray: Schema.Schema<Array<Envelope.PartialEncoded>, Array<Envelope.Encoded>>;
+/**
+ * @since 1.0.0
+ * @category serialization / deserialization
+ */
+export declare const PartialEncodedRequestFromSelf: Schema.Struct<{
+    _tag: Schema.Literal<["Request"]>;
+    requestId: Schema.Schema<Snowflake>;
+    address: Schema.Schema<EntityAddress>;
+    tag: typeof Schema.String;
+    payload: typeof Schema.Unknown;
+    headers: Schema.Schema<Headers.Headers>;
+    traceId: typeof Schema.String;
+    spanId: typeof Schema.String;
+    sampled: typeof Schema.Boolean;
+}>;
+/**
+ * @since 1.0.0
+ * @category serialization / deserialization
+ */
+export declare const PartialEncodedFromSelf: Schema.Union<[
+    Schema.Struct<{
+        _tag: Schema.Literal<["Request"]>;
+        requestId: Schema.Schema<Snowflake>;
+        address: Schema.Schema<EntityAddress>;
+        tag: typeof Schema.String;
+        payload: typeof Schema.Unknown;
+        headers: Schema.Schema<Headers.Headers>;
+        traceId: typeof Schema.String;
+        spanId: typeof Schema.String;
+        sampled: typeof Schema.Boolean;
+    }>,
+    Schema.Schema<AckChunk>,
+    Schema.Schema<Interrupt>
+]>;
+/**
+ * @since 1.0.0
+ * @category primary key
+ */
+export declare const primaryKey: <R extends Rpc.Any>(envelope: Envelope<R>) => string | null;
+export {};
+//# sourceMappingURL=Envelope.d.ts.map
\ No newline at end of file
diff --git a/dist/dts/Envelope.d.ts.map b/dist/dts/Envelope.d.ts.map
new file mode 100644
index 0000000000000000000000000000000000000000..ae9478f6ac7cccf6b82bb21e844dbce2c3028051
--- /dev/null
+++ b/dist/dts/Envelope.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"Envelope.d.ts","sourceRoot":"","sources":["../../src/Envelope.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/dts/HttpCommon.d.ts b/dist/dts/HttpCommon.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..543b09aa22f514e74e40802a2077a5b342ae1b0a
--- /dev/null
+++ b/dist/dts/HttpCommon.d.ts
@@ -0,0 +1,25 @@
+/**
+ * @since 1.0.0
+ */
+import * as HttpClient from "@effect/platform/HttpClient";
+import * as Socket from "@effect/platform/Socket";
+import * as RpcSerialization from "@effect/rpc/RpcSerialization";
+import * as Layer from "effect/Layer";
+import { RpcClientProtocol } from "./Runners.js";
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export declare const layerClientProtocolHttp: (options: {
+    readonly path: string;
+    readonly https?: boolean | undefined;
+}) => Layer.Layer<RpcClientProtocol, never, RpcSerialization.RpcSerialization | HttpClient.HttpClient>;
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export declare const layerClientProtocolWebsocket: (options: {
+    readonly path: string;
+    readonly https?: boolean | undefined;
+}) => Layer.Layer<RpcClientProtocol, never, RpcSerialization.RpcSerialization | Socket.WebSocketConstructor>;
+//# sourceMappingURL=HttpCommon.d.ts.map
\ No newline at end of file
diff --git a/dist/dts/HttpCommon.d.ts.map b/dist/dts/HttpCommon.d.ts.map
new file mode 100644
index 0000000000000000000000000000000000000000..4a7da23be32e40ee6e53377c6a0a3b86413e94e1
--- /dev/null
+++ b/dist/dts/HttpCommon.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"HttpCommon.d.ts","sourceRoot":"","sources":["../../src/HttpCommon.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,OAAO,KAAK,UAAU,MAAM,6BAA6B,CAAA;AAEzD,OAAO,KAAK,MAAM,MAAM,yBAAyB,CAAA;AAEjD,OAAO,KAAK,gBAAgB,MAAM,8BAA8B,CAAA;AAEhE,OAAO,KAAK,KAAK,MAAM,cAAc,CAAA;AACrC,OAAO,EAAE,iBAAiB,EAAE,MAAM,cAAc,CAAA;AAEhD;;;GAGG;AACH,eAAO,MAAM,uBAAuB,YAAa;IAC/C,QAAQ,CAAC,IAAI,EAAE,MAAM,CAAA;IACrB,QAAQ,CAAC,KAAK,CAAC,EAAE,OAAO,GAAG,SAAS,CAAA;CACrC,KAAG,KAAK,CAAC,KAAK,CACb,iBAAiB,EACjB,KAAK,EACL,gBAAgB,CAAC,gBAAgB,GAAG,UAAU,CAAC,UAAU,CAkBxD,CAAA;AAEH;;;GAGG;AACH,eAAO,MAAM,4BAA4B,YAAa;IACpD,QAAQ,CAAC,IAAI,EAAE,MAAM,CAAA;IACrB,QAAQ,CAAC,KAAK,CAAC,EAAE,OAAO,GAAG,SAAS,CAAA;CACrC,KAAG,KAAK,CAAC,KAAK,CACb,iBAAiB,EACjB,KAAK,EACL,gBAAgB,CAAC,gBAAgB,GAAG,MAAM,CAAC,oBAAoB,CAoB9D,CAAA"}
\ No newline at end of file
diff --git a/dist/dts/HttpRunner.d.ts b/dist/dts/HttpRunner.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4e40d4bc0a445e4a2c1bc539b9c790381a229723
--- /dev/null
+++ b/dist/dts/HttpRunner.d.ts
@@ -0,0 +1,76 @@
+/**
+ * @since 1.0.0
+ */
+import type * as HttpApp from "@effect/platform/HttpApp";
+import type * as HttpClient from "@effect/platform/HttpClient";
+import * as HttpRouter from "@effect/platform/HttpRouter";
+import * as HttpServer from "@effect/platform/HttpServer";
+import type * as Socket from "@effect/platform/Socket";
+import type * as RpcSerialization from "@effect/rpc/RpcSerialization";
+import * as Effect from "effect/Effect";
+import * as Layer from "effect/Layer";
+import type { Scope } from "effect/Scope";
+import type { MessageStorage } from "./MessageStorage.js";
+import * as Runners from "./Runners.js";
+import * as Sharding from "./Sharding.js";
+import type * as ShardingConfig from "./ShardingConfig.js";
+import type { ShardStorage } from "./ShardStorage.js";
+/**
+ * @since 1.0.0
+ * @category Http App
+ */
+export declare const toHttpApp: Effect.Effect<HttpApp.Default<never, Scope>, never, Scope | Sharding.Sharding | RpcSerialization.RpcSerialization | MessageStorage>;
+/**
+ * @since 1.0.0
+ * @category Http App
+ */
+export declare const toHttpAppWebsocket: Effect.Effect<HttpApp.Default<never, Scope>, never, Scope | Sharding.Sharding | RpcSerialization.RpcSerialization | MessageStorage>;
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export declare const layerClient: Layer.Layer<Sharding.Sharding | Runners.Runners, never, ShardingConfig.ShardingConfig | Runners.RpcClientProtocol | MessageStorage | ShardStorage>;
+/**
+ * A HTTP layer for the `Runners` services, that adds a route to the provided
+ * `HttpRouter.Tag`.
+ *
+ * By default, it uses the `HttpRouter.Default` tag.
+ *
+ * @since 1.0.0
+ * @category Layers
+ */
+export declare const layer: <I = HttpRouter.Default>(options: {
+    readonly path: HttpRouter.PathInput;
+    readonly routerTag?: HttpRouter.HttpRouter.TagClass<I, string, any, any>;
+    readonly logAddress?: boolean | undefined;
+}) => Layer.Layer<Sharding.Sharding | Runners.Runners, never, RpcSerialization.RpcSerialization | ShardingConfig.ShardingConfig | Runners.RpcClientProtocol | HttpServer.HttpServer | MessageStorage | ShardStorage>;
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export declare const layerWebsocketOptions: <I = HttpRouter.Default>(options: {
+    readonly path: HttpRouter.PathInput;
+    readonly routerTag?: HttpRouter.HttpRouter.TagClass<I, string, any, any>;
+    readonly logAddress?: boolean | undefined;
+}) => Layer.Layer<Sharding.Sharding | Runners.Runners, never, RpcSerialization.RpcSerialization | ShardingConfig.ShardingConfig | Runners.RpcClientProtocol | HttpServer.HttpServer | MessageStorage | ShardStorage>;
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export declare const layerHttp: Layer.Layer<Sharding.Sharding | Runners.Runners, never, RpcSerialization.RpcSerialization | ShardingConfig.ShardingConfig | HttpClient.HttpClient | HttpServer.HttpServer | MessageStorage | ShardStorage>;
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export declare const layerHttpClientOnly: Layer.Layer<Sharding.Sharding | Runners.Runners, never, RpcSerialization.RpcSerialization | ShardingConfig.ShardingConfig | HttpClient.HttpClient | MessageStorage>;
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export declare const layerWebsocket: Layer.Layer<Sharding.Sharding | Runners.Runners, never, RpcSerialization.RpcSerialization | ShardingConfig.ShardingConfig | Socket.WebSocketConstructor | HttpServer.HttpServer | MessageStorage | ShardStorage>;
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export declare const layerWebsocketClientOnly: Layer.Layer<Sharding.Sharding | Runners.Runners, never, ShardingConfig.ShardingConfig | MessageStorage | RpcSerialization.RpcSerialization | Socket.WebSocketConstructor>;
+//# sourceMappingURL=HttpRunner.d.ts.map
\ No newline at end of file
diff --git a/dist/dts/HttpRunner.d.ts.map b/dist/dts/HttpRunner.d.ts.map
new file mode 100644
index 0000000000000000000000000000000000000000..70f7c748009972c9b6fd98c237150baf00f1833f
--- /dev/null
+++ b/dist/dts/HttpRunner.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"HttpRunner.d.ts","sourceRoot":"","sources":["../../src/HttpRunner.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/dts/HttpShardManager.d.ts b/dist/dts/HttpShardManager.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3b3c391a6fd146aaae5fdfcf00224dc4f413be85
--- /dev/null
+++ b/dist/dts/HttpShardManager.d.ts
@@ -0,0 +1,119 @@
+/**
+ * @since 1.0.0
+ */
+import type * as HttpApp from "@effect/platform/HttpApp";
+import type * as HttpClient from "@effect/platform/HttpClient";
+import * as HttpRouter from "@effect/platform/HttpRouter";
+import * as HttpServer from "@effect/platform/HttpServer";
+import type * as Socket from "@effect/platform/Socket";
+import type * as RpcSerialization from "@effect/rpc/RpcSerialization";
+import * as Effect from "effect/Effect";
+import * as Layer from "effect/Layer";
+import type { Scope } from "effect/Scope";
+import * as RunnerHealth from "./RunnerHealth.js";
+import type { ShardingConfig } from "./ShardingConfig.js";
+import * as ShardManager from "./ShardManager.js";
+import type { ShardStorage } from "./ShardStorage.js";
+/**
+ * @since 1.0.0
+ * @category Http App
+ */
+export declare const toHttpApp: Effect.Effect<HttpApp.Default<never, Scope>, never, Scope | RpcSerialization.RpcSerialization | ShardManager.ShardManager>;
+/**
+ * @since 1.0.0
+ * @category Http App
+ */
+export declare const toHttpAppWebsocket: Effect.Effect<HttpApp.Default<never, Scope>, never, Scope | RpcSerialization.RpcSerialization | ShardManager.ShardManager>;
+/**
+ * A layer for the `ShardManager` service, that does not run a server.
+ *
+ * It only provides the `Runners` rpc client.
+ *
+ * You can use this with the `toHttpApp` and `toHttpAppWebsocket` apis
+ * to run a complete `ShardManager` server.
+ *
+ * @since 1.0.0
+ * @category Layers
+ */
+export declare const layerNoServerHttp: (options: {
+    readonly runnerPath: string;
+    readonly runnerHttps?: boolean | undefined;
+}) => Layer.Layer<ShardManager.ShardManager, never, RpcSerialization.RpcSerialization | ShardStorage | RunnerHealth.RunnerHealth | HttpClient.HttpClient | ShardManager.Config | ShardingConfig>;
+/**
+ * A layer for the `ShardManager` service, that does not run a server.
+ *
+ * It only provides the `Runners` rpc client.
+ *
+ * You can use this with the `toHttpApp` and `toHttpAppWebsocket` apis
+ * to run a complete `ShardManager` server.
+ *
+ * @since 1.0.0
+ * @category Layers
+ */
+export declare const layerNoServerWebsocket: (options: {
+    readonly runnerPath: string;
+    readonly runnerHttps?: boolean | undefined;
+}) => Layer.Layer<ShardManager.ShardManager, never, RpcSerialization.RpcSerialization | ShardStorage | RunnerHealth.RunnerHealth | Socket.WebSocketConstructor | ShardManager.Config | ShardingConfig>;
+/**
+ * A HTTP layer for the `ShardManager` server, that adds a route to the provided
+ * `HttpRouter.Tag`.
+ *
+ * By default, it uses the `HttpRouter.Default` tag.
+ *
+ * @since 1.0.0
+ * @category Layers
+ */
+export declare const layerHttpOptions: <I = HttpRouter.Default>(options: {
+    readonly path: HttpRouter.PathInput;
+    readonly routerTag?: HttpRouter.HttpRouter.TagClass<I, string, any, any>;
+    readonly runnerPath: string;
+    readonly runnerHttps?: boolean | undefined;
+    readonly logAddress?: boolean | undefined;
+}) => Layer.Layer<ShardManager.ShardManager, never, RpcSerialization.RpcSerialization | ShardStorage | RunnerHealth.RunnerHealth | HttpClient.HttpClient | HttpServer.HttpServer | ShardManager.Config | ShardingConfig>;
+/**
+ * A WebSocket layer for the `ShardManager` server, that adds a route to the provided
+ * `HttpRouter.Tag`.
+ *
+ * By default, it uses the `HttpRouter.Default` tag.
+ *
+ * @since 1.0.0
+ * @category Layers
+ */
+export declare const layerWebsocketOptions: <I = HttpRouter.Default>(options: {
+    readonly path: HttpRouter.PathInput;
+    readonly routerTag?: HttpRouter.HttpRouter.TagClass<I, string, any, any>;
+    readonly runnerPath: string;
+    readonly runnerHttps?: boolean | undefined;
+    readonly logAddress?: boolean | undefined;
+}) => Layer.Layer<ShardManager.ShardManager, never, RpcSerialization.RpcSerialization | ShardStorage | RunnerHealth.RunnerHealth | HttpServer.HttpServer | Socket.WebSocketConstructor | ShardManager.Config | ShardingConfig>;
+/**
+ * A HTTP layer for the `ShardManager` server, that adds a route to the provided
+ * `HttpRouter.Tag`.
+ *
+ * By default, it uses the `HttpRouter.Default` tag.
+ *
+ * @since 1.0.0
+ * @category Layers
+ */
+export declare const layerHttp: Layer.Layer<ShardManager.ShardManager, never, RpcSerialization.RpcSerialization | ShardStorage | RunnerHealth.RunnerHealth | HttpClient.HttpClient | HttpServer.HttpServer | ShardManager.Config | ShardingConfig>;
+/**
+ * A Websocket layer for the `ShardManager` server, that adds a route to the provided
+ * `HttpRouter.Tag`.
+ *
+ * By default, it uses the `HttpRouter.Default` tag.
+ *
+ * @since 1.0.0
+ * @category Layers
+ */
+export declare const layerWebsocket: Layer.Layer<ShardManager.ShardManager, never, RpcSerialization.RpcSerialization | ShardStorage | RunnerHealth.RunnerHealth | Socket.WebSocketConstructor | HttpServer.HttpServer | ShardManager.Config | ShardingConfig>;
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export declare const layerRunnerHealthHttp: Layer.Layer<RunnerHealth.RunnerHealth, never, RpcSerialization.RpcSerialization | HttpClient.HttpClient | ShardingConfig>;
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export declare const layerRunnerHealthWebsocket: Layer.Layer<RunnerHealth.RunnerHealth, never, RpcSerialization.RpcSerialization | Socket.WebSocketConstructor | ShardingConfig>;
+//# sourceMappingURL=HttpShardManager.d.ts.map
\ No newline at end of file
diff --git a/dist/dts/HttpShardManager.d.ts.map b/dist/dts/HttpShardManager.d.ts.map
new file mode 100644
index 0000000000000000000000000000000000000000..8858d5edd82e20b0dfef5024003ec5c15fe941a8
--- /dev/null
+++ b/dist/dts/HttpShardManager.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"HttpShardManager.d.ts","sourceRoot":"","sources":["../../src/HttpShardManager.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/dts/MachineId.d.ts b/dist/dts/MachineId.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1a4e193bfec3cc201abd01b73e96627f1ccfb2ba
--- /dev/null
+++ b/dist/dts/MachineId.d.ts
@@ -0,0 +1,20 @@
+/**
+ * @since 1.0.0
+ */
+import * as Schema from "effect/Schema";
+/**
+ * @since 1.0.0
+ * @category constructors
+ */
+export declare const MachineId: Schema.brand<typeof Schema.Int, "MachineId">;
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export type MachineId = typeof MachineId.Type;
+/**
+ * @since 1.0.0
+ * @category Constructors
+ */
+export declare const make: (shardId: number) => MachineId;
+//# sourceMappingURL=MachineId.d.ts.map
\ No newline at end of file
diff --git a/dist/dts/MachineId.d.ts.map b/dist/dts/MachineId.d.ts.map
new file mode 100644
index 0000000000000000000000000000000000000000..cb58dd40b41b0748151539df624d3d34e9c79810
--- /dev/null
+++ b/dist/dts/MachineId.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"MachineId.d.ts","sourceRoot":"","sources":["../../src/MachineId.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,OAAO,KAAK,MAAM,MAAM,eAAe,CAAA;AAEvC;;;GAGG;AACH,eAAO,MAAM,SAAS,8CAKrB,CAAA;AAED;;;GAGG;AACH,MAAM,MAAM,SAAS,GAAG,OAAO,SAAS,CAAC,IAAI,CAAA;AAE7C;;;GAGG;AACH,eAAO,MAAM,IAAI,YAAa,MAAM,KAAG,SAAoC,CAAA"}
\ No newline at end of file
diff --git a/dist/dts/Message.d.ts b/dist/dts/Message.d.ts
index d69a9dfd3fc609943a264e1d7e4effab38627625..930ccb9a122312a5dde25d495b35c8f92df303e8 100644
--- a/dist/dts/Message.d.ts
+++ b/dist/dts/Message.d.ts
@@ -1,105 +1,122 @@
 /**
  * @since 1.0.0
  */
-import type * as Exit_ from "effect/Exit";
-import type * as PrimaryKey from "effect/PrimaryKey";
-import type * as Schema from "effect/Schema";
-import type * as Types from "effect/Types";
+import type * as Rpc from "@effect/rpc/Rpc";
+import type { Context } from "effect/Context";
+import * as Effect from "effect/Effect";
+import * as Option from "effect/Option";
+import type { PersistenceError } from "./ClusterError.js";
+import { MalformedMessage } from "./ClusterError.js";
+import * as Envelope from "./Envelope.js";
+import type * as Reply from "./Reply.js";
 /**
- * A Message is a request for an entity that will process it.
- * A Message also has a PrimaryKey so that the receiver is eventually able to detect duplicated messages.
- *
  * @since 1.0.0
- * @category models
+ * @category incoming
  */
-export interface Message<A, AI, E, EI> extends Schema.SerializableWithResult<any, any, never, A, AI, E, EI, never>, PrimaryKey.PrimaryKey {
+export type Incoming<R extends Rpc.Any> = IncomingRequest<R> | IncomingEnvelope;
+/**
+ * @since 1.0.0
+ * @category incoming
+ */
+export type IncomingLocal<R extends Rpc.Any> = IncomingRequestLocal<R> | IncomingEnvelope;
+/**
+ * @since 1.0.0
+ * @category incoming
+ */
+export declare const incomingLocalFromOutgoing: <R extends Rpc.Any>(self: Outgoing<R>) => IncomingLocal<R>;
+declare const IncomingRequest_base: new <A extends Record<string, any> = {}>(args: import("effect/Types").Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => Readonly<A> & {
+    readonly _tag: "IncomingRequest";
+};
+/**
+ * @since 1.0.0
+ * @category incoming
+ */
+export declare class IncomingRequest<R extends Rpc.Any> extends IncomingRequest_base<{
+    readonly envelope: Envelope.Request.PartialEncoded;
+    readonly lastSentReply: Option.Option<Reply.ReplyEncoded<R>>;
+    readonly respond: (reply: Reply.ReplyWithContext<R>) => Effect.Effect<void, MalformedMessage | PersistenceError>;
+}> {
 }
+declare const IncomingRequestLocal_base: new <A extends Record<string, any> = {}>(args: import("effect/Types").Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => Readonly<A> & {
+    readonly _tag: "IncomingRequestLocal";
+};
 /**
  * @since 1.0.0
- * @category models
+ * @category outgoing
  */
-export declare namespace Message {
-    /**
-     * @since 1.0.0
-     * @category models
-     */
-    type Any = Message<any, any, any, any> | Message<any, any, never, never>;
-    /**
-     * Extracts the success type from a `Message`.
-     *
-     * @since 1.0.0
-     * @category utils
-     */
-    type Success<S> = S extends Message<infer A, infer _AI, infer _E, infer _EI> ? A : never;
-    /**
-     * Extracts the success type from a `Message`.
-     *
-     * @since 1.0.0
-     * @category utils
-     */
-    type SuccessEncoded<S> = S extends Message<infer _A, infer _AI, infer _E, infer _EI> ? _AI : never;
-    /**
-     * Extracts the error type from a `Message`.
-     *
-     * @since 1.0.0
-     * @category utils
-     */
-    type Error<S> = S extends Message<infer _A, infer _AI, infer E, infer _EI> ? E : never;
-    /**
-     * Extracts the error type from a `Message`.
-     *
-     * @since 1.0.0
-     * @category utils
-     */
-    type ErrorEncoded<S> = S extends Message<infer _A, infer _AI, infer _E, infer _EI> ? _EI : never;
-    /**
-     * Extracts the exit type from a `Message`.
-     *
-     * @since 1.0.0
-     * @category utils
-     */
-    type Exit<S> = S extends Schema.WithResult<infer A, infer _AI, infer E, infer _EI, infer _R> ? Exit_.Exit<A, E> : never;
+export declare class IncomingRequestLocal<R extends Rpc.Any> extends IncomingRequestLocal_base<{
+    readonly envelope: Envelope.Request<R>;
+    readonly lastSentReply: Option.Option<Reply.Reply<R>>;
+    readonly respond: (reply: Reply.Reply<R>) => Effect.Effect<void, MalformedMessage | PersistenceError>;
+}> {
 }
+declare const IncomingEnvelope_base: new <A extends Record<string, any> = {}>(args: import("effect/Types").Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => Readonly<A> & {
+    readonly _tag: "IncomingEnvelope";
+};
 /**
  * @since 1.0.0
- * @category schemas
+ * @category incoming
  */
-export interface TaggedMessageConstructor<Tag extends string, Self, R, IS, S, IE, E, IA, A> extends Schema.Schema<Self, Types.Simplify<IS & {
-    readonly _tag: Tag;
-}>, R> {
-    new (props: Types.Equals<S, {}> extends true ? void : S, disableValidation?: boolean): Schema.TaggedRequest<Tag, S, IS & {
-        readonly _tag: Tag;
-    }, never, A, IA, E, IE, never> & S & PrimaryKey.PrimaryKey;
+export declare class IncomingEnvelope extends IncomingEnvelope_base<{
+    readonly _tag: "IncomingEnvelope";
+    readonly envelope: Envelope.AckChunk | Envelope.Interrupt;
+}> {
 }
 /**
  * @since 1.0.0
- * @category schemas
+ * @category outgoing
  */
-export declare const TaggedMessage: <Self>() => <Tag extends string, E, IE, A, IA, Fields extends Schema.Struct.Fields>(tag: Tag, failure: Schema.Schema<E, IE, never>, success: Schema.Schema<A, IA, never>, fields: Fields, messageToId: (message: Schema.Struct.Encoded<Fields>) => string) => TaggedMessageConstructor<Tag, Self, Schema.Schema.Context<Fields[keyof Fields]>, Types.Simplify<Schema.Struct.Encoded<Fields>>, Types.Simplify<Schema.Struct.Type<Fields>>, IE, E, IA, A>;
+export type Outgoing<R extends Rpc.Any> = OutgoingRequest<R> | OutgoingEnvelope;
+declare const OutgoingRequest_base: new <A extends Record<string, any> = {}>(args: import("effect/Types").Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => Readonly<A> & {
+    readonly _tag: "OutgoingRequest";
+};
+/**
+ * @since 1.0.0
+ * @category outgoing
+ */
+export declare class OutgoingRequest<R extends Rpc.Any> extends OutgoingRequest_base<{
+    readonly envelope: Envelope.Request<R>;
+    readonly context: Context<Rpc.Context<R>>;
+    readonly lastReceivedReply: Option.Option<Reply.Reply<R>>;
+    readonly rpc: R;
+    readonly respond: (reply: Reply.Reply<R>) => Effect.Effect<void, PersistenceError>;
+}> {
+    /**
+     * @since 1.0.0
+     */
+    encodedCache?: Envelope.Request.PartialEncoded;
+}
+declare const OutgoingEnvelope_base: new <A extends Record<string, any> = {}>(args: import("effect/Types").Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => Readonly<A> & {
+    readonly _tag: "OutgoingEnvelope";
+};
+/**
+ * @since 1.0.0
+ * @category outgoing
+ */
+export declare class OutgoingEnvelope extends OutgoingEnvelope_base<{
+    readonly envelope: Envelope.AckChunk | Envelope.Interrupt;
+    readonly rpc: Rpc.AnyWithProps;
+}> {
+}
 /**
  * @since 1.0.0
- * @category utils
+ * @category serialization / deserialization
  */
-export declare const isMessageWithResult: (value: unknown) => value is Message<unknown, unknown, unknown, unknown>;
+export declare const serialize: <Rpc extends Rpc.Any>(message: Outgoing<Rpc>) => Effect.Effect<Envelope.Envelope.PartialEncoded, MalformedMessage>;
 /**
- * Extracts the exit schema from a Message. This schema will be used to encode the remote exit of the Message processor.
- *
  * @since 1.0.0
- * @category utils
+ * @category serialization / deserialization
  */
-export declare const exitSchema: <A extends Message.Any>(message: A) => Schema.Schema<Message.Exit<A>, unknown>;
+export declare const serializeEnvelope: <Rpc extends Rpc.Any>(message: Outgoing<Rpc>) => Effect.Effect<Envelope.Envelope.Encoded, MalformedMessage>;
 /**
- * Extracts the failure schema from a Message. This schema will be used to encode remote failures of the Message processor.
- *
  * @since 1.0.0
- * @category utils
+ * @category serialization / deserialization
  */
-export declare const failureSchema: <A extends Message.Any>(message: A) => Schema.Schema<Message.Error<A>, unknown>;
+export declare const serializeRequest: <Rpc extends Rpc.Any>(self: OutgoingRequest<Rpc>) => Effect.Effect<Envelope.Request.PartialEncoded, MalformedMessage>;
 /**
- * Extracts the success schema from a Message. This schema will be used to encode the remote success of the Message processor.
- *
  * @since 1.0.0
- * @category utils
+ * @category serialization / deserialization
  */
-export declare const successSchema: <A extends Message.Any>(message: A) => Schema.Schema<Message.Success<A>, unknown>;
+export declare const deserializeLocal: <Rpc extends Rpc.Any>(self: Outgoing<Rpc>, encoded: Envelope.Envelope.PartialEncoded) => Effect.Effect<IncomingLocal<Rpc>, MalformedMessage>;
+export {};
 //# sourceMappingURL=Message.d.ts.map
\ No newline at end of file
diff --git a/dist/dts/Message.d.ts.map b/dist/dts/Message.d.ts.map
index 3263a7c794f01b6a4e032b1e427ab98d4fd35af4..8ffe5c5a3c4ddec47d98b8e39d34ce3c1a0ed6aa 100644
--- a/dist/dts/Message.d.ts.map
+++ b/dist/dts/Message.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"Message.d.ts","sourceRoot":"","sources":["../../src/Message.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"Message.d.ts","sourceRoot":"","sources":["../../src/Message.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/dts/MessageStorage.d.ts b/dist/dts/MessageStorage.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5619963cb828be83a51777354415962993c4487d
--- /dev/null
+++ b/dist/dts/MessageStorage.d.ts
@@ -0,0 +1,336 @@
+/**
+ * @since 1.0.0
+ */
+import type * as Rpc from "@effect/rpc/Rpc";
+import * as Context from "effect/Context";
+import * as Data from "effect/Data";
+import * as Effect from "effect/Effect";
+import * as Layer from "effect/Layer";
+import * as Option from "effect/Option";
+import type { PersistenceError } from "./ClusterError.js";
+import { MalformedMessage } from "./ClusterError.js";
+import type { EntityAddress } from "./EntityAddress.js";
+import * as Envelope from "./Envelope.js";
+import * as Message from "./Message.js";
+import * as Reply from "./Reply.js";
+import type { ShardId } from "./ShardId.js";
+import type { ShardingConfig } from "./ShardingConfig.js";
+import * as Snowflake from "./Snowflake.js";
+declare const MessageStorage_base: Context.TagClass<MessageStorage, "@effect/cluster/MessageStorage", {
+    /**
+     * Save the provided message and its associated metadata.
+     */
+    readonly saveRequest: <R extends Rpc.Any>(envelope: Message.OutgoingRequest<R>) => Effect.Effect<SaveResult<R>, PersistenceError | MalformedMessage>;
+    /**
+     * Save the provided message and its associated metadata.
+     */
+    readonly saveEnvelope: (envelope: Message.OutgoingEnvelope) => Effect.Effect<void, PersistenceError | MalformedMessage>;
+    /**
+     * Save the provided `Reply` and its associated metadata.
+     */
+    readonly saveReply: <R extends Rpc.Any>(reply: Reply.ReplyWithContext<R>) => Effect.Effect<void, PersistenceError | MalformedMessage>;
+    /**
+     * Retrieves the replies for the specified requests.
+     *
+     * - Un-acknowledged chunk replies
+     * - WithExit replies
+     */
+    readonly repliesFor: <R extends Rpc.Any>(requests: Iterable<Message.OutgoingRequest<R>>) => Effect.Effect<Array<Reply.Reply<R>>, PersistenceError | MalformedMessage>;
+    /**
+     * For locally sent messages, register a handler to process the replies.
+     */
+    readonly registerReplyHandler: <R extends Rpc.Any>(message: Message.OutgoingRequest<R>) => Effect.Effect<void>;
+    /**
+     * Retrieves the unprocessed messages for the specified shards.
+     *
+     * A message is unprocessed when:
+     *
+     * - Requests that have no WithExit replies
+     *   - Or they have no unacknowledged chunk replies
+     * - The latest AckChunk envelope
+     * - All Interrupt's for unprocessed requests
+     */
+    readonly unprocessedMessages: (shardIds: Iterable<ShardId>) => Effect.Effect<Array<Message.Incoming<any>>, PersistenceError>;
+    /**
+     * Retrieves the unprocessed messages by id.
+     */
+    readonly unprocessedMessagesById: <R extends Rpc.Any>(messageIds: Iterable<Snowflake.Snowflake>) => Effect.Effect<Array<Message.Incoming<R>>, PersistenceError>;
+    /**
+     * Reset the mailbox state for the provided address.
+     */
+    readonly resetAddress: (address: EntityAddress) => Effect.Effect<void, PersistenceError>;
+}>;
+/**
+ * @since 1.0.0
+ * @category context
+ */
+export declare class MessageStorage extends MessageStorage_base {
+}
+/**
+ * @since 1.0.0
+ * @category SaveResult
+ */
+export type SaveResult<R extends Rpc.Any> = SaveResult.Success | SaveResult.Duplicate<R>;
+/**
+ * @since 1.0.0
+ * @category SaveResult
+ */
+export declare const SaveResult: {
+    readonly Success: <A>(args: void) => SaveResult.Success;
+    readonly Duplicate: <A>(args: {
+        readonly originalId: Snowflake.Snowflake;
+        readonly lastReceivedReply: Option.Option<Reply.Reply<any>>;
+    }) => SaveResult.Duplicate<any>;
+    readonly $is: <Tag extends "Success" | "Duplicate">(tag: Tag) => {
+        <T extends SaveResult<any>>(u: T): u is T & {
+            readonly _tag: Tag;
+        };
+        (u: unknown): u is Extract<SaveResult.Success, {
+            readonly _tag: Tag;
+        }> | Extract<SaveResult.Duplicate<any>, {
+            readonly _tag: Tag;
+        }>;
+    };
+    readonly $match: {
+        <A, B, C, D, Cases extends {
+            readonly Success: (args: SaveResult.Success) => any;
+            readonly Duplicate: (args: SaveResult.Duplicate<any>) => any;
+        }>(cases: Cases): (self: SaveResult<any>) => import("effect/Unify").Unify<ReturnType<Cases["Success" | "Duplicate"]>>;
+        <A, B, C, D, Cases extends {
+            readonly Success: (args: SaveResult.Success) => any;
+            readonly Duplicate: (args: SaveResult.Duplicate<any>) => any;
+        }>(self: SaveResult<any>, cases: Cases): import("effect/Unify").Unify<ReturnType<Cases["Success" | "Duplicate"]>>;
+    };
+};
+/**
+ * @since 1.0.0
+ * @category SaveResult
+ */
+export declare const SaveResultEncoded: {
+    readonly Success: Data.Case.Constructor<SaveResult.Success, "_tag">;
+    readonly Duplicate: Data.Case.Constructor<SaveResult.DuplicateEncoded, "_tag">;
+    readonly $is: <Tag extends "Success" | "Duplicate">(tag: Tag) => (u: unknown) => u is Extract<SaveResult.Success, {
+        readonly _tag: Tag;
+    }> | Extract<SaveResult.DuplicateEncoded, {
+        readonly _tag: Tag;
+    }>;
+    readonly $match: {
+        <Cases extends {
+            readonly Success: (args: SaveResult.Success) => any;
+            readonly Duplicate: (args: SaveResult.DuplicateEncoded) => any;
+        }>(cases: Cases): (value: SaveResult.Encoded) => import("effect/Unify").Unify<ReturnType<Cases["Success" | "Duplicate"]>>;
+        <Cases extends {
+            readonly Success: (args: SaveResult.Success) => any;
+            readonly Duplicate: (args: SaveResult.DuplicateEncoded) => any;
+        }>(value: SaveResult.Encoded, cases: Cases): import("effect/Unify").Unify<ReturnType<Cases["Success" | "Duplicate"]>>;
+    };
+};
+/**
+ * @since 1.0.0
+ * @category SaveResult
+ */
+export declare namespace SaveResult {
+    /**
+     * @since 1.0.0
+     * @category SaveResult
+     */
+    type Encoded = SaveResult.Success | SaveResult.DuplicateEncoded;
+    /**
+     * @since 1.0.0
+     * @category SaveResult
+     */
+    interface Success {
+        readonly _tag: "Success";
+    }
+    /**
+     * @since 1.0.0
+     * @category SaveResult
+     */
+    interface Duplicate<R extends Rpc.Any> {
+        readonly _tag: "Duplicate";
+        readonly originalId: Snowflake.Snowflake;
+        readonly lastReceivedReply: Option.Option<Reply.Reply<R>>;
+    }
+    /**
+     * @since 1.0.0
+     * @category SaveResult
+     */
+    interface DuplicateEncoded {
+        readonly _tag: "Duplicate";
+        readonly originalId: Snowflake.Snowflake;
+        readonly lastReceivedReply: Option.Option<Reply.ReplyEncoded<any>>;
+    }
+    /**
+     * @since 1.0.0
+     * @category SaveResult
+     */
+    interface Constructor extends Data.TaggedEnum.WithGenerics<1> {
+        readonly taggedEnum: SaveResult<this["A"]>;
+    }
+}
+/**
+ * @since 1.0.0
+ * @category Encoded
+ */
+export type Encoded = {
+    /**
+     * Save the provided message and its associated metadata.
+     */
+    readonly saveEnvelope: (options: {
+        readonly envelope: Envelope.Envelope.Encoded;
+        readonly primaryKey: string | null;
+        readonly deliverAt: number | null;
+    }) => Effect.Effect<SaveResult.Encoded, PersistenceError>;
+    /**
+     * Save the provided `Reply` and its associated metadata.
+     */
+    readonly saveReply: (reply: Reply.ReplyEncoded<any>) => Effect.Effect<void, PersistenceError>;
+    /**
+     * Retrieves the replies for the specified requests.
+     *
+     * - Un-acknowledged chunk replies
+     * - WithExit replies
+     */
+    readonly repliesFor: (requestIds: Array<string>) => Effect.Effect<Array<Reply.ReplyEncoded<any>>, PersistenceError>;
+    /**
+     * Retrieves the unprocessed messages for the given shards.
+     *
+     * A message is unprocessed when:
+     *
+     * - Requests that have no WithExit replies
+     *   - Or they have no unacknowledged chunk replies
+     * - The latest AckChunk envelope
+     * - All Interrupt's for unprocessed requests
+     */
+    readonly unprocessedMessages: (shardIds: ReadonlyArray<number>, now: number) => Effect.Effect<Array<{
+        readonly envelope: Envelope.Envelope.Encoded;
+        readonly lastSentReply: Option.Option<Reply.ReplyEncoded<any>>;
+    }>, PersistenceError>;
+    /**
+     * Retrieves the unprocessed messages by id.
+     */
+    readonly unprocessedMessagesById: (messageIds: ReadonlyArray<Snowflake.Snowflake>, now: number) => Effect.Effect<Array<{
+        readonly envelope: Envelope.Envelope.Encoded;
+        readonly lastSentReply: Option.Option<Reply.ReplyEncoded<any>>;
+    }>, PersistenceError>;
+    /**
+     * Reset the mailbox state for the provided address.
+     */
+    readonly resetAddress: (address: EntityAddress) => Effect.Effect<void, PersistenceError>;
+};
+/**
+ * @since 1.0.0
+ * @category Encoded
+ */
+export type EncodedUnprocessedOptions<A> = {
+    readonly existingShards: Array<number>;
+    readonly newShards: Array<number>;
+    readonly cursor: Option.Option<A>;
+};
+/**
+ * @since 1.0.0
+ * @category Encoded
+ */
+export type EncodedRepliesOptions<A> = {
+    readonly existingRequests: Array<string>;
+    readonly newRequests: Array<string>;
+    readonly cursor: Option.Option<A>;
+};
+/**
+ * @since 1.0.0
+ * @category constructors
+ */
+export declare const make: (storage: Omit<MessageStorage["Type"], "registerReplyHandler">) => Effect.Effect<MessageStorage["Type"]>;
+/**
+ * @since 1.0.0
+ * @category constructors
+ */
+export declare const makeEncoded: (encoded: Encoded) => Effect.Effect<MessageStorage["Type"], never, Snowflake.Generator>;
+/**
+ * @since 1.0.0
+ * @category Constructors
+ */
+export declare const noop: MessageStorage["Type"];
+/**
+ * @since 1.0.0
+ * @category Memory
+ */
+export type MemoryEntry = {
+    readonly envelope: Envelope.Request.Encoded;
+    lastReceivedChunk: Option.Option<Reply.ChunkEncoded<any>>;
+    replies: Array<Reply.ReplyEncoded<any>>;
+};
+declare const MemoryDriver_base: Effect.Service.Class<MemoryDriver, "@effect/cluster/MessageStorage/MemoryDriver", {
+    readonly dependencies: readonly [Layer.Layer<Snowflake.Generator, never, never>];
+    readonly effect: Effect.Effect<{
+        readonly storage: {
+            /**
+             * Save the provided message and its associated metadata.
+             */
+            readonly saveRequest: <R extends Rpc.Any>(envelope: Message.OutgoingRequest<R>) => Effect.Effect<SaveResult<R>, PersistenceError | MalformedMessage>;
+            /**
+             * Save the provided message and its associated metadata.
+             */
+            readonly saveEnvelope: (envelope: Message.OutgoingEnvelope) => Effect.Effect<void, PersistenceError | MalformedMessage>;
+            /**
+             * Save the provided `Reply` and its associated metadata.
+             */
+            readonly saveReply: <R extends Rpc.Any>(reply: Reply.ReplyWithContext<R>) => Effect.Effect<void, PersistenceError | MalformedMessage>;
+            /**
+             * Retrieves the replies for the specified requests.
+             *
+             * - Un-acknowledged chunk replies
+             * - WithExit replies
+             */
+            readonly repliesFor: <R extends Rpc.Any>(requests: Iterable<Message.OutgoingRequest<R>>) => Effect.Effect<Array<Reply.Reply<R>>, PersistenceError | MalformedMessage>;
+            /**
+             * For locally sent messages, register a handler to process the replies.
+             */
+            readonly registerReplyHandler: <R extends Rpc.Any>(message: Message.OutgoingRequest<R>) => Effect.Effect<void>;
+            /**
+             * Retrieves the unprocessed messages for the specified shards.
+             *
+             * A message is unprocessed when:
+             *
+             * - Requests that have no WithExit replies
+             *   - Or they have no unacknowledged chunk replies
+             * - The latest AckChunk envelope
+             * - All Interrupt's for unprocessed requests
+             */
+            readonly unprocessedMessages: (shardIds: Iterable<ShardId>) => Effect.Effect<Array<Message.Incoming<any>>, PersistenceError>;
+            /**
+             * Retrieves the unprocessed messages by id.
+             */
+            readonly unprocessedMessagesById: <R extends Rpc.Any>(messageIds: Iterable<Snowflake.Snowflake>) => Effect.Effect<Array<Message.Incoming<R>>, PersistenceError>;
+            /**
+             * Reset the mailbox state for the provided address.
+             */
+            readonly resetAddress: (address: EntityAddress) => Effect.Effect<void, PersistenceError>;
+        };
+        readonly encoded: Encoded;
+        readonly requests: Map<string, MemoryEntry>;
+        readonly requestsByPrimaryKey: Map<string, MemoryEntry>;
+        readonly unprocessed: Set<Envelope.Request.Encoded>;
+        readonly replyIds: Set<string>;
+        readonly journal: Envelope.Envelope.Encoded[];
+        readonly cursors: WeakMap<{}, number>;
+    }, never, Snowflake.Generator>;
+}>;
+/**
+ * @since 1.0.0
+ * @category Memory
+ */
+export declare class MemoryDriver extends MemoryDriver_base {
+}
+/**
+ * @since 1.0.0
+ * @category layers
+ */
+export declare const layerNoop: Layer.Layer<MessageStorage>;
+/**
+ * @since 1.0.0
+ * @category layers
+ */
+export declare const layerMemory: Layer.Layer<MessageStorage | MemoryDriver, never, ShardingConfig>;
+export {};
+//# sourceMappingURL=MessageStorage.d.ts.map
\ No newline at end of file
diff --git a/dist/dts/MessageStorage.d.ts.map b/dist/dts/MessageStorage.d.ts.map
new file mode 100644
index 0000000000000000000000000000000000000000..9e74ad62650731fc44ab749d069443712b4bdeda
--- /dev/null
+++ b/dist/dts/MessageStorage.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"MessageStorage.d.ts","sourceRoot":"","sources":["../../src/MessageStorage.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/dts/Reply.d.ts b/dist/dts/Reply.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..20fb281ba5c934a331f927c0da07f8f9843422df
--- /dev/null
+++ b/dist/dts/Reply.d.ts
@@ -0,0 +1,171 @@
+/**
+ * @since 1.0.0
+ */
+import * as Rpc from "@effect/rpc/Rpc";
+import type { NonEmptyReadonlyArray } from "effect/Array";
+import * as Context from "effect/Context";
+import * as Effect from "effect/Effect";
+import type * as Option from "effect/Option";
+import * as Schema from "effect/Schema";
+import { MalformedMessage } from "./ClusterError.js";
+import type { OutgoingRequest } from "./Message.js";
+import { Snowflake } from "./Snowflake.js";
+/**
+ * @since 1.0.0
+ * @category type ids
+ */
+export declare const TypeId: unique symbol;
+/**
+ * @since 1.0.0
+ * @category type ids
+ */
+export type TypeId = typeof TypeId;
+/**
+ * @since 1.0.0
+ * @category guards
+ */
+export declare const isReply: (u: unknown) => u is Reply<Rpc.Any>;
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export type Reply<R extends Rpc.Any> = WithExit<R> | Chunk<R>;
+declare const ReplyWithContext_base: new <A extends Record<string, any> = {}>(args: import("effect/Types").Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => Readonly<A> & {
+    readonly _tag: "ReplyWithContext";
+};
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export declare class ReplyWithContext<R extends Rpc.Any> extends ReplyWithContext_base<{
+    readonly reply: Reply<R>;
+    readonly context: Context.Context<Rpc.Context<R>>;
+    readonly rpc: R;
+}> {
+    /**
+     * @since 1.0.0
+     */
+    static fromDefect(options: {
+        readonly id: Snowflake;
+        readonly requestId: Snowflake;
+        readonly defect: unknown;
+    }): ReplyWithContext<any>;
+}
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export type ReplyEncoded<R extends Rpc.Any> = WithExitEncoded<R> | ChunkEncoded<R>;
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export interface WithExitEncoded<R extends Rpc.Any> {
+    readonly _tag: "WithExit";
+    readonly requestId: string;
+    readonly id: string;
+    readonly exit: Rpc.ExitEncoded<R>;
+}
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export interface ChunkEncoded<R extends Rpc.Any> {
+    readonly _tag: "Chunk";
+    readonly requestId: string;
+    readonly id: string;
+    readonly sequence: number;
+    readonly values: NonEmptyReadonlyArray<Rpc.SuccessChunkEncoded<R>>;
+}
+/**
+ * @since 1.0.0
+ * @category schemas
+ */
+export declare const Reply: <R extends Rpc.Any>(rpc: R) => Schema.Schema<Reply<R>, ReplyEncoded<R>, Rpc.Context<R>>;
+/**
+ * @since 1.0.0
+ * @category schemas
+ */
+export declare const Encoded: Schema.Union<[Schema.Struct<{
+    _tag: Schema.Literal<["WithExit"]>;
+    requestId: typeof Schema.String;
+    id: typeof Schema.String;
+    exit: typeof Schema.Unknown;
+}>, Schema.Struct<{
+    _tag: Schema.Literal<["Chunk"]>;
+    requestId: typeof Schema.String;
+    id: typeof Schema.String;
+    sequence: typeof Schema.Number;
+    values: Schema.Array$<typeof Schema.Unknown>;
+}>]>;
+declare const Chunk_base: new <A extends Record<string, any> = {}>(args: import("effect/Types").Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => Readonly<A> & {
+    readonly _tag: "Chunk";
+};
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export declare class Chunk<R extends Rpc.Any> extends Chunk_base<{
+    readonly requestId: Snowflake;
+    readonly id: Snowflake;
+    readonly sequence: number;
+    readonly values: NonEmptyReadonlyArray<Rpc.SuccessChunk<R>>;
+}> {
+    /**
+     * @since 1.0.0
+     */
+    readonly [TypeId]: symbol;
+    /**
+     * @since 1.0.0
+     */
+    static emptyFrom(requestId: Snowflake): Chunk<Rpc.Any>;
+    /**
+     * @since 1.0.0
+     */
+    static readonly schemaFromSelf: Schema.Schema<Chunk<never>>;
+    /**
+     * @since 1.0.0
+     */
+    static schema<R extends Rpc.Any>(rpc: R): Schema.Schema<Chunk<R>, ChunkEncoded<R>, Rpc.Context<R>>;
+    /**
+     * @since 1.0.0
+     */
+    withRequestId(requestId: Snowflake): Chunk<R>;
+}
+declare const WithExit_base: new <A extends Record<string, any> = {}>(args: import("effect/Types").Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => Readonly<A> & {
+    readonly _tag: "WithExit";
+};
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export declare class WithExit<R extends Rpc.Any> extends WithExit_base<{
+    readonly requestId: Snowflake;
+    readonly id: Snowflake;
+    readonly exit: Rpc.Exit<R>;
+}> {
+    /**
+     * @since 1.0.0
+     */
+    readonly [TypeId]: symbol;
+    /**
+     * @since 1.0.0
+     */
+    static schema<R extends Rpc.Any>(rpc: R): Schema.Schema<WithExit<R>, WithExitEncoded<R>, Rpc.Context<R>>;
+    /**
+     * @since 1.0.0
+     */
+    withRequestId(requestId: Snowflake): WithExit<R>;
+}
+/**
+ * @since 1.0.0
+ * @category serialization / deserialization
+ */
+export declare const serialize: <R extends Rpc.Any>(self: ReplyWithContext<R>) => Effect.Effect<ReplyEncoded<R>, MalformedMessage>;
+/**
+ * @since 1.0.0
+ * @category serialization / deserialization
+ */
+export declare const serializeLastReceived: <R extends Rpc.Any>(self: OutgoingRequest<R>) => Effect.Effect<Option.Option<ReplyEncoded<R>>, MalformedMessage>;
+export {};
+//# sourceMappingURL=Reply.d.ts.map
\ No newline at end of file
diff --git a/dist/dts/Reply.d.ts.map b/dist/dts/Reply.d.ts.map
new file mode 100644
index 0000000000000000000000000000000000000000..89c8596df9047febe7e866a8b3ac11f1a7bd65da
--- /dev/null
+++ b/dist/dts/Reply.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"Reply.d.ts","sourceRoot":"","sources":["../../src/Reply.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/dts/Runner.d.ts b/dist/dts/Runner.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd74abb8351a2d0430f99acad289948a429ca79b
--- /dev/null
+++ b/dist/dts/Runner.d.ts
@@ -0,0 +1,81 @@
+/**
+ * @since 1.0.0
+ */
+import { NodeInspectSymbol } from "effect/Inspectable";
+import * as Schema from "effect/Schema";
+import { RunnerAddress } from "./RunnerAddress.js";
+/**
+ * @since 1.0.0
+ * @category type ids
+ */
+export declare const TypeId: unique symbol;
+/**
+ * @since 1.0.0
+ * @category type ids
+ */
+export type TypeId = typeof TypeId;
+declare const Runner_base: Schema.Class<Runner, {
+    address: typeof RunnerAddress;
+    version: typeof Schema.Int;
+}, Schema.Struct.Encoded<{
+    address: typeof RunnerAddress;
+    version: typeof Schema.Int;
+}>, never, {
+    readonly address: RunnerAddress;
+} & {
+    readonly version: number;
+}, {}, {}>;
+/**
+ * A `Runner` represents a physical application server that is capable of running
+ * entities.
+ *
+ * Because a Runner represents a physical application server, a Runner must have a
+ * unique `address` which can be used to communicate with the server.
+ *
+ * The version of a Runner is used during rebalancing to give priority to newer
+ * application servers and slowly decommission older ones.
+ *
+ * @since 1.0.0
+ * @category models
+ */
+export declare class Runner extends Runner_base {
+    /**
+     * @since 1.0.0
+     */
+    static pretty: (a: Runner) => string;
+    /**
+     * @since 1.0.0
+     */
+    readonly [TypeId]: symbol;
+    /**
+     * @since 1.0.0
+     */
+    static readonly decodeSync: (i: string, overrideOptions?: import("effect/SchemaAST").ParseOptions) => Runner;
+    /**
+     * @since 1.0.0
+     */
+    static readonly encodeSync: (a: Runner, overrideOptions?: import("effect/SchemaAST").ParseOptions) => string;
+    /**
+     * @since 1.0.0
+     */
+    [NodeInspectSymbol](): string;
+}
+/**
+ * A `Runner` represents a physical application server that is capable of running
+ * entities.
+ *
+ * Because a Runner represents a physical application server, a Runner must have a
+ * unique `address` which can be used to communicate with the server.
+ *
+ * The version of a Runner is used during rebalancing to give priority to newer
+ * application servers and slowly decommission older ones.
+ *
+ * @since 1.0.0
+ * @category Constructors
+ */
+export declare const make: (props: {
+    readonly address: RunnerAddress;
+    readonly version: number;
+}) => Runner;
+export {};
+//# sourceMappingURL=Runner.d.ts.map
\ No newline at end of file
diff --git a/dist/dts/Runner.d.ts.map b/dist/dts/Runner.d.ts.map
new file mode 100644
index 0000000000000000000000000000000000000000..4b9e2273f6ac5e4ff6b00818c5cadc6df52af0ab
--- /dev/null
+++ b/dist/dts/Runner.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"Runner.d.ts","sourceRoot":"","sources":["../../src/Runner.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,OAAO,EAAE,iBAAiB,EAAE,MAAM,oBAAoB,CAAA;AAEtD,OAAO,KAAK,MAAM,MAAM,eAAe,CAAA;AACvC,OAAO,EAAE,aAAa,EAAE,MAAM,oBAAoB,CAAA;AAIlD;;;GAGG;AACH,eAAO,MAAM,MAAM,EAAE,OAAO,MAA8B,CAAA;AAE1D;;;GAGG;AACH,MAAM,MAAM,MAAM,GAAG,OAAO,MAAM,CAAA;;;;;;;;;;;;AAElC;;;;;;;;;;;;GAYG;AACH,qBAAa,MAAO,SAAQ,WAG1B;IACA;;OAEG;IACH,MAAM,CAAC,MAAM,wBAAoB;IAEjC;;OAEG;IACH,QAAQ,CAAC,CAAC,MAAM,CAAC,SAAS;IAE1B;;OAEG;IACH,MAAM,CAAC,QAAQ,CAAC,UAAU,mFAA8C;IAExE;;OAEG;IACH,MAAM,CAAC,QAAQ,CAAC,UAAU,mFAA+C;IAEzE;;OAEG;IACH,CAAC,iBAAiB,CAAC,IAAI,MAAM;CAG9B;AAED;;;;;;;;;;;;GAYG;AACH,eAAO,MAAM,IAAI,UAAW;IAC1B,QAAQ,CAAC,OAAO,EAAE,aAAa,CAAA;IAC/B,QAAQ,CAAC,OAAO,EAAE,MAAM,CAAA;CACzB,KAAG,MAA2B,CAAA"}
\ No newline at end of file
diff --git a/dist/dts/RunnerAddress.d.ts b/dist/dts/RunnerAddress.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..75a2ec162278c5b44df399c38de5fe4d55bf2cac
--- /dev/null
+++ b/dist/dts/RunnerAddress.d.ts
@@ -0,0 +1,56 @@
+/**
+ * @since 1.0.0
+ */
+import * as Hash from "effect/Hash";
+import { NodeInspectSymbol } from "effect/Inspectable";
+import * as Schema from "effect/Schema";
+/**
+ * @since 1.0.0
+ * @category type ids
+ */
+export declare const TypeId: unique symbol;
+/**
+ * @since 1.0.0
+ * @category type ids
+ */
+export type TypeId = typeof TypeId;
+declare const RunnerAddress_base: Schema.Class<RunnerAddress, {
+    host: typeof Schema.NonEmptyString;
+    port: typeof Schema.Int;
+}, Schema.Struct.Encoded<{
+    host: typeof Schema.NonEmptyString;
+    port: typeof Schema.Int;
+}>, never, {
+    readonly host: string;
+} & {
+    readonly port: number;
+}, {}, {}>;
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export declare class RunnerAddress extends RunnerAddress_base {
+    /**
+     * @since 1.0.0
+     */
+    readonly [TypeId]: symbol;
+    /**
+     * @since 1.0.0
+     */
+    [Hash.symbol](): number;
+    /**
+     * @since 1.0.0
+     */
+    toString(): string;
+    /**
+     * @since 1.0.0
+     */
+    [NodeInspectSymbol](): string;
+}
+/**
+ * @since 1.0.0
+ * @category constructors
+ */
+export declare const make: (host: string, port: number) => RunnerAddress;
+export {};
+//# sourceMappingURL=RunnerAddress.d.ts.map
\ No newline at end of file
diff --git a/dist/dts/RunnerAddress.d.ts.map b/dist/dts/RunnerAddress.d.ts.map
new file mode 100644
index 0000000000000000000000000000000000000000..1eab00df0df9dfba18b18aa8917921d47e427037
--- /dev/null
+++ b/dist/dts/RunnerAddress.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"RunnerAddress.d.ts","sourceRoot":"","sources":["../../src/RunnerAddress.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,OAAO,KAAK,IAAI,MAAM,aAAa,CAAA;AACnC,OAAO,EAAE,iBAAiB,EAAE,MAAM,oBAAoB,CAAA;AACtD,OAAO,KAAK,MAAM,MAAM,eAAe,CAAA;AAIvC;;;GAGG;AACH,eAAO,MAAM,MAAM,EAAE,OAAO,MAA8B,CAAA;AAE1D;;;GAGG;AACH,MAAM,MAAM,MAAM,GAAG,OAAO,MAAM,CAAA;;;;;;;;;;;;AAElC;;;GAGG;AACH,qBAAa,aAAc,SAAQ,kBAGjC;IACA;;OAEG;IACH,QAAQ,CAAC,CAAC,MAAM,CAAC,SAAU;IAE3B;;OAEG;IACH,CAAC,IAAI,CAAC,MAAM,CAAC;IAIb;;OAEG;IACH,QAAQ,IAAI,MAAM;IAIlB;;OAEG;IACH,CAAC,iBAAiB,CAAC,IAAI,MAAM;CAG9B;AAED;;;GAGG;AACH,eAAO,MAAM,IAAI,SAAU,MAAM,QAAQ,MAAM,KAAG,aAAkD,CAAA"}
\ No newline at end of file
diff --git a/dist/dts/RunnerHealth.d.ts b/dist/dts/RunnerHealth.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..252375dd02a35b1cfb2f9baa4ad859246d2117da
--- /dev/null
+++ b/dist/dts/RunnerHealth.d.ts
@@ -0,0 +1,54 @@
+/**
+ * @since 1.0.0
+ */
+import * as Context from "effect/Context";
+import * as Effect from "effect/Effect";
+import * as Layer from "effect/Layer";
+import type { RunnerAddress } from "./RunnerAddress.js";
+import * as Runners from "./Runners.js";
+import type { ShardingConfig } from "./ShardingConfig.js";
+declare const RunnerHealth_base: Context.TagClass<RunnerHealth, "@effect/cluster/RunnerHealth", {
+    readonly isAlive: (address: RunnerAddress) => Effect.Effect<boolean>;
+}>;
+/**
+ * Represents the service used to check if a Runner is healthy.
+ *
+ * If a Runner is responsive, shards will not be re-assigned because the Runner may
+ * still be processing messages. If a Runner is not responsive, then its
+ * associated shards can and will be re-assigned to a different Runner.
+ *
+ * @since 1.0.0
+ * @category models
+ */
+export declare class RunnerHealth extends RunnerHealth_base {
+}
+/**
+ * A layer which will **always** consider a Runner healthy.
+ *
+ * This is useful for testing.
+ *
+ * @since 1.0.0
+ * @category layers
+ */
+export declare const layerNoop: Layer.Layer<RunnerHealth, never, never>;
+/**
+ * @since 1.0.0
+ * @category Constructors
+ */
+export declare const make: Effect.Effect<RunnerHealth["Type"], never, Runners.Runners>;
+/**
+ * A layer which will ping a Runner directly to check if it is healthy.
+ *
+ * @since 1.0.0
+ * @category layers
+ */
+export declare const layer: Layer.Layer<RunnerHealth, never, Runners.Runners>;
+/**
+ * A layer which will ping a Runner directly to check if it is healthy.
+ *
+ * @since 1.0.0
+ * @category layers
+ */
+export declare const layerRpc: Layer.Layer<RunnerHealth, never, Runners.RpcClientProtocol | ShardingConfig>;
+export {};
+//# sourceMappingURL=RunnerHealth.d.ts.map
\ No newline at end of file
diff --git a/dist/dts/RunnerHealth.d.ts.map b/dist/dts/RunnerHealth.d.ts.map
new file mode 100644
index 0000000000000000000000000000000000000000..c6e8b055460d7d44230f09bc22fe25dcf4467074
--- /dev/null
+++ b/dist/dts/RunnerHealth.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"RunnerHealth.d.ts","sourceRoot":"","sources":["../../src/RunnerHealth.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,OAAO,KAAK,OAAO,MAAM,gBAAgB,CAAA;AACzC,OAAO,KAAK,MAAM,MAAM,eAAe,CAAA;AACvC,OAAO,KAAK,KAAK,MAAM,cAAc,CAAA;AAErC,OAAO,KAAK,EAAE,aAAa,EAAE,MAAM,oBAAoB,CAAA;AACvD,OAAO,KAAK,OAAO,MAAM,cAAc,CAAA;AACvC,OAAO,KAAK,EAAE,cAAc,EAAE,MAAM,qBAAqB,CAAA;;sBAenC,CAAC,OAAO,EAAE,aAAa,KAAK,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC;;AAbxE;;;;;;;;;GASG;AACH,qBAAa,YAAa,SAAQ,iBAK/B;CAAG;AAEN;;;;;;;GAOG;AACH,eAAO,MAAM,SAAS,yCAKrB,CAAA;AAED;;;GAGG;AACH,eAAO,MAAM,IAAI,EAAE,MAAM,CAAC,MAAM,CAC9B,YAAY,CAAC,MAAM,CAAC,EACpB,KAAK,EACL,OAAO,CAAC,OAAO,CASf,CAAA;AAEF;;;;;GAKG;AACH,eAAO,MAAM,KAAK,EAAE,KAAK,CAAC,KAAK,CAC7B,YAAY,EACZ,KAAK,EACL,OAAO,CAAC,OAAO,CACmB,CAAA;AAEpC;;;;;GAKG;AACH,eAAO,MAAM,QAAQ,EAAE,KAAK,CAAC,KAAK,CAChC,YAAY,EACZ,KAAK,EACL,OAAO,CAAC,iBAAiB,GAAG,cAAc,CAI3C,CAAA"}
\ No newline at end of file
diff --git a/dist/dts/RunnerServer.d.ts b/dist/dts/RunnerServer.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6e0d4943d3e8c2dc12f8b3eefbfd192ec4a2402f
--- /dev/null
+++ b/dist/dts/RunnerServer.d.ts
@@ -0,0 +1,44 @@
+/**
+ * @since 1.0.0
+ */
+import * as RpcServer from "@effect/rpc/RpcServer";
+import * as Layer from "effect/Layer";
+import type * as MessageStorage from "./MessageStorage.js";
+import * as Runners from "./Runners.js";
+import * as Sharding from "./Sharding.js";
+import { ShardingConfig } from "./ShardingConfig.js";
+import * as ShardStorage from "./ShardStorage.js";
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export declare const layerHandlers: Layer.Layer<import("@effect/rpc/Rpc").Handler<"Ping"> | import("@effect/rpc/Rpc").Handler<"Notify"> | import("@effect/rpc/Rpc").Handler<"Effect"> | import("@effect/rpc/Rpc").Handler<"Stream"> | import("@effect/rpc/Rpc").Handler<"Envelope">, never, Sharding.Sharding>;
+/**
+ * The `RunnerServer` recieves messages from other Runners and forwards them to the
+ * `Sharding` layer.
+ *
+ * It also responds to `Ping` requests.
+ *
+ * @since 1.0.0
+ * @category Layers
+ */
+export declare const layer: Layer.Layer<never, never, RpcServer.Protocol | Sharding.Sharding | MessageStorage.MessageStorage>;
+/**
+ * A `RunnerServer` layer that includes the `Runners` & `Sharding` clients.
+ *
+ * @since 1.0.0
+ * @category Layers
+ */
+export declare const layerWithClients: Layer.Layer<Sharding.Sharding | Runners.Runners, never, RpcServer.Protocol | ShardingConfig | Runners.RpcClientProtocol | MessageStorage.MessageStorage | ShardStorage.ShardStorage>;
+/**
+ * A `Runners` layer that is client only.
+ *
+ * It will not register with the ShardManager and recieve shard assignments,
+ * so this layer can be used to embed a cluster client inside another effect
+ * application.
+ *
+ * @since 1.0.0
+ * @category Layers
+ */
+export declare const layerClientOnly: Layer.Layer<Sharding.Sharding | Runners.Runners, never, ShardingConfig | Runners.RpcClientProtocol | MessageStorage.MessageStorage>;
+//# sourceMappingURL=RunnerServer.d.ts.map
\ No newline at end of file
diff --git a/dist/dts/RunnerServer.d.ts.map b/dist/dts/RunnerServer.d.ts.map
new file mode 100644
index 0000000000000000000000000000000000000000..0f479455c67782c999f832933487a6ed2dd51a24
--- /dev/null
+++ b/dist/dts/RunnerServer.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"RunnerServer.d.ts","sourceRoot":"","sources":["../../src/RunnerServer.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,OAAO,KAAK,SAAS,MAAM,uBAAuB,CAAA;AAGlD,OAAO,KAAK,KAAK,MAAM,cAAc,CAAA;AAIrC,OAAO,KAAK,KAAK,cAAc,MAAM,qBAAqB,CAAA;AAE1D,OAAO,KAAK,OAAO,MAAM,cAAc,CAAA;AACvC,OAAO,KAAK,QAAQ,MAAM,eAAe,CAAA;AACzC,OAAO,EAAE,cAAc,EAAE,MAAM,qBAAqB,CAAA;AAEpD,OAAO,KAAK,YAAY,MAAM,mBAAmB,CAAA;AAKjD;;;GAGG;AACH,eAAO,MAAM,aAAa,4QAiEvB,CAAA;AAEH;;;;;;;;GAQG;AACH,eAAO,MAAM,KAAK,EAAE,KAAK,CAAC,KAAK,CAC7B,KAAK,EACL,KAAK,EACL,SAAS,CAAC,QAAQ,GAAG,QAAQ,CAAC,QAAQ,GAAG,cAAc,CAAC,cAAc,CAInC,CAAA;AAErC;;;;;GAKG;AACH,eAAO,MAAM,gBAAgB,EAAE,KAAK,CAAC,KAAK,CACxC,QAAQ,CAAC,QAAQ,GAAG,OAAO,CAAC,OAAO,EACnC,KAAK,EACH,SAAS,CAAC,QAAQ,GAClB,cAAc,GACd,OAAO,CAAC,iBAAiB,GACzB,cAAc,CAAC,cAAc,GAC7B,YAAY,CAAC,YAAY,CAM5B,CAAA;AAED;;;;;;;;;GASG;AACH,eAAO,MAAM,eAAe,EAAE,KAAK,CAAC,KAAK,CACvC,QAAQ,CAAC,QAAQ,GAAG,OAAO,CAAC,OAAO,EACnC,KAAK,EACH,cAAc,GACd,OAAO,CAAC,iBAAiB,GACzB,cAAc,CAAC,cAAc,CAShC,CAAA"}
\ No newline at end of file
diff --git a/dist/dts/Runners.d.ts b/dist/dts/Runners.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..acff45492a8f0fe99a5ec5bfbc08dc3cab617e14
--- /dev/null
+++ b/dist/dts/Runners.d.ts
@@ -0,0 +1,160 @@
+/**
+ * @since 1.0.0
+ */
+import * as Rpc from "@effect/rpc/Rpc";
+import * as RpcClient_ from "@effect/rpc/RpcClient";
+import * as RpcGroup from "@effect/rpc/RpcGroup";
+import * as RpcSchema from "@effect/rpc/RpcSchema";
+import * as Context from "effect/Context";
+import * as Effect from "effect/Effect";
+import * as Layer from "effect/Layer";
+import * as Schema from "effect/Schema";
+import type { Scope } from "effect/Scope";
+import { AlreadyProcessingMessage, EntityNotManagedByRunner, MailboxFull, PersistenceError, RunnerUnavailable } from "./ClusterError.js";
+import * as Envelope from "./Envelope.js";
+import * as Message from "./Message.js";
+import * as MessageStorage from "./MessageStorage.js";
+import * as Reply from "./Reply.js";
+import type { RunnerAddress } from "./RunnerAddress.js";
+import { ShardingConfig } from "./ShardingConfig.js";
+import * as Snowflake from "./Snowflake.js";
+declare const Runners_base: Context.TagClass<Runners, "@effect/cluster/Runners", {
+    /**
+     * Checks if a Runner is responsive.
+     */
+    readonly ping: (address: RunnerAddress) => Effect.Effect<void, RunnerUnavailable>;
+    /**
+     * Send a message locally.
+     *
+     * This ensures that the message hits storage before being sent to the local
+     * entity.
+     */
+    readonly sendLocal: <R extends Rpc.Any>(options: {
+        readonly message: Message.Outgoing<R>;
+        readonly send: <Rpc extends Rpc.Any>(message: Message.IncomingLocal<Rpc>) => Effect.Effect<void, EntityNotManagedByRunner | MailboxFull | AlreadyProcessingMessage>;
+        readonly simulateRemoteSerialization: boolean;
+    }) => Effect.Effect<void, EntityNotManagedByRunner | MailboxFull | AlreadyProcessingMessage>;
+    /**
+     * Send a message to a Runner.
+     */
+    readonly send: <R extends Rpc.Any>(options: {
+        readonly address: RunnerAddress;
+        readonly message: Message.Outgoing<R>;
+    }) => Effect.Effect<void, EntityNotManagedByRunner | RunnerUnavailable | MailboxFull | AlreadyProcessingMessage | PersistenceError>;
+    /**
+     * Notify a Runner that a message is available, then read replies from storage.
+     */
+    readonly notify: <R extends Rpc.Any>(options: {
+        readonly address: RunnerAddress;
+        readonly message: Message.Outgoing<R>;
+        readonly discard: boolean;
+    }) => Effect.Effect<void>;
+    /**
+     * Notify the current Runner that a message is available, then read replies from
+     * storage.
+     *
+     * This ensures that the message hits storage before being sent to the local
+     * entity.
+     */
+    readonly notifyLocal: <R extends Rpc.Any>(options: {
+        readonly message: Message.Outgoing<R>;
+        readonly notify: (options: Message.IncomingLocal<any>) => Effect.Effect<void, EntityNotManagedByRunner>;
+        readonly discard: boolean;
+    }) => Effect.Effect<void>;
+}>;
+/**
+ * @since 1.0.0
+ * @category context
+ */
+export declare class Runners extends Runners_base {
+}
+/**
+ * @since 1.0.0
+ * @category Constructors
+ */
+export declare const make: (options: Omit<Runners["Type"], "sendLocal" | "notifyLocal">) => Effect.Effect<Runners["Type"], never, MessageStorage.MessageStorage | Snowflake.Generator | ShardingConfig | Scope>;
+/**
+ * @since 1.0.0
+ * @category No-op
+ */
+export declare const makeNoop: Effect.Effect<Runners["Type"], never, MessageStorage.MessageStorage | Snowflake.Generator | ShardingConfig | Scope>;
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export declare const layerNoop: Layer.Layer<Runners, never, ShardingConfig | MessageStorage.MessageStorage>;
+declare const Rpcs_base: RpcGroup.RpcGroup<Rpc.Rpc<"Ping", Schema.Struct<{}>, typeof Schema.Void, typeof Schema.Never, never> | Rpc.Rpc<"Notify", Schema.Struct<{
+    envelope: Schema.Union<[Schema.Struct<{
+        _tag: Schema.Literal<["Request"]>;
+        requestId: Schema.Schema<Snowflake.Snowflake, string>;
+        address: typeof import("./EntityAddress.js").EntityAddress;
+        tag: typeof Schema.String;
+        payload: typeof Schema.Unknown;
+        headers: Schema.Schema<import("@effect/platform/Headers").Headers, import("effect/Record").ReadonlyRecord<string, string>>;
+        traceId: typeof Schema.String;
+        spanId: typeof Schema.String;
+        sampled: typeof Schema.Boolean;
+    }>, typeof Envelope.AckChunk, typeof Envelope.Interrupt]>;
+}>, typeof Schema.Void, typeof EntityNotManagedByRunner, never> | Rpc.Rpc<"Effect", Schema.Struct<{
+    request: Schema.Struct<{
+        _tag: Schema.Literal<["Request"]>;
+        requestId: Schema.Schema<Snowflake.Snowflake, string>;
+        address: typeof import("./EntityAddress.js").EntityAddress;
+        tag: typeof Schema.String;
+        payload: typeof Schema.Unknown;
+        headers: Schema.Schema<import("@effect/platform/Headers").Headers, import("effect/Record").ReadonlyRecord<string, string>>;
+        traceId: typeof Schema.String;
+        spanId: typeof Schema.String;
+        sampled: typeof Schema.Boolean;
+    }>;
+}>, Schema.Schema<Reply.ReplyEncoded<any>, Reply.ReplyEncoded<any>, never>, Schema.Union<[typeof EntityNotManagedByRunner, typeof MailboxFull, typeof AlreadyProcessingMessage, typeof PersistenceError]>, never> | Rpc.Rpc<"Stream", Schema.Struct<{
+    request: Schema.Struct<{
+        _tag: Schema.Literal<["Request"]>;
+        requestId: Schema.Schema<Snowflake.Snowflake, string>;
+        address: typeof import("./EntityAddress.js").EntityAddress;
+        tag: typeof Schema.String;
+        payload: typeof Schema.Unknown;
+        headers: Schema.Schema<import("@effect/platform/Headers").Headers, import("effect/Record").ReadonlyRecord<string, string>>;
+        traceId: typeof Schema.String;
+        spanId: typeof Schema.String;
+        sampled: typeof Schema.Boolean;
+    }>;
+}>, RpcSchema.Stream<Schema.Schema<Reply.ReplyEncoded<any>, Reply.ReplyEncoded<any>, never>, Schema.Union<[typeof EntityNotManagedByRunner, typeof MailboxFull, typeof AlreadyProcessingMessage, typeof PersistenceError]>>, typeof Schema.Never, never> | Rpc.Rpc<"Envelope", Schema.Struct<{
+    envelope: Schema.Union<[typeof Envelope.AckChunk, typeof Envelope.Interrupt]>;
+}>, typeof Schema.Void, Schema.Union<[typeof EntityNotManagedByRunner, typeof MailboxFull, typeof AlreadyProcessingMessage, typeof PersistenceError]>, never>>;
+/**
+ * @since 1.0.0
+ * @category Rpcs
+ */
+export declare class Rpcs extends Rpcs_base {
+}
+/**
+ * @since 1.0.0
+ * @category Rpcs
+ */
+export interface RpcClient extends RpcClient_.FromGroup<typeof Rpcs> {
+}
+/**
+ * @since 1.0.0
+ * @category Rpcs
+ */
+export declare const makeRpcClient: Effect.Effect<RpcClient, never, RpcClient_.Protocol | Scope>;
+/**
+ * @since 1.0.0
+ * @category constructors
+ */
+export declare const makeRpc: Effect.Effect<Runners["Type"], never, Scope | RpcClientProtocol | MessageStorage.MessageStorage | Snowflake.Generator | ShardingConfig>;
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export declare const layerRpc: Layer.Layer<Runners, never, MessageStorage.MessageStorage | RpcClientProtocol | ShardingConfig>;
+declare const RpcClientProtocol_base: Context.TagClass<RpcClientProtocol, "@effect/cluster/Runners/RpcClientProtocol", (address: RunnerAddress) => Effect.Effect<RpcClient_.Protocol["Type"], never, Scope>>;
+/**
+ * @since 1.0.0
+ * @category Client
+ */
+export declare class RpcClientProtocol extends RpcClientProtocol_base {
+}
+export {};
+//# sourceMappingURL=Runners.d.ts.map
\ No newline at end of file
diff --git a/dist/dts/Runners.d.ts.map b/dist/dts/Runners.d.ts.map
new file mode 100644
index 0000000000000000000000000000000000000000..485780d4b8e9f1df0588d08a40404275f5ab19bb
--- /dev/null
+++ b/dist/dts/Runners.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"Runners.d.ts","sourceRoot":"","sources":["../../src/Runners.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/dts/ShardId.d.ts b/dist/dts/ShardId.d.ts
index 5a2fa8960afe63e08f2758ddea6b36dbe517dc6c..45fa7cf6bf7e7953213a599d4b259db02d52a2ed 100644
--- a/dist/dts/ShardId.d.ts
+++ b/dist/dts/ShardId.d.ts
@@ -4,67 +4,17 @@
 import * as Schema from "effect/Schema";
 /**
  * @since 1.0.0
- * @category symbols
- */
-export declare const ShardIdTypeId: unique symbol;
-/**
- * @since 1.0.0
- * @category symbols
- */
-export type ShardIdTypeId = typeof ShardIdTypeId;
-declare const ShardId_base: Schema.Class<ShardId, {
-    [ShardIdTypeId]: Schema.PropertySignature<":", typeof ShardIdTypeId, "@effect/cluster/ShardId", ":", "@effect/cluster/ShardId", false, never>;
-    value: typeof Schema.Number;
-}, Schema.Struct.Encoded<{
-    [ShardIdTypeId]: Schema.PropertySignature<":", typeof ShardIdTypeId, "@effect/cluster/ShardId", ":", "@effect/cluster/ShardId", false, never>;
-    value: typeof Schema.Number;
-}>, never, {
-    readonly value: number;
-} & {
-    readonly [ShardIdTypeId]: typeof ShardIdTypeId;
-}, {}, {}>;
-/**
- * A shard is a logical grouping of multiple entities. There could be thousands of entities in your system,
- * so instead of managing every single entity id, the shard manager group them by shard id, and when they are assigned
- * or moved around, we always move all the entities with the same shard id.
- *
- * @since 1.0.0
- * @category models
+ * @category constructors
  */
-export declare class ShardId extends ShardId_base {
-    /**
-     * @since 1.0.0
-     */
-    toString(): string;
-}
+export declare const ShardId: Schema.brand<typeof Schema.Int, "ShardId">;
 /**
  * @since 1.0.0
  * @category models
  */
-export declare namespace ShardId {
-    /**
-     * This is the shape that a shard id has over the wire.
-     *
-     * @since 1.0.0
-     * @category models
-     */
-    interface Encoded extends Schema.Schema.Encoded<typeof ShardId> {
-    }
-}
-/**
- * Constructs a shard id from its numerical value.
- * The shard id is currently built up by making the hash of the entity id, and then modulo the max amount of shards configured in ManagerConfig.
- *
- * @since 1.0.0
- * @category constructors
- */
-export declare function make(value: number): ShardId;
+export type ShardId = typeof ShardId.Type;
 /**
- * This is the schema for a ShardId.
- *
  * @since 1.0.0
- * @category schema
+ * @category Constructors
  */
-export declare const schema: Schema.Schema<ShardId, ShardId.Encoded>;
-export {};
+export declare const make: (shardId: number) => ShardId;
 //# sourceMappingURL=ShardId.d.ts.map
\ No newline at end of file
diff --git a/dist/dts/ShardId.d.ts.map b/dist/dts/ShardId.d.ts.map
index 769439727c7a14dd0e997b2b304ed3814e5ec763..5b9cca60433d0d8af9e60c8147373de739329fae 100644
--- a/dist/dts/ShardId.d.ts.map
+++ b/dist/dts/ShardId.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"ShardId.d.ts","sourceRoot":"","sources":["../../src/ShardId.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,OAAO,KAAK,MAAM,MAAM,eAAe,CAAA;AAMvC;;;GAGG;AACH,eAAO,MAAM,aAAa,EAAE,OAAO,MAAqC,CAAA;AAExE;;;GAGG;AACH,MAAM,MAAM,aAAa,GAAG,OAAO,aAAa,CAAA;;;;;;;;;;;;AAKhD;;;;;;;GAOG;AACH,qBAAa,OAAQ,SAAQ,YAG3B;IACA;;OAEG;IACH,QAAQ;CAGT;AAED;;;GAGG;AACH,yBAAiB,OAAO,CAAC;IACvB;;;;;OAKG;IACH,UAAiB,OAAQ,SAAQ,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,OAAO,OAAO,CAAC;KAAG;CAC1E;AAED;;;;;;GAMG;AACH,wBAAgB,IAAI,CAAC,KAAK,EAAE,MAAM,GAAG,OAAO,CAE3C;AAED;;;;;GAKG;AACH,eAAO,MAAM,MAAM,EAAE,MAAM,CAAC,MAAM,CAChC,OAAO,EACP,OAAO,CAAC,OAAO,CACW,CAAA"}
\ No newline at end of file
+{"version":3,"file":"ShardId.d.ts","sourceRoot":"","sources":["../../src/ShardId.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,OAAO,KAAK,MAAM,MAAM,eAAe,CAAA;AAEvC;;;GAGG;AACH,eAAO,MAAM,OAAO,4CAKnB,CAAA;AAED;;;GAGG;AACH,MAAM,MAAM,OAAO,GAAG,OAAO,OAAO,CAAC,IAAI,CAAA;AAEzC;;;GAGG;AACH,eAAO,MAAM,IAAI,YAAa,MAAM,KAAG,OAAgC,CAAA"}
\ No newline at end of file
diff --git a/dist/dts/ShardManager.d.ts b/dist/dts/ShardManager.d.ts
index 8b522c6f3b06a4335c1d5a1e8de6e2d9140b6814..e2072192099769a6af7d532a368fdcfe4178a577 100644
--- a/dist/dts/ShardManager.d.ts
+++ b/dist/dts/ShardManager.d.ts
@@ -1,44 +1,456 @@
 /**
  * @since 1.0.0
  */
-import type * as Effect from "effect/Effect";
-import type * as HashMap from "effect/HashMap";
-import type * as Option from "effect/Option";
-import type * as Stream from "effect/Stream";
-import type * as Pod from "./Pod.js";
-import type * as PodAddress from "./PodAddress.js";
-import type * as ShardId from "./ShardId.js";
-import type * as ShardingEvent from "./ShardingEvent.js";
+import * as Rpc from "@effect/rpc/Rpc";
+import * as RpcClient from "@effect/rpc/RpcClient";
+import * as RpcGroup from "@effect/rpc/RpcGroup";
+import * as RpcServer from "@effect/rpc/RpcServer";
+import * as Config_ from "effect/Config";
+import type { ConfigError } from "effect/ConfigError";
+import * as Context from "effect/Context";
+import * as Data from "effect/Data";
+import * as Duration from "effect/Duration";
+import * as Effect from "effect/Effect";
+import * as Layer from "effect/Layer";
+import * as Mailbox from "effect/Mailbox";
+import * as Option from "effect/Option";
+import * as Queue from "effect/Queue";
+import * as Schema from "effect/Schema";
+import type { Scope } from "effect/Scope";
+import * as MachineId from "./MachineId.js";
+import { Runner } from "./Runner.js";
+import { RunnerAddress } from "./RunnerAddress.js";
+import { RunnerHealth } from "./RunnerHealth.js";
+import { RpcClientProtocol, Runners } from "./Runners.js";
+import { ShardId } from "./ShardId.js";
+import { ShardingConfig } from "./ShardingConfig.js";
+import { ShardStorage } from "./ShardStorage.js";
+declare const ShardManager_base: Context.TagClass<ShardManager, "@effect/cluster/ShardManager", {
+    /**
+     * Get all shard assignments.
+     */
+    readonly getAssignments: Effect.Effect<ReadonlyMap<ShardId, Option.Option<RunnerAddress>>>;
+    /**
+     * Get a stream of sharding events emit by the shard manager.
+     */
+    readonly shardingEvents: Effect.Effect<Queue.Dequeue<ShardingEvent>, never, Scope>;
+    /**
+     * Register a new runner with the cluster.
+     */
+    readonly register: (runner: Runner) => Effect.Effect<MachineId.MachineId>;
+    /**
+     * Unregister a runner from the cluster.
+     */
+    readonly unregister: (address: RunnerAddress) => Effect.Effect<void>;
+    /**
+     * Rebalance shards assigned to runners within the cluster.
+     */
+    readonly rebalance: (immediate: boolean) => Effect.Effect<void>;
+    /**
+     * Notify the cluster of an unhealthy runner.
+     */
+    readonly notifyUnhealthyRunner: (address: RunnerAddress) => Effect.Effect<void>;
+    /**
+     * Check and repot on the health of all runners in the cluster.
+     */
+    readonly checkRunnerHealth: Effect.Effect<void>;
+}>;
 /**
  * @since 1.0.0
- * @category symbols
+ * @category models
+ */
+export declare class ShardManager extends ShardManager_base {
+}
+declare const Config_base: Context.TagClass<Config, "@effect/cluster/ShardManager/Config", {
+    /**
+     * The duration to wait before rebalancing shards after a change.
+     */
+    readonly rebalanceDebounce: Duration.DurationInput;
+    /**
+     * The interval on which regular rebalancing of shards will occur.
+     */
+    readonly rebalanceInterval: Duration.DurationInput;
+    /**
+     * The interval on which rebalancing of shards which failed to be
+     * rebalanced will be retried.
+     */
+    readonly rebalanceRetryInterval: Duration.DurationInput;
+    /**
+     * The maximum ratio of shards to rebalance at once.
+     *
+     * **Note**: this value should be a number between `0` and `1`.
+     */
+    readonly rebalanceRate: number;
+    /**
+     * The interval on which persistence of Runners will be retried if it fails.
+     */
+    readonly persistRetryInterval: Duration.DurationInput;
+    /**
+     * The number of times persistence of Runners will be retried if it fails.
+     */
+    readonly persistRetryCount: number;
+    /**
+     * The interval on which Runner health will be checked.
+     */
+    readonly runnerHealthCheckInterval: Duration.DurationInput;
+    /**
+     * The length of time to wait for a Runner to respond to a ping.
+     */
+    readonly runnerPingTimeout: Duration.DurationInput;
+}>;
+/**
+ * @since 1.0.0
+ * @category Config
+ */
+export declare class Config extends Config_base {
+    /**
+     * @since 1.0.0
+     */
+    static readonly defaults: Config["Type"];
+}
+/**
+ * @since 1.0.0
+ * @category Config
+ */
+export declare const configConfig: Config_.Config<Config["Type"]>;
+/**
+ * @since 1.0.0
+ * @category Config
  */
-export declare const ShardManagerTypeId: unique symbol;
+export declare const configFromEnv: Effect.Effect<Config["Type"], ConfigError>;
 /**
  * @since 1.0.0
- * @category symbols
+ * @category Config
  */
-export type ShardManagerTypeId = typeof ShardManagerTypeId;
+export declare const layerConfig: (config?: Partial<Config["Type"]>) => Layer.Layer<Config>;
 /**
  * @since 1.0.0
- * @category context
+ * @category Config
  */
-export declare const ShardManager: import("effect/Context").Tag<ShardManager, ShardManager>;
+export declare const layerConfigFromEnv: Layer.Layer<Config, ConfigError>;
+declare const ShardManagerClient_base: Context.TagClass<ShardManagerClient, "@effect/cluster/ShardManager/ShardManagerClient", {
+    /**
+     * Register a new runner with the cluster.
+     */
+    readonly register: (address: RunnerAddress) => Effect.Effect<MachineId.MachineId>;
+    /**
+     * Unregister a runner from the cluster.
+     */
+    readonly unregister: (address: RunnerAddress) => Effect.Effect<void>;
+    /**
+     * Notify the cluster of an unhealthy runner.
+     */
+    readonly notifyUnhealthyRunner: (address: RunnerAddress) => Effect.Effect<void>;
+    /**
+     * Get all shard assignments.
+     */
+    readonly getAssignments: Effect.Effect<ReadonlyMap<ShardId, Option.Option<RunnerAddress>>>;
+    /**
+     * Get a stream of sharding events emit by the shard manager.
+     */
+    readonly shardingEvents: Effect.Effect<Mailbox.ReadonlyMailbox<ShardingEvent>, never, Scope>;
+    /**
+     * Get the current time on the shard manager.
+     */
+    readonly getTime: Effect.Effect<number>;
+}>;
+/**
+ * Represents a client which can be used to communicate with the
+ * `ShardManager`.
+ *
+ * @since 1.0.0
+ * @category Client
+ */
+export declare class ShardManagerClient extends ShardManagerClient_base {
+}
 /**
  * @since 1.0.0
  * @category models
  */
-export interface ShardManager {
-    readonly getShardingEvents: Stream.Stream<ShardingEvent.ShardingEvent>;
-    readonly register: (pod: Pod.Pod) => Effect.Effect<void>;
-    readonly unregister: (podAddress: PodAddress.PodAddress) => Effect.Effect<void>;
-    readonly notifyUnhealthyPod: (podAddress: PodAddress.PodAddress) => Effect.Effect<void>;
-    readonly checkAllPodsHealth: Effect.Effect<void>;
-    readonly getAssignments: Effect.Effect<HashMap.HashMap<ShardId.ShardId, Option.Option<PodAddress.PodAddress>>>;
+export declare const ShardingEventSchema: Schema.Union<[Schema.TaggedStruct<"StreamStarted", {}>, Schema.TaggedStruct<"ShardsAssigned", {
+    address: typeof RunnerAddress;
+    shards: Schema.Array$<Schema.brand<typeof Schema.Int, "ShardId">>;
+}>, Schema.TaggedStruct<"ShardsUnassigned", {
+    address: typeof RunnerAddress;
+    shards: Schema.Array$<Schema.brand<typeof Schema.Int, "ShardId">>;
+}>, Schema.TaggedStruct<"RunnerRegistered", {
+    address: typeof RunnerAddress;
+}>, Schema.TaggedStruct<"RunnerUnregistered", {
+    address: typeof RunnerAddress;
+}>]>;
+declare const Rpcs_base: RpcGroup.RpcGroup<Rpc.Rpc<"Register", Schema.Struct<{
+    runner: typeof Runner;
+}>, Schema.brand<typeof Schema.Int, "MachineId">, typeof Schema.Never, never> | Rpc.Rpc<"Unregister", Schema.Struct<{
+    address: typeof RunnerAddress;
+}>, typeof Schema.Void, typeof Schema.Never, never> | Rpc.Rpc<"NotifyUnhealthyRunner", Schema.Struct<{
+    address: typeof RunnerAddress;
+}>, typeof Schema.Void, typeof Schema.Never, never> | Rpc.Rpc<"GetAssignments", Schema.Struct<{}>, Schema.ReadonlyMap$<Schema.brand<typeof Schema.Int, "ShardId">, Schema.Option<typeof RunnerAddress>>, typeof Schema.Never, never> | Rpc.Rpc<"ShardingEvents", Schema.Struct<{}>, import("@effect/rpc/RpcSchema").Stream<Schema.Union<[Schema.TaggedStruct<"StreamStarted", {}>, Schema.TaggedStruct<"ShardsAssigned", {
+    address: typeof RunnerAddress;
+    shards: Schema.Array$<Schema.brand<typeof Schema.Int, "ShardId">>;
+}>, Schema.TaggedStruct<"ShardsUnassigned", {
+    address: typeof RunnerAddress;
+    shards: Schema.Array$<Schema.brand<typeof Schema.Int, "ShardId">>;
+}>, Schema.TaggedStruct<"RunnerRegistered", {
+    address: typeof RunnerAddress;
+}>, Schema.TaggedStruct<"RunnerUnregistered", {
+    address: typeof RunnerAddress;
+}>]>, typeof Schema.Never>, typeof Schema.Never, never> | Rpc.Rpc<"GetTime", Schema.Struct<{}>, typeof Schema.Number, typeof Schema.Never, never>>;
+/**
+ * The messaging protocol for the `ShardManager`.
+ *
+ * @since 1.0.0
+ * @category Rpcs
+ */
+export declare class Rpcs extends Rpcs_base {
 }
 /**
  * @since 1.0.0
- * @category layers
+ * @category models
+ */
+export type ShardingEvent = Data.TaggedEnum<{
+    StreamStarted: {};
+    ShardsAssigned: {
+        address: RunnerAddress;
+        shards: ReadonlyArray<ShardId>;
+    };
+    ShardsUnassigned: {
+        address: RunnerAddress;
+        shards: ReadonlyArray<ShardId>;
+    };
+    RunnerRegistered: {
+        address: RunnerAddress;
+    };
+    RunnerUnregistered: {
+        address: RunnerAddress;
+    };
+}>;
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export declare const ShardingEvent: {
+    readonly StreamStarted: Data.Case.Constructor<{
+        readonly _tag: "StreamStarted";
+    }, "_tag">;
+    readonly ShardsAssigned: Data.Case.Constructor<{
+        readonly _tag: "ShardsAssigned";
+        readonly address: RunnerAddress;
+        readonly shards: ReadonlyArray<ShardId>;
+    }, "_tag">;
+    readonly ShardsUnassigned: Data.Case.Constructor<{
+        readonly _tag: "ShardsUnassigned";
+        readonly address: RunnerAddress;
+        readonly shards: ReadonlyArray<ShardId>;
+    }, "_tag">;
+    readonly RunnerRegistered: Data.Case.Constructor<{
+        readonly _tag: "RunnerRegistered";
+        readonly address: RunnerAddress;
+    }, "_tag">;
+    readonly RunnerUnregistered: Data.Case.Constructor<{
+        readonly _tag: "RunnerUnregistered";
+        readonly address: RunnerAddress;
+    }, "_tag">;
+    readonly $is: <Tag extends "StreamStarted" | "ShardsAssigned" | "ShardsUnassigned" | "RunnerRegistered" | "RunnerUnregistered">(tag: Tag) => (u: unknown) => u is Extract<{
+        readonly _tag: "StreamStarted";
+    }, {
+        readonly _tag: Tag;
+    }> | Extract<{
+        readonly _tag: "ShardsAssigned";
+        readonly address: RunnerAddress;
+        readonly shards: ReadonlyArray<ShardId>;
+    }, {
+        readonly _tag: Tag;
+    }> | Extract<{
+        readonly _tag: "ShardsUnassigned";
+        readonly address: RunnerAddress;
+        readonly shards: ReadonlyArray<ShardId>;
+    }, {
+        readonly _tag: Tag;
+    }> | Extract<{
+        readonly _tag: "RunnerRegistered";
+        readonly address: RunnerAddress;
+    }, {
+        readonly _tag: Tag;
+    }> | Extract<{
+        readonly _tag: "RunnerUnregistered";
+        readonly address: RunnerAddress;
+    }, {
+        readonly _tag: Tag;
+    }>;
+    readonly $match: {
+        <Cases extends {
+            readonly StreamStarted: (args: {
+                readonly _tag: "StreamStarted";
+            }) => any;
+            readonly ShardsAssigned: (args: {
+                readonly _tag: "ShardsAssigned";
+                readonly address: RunnerAddress;
+                readonly shards: ReadonlyArray<ShardId>;
+            }) => any;
+            readonly ShardsUnassigned: (args: {
+                readonly _tag: "ShardsUnassigned";
+                readonly address: RunnerAddress;
+                readonly shards: ReadonlyArray<ShardId>;
+            }) => any;
+            readonly RunnerRegistered: (args: {
+                readonly _tag: "RunnerRegistered";
+                readonly address: RunnerAddress;
+            }) => any;
+            readonly RunnerUnregistered: (args: {
+                readonly _tag: "RunnerUnregistered";
+                readonly address: RunnerAddress;
+            }) => any;
+        }>(cases: Cases): (value: {
+            readonly _tag: "StreamStarted";
+        } | {
+            readonly _tag: "ShardsAssigned";
+            readonly address: RunnerAddress;
+            readonly shards: ReadonlyArray<ShardId>;
+        } | {
+            readonly _tag: "ShardsUnassigned";
+            readonly address: RunnerAddress;
+            readonly shards: ReadonlyArray<ShardId>;
+        } | {
+            readonly _tag: "RunnerRegistered";
+            readonly address: RunnerAddress;
+        } | {
+            readonly _tag: "RunnerUnregistered";
+            readonly address: RunnerAddress;
+        }) => import("effect/Unify").Unify<ReturnType<Cases["StreamStarted" | "ShardsAssigned" | "ShardsUnassigned" | "RunnerRegistered" | "RunnerUnregistered"]>>;
+        <Cases extends {
+            readonly StreamStarted: (args: {
+                readonly _tag: "StreamStarted";
+            }) => any;
+            readonly ShardsAssigned: (args: {
+                readonly _tag: "ShardsAssigned";
+                readonly address: RunnerAddress;
+                readonly shards: ReadonlyArray<ShardId>;
+            }) => any;
+            readonly ShardsUnassigned: (args: {
+                readonly _tag: "ShardsUnassigned";
+                readonly address: RunnerAddress;
+                readonly shards: ReadonlyArray<ShardId>;
+            }) => any;
+            readonly RunnerRegistered: (args: {
+                readonly _tag: "RunnerRegistered";
+                readonly address: RunnerAddress;
+            }) => any;
+            readonly RunnerUnregistered: (args: {
+                readonly _tag: "RunnerUnregistered";
+                readonly address: RunnerAddress;
+            }) => any;
+        }>(value: {
+            readonly _tag: "StreamStarted";
+        } | {
+            readonly _tag: "ShardsAssigned";
+            readonly address: RunnerAddress;
+            readonly shards: ReadonlyArray<ShardId>;
+        } | {
+            readonly _tag: "ShardsUnassigned";
+            readonly address: RunnerAddress;
+            readonly shards: ReadonlyArray<ShardId>;
+        } | {
+            readonly _tag: "RunnerRegistered";
+            readonly address: RunnerAddress;
+        } | {
+            readonly _tag: "RunnerUnregistered";
+            readonly address: RunnerAddress;
+        }, cases: Cases): import("effect/Unify").Unify<ReturnType<Cases["StreamStarted" | "ShardsAssigned" | "ShardsUnassigned" | "RunnerRegistered" | "RunnerUnregistered"]>>;
+    };
+};
+/**
+ * @since 1.0.0
+ * @category Client
+ */
+export declare const makeClientLocal: Effect.Effect<{
+    /**
+     * Register a new runner with the cluster.
+     */
+    readonly register: (address: RunnerAddress) => Effect.Effect<MachineId.MachineId>;
+    /**
+     * Unregister a runner from the cluster.
+     */
+    readonly unregister: (address: RunnerAddress) => Effect.Effect<void>;
+    /**
+     * Notify the cluster of an unhealthy runner.
+     */
+    readonly notifyUnhealthyRunner: (address: RunnerAddress) => Effect.Effect<void>;
+    /**
+     * Get all shard assignments.
+     */
+    readonly getAssignments: Effect.Effect<ReadonlyMap<ShardId, Option.Option<RunnerAddress>>>;
+    /**
+     * Get a stream of sharding events emit by the shard manager.
+     */
+    readonly shardingEvents: Effect.Effect<Mailbox.ReadonlyMailbox<ShardingEvent>, never, Scope>;
+    /**
+     * Get the current time on the shard manager.
+     */
+    readonly getTime: Effect.Effect<number>;
+}, never, ShardingConfig>;
+/**
+ * @since 1.0.0
+ * @category Client
+ */
+export declare const makeClientRpc: Effect.Effect<ShardManagerClient["Type"], never, ShardingConfig | RpcClient.Protocol | Scope>;
+/**
+ * @since 1.0.0
+ * @category Client
+ */
+export declare const layerClientLocal: Layer.Layer<ShardManagerClient, never, ShardingConfig>;
+/**
+ * @since 1.0.0
+ * @category Client
+ */
+export declare const layerClientRpc: Layer.Layer<ShardManagerClient, never, ShardingConfig | RpcClientProtocol>;
+/**
+ * @since 1.0.0
+ * @category Constructors
+ */
+export declare const make: Effect.Effect<{
+    /**
+     * Get all shard assignments.
+     */
+    readonly getAssignments: Effect.Effect<ReadonlyMap<ShardId, Option.Option<RunnerAddress>>>;
+    /**
+     * Get a stream of sharding events emit by the shard manager.
+     */
+    readonly shardingEvents: Effect.Effect<Queue.Dequeue<ShardingEvent>, never, Scope>;
+    /**
+     * Register a new runner with the cluster.
+     */
+    readonly register: (runner: Runner) => Effect.Effect<MachineId.MachineId>;
+    /**
+     * Unregister a runner from the cluster.
+     */
+    readonly unregister: (address: RunnerAddress) => Effect.Effect<void>;
+    /**
+     * Rebalance shards assigned to runners within the cluster.
+     */
+    readonly rebalance: (immediate: boolean) => Effect.Effect<void>;
+    /**
+     * Notify the cluster of an unhealthy runner.
+     */
+    readonly notifyUnhealthyRunner: (address: RunnerAddress) => Effect.Effect<void>;
+    /**
+     * Check and repot on the health of all runners in the cluster.
+     */
+    readonly checkRunnerHealth: Effect.Effect<void>;
+}, never, ShardingConfig | Scope | Runners | RunnerHealth | ShardStorage | Config>;
+/**
+ * @since 1.0.0
+ * @category layer
+ */
+export declare const layer: Layer.Layer<ShardManager, never, ShardStorage | RunnerHealth | Runners | Config | ShardingConfig>;
+/**
+ * @since 1.0.0
+ * @category Server
+ */
+export declare const layerServerHandlers: Layer.Layer<Rpc.Handler<"Register"> | Rpc.Handler<"Unregister"> | Rpc.Handler<"NotifyUnhealthyRunner"> | Rpc.Handler<"GetAssignments"> | Rpc.Handler<"ShardingEvents"> | Rpc.Handler<"GetTime">, never, ShardManager>;
+/**
+ * @since 1.0.0
+ * @category Server
  */
-export declare const live: import("effect/Layer").Layer<ShardManager, never, import("./Pods.js").Pods | import("./Storage.js").Storage | import("./ManagerConfig.js").ManagerConfig | import("./PodsHealth.js").PodsHealth>;
+export declare const layerServer: Layer.Layer<never, never, ShardManager | RpcServer.Protocol>;
+export {};
 //# sourceMappingURL=ShardManager.d.ts.map
\ No newline at end of file
diff --git a/dist/dts/ShardManager.d.ts.map b/dist/dts/ShardManager.d.ts.map
index 568375ea7ed142c2027d35a49390f9cd64c8339e..85a763e61f6289d40c7a4f3907ce84cd232ed158 100644
--- a/dist/dts/ShardManager.d.ts.map
+++ b/dist/dts/ShardManager.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"ShardManager.d.ts","sourceRoot":"","sources":["../../src/ShardManager.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,OAAO,KAAK,KAAK,MAAM,MAAM,eAAe,CAAA;AAC5C,OAAO,KAAK,KAAK,OAAO,MAAM,gBAAgB,CAAA;AAC9C,OAAO,KAAK,KAAK,MAAM,MAAM,eAAe,CAAA;AAC5C,OAAO,KAAK,KAAK,MAAM,MAAM,eAAe,CAAA;AAE5C,OAAO,KAAK,KAAK,GAAG,MAAM,UAAU,CAAA;AACpC,OAAO,KAAK,KAAK,UAAU,MAAM,iBAAiB,CAAA;AAClD,OAAO,KAAK,KAAK,OAAO,MAAM,cAAc,CAAA;AAC5C,OAAO,KAAK,KAAK,aAAa,MAAM,oBAAoB,CAAA;AAExD;;;GAGG;AACH,eAAO,MAAM,kBAAkB,EAAE,OAAO,MAAoC,CAAA;AAE5E;;;GAGG;AACH,MAAM,MAAM,kBAAkB,GAAG,OAAO,kBAAkB,CAAA;AAE1D;;;GAGG;AACH,eAAO,MAAM,YAAY,0DAA2B,CAAA;AAEpD;;;GAGG;AACH,MAAM,WAAW,YAAY;IAC3B,QAAQ,CAAC,iBAAiB,EAAE,MAAM,CAAC,MAAM,CAAC,aAAa,CAAC,aAAa,CAAC,CAAA;IACtE,QAAQ,CAAC,QAAQ,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC,GAAG,KAAK,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAA;IACxD,QAAQ,CAAC,UAAU,EAAE,CAAC,UAAU,EAAE,UAAU,CAAC,UAAU,KAAK,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAA;IAC/E,QAAQ,CAAC,kBAAkB,EAAE,CAAC,UAAU,EAAE,UAAU,CAAC,UAAU,KAAK,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAA;IACvF,QAAQ,CAAC,kBAAkB,EAAE,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAA;IAChD,QAAQ,CAAC,cAAc,EAAE,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,OAAO,EAAE,MAAM,CAAC,MAAM,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC,CAAC,CAAA;CAK/G;AAED;;;GAGG;AACH,eAAO,MAAM,IAAI,kMAAgB,CAAA"}
\ No newline at end of file
+{"version":3,"file":"ShardManager.d.ts","sourceRoot":"","sources":["../../src/ShardManager.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/dts/ShardStorage.d.ts b/dist/dts/ShardStorage.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..37b168ce35aba7a505293dda93d1d9c6e0a8302e
--- /dev/null
+++ b/dist/dts/ShardStorage.d.ts
@@ -0,0 +1,200 @@
+/**
+ * @since 1.0.0
+ */
+import * as Context from "effect/Context";
+import * as Effect from "effect/Effect";
+import * as Layer from "effect/Layer";
+import * as Option from "effect/Option";
+import type { PersistenceError } from "./ClusterError.js";
+import { Runner } from "./Runner.js";
+import { RunnerAddress } from "./RunnerAddress.js";
+import { ShardId } from "./ShardId.js";
+declare const ShardStorage_base: Context.TagClass<ShardStorage, "@effect/cluster/ShardStorage", {
+    /**
+     * Get the current assignments of shards to runners.
+     */
+    readonly getAssignments: Effect.Effect<ReadonlyMap<ShardId, Option.Option<RunnerAddress>>, PersistenceError>;
+    /**
+     * Save the current state of shards assignments to runners.
+     */
+    readonly saveAssignments: (assignments: Iterable<readonly [ShardId, Option.Option<RunnerAddress>]>) => Effect.Effect<void, PersistenceError>;
+    /**
+     * Get all runners registered with the cluster.
+     */
+    readonly getRunners: Effect.Effect<Array<[RunnerAddress, Runner]>, PersistenceError>;
+    /**
+     * Save the current runners registered with the cluster.
+     */
+    readonly saveRunners: (runners: Iterable<readonly [RunnerAddress, Runner]>) => Effect.Effect<void, PersistenceError>;
+    /**
+     * Try to acquire the given shard ids for processing.
+     *
+     * It returns an array of shards it was able to acquire.
+     */
+    readonly acquire: (address: RunnerAddress, shardIds: Iterable<ShardId>) => Effect.Effect<Array<ShardId>, PersistenceError>;
+    /**
+     * Refresh the locks owned by the given runner.
+     *
+     * Locks expire after 90 seconds, so this method should be called every 60
+     * seconds to keep the locks alive.
+     */
+    readonly refresh: (address: RunnerAddress, shardIds: Iterable<ShardId>) => Effect.Effect<Array<ShardId>, PersistenceError>;
+    /**
+     * Release the given shard ids.
+     */
+    readonly release: (address: RunnerAddress, shardId: ShardId) => Effect.Effect<void, PersistenceError>;
+    /**
+     * Release all the shards assigned to the given runner.
+     */
+    readonly releaseAll: (address: RunnerAddress) => Effect.Effect<void, PersistenceError>;
+}>;
+/**
+ * Represents a generic interface to the persistent storage required by the
+ * cluster.
+ *
+ * @since 1.0.0
+ * @category models
+ */
+export declare class ShardStorage extends ShardStorage_base {
+}
+/**
+ * @since 1.0.0
+ * @category Encoded
+ */
+export interface Encoded {
+    /**
+     * Get the current assignments of shards to runners.
+     */
+    readonly getAssignments: Effect.Effect<Array<readonly [
+        shardId: number,
+        runnerAddress: string | null
+    ]>, PersistenceError>;
+    /**
+     * Save the current state of shards assignments to runners.
+     */
+    readonly saveAssignments: (assignments: Array<readonly [shardId: number, RunnerAddress: string | null]>) => Effect.Effect<void, PersistenceError>;
+    /**
+     * Get all runners registered with the cluster.
+     */
+    readonly getRunners: Effect.Effect<Array<readonly [address: string, runner: string]>, PersistenceError>;
+    /**
+     * Save the current runners registered with the cluster.
+     */
+    readonly saveRunners: (runners: Array<readonly [address: string, runner: string]>) => Effect.Effect<void, PersistenceError>;
+    /**
+     * Acquire the lock on the given shards, returning the shards that were
+     * successfully locked.
+     */
+    readonly acquire: (address: string, shardIds: ReadonlyArray<number>) => Effect.Effect<Array<number>, PersistenceError>;
+    /**
+     * Refresh the lock on the given shards, returning the shards that were
+     * successfully locked.
+     */
+    readonly refresh: (address: string, shardIds: ReadonlyArray<number>) => Effect.Effect<Array<number>, PersistenceError>;
+    /**
+     * Release the lock on the given shards.
+     */
+    readonly release: (address: string, shardIds: number) => Effect.Effect<void, PersistenceError>;
+    /**
+     * Release the lock on all shards for the given runner.
+     */
+    readonly releaseAll: (address: string) => Effect.Effect<void, PersistenceError>;
+}
+/**
+ * @since 1.0.0
+ * @category layers
+ */
+export declare const makeEncoded: (encoded: Encoded) => Effect.Effect<{
+    /**
+     * Get the current assignments of shards to runners.
+     */
+    readonly getAssignments: Effect.Effect<ReadonlyMap<ShardId, Option.Option<RunnerAddress>>, PersistenceError>;
+    /**
+     * Save the current state of shards assignments to runners.
+     */
+    readonly saveAssignments: (assignments: Iterable<readonly [ShardId, Option.Option<RunnerAddress>]>) => Effect.Effect<void, PersistenceError>;
+    /**
+     * Get all runners registered with the cluster.
+     */
+    readonly getRunners: Effect.Effect<Array<[RunnerAddress, Runner]>, PersistenceError>;
+    /**
+     * Save the current runners registered with the cluster.
+     */
+    readonly saveRunners: (runners: Iterable<readonly [RunnerAddress, Runner]>) => Effect.Effect<void, PersistenceError>;
+    /**
+     * Try to acquire the given shard ids for processing.
+     *
+     * It returns an array of shards it was able to acquire.
+     */
+    readonly acquire: (address: RunnerAddress, shardIds: Iterable<ShardId>) => Effect.Effect<Array<ShardId>, PersistenceError>;
+    /**
+     * Refresh the locks owned by the given runner.
+     *
+     * Locks expire after 90 seconds, so this method should be called every 60
+     * seconds to keep the locks alive.
+     */
+    readonly refresh: (address: RunnerAddress, shardIds: Iterable<ShardId>) => Effect.Effect<Array<ShardId>, PersistenceError>;
+    /**
+     * Release the given shard ids.
+     */
+    readonly release: (address: RunnerAddress, shardId: ShardId) => Effect.Effect<void, PersistenceError>;
+    /**
+     * Release all the shards assigned to the given runner.
+     */
+    readonly releaseAll: (address: RunnerAddress) => Effect.Effect<void, PersistenceError>;
+}, never, never>;
+/**
+ * @since 1.0.0
+ * @category layers
+ */
+export declare const layerNoop: Layer.Layer<ShardStorage>;
+/**
+ * @since 1.0.0
+ * @category constructors
+ */
+export declare const makeMemory: Effect.Effect<{
+    /**
+     * Get the current assignments of shards to runners.
+     */
+    readonly getAssignments: Effect.Effect<ReadonlyMap<ShardId, Option.Option<RunnerAddress>>, PersistenceError>;
+    /**
+     * Save the current state of shards assignments to runners.
+     */
+    readonly saveAssignments: (assignments: Iterable<readonly [ShardId, Option.Option<RunnerAddress>]>) => Effect.Effect<void, PersistenceError>;
+    /**
+     * Get all runners registered with the cluster.
+     */
+    readonly getRunners: Effect.Effect<Array<[RunnerAddress, Runner]>, PersistenceError>;
+    /**
+     * Save the current runners registered with the cluster.
+     */
+    readonly saveRunners: (runners: Iterable<readonly [RunnerAddress, Runner]>) => Effect.Effect<void, PersistenceError>;
+    /**
+     * Try to acquire the given shard ids for processing.
+     *
+     * It returns an array of shards it was able to acquire.
+     */
+    readonly acquire: (address: RunnerAddress, shardIds: Iterable<ShardId>) => Effect.Effect<Array<ShardId>, PersistenceError>;
+    /**
+     * Refresh the locks owned by the given runner.
+     *
+     * Locks expire after 90 seconds, so this method should be called every 60
+     * seconds to keep the locks alive.
+     */
+    readonly refresh: (address: RunnerAddress, shardIds: Iterable<ShardId>) => Effect.Effect<Array<ShardId>, PersistenceError>;
+    /**
+     * Release the given shard ids.
+     */
+    readonly release: (address: RunnerAddress, shardId: ShardId) => Effect.Effect<void, PersistenceError>;
+    /**
+     * Release all the shards assigned to the given runner.
+     */
+    readonly releaseAll: (address: RunnerAddress) => Effect.Effect<void, PersistenceError>;
+}, never, never>;
+/**
+ * @since 1.0.0
+ * @category layers
+ */
+export declare const layerMemory: Layer.Layer<ShardStorage>;
+export {};
+//# sourceMappingURL=ShardStorage.d.ts.map
\ No newline at end of file
diff --git a/dist/dts/ShardStorage.d.ts.map b/dist/dts/ShardStorage.d.ts.map
new file mode 100644
index 0000000000000000000000000000000000000000..74c3dd7f93fdeeab34afb1bbbc24d20b0be8204c
--- /dev/null
+++ b/dist/dts/ShardStorage.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"ShardStorage.d.ts","sourceRoot":"","sources":["../../src/ShardStorage.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/dts/Sharding.d.ts b/dist/dts/Sharding.d.ts
index 441f6a76760ae32e694a69d3c5d2a8c9744fcd4f..9d100184ea98fc2949e004fb1e4576a09c45e0f4 100644
--- a/dist/dts/Sharding.d.ts
+++ b/dist/dts/Sharding.d.ts
@@ -1,146 +1,124 @@
 /**
  * @since 1.0.0
  */
-import type * as Effect from "effect/Effect";
-import type * as HashSet from "effect/HashSet";
-import type * as Scope from "effect/Scope";
-import type * as Stream from "effect/Stream";
-import type { Broadcaster } from "./Broadcaster.js";
-import type * as Message from "./Message.js";
-import type * as MessageState from "./MessageState.js";
-import type { Messenger } from "./Messenger.js";
-import type * as PodAddress from "./PodAddress.js";
-import type * as RecipientAddress from "./RecipientAddress.js";
-import type * as RecipientBehaviour from "./RecipientBehaviour.js";
-import type * as RecipientBehaviourContext from "./RecipientBehaviourContext.js";
-import type * as RecipentType from "./RecipientType.js";
-import type * as SerializedEnvelope from "./SerializedEnvelope.js";
-import type * as SerializedMessage from "./SerializedMessage.js";
-import type * as ShardId from "./ShardId.js";
-import type * as ShardingException from "./ShardingException.js";
-import type * as ShardingRegistrationEvent from "./ShardingRegistrationEvent.js";
-/**
- * @since 1.0.0
- * @category symbols
- */
-export declare const ShardingTypeId: unique symbol;
-/**
- * @since 1.0.0
- * @category symbols
- */
-export type ShardingTypeId = typeof ShardingTypeId;
+import type * as Rpc from "@effect/rpc/Rpc";
+import * as RpcClient from "@effect/rpc/RpcClient";
+import * as Context from "effect/Context";
+import type { DurationInput } from "effect/Duration";
+import * as Effect from "effect/Effect";
+import * as Layer from "effect/Layer";
+import * as Scope from "effect/Scope";
+import * as Stream from "effect/Stream";
+import type { AlreadyProcessingMessage, MailboxFull, PersistenceError } from "./ClusterError.js";
+import { EntityNotManagedByRunner } from "./ClusterError.js";
+import type { CurrentAddress, Entity, HandlersFrom } from "./Entity.js";
+import { EntityId } from "./EntityId.js";
+import { EntityReaper } from "./internal/entityReaper.js";
+import * as Message from "./Message.js";
+import * as MessageStorage from "./MessageStorage.js";
+import { Runners } from "./Runners.js";
+import { ShardId } from "./ShardId.js";
+import { ShardingConfig } from "./ShardingConfig.js";
+import { type ShardingRegistrationEvent } from "./ShardingRegistrationEvent.js";
+import { ShardManagerClient } from "./ShardManager.js";
+import { ShardStorage } from "./ShardStorage.js";
+import * as Snowflake from "./Snowflake.js";
+declare const Sharding_base: Context.TagClass<Sharding, "@effect/cluster/Sharding", {
+    /**
+     * Returns a stream of events that occur when the runner registers entities or
+     * singletons.
+     */
+    readonly getRegistrationEvents: Stream.Stream<ShardingRegistrationEvent>;
+    /**
+     * Returns the `ShardId` of the shard to which the entity at the specified
+     * `address` is assigned.
+     */
+    readonly getShardId: (entityId: EntityId) => ShardId;
+    /**
+     * Returns `true` if sharding is shutting down, `false` otherwise.
+     */
+    readonly isShutdown: Effect.Effect<boolean>;
+    /**
+     * Constructs a `RpcClient` which can be used to send messages to the
+     * specified `Entity`.
+     */
+    readonly makeClient: <Rpcs extends Rpc.Any>(entity: Entity<Rpcs>) => Effect.Effect<(entityId: string) => RpcClient.RpcClient<Rpcs, MailboxFull | AlreadyProcessingMessage | PersistenceError>>;
+    /**
+     * Registers a new entity with the runner.
+     */
+    readonly registerEntity: <Rpcs extends Rpc.Any, Handlers extends HandlersFrom<Rpcs>, RX>(entity: Entity<Rpcs>, handlers: Effect.Effect<Handlers, never, RX>, options?: {
+        readonly maxIdleTime?: DurationInput | undefined;
+        readonly concurrency?: number | "unbounded" | undefined;
+        readonly mailboxCapacity?: number | "unbounded" | undefined;
+    }) => Effect.Effect<void, never, Rpc.Context<Rpcs> | Rpc.Middleware<Rpcs> | Exclude<RX, Scope.Scope | CurrentAddress>>;
+    /**
+     * Registers a new singleton with the runner.
+     */
+    readonly registerSingleton: <E, R>(name: string, run: Effect.Effect<void, E, R>) => Effect.Effect<void, never, Exclude<R, Scope.Scope>>;
+    /**
+     * Sends a message to the specified entity.
+     */
+    readonly send: (message: Message.Incoming<any>) => Effect.Effect<void, EntityNotManagedByRunner | MailboxFull | AlreadyProcessingMessage>;
+    /**
+     * Notify sharding that a message has been persisted to storage.
+     */
+    readonly notify: (message: Message.Incoming<any>) => Effect.Effect<void, EntityNotManagedByRunner>;
+}>;
 /**
  * @since 1.0.0
  * @category models
  */
-export interface Sharding {
-    readonly [ShardingTypeId]: ShardingTypeId;
-    readonly register: Effect.Effect<void>;
-    readonly unregister: Effect.Effect<void>;
-    readonly messenger: <Msg extends Message.Message.Any>(entityType: RecipentType.EntityType<Msg>) => Messenger<Msg>;
-    readonly broadcaster: <Msg extends Message.Message.Any>(topicType: RecipentType.TopicType<Msg>) => Broadcaster<Msg>;
-    readonly isEntityOnLocalShards: (recipientAddress: RecipientAddress.RecipientAddress) => Effect.Effect<boolean>;
-    readonly isShuttingDown: Effect.Effect<boolean>;
-    readonly registerScoped: Effect.Effect<void, never, Scope.Scope>;
-    readonly registerEntity: <Msg extends Message.Message.Any>(entityType: RecipentType.EntityType<Msg>) => <R>(behaviour: RecipientBehaviour.RecipientBehaviour<Msg, R>, options?: RecipientBehaviour.EntityBehaviourOptions) => Effect.Effect<void, never, Exclude<R, RecipientBehaviourContext.RecipientBehaviourContext>>;
-    readonly registerTopic: <Msg extends Message.Message.Any>(topicType: RecipentType.TopicType<Msg>) => <R>(behaviour: RecipientBehaviour.RecipientBehaviour<Msg, R>, options?: RecipientBehaviour.EntityBehaviourOptions) => Effect.Effect<void, never, Exclude<R, RecipientBehaviourContext.RecipientBehaviourContext>>;
-    readonly getShardingRegistrationEvents: Stream.Stream<ShardingRegistrationEvent.ShardingRegistrationEvent>;
-    readonly registerSingleton: <R>(name: string, run: Effect.Effect<void, never, R>) => Effect.Effect<void, never, R>;
-    readonly assign: (shards: HashSet.HashSet<ShardId.ShardId>) => Effect.Effect<void>;
-    readonly unassign: (shards: HashSet.HashSet<ShardId.ShardId>) => Effect.Effect<void>;
-    readonly sendMessageToLocalEntityManagerWithoutRetries: (message: SerializedEnvelope.SerializedEnvelope) => Effect.Effect<MessageState.MessageState<SerializedMessage.SerializedMessage>, ShardingException.ShardingException>;
-    readonly getPods: Effect.Effect<HashSet.HashSet<PodAddress.PodAddress>>;
-    readonly getAssignedShardIds: Effect.Effect<HashSet.HashSet<ShardId.ShardId>>;
+export declare class Sharding extends Sharding_base {
 }
 /**
  * @since 1.0.0
- * @category context
- */
-export declare const Tag: import("effect/Context").Tag<Sharding, Sharding>;
+ * @category constructors
+ */
+export declare const make: Effect.Effect<{
+    /**
+     * Returns a stream of events that occur when the runner registers entities or
+     * singletons.
+     */
+    readonly getRegistrationEvents: Stream.Stream<ShardingRegistrationEvent>;
+    /**
+     * Returns the `ShardId` of the shard to which the entity at the specified
+     * `address` is assigned.
+     */
+    readonly getShardId: (entityId: EntityId) => ShardId;
+    /**
+     * Returns `true` if sharding is shutting down, `false` otherwise.
+     */
+    readonly isShutdown: Effect.Effect<boolean>;
+    /**
+     * Constructs a `RpcClient` which can be used to send messages to the
+     * specified `Entity`.
+     */
+    readonly makeClient: <Rpcs extends Rpc.Any>(entity: Entity<Rpcs>) => Effect.Effect<(entityId: string) => RpcClient.RpcClient<Rpcs, MailboxFull | AlreadyProcessingMessage | PersistenceError>>;
+    /**
+     * Registers a new entity with the runner.
+     */
+    readonly registerEntity: <Rpcs extends Rpc.Any, Handlers extends HandlersFrom<Rpcs>, RX>(entity: Entity<Rpcs>, handlers: Effect.Effect<Handlers, never, RX>, options?: {
+        readonly maxIdleTime?: DurationInput | undefined;
+        readonly concurrency?: number | "unbounded" | undefined;
+        readonly mailboxCapacity?: number | "unbounded" | undefined;
+    }) => Effect.Effect<void, never, Rpc.Context<Rpcs> | Rpc.Middleware<Rpcs> | Exclude<RX, Scope.Scope | CurrentAddress>>;
+    /**
+     * Registers a new singleton with the runner.
+     */
+    readonly registerSingleton: <E, R>(name: string, run: Effect.Effect<void, E, R>) => Effect.Effect<void, never, Exclude<R, Scope.Scope>>;
+    /**
+     * Sends a message to the specified entity.
+     */
+    readonly send: (message: Message.Incoming<any>) => Effect.Effect<void, EntityNotManagedByRunner | MailboxFull | AlreadyProcessingMessage>;
+    /**
+     * Notify sharding that a message has been persisted to storage.
+     */
+    readonly notify: (message: Message.Incoming<any>) => Effect.Effect<void, EntityNotManagedByRunner>;
+}, never, Snowflake.Generator | ShardingConfig | MessageStorage.MessageStorage | Scope.Scope | EntityReaper | Runners | ShardStorage | ShardManagerClient>;
 /**
  * @since 1.0.0
  * @category layers
  */
-export declare const live: import("effect/Layer").Layer<Sharding, never, import("./Serialization.js").Serialization | import("./Pods.js").Pods | import("./ShardingConfig.js").ShardingConfig | import("./ShardManagerClient.js").ShardManagerClient | import("./Storage.js").Storage>;
-/**
- * Notify the shard manager that shards can now be assigned to this pod.
- *
- * @since 1.0.0
- * @category utils
- */
-export declare const register: Effect.Effect<void, never, Sharding>;
-/**
- * Notify the shard manager that shards must be unassigned from this pod.
- *
- * @since 1.0.0
- * @category utils
- */
-export declare const unregister: Effect.Effect<void, never, Sharding>;
-/**
- * Same as `register`, but will automatically call `unregister` when the `Scope` is terminated.
- *
- * @since 1.0.0
- * @category utils
- */
-export declare const registerScoped: Effect.Effect<void, never, Scope.Scope | Sharding>;
-/**
- * Start a computation that is guaranteed to run only on a single pod.
- * Each pod should call `registerSingleton` but only a single pod will actually run it at any given time.
- *
- * @since 1.0.0
- * @category utils
- */
-export declare const registerSingleton: <R>(name: string, run: Effect.Effect<void, never, R>) => Effect.Effect<void, never, Sharding | R>;
-/**
- * Register a new entity type, allowing pods to send messages to entities of this type.
- *
- * @since 1.0.0
- * @category utils
- */
-export declare const registerEntity: <Msg extends Message.Message.Any>(entityType: RecipentType.EntityType<Msg>) => <R>(behavior: RecipientBehaviour.RecipientBehaviour<Msg, R>, options?: RecipientBehaviour.EntityBehaviourOptions | undefined) => Effect.Effect<void, never, Sharding | Exclude<R, RecipientBehaviourContext.RecipientBehaviourContext>>;
-/**
- * Register a new topic type, allowing pods to broadcast messages to subscribers.
- *
- * @since 1.0.0
- * @category utils
- */
-export declare const registerTopic: <Msg extends Message.Message.Any>(topicType: RecipentType.TopicType<Msg>) => <R>(behavior: RecipientBehaviour.RecipientBehaviour<Msg, R>, options?: RecipientBehaviour.EntityBehaviourOptions | undefined) => Effect.Effect<void, never, Sharding | Exclude<R, RecipientBehaviourContext.RecipientBehaviourContext>>;
-/**
- * Get an object that allows sending messages to a given entity type.
- * You can provide a custom send timeout to override the one globally defined.
- *
- * @since 1.0.0
- * @category utils
- */
-export declare const messenger: <Msg extends Message.Message.Any>(entityType: RecipentType.EntityType<Msg>) => Effect.Effect<Messenger<Msg>, never, Sharding>;
-/**
- * Get an object that allows broadcasting messages to a given topic type.
- * You can provide a custom send timeout to override the one globally defined.
- *
- * @since 1.0.0
- * @category utils
- */
-export declare const broadcaster: <Msg extends Message.Message.Any>(topicType: RecipentType.TopicType<Msg>) => Effect.Effect<Broadcaster<Msg>, never, Sharding>;
-/**
- * Get the list of pods currently registered to the Shard Manager
- *
- * @since 1.0.0
- * @category utils
- */
-export declare const getPods: Effect.Effect<HashSet.HashSet<PodAddress.PodAddress>, never, Sharding>;
-/**
- * Sends a raw message to the local entity manager without performing reties.
- * Those are up to the caller.
- *
- * @since 1.0.0
- * @category utils
- */
-export declare const sendMessageToLocalEntityManagerWithoutRetries: (message: SerializedEnvelope.SerializedEnvelope) => Effect.Effect<MessageState.MessageState<SerializedMessage.SerializedMessage>, ShardingException.ShardingException, Sharding>;
-/**
- * Gets the list of shardIds assigned to the current Pod
- *
- * @since 1.0.0
- * @category utils
- */
-export declare const getAssignedShardIds: Effect.Effect<HashSet.HashSet<ShardId.ShardId>, never, Sharding>;
+export declare const layer: Layer.Layer<Sharding, never, ShardingConfig | Runners | ShardManagerClient | MessageStorage.MessageStorage | ShardStorage>;
+export {};
 //# sourceMappingURL=Sharding.d.ts.map
\ No newline at end of file
diff --git a/dist/dts/Sharding.d.ts.map b/dist/dts/Sharding.d.ts.map
index b1e01fb84fb12d3dd7febe71d81c39ec87032517..70cba1108452e725e1a8a5ca1c182fa08bf79aa7 100644
--- a/dist/dts/Sharding.d.ts.map
+++ b/dist/dts/Sharding.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"Sharding.d.ts","sourceRoot":"","sources":["../../src/Sharding.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"Sharding.d.ts","sourceRoot":"","sources":["../../src/Sharding.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/dts/ShardingConfig.d.ts b/dist/dts/ShardingConfig.d.ts
index d1973d4940ac70dc79d6a489c3a57e4950e4bcbf..1a91106bb48f852ccb5640d54d757cdad72e9c2f 100644
--- a/dist/dts/ShardingConfig.d.ts
+++ b/dist/dts/ShardingConfig.d.ts
@@ -1,69 +1,172 @@
 /**
  * @since 1.0.0
  */
-import type * as ConfigError from "effect/ConfigError";
-import type * as Context from "effect/Context";
-import type * as Duration from "effect/Duration";
-import type * as Layer from "effect/Layer";
+import * as Config from "effect/Config";
+import type { ConfigError } from "effect/ConfigError";
+import * as Context from "effect/Context";
+import type { DurationInput } from "effect/Duration";
+import * as Effect from "effect/Effect";
+import * as Layer from "effect/Layer";
+import * as Option from "effect/Option";
+import { RunnerAddress } from "./RunnerAddress.js";
+declare const ShardingConfig_base: Context.TagClass<ShardingConfig, "@effect/cluster/ShardingConfig", {
+    /**
+     * The address for the current runner.
+     *
+     * If `None`, the runner is not part of the cluster and will be in a client-only
+     * mode.
+     */
+    readonly runnerAddress: Option.Option<RunnerAddress>;
+    /**
+     * The version of the current runner.
+     */
+    readonly serverVersion: number;
+    /**
+     * The number of shards to allocate to a runner.
+     *
+     * **Note**: this value should be consistent across all runners.
+     */
+    readonly numberOfShards: number;
+    /**
+     * The address of the shard manager.
+     */
+    readonly shardManagerAddress: RunnerAddress;
+    /**
+     * If the shard manager is unavailable for this duration, all the shard
+     * assignments will be reset.
+     */
+    readonly shardManagerUnavailableTimeout: DurationInput;
+    /**
+     * The default capacity of the mailbox for entities.
+     */
+    readonly entityMailboxCapacity: number | "unbounded";
+    /**
+     * The maximum duration of inactivity (i.e. without receiving a message)
+     * after which an entity will be interrupted.
+     */
+    readonly entityMaxIdleTime: DurationInput;
+    /**
+     * The maximum duration of time to wait for an entity to terminate.
+     *
+     * By default this is set to 15 seconds to stay within kubernetes defaults.
+     */
+    readonly entityTerminationTimeout: DurationInput;
+    /**
+     * The interval at which to poll for unprocessed messages from storage.
+     */
+    readonly entityMessagePollInterval: DurationInput;
+    /**
+     * The interval at which to poll for client replies from storage.
+     */
+    readonly entityReplyPollInterval: DurationInput;
+    readonly refreshAssignmentsInterval: DurationInput;
+    /**
+     * The interval to retry a send if EntityNotManagedByRunner is returned.
+     */
+    readonly sendRetryInterval: DurationInput;
+    /**
+     * Simulate serialization and deserialization to remote runners for local
+     * entities.
+     */
+    readonly simulateRemoteSerialization: boolean;
+}>;
 /**
+ * Represents the configuration for the `Sharding` service on a given runner.
+ *
  * @since 1.0.0
- * @category symbols
+ * @category models
  */
-export declare const ShardingConfigTypeId: unique symbol;
+export declare class ShardingConfig extends ShardingConfig_base {
+}
 /**
  * @since 1.0.0
- * @category symbols
+ * @category defaults
  */
-export type ShardingConfigTypeId = typeof ShardingConfigTypeId;
+export declare const defaults: ShardingConfig["Type"];
 /**
- * Sharding configuration
- * @param numberOfShards number of shards (see documentation on how to choose this), should be same on all nodes
- * @param selfHost hostname or IP address of the current pod
- * @param shardingPort port used for pods to communicate together
- * @param shardManagerUri url of the Shard Manager API
- * @param serverVersion version of the current pod
- * @param entityMaxIdleTime time of inactivity (without receiving any message) after which an entity will be interrupted
- * @param entityTerminationTimeout time we give to an entity to handle the termination message before interrupting it
- * @param refreshAssignmentsRetryInterval retry interval in case of failure getting shard assignments from storage
- * @param unhealthyPodReportInterval interval to report unhealthy pods to the Shard Manager (this exists to prevent calling the Shard Manager for each failed message)
  * @since 1.0.0
- * @category models
+ * @category Layers
  */
-export interface ShardingConfig {
-    readonly numberOfShards: number;
-    readonly selfHost: string;
-    readonly shardingPort: number;
-    readonly shardManagerUri: string;
-    readonly serverVersion: string;
-    readonly entityMaxIdleTime: Duration.Duration;
-    readonly entityTerminationTimeout: Duration.Duration;
-    readonly refreshAssignmentsRetryInterval: Duration.Duration;
-    readonly unhealthyPodReportInterval: Duration.Duration;
-}
+export declare const layer: (options?: Partial<ShardingConfig["Type"]>) => Layer.Layer<ShardingConfig>;
 /**
  * @since 1.0.0
- * @category context
+ * @category defaults
  */
-export declare const ShardingConfig: Context.Tag<ShardingConfig, ShardingConfig>;
+export declare const layerDefaults: Layer.Layer<ShardingConfig>;
 /**
- * Provides the default values for the ShardingConfig.
- *
  * @since 1.0.0
- * @category layers
+ * @category Config
  */
-export declare const defaults: Layer.Layer<ShardingConfig>;
+export declare const config: Config.Config<ShardingConfig["Type"]>;
 /**
- * Provides the ShardingConfig, values that are omitted will be read from the defaults
- *
  * @since 1.0.0
- * @category layers
+ * @category Config
  */
-export declare const withDefaults: (customs: Partial<ShardingConfig>) => Layer.Layer<ShardingConfig>;
+export declare const configFromEnv: Effect.Effect<{
+    /**
+     * The address for the current runner.
+     *
+     * If `None`, the runner is not part of the cluster and will be in a client-only
+     * mode.
+     */
+    readonly runnerAddress: Option.Option<RunnerAddress>;
+    /**
+     * The version of the current runner.
+     */
+    readonly serverVersion: number;
+    /**
+     * The number of shards to allocate to a runner.
+     *
+     * **Note**: this value should be consistent across all runners.
+     */
+    readonly numberOfShards: number;
+    /**
+     * The address of the shard manager.
+     */
+    readonly shardManagerAddress: RunnerAddress;
+    /**
+     * If the shard manager is unavailable for this duration, all the shard
+     * assignments will be reset.
+     */
+    readonly shardManagerUnavailableTimeout: DurationInput;
+    /**
+     * The default capacity of the mailbox for entities.
+     */
+    readonly entityMailboxCapacity: number | "unbounded";
+    /**
+     * The maximum duration of inactivity (i.e. without receiving a message)
+     * after which an entity will be interrupted.
+     */
+    readonly entityMaxIdleTime: DurationInput;
+    /**
+     * The maximum duration of time to wait for an entity to terminate.
+     *
+     * By default this is set to 15 seconds to stay within kubernetes defaults.
+     */
+    readonly entityTerminationTimeout: DurationInput;
+    /**
+     * The interval at which to poll for unprocessed messages from storage.
+     */
+    readonly entityMessagePollInterval: DurationInput;
+    /**
+     * The interval at which to poll for client replies from storage.
+     */
+    readonly entityReplyPollInterval: DurationInput;
+    readonly refreshAssignmentsInterval: DurationInput;
+    /**
+     * The interval to retry a send if EntityNotManagedByRunner is returned.
+     */
+    readonly sendRetryInterval: DurationInput;
+    /**
+     * Simulate serialization and deserialization to remote runners for local
+     * entities.
+     */
+    readonly simulateRemoteSerialization: boolean;
+}, ConfigError, never>;
 /**
- * Reads the ShardingConfig from the effect/ConfigProvider
- *
  * @since 1.0.0
- * @category layers
+ * @category Layers
  */
-export declare const fromConfig: Layer.Layer<ShardingConfig, ConfigError.ConfigError>;
+export declare const layerFromEnv: (options?: Partial<ShardingConfig["Type"]> | undefined) => Layer.Layer<ShardingConfig, ConfigError>;
+export {};
 //# sourceMappingURL=ShardingConfig.d.ts.map
\ No newline at end of file
diff --git a/dist/dts/ShardingConfig.d.ts.map b/dist/dts/ShardingConfig.d.ts.map
index ae138d971e9067f4e8951d6680f1166acab0bca9..29c96d19c5f7efbf314b3cd8dfae5e9bcc5318a7 100644
--- a/dist/dts/ShardingConfig.d.ts.map
+++ b/dist/dts/ShardingConfig.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"ShardingConfig.d.ts","sourceRoot":"","sources":["../../src/ShardingConfig.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,OAAO,KAAK,KAAK,WAAW,MAAM,oBAAoB,CAAA;AACtD,OAAO,KAAK,KAAK,OAAO,MAAM,gBAAgB,CAAA;AAC9C,OAAO,KAAK,KAAK,QAAQ,MAAM,iBAAiB,CAAA;AAChD,OAAO,KAAK,KAAK,KAAK,MAAM,cAAc,CAAA;AAG1C;;;GAGG;AACH,eAAO,MAAM,oBAAoB,EAAE,OAAO,MAAsC,CAAA;AAEhF;;;GAGG;AACH,MAAM,MAAM,oBAAoB,GAAG,OAAO,oBAAoB,CAAA;AAE9D;;;;;;;;;;;;;GAaG;AACH,MAAM,WAAW,cAAc;IAC7B,QAAQ,CAAC,cAAc,EAAE,MAAM,CAAA;IAC/B,QAAQ,CAAC,QAAQ,EAAE,MAAM,CAAA;IACzB,QAAQ,CAAC,YAAY,EAAE,MAAM,CAAA;IAC7B,QAAQ,CAAC,eAAe,EAAE,MAAM,CAAA;IAChC,QAAQ,CAAC,aAAa,EAAE,MAAM,CAAA;IAC9B,QAAQ,CAAC,iBAAiB,EAAE,QAAQ,CAAC,QAAQ,CAAA;IAC7C,QAAQ,CAAC,wBAAwB,EAAE,QAAQ,CAAC,QAAQ,CAAA;IACpD,QAAQ,CAAC,+BAA+B,EAAE,QAAQ,CAAC,QAAQ,CAAA;IAC3D,QAAQ,CAAC,0BAA0B,EAAE,QAAQ,CAAC,QAAQ,CAAA;CACvD;AAED;;;GAGG;AACH,eAAO,MAAM,cAAc,EAAE,OAAO,CAAC,GAAG,CAAC,cAAc,EAAE,cAAc,CAA8B,CAAA;AAErG;;;;;GAKG;AACH,eAAO,MAAM,QAAQ,EAAE,KAAK,CAAC,KAAK,CAAC,cAAc,CAAqB,CAAA;AAEtE;;;;;GAKG;AACH,eAAO,MAAM,YAAY,EAAE,CAAC,OAAO,EAAE,OAAO,CAAC,cAAc,CAAC,KAAK,KAAK,CAAC,KAAK,CAAC,cAAc,CAAyB,CAAA;AAEpH;;;;;GAKG;AACH,eAAO,MAAM,UAAU,EAAE,KAAK,CAAC,KAAK,CAAC,cAAc,EAAE,WAAW,CAAC,WAAW,CAAuB,CAAA"}
\ No newline at end of file
+{"version":3,"file":"ShardingConfig.d.ts","sourceRoot":"","sources":["../../src/ShardingConfig.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,OAAO,KAAK,MAAM,MAAM,eAAe,CAAA;AACvC,OAAO,KAAK,EAAE,WAAW,EAAE,MAAM,oBAAoB,CAAA;AAErD,OAAO,KAAK,OAAO,MAAM,gBAAgB,CAAA;AACzC,OAAO,KAAK,EAAE,aAAa,EAAE,MAAM,iBAAiB,CAAA;AAEpD,OAAO,KAAK,MAAM,MAAM,eAAe,CAAA;AACvC,OAAO,KAAK,KAAK,MAAM,cAAc,CAAA;AACrC,OAAO,KAAK,MAAM,MAAM,eAAe,CAAA;AACvC,OAAO,EAAE,aAAa,EAAE,MAAM,oBAAoB,CAAA;;IAShD;;;;;OAKG;4BACqB,MAAM,CAAC,MAAM,CAAC,aAAa,CAAC;IACpD;;OAEG;4BACqB,MAAM;IAC9B;;;;OAIG;6BACsB,MAAM;IAC/B;;OAEG;kCAC2B,aAAa;IAC3C;;;OAGG;6CACsC,aAAa;IACtD;;OAEG;oCAC6B,MAAM,GAAG,WAAW;IACpD;;;OAGG;gCACyB,aAAa;IACzC;;;;OAIG;uCACgC,aAAa;IAChD;;OAEG;wCACiC,aAAa;IACjD;;OAEG;sCAC+B,aAAa;yCACV,aAAa;IAClD;;OAEG;gCACyB,aAAa;IAEzC;;;OAGG;0CACmC,OAAO;;AAlE/C;;;;;GAKG;AACH,qBAAa,cAAe,SAAQ,mBA6DhC;CAAG;AAIP;;;GAGG;AACH,eAAO,MAAM,QAAQ,EAAE,cAAc,CAAC,MAAM,CAc3C,CAAA;AAED;;;GAGG;AACH,eAAO,MAAM,KAAK,aAAc,OAAO,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC,KAAG,KAAK,CAAC,KAAK,CAAC,cAAc,CAChC,CAAA;AAE5D;;;GAGG;AACH,eAAO,MAAM,aAAa,EAAE,KAAK,CAAC,KAAK,CAAC,cAAc,CAAW,CAAA;AAEjE;;;GAGG;AACH,eAAO,MAAM,MAAM,EAAE,MAAM,CAAC,MAAM,CAAC,cAAc,CAAC,MAAM,CAAC,CAqEvD,CAAA;AAEF;;;GAGG;AACH,eAAO,MAAM,aAAa;IAhLxB;;;;;OAKG;4BACqB,MAAM,CAAC,MAAM,CAAC,aAAa,CAAC;IACpD;;OAEG;4BACqB,MAAM;IAC9B;;;;OAIG;6BACsB,MAAM;IAC/B;;OAEG;kCAC2B,aAAa;IAC3C;;;OAGG;6CACsC,aAAa;IACtD;;OAEG;oCAC6B,MAAM,GAAG,WAAW;IACpD;;;OAGG;gCACyB,aAAa;IACzC;;;;OAIG;uCACgC,aAAa;IAChD;;OAEG;wCACiC,aAAa;IACjD;;OAEG;sCAC+B,aAAa;yCACV,aAAa;IAClD;;OAEG;gCACyB,aAAa;IAEzC;;;OAGG;0CACmC,OAAO;sBA2H9C,CAAA;AAED;;;GAGG;AACH,eAAO,MAAM,YAAY,aAAc,OAAO,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC,GAAG,SAAS,KAAG,KAAK,CAAC,KAAK,CAC9F,cAAc,EACd,WAAW,CAKV,CAAA"}
\ No newline at end of file
diff --git a/dist/dts/ShardingRegistrationEvent.d.ts b/dist/dts/ShardingRegistrationEvent.d.ts
index 3f670701fa5accb2c458cf794dd6069ca93fb6d4..db144db26b2d802fed453918b8164578a6bfe0cb 100644
--- a/dist/dts/ShardingRegistrationEvent.d.ts
+++ b/dist/dts/ShardingRegistrationEvent.d.ts
@@ -1,44 +1,59 @@
 /**
  * @since 1.0.0
  */
-import type * as Message from "./Message.js";
-import type * as RecipientType from "./RecipientType.js";
-interface EntityRegistered<Msg extends Message.Message.Any> {
-    _tag: "EntityRegistered";
-    entityType: RecipientType.EntityType<Msg>;
-}
+import * as Data from "effect/Data";
+import type { Entity } from "./Entity.js";
+import type { SingletonAddress } from "./SingletonAddress.js";
 /**
- * Constructs and event that occurs when a new EntityType gets registered.
+ * Represents events that can occur when a runner registers entities or singletons.
  *
  * @since 1.0.0
- * @category constructors
+ * @category models
+ */
+export type ShardingRegistrationEvent = EntityRegistered | SingletonRegistered;
+/**
+ * Represents an event that occurs when a new entity is registered with a runner.
+ *
+ * @since 1.0.0
+ * @category models
  */
-export declare function EntityRegistered<Msg extends Message.Message.Any>(entityType: RecipientType.EntityType<Msg>): ShardingRegistrationEvent;
-interface SingletonRegistered {
-    _tag: "SingletonRegistered";
-    name: string;
+export interface EntityRegistered {
+    readonly _tag: "EntityRegistered";
+    readonly entity: Entity<any>;
 }
 /**
- * Constructs a new event that occurs when a new Singleton is registered.
+ * Represents an event that occurs when a new singleton is registered with a
+ * runner.
  *
  * @since 1.0.0
- * @category constructors
+ * @category models
  */
-export declare function SingletonRegistered(name: string): ShardingRegistrationEvent;
-interface TopicRegistered<Msg extends Message.Message.Any> {
-    _tag: "TopicRegistered";
-    topicType: RecipientType.TopicType<Msg>;
+export interface SingletonRegistered {
+    readonly _tag: "SingletonRegistered";
+    readonly address: SingletonAddress;
 }
 /**
- * Constructs a new event that occurs when a topic is Registered.
+ * @since 1.0.0
+ * @category pattern matching
+ */
+export declare const match: {
+    <Cases extends {
+        readonly EntityRegistered: (args: EntityRegistered) => any;
+        readonly SingletonRegistered: (args: SingletonRegistered) => any;
+    }>(cases: Cases): (value: ShardingRegistrationEvent) => import("effect/Unify").Unify<ReturnType<Cases["EntityRegistered" | "SingletonRegistered"]>>;
+    <Cases extends {
+        readonly EntityRegistered: (args: EntityRegistered) => any;
+        readonly SingletonRegistered: (args: SingletonRegistered) => any;
+    }>(value: ShardingRegistrationEvent, cases: Cases): import("effect/Unify").Unify<ReturnType<Cases["EntityRegistered" | "SingletonRegistered"]>>;
+}, 
+/**
  * @since 1.0.0
  * @category constructors
  */
-export declare function TopicRegistered<Msg extends Message.Message.Any>(topicType: RecipientType.TopicType<Msg>): ShardingRegistrationEvent;
+EntityRegistered: Data.Case.Constructor<EntityRegistered, "_tag">, 
 /**
  * @since 1.0.0
- * @category models
+ * @category constructors
  */
-export type ShardingRegistrationEvent = EntityRegistered<any> | SingletonRegistered | TopicRegistered<any>;
-export {};
+SingletonRegistered: Data.Case.Constructor<SingletonRegistered, "_tag">;
 //# sourceMappingURL=ShardingRegistrationEvent.d.ts.map
\ No newline at end of file
diff --git a/dist/dts/ShardingRegistrationEvent.d.ts.map b/dist/dts/ShardingRegistrationEvent.d.ts.map
index bdddb28a1f8a01ec0817d573eb2311861c80a0e8..6ba4bfadc82a313bf1fe399aafda21cf8c7be980 100644
--- a/dist/dts/ShardingRegistrationEvent.d.ts.map
+++ b/dist/dts/ShardingRegistrationEvent.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"ShardingRegistrationEvent.d.ts","sourceRoot":"","sources":["../../src/ShardingRegistrationEvent.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,OAAO,KAAK,KAAK,OAAO,MAAM,cAAc,CAAA;AAC5C,OAAO,KAAK,KAAK,aAAa,MAAM,oBAAoB,CAAA;AAExD,UAAU,gBAAgB,CAAC,GAAG,SAAS,OAAO,CAAC,OAAO,CAAC,GAAG;IACxD,IAAI,EAAE,kBAAkB,CAAA;IACxB,UAAU,EAAE,aAAa,CAAC,UAAU,CAAC,GAAG,CAAC,CAAA;CAC1C;AAED;;;;;GAKG;AACH,wBAAgB,gBAAgB,CAAC,GAAG,SAAS,OAAO,CAAC,OAAO,CAAC,GAAG,EAC9D,UAAU,EAAE,aAAa,CAAC,UAAU,CAAC,GAAG,CAAC,GACxC,yBAAyB,CAE3B;AAED,UAAU,mBAAmB;IAC3B,IAAI,EAAE,qBAAqB,CAAA;IAC3B,IAAI,EAAE,MAAM,CAAA;CACb;AAED;;;;;GAKG;AACH,wBAAgB,mBAAmB,CAAC,IAAI,EAAE,MAAM,GAAG,yBAAyB,CAE3E;AAED,UAAU,eAAe,CAAC,GAAG,SAAS,OAAO,CAAC,OAAO,CAAC,GAAG;IACvD,IAAI,EAAE,iBAAiB,CAAA;IACvB,SAAS,EAAE,aAAa,CAAC,SAAS,CAAC,GAAG,CAAC,CAAA;CACxC;AAED;;;;GAIG;AACH,wBAAgB,eAAe,CAAC,GAAG,SAAS,OAAO,CAAC,OAAO,CAAC,GAAG,EAC7D,SAAS,EAAE,aAAa,CAAC,SAAS,CAAC,GAAG,CAAC,GACtC,yBAAyB,CAE3B;AAED;;;GAGG;AACH,MAAM,MAAM,yBAAyB,GACjC,gBAAgB,CAAC,GAAG,CAAC,GACrB,mBAAmB,GACnB,eAAe,CAAC,GAAG,CAAC,CAAA"}
\ No newline at end of file
+{"version":3,"file":"ShardingRegistrationEvent.d.ts","sourceRoot":"","sources":["../../src/ShardingRegistrationEvent.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,OAAO,KAAK,IAAI,MAAM,aAAa,CAAA;AACnC,OAAO,KAAK,EAAE,MAAM,EAAE,MAAM,aAAa,CAAA;AACzC,OAAO,KAAK,EAAE,gBAAgB,EAAE,MAAM,uBAAuB,CAAA;AAE7D;;;;;GAKG;AACH,MAAM,MAAM,yBAAyB,GACjC,gBAAgB,GAChB,mBAAmB,CAAA;AAEvB;;;;;GAKG;AACH,MAAM,WAAW,gBAAgB;IAC/B,QAAQ,CAAC,IAAI,EAAE,kBAAkB,CAAA;IACjC,QAAQ,CAAC,MAAM,EAAE,MAAM,CAAC,GAAG,CAAC,CAAA;CAC7B;AAED;;;;;;GAMG;AACH,MAAM,WAAW,mBAAmB;IAClC,QAAQ,CAAC,IAAI,EAAE,qBAAqB,CAAA;IACpC,QAAQ,CAAC,OAAO,EAAE,gBAAgB,CAAA;CACnC;AAED;;;GAGG;AACH,eAAO,MAKG,KAAK;;;;;;;;;;AACb;;;GAGG;AACH,gBAAgB;AAChB;;;GAGG;AACH,mBAAmB,oDAC2B,CAAA"}
\ No newline at end of file
diff --git a/dist/dts/Singleton.d.ts b/dist/dts/Singleton.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7a8ead7a562e33dcc15b9a73e4fd2962ec708e7a
--- /dev/null
+++ b/dist/dts/Singleton.d.ts
@@ -0,0 +1,13 @@
+/**
+ * @since 1.0.0
+ */
+import * as Effect from "effect/Effect";
+import * as Layer from "effect/Layer";
+import type { Scope } from "effect/Scope";
+import { Sharding } from "./Sharding.js";
+/**
+ * @since 1.0.0
+ * @category constructors
+ */
+export declare const make: <E, R>(name: string, run: Effect.Effect<void, E, R>) => Layer.Layer<never, never, Sharding | Exclude<R, Scope>>;
+//# sourceMappingURL=Singleton.d.ts.map
\ No newline at end of file
diff --git a/dist/dts/Singleton.d.ts.map b/dist/dts/Singleton.d.ts.map
new file mode 100644
index 0000000000000000000000000000000000000000..a966288c488dd4a65036a08831da7b65d66ff93a
--- /dev/null
+++ b/dist/dts/Singleton.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"Singleton.d.ts","sourceRoot":"","sources":["../../src/Singleton.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,OAAO,KAAK,MAAM,MAAM,eAAe,CAAA;AACvC,OAAO,KAAK,KAAK,MAAM,cAAc,CAAA;AACrC,OAAO,KAAK,EAAE,KAAK,EAAE,MAAM,cAAc,CAAA;AACzC,OAAO,EAAE,QAAQ,EAAE,MAAM,eAAe,CAAA;AAExC;;;GAGG;AACH,eAAO,MAAM,IAAI,GAAI,CAAC,EAAE,CAAC,QACjB,MAAM,OACP,MAAM,CAAC,MAAM,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,KAC7B,KAAK,CAAC,KAAK,CAAC,KAAK,EAAE,KAAK,EAAE,QAAQ,GAAG,OAAO,CAAC,CAAC,EAAE,KAAK,CAAC,CAIpD,CAAA"}
\ No newline at end of file
diff --git a/dist/dts/SingletonAddress.d.ts b/dist/dts/SingletonAddress.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7c6cc86a04d852d564a310779936e35d65d662ea
--- /dev/null
+++ b/dist/dts/SingletonAddress.d.ts
@@ -0,0 +1,49 @@
+/**
+ * @since 1.0.0
+ */
+import * as Equal from "effect/Equal";
+import * as Hash from "effect/Hash";
+import * as Schema from "effect/Schema";
+/**
+ * @since 1.0.0
+ * @category Address
+ */
+export declare const TypeId: unique symbol;
+/**
+ * @since 1.0.0
+ * @category Address
+ */
+export type TypeId = typeof TypeId;
+declare const SingletonAddress_base: Schema.Class<SingletonAddress, {
+    shardId: Schema.brand<typeof Schema.Int, "ShardId">;
+    name: typeof Schema.NonEmptyTrimmedString;
+}, Schema.Struct.Encoded<{
+    shardId: Schema.brand<typeof Schema.Int, "ShardId">;
+    name: typeof Schema.NonEmptyTrimmedString;
+}>, never, {
+    readonly shardId: number & import("effect/Brand").Brand<"ShardId">;
+} & {
+    readonly name: string;
+}, {}, {}>;
+/**
+ * Represents the unique address of an singleton within the cluster.
+ *
+ * @since 1.0.0
+ * @category Address
+ */
+export declare class SingletonAddress extends SingletonAddress_base {
+    /**
+     * @since 1.0.0
+     */
+    readonly [TypeId]: symbol;
+    /**
+     * @since 1.0.0
+     */
+    [Hash.symbol](): number;
+    /**
+     * @since 1.0.0
+     */
+    [Equal.symbol](that: SingletonAddress): boolean;
+}
+export {};
+//# sourceMappingURL=SingletonAddress.d.ts.map
\ No newline at end of file
diff --git a/dist/dts/SingletonAddress.d.ts.map b/dist/dts/SingletonAddress.d.ts.map
new file mode 100644
index 0000000000000000000000000000000000000000..6928af5db65dddd2e3c2315fa4aebfa08a8dd5f0
--- /dev/null
+++ b/dist/dts/SingletonAddress.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"SingletonAddress.d.ts","sourceRoot":"","sources":["../../src/SingletonAddress.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,OAAO,KAAK,KAAK,MAAM,cAAc,CAAA;AACrC,OAAO,KAAK,IAAI,MAAM,aAAa,CAAA;AACnC,OAAO,KAAK,MAAM,MAAM,eAAe,CAAA;AAGvC;;;GAGG;AACH,eAAO,MAAM,MAAM,EAAE,OAAO,MAAuD,CAAA;AAEnF;;;GAGG;AACH,MAAM,MAAM,MAAM,GAAG,OAAO,MAAM,CAAA;;;;;;;;;;;;AAElC;;;;;GAKG;AACH,qBAAa,gBAAiB,SAAQ,qBAGpC;IACA;;OAEG;IACH,QAAQ,CAAC,CAAC,MAAM,CAAC,SAAU;IAC3B;;OAEG;IACH,CAAC,IAAI,CAAC,MAAM,CAAC;IAGb;;OAEG;IACH,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,IAAI,EAAE,gBAAgB,GAAG,OAAO;CAGhD"}
\ No newline at end of file
diff --git a/dist/dts/Snowflake.d.ts b/dist/dts/Snowflake.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f70b70ec1f031b771259d020747b04ed77e0b1f5
--- /dev/null
+++ b/dist/dts/Snowflake.d.ts
@@ -0,0 +1,121 @@
+/**
+ * @since 1.0.0
+ */
+import type * as Brand from "effect/Brand";
+import * as Context from "effect/Context";
+import * as DateTime from "effect/DateTime";
+import * as Effect from "effect/Effect";
+import * as Layer from "effect/Layer";
+import * as Schema from "effect/Schema";
+import type { MachineId } from "./MachineId.js";
+/**
+ * @since 1.0.0
+ * @category Symbols
+ */
+export declare const TypeId: unique symbol;
+/**
+ * @since 1.0.0
+ * @category Symbols
+ */
+export type TypeId = typeof TypeId;
+/**
+ * @since 1.0.0
+ * @category Models
+ */
+export type Snowflake = Brand.Branded<bigint, TypeId>;
+/**
+ * @since 1.0.0
+ * @category Models
+ */
+export declare const Snowflake: (input: string | bigint) => Snowflake;
+/**
+ * @since 1.0.0
+ * @category Models
+ */
+export declare namespace Snowflake {
+    /**
+     * @since 1.0.0
+     * @category Models
+     */
+    interface Parts {
+        readonly timestamp: number;
+        readonly machineId: MachineId;
+        readonly sequence: number;
+    }
+    /**
+     * @since 1.0.0
+     * @category Models
+     */
+    interface Generator {
+        readonly unsafeNext: () => Snowflake;
+        readonly setMachineId: (machineId: MachineId) => Effect.Effect<void>;
+    }
+}
+/**
+ * @since 1.0.0
+ * @category Schemas
+ */
+export declare const SnowflakeFromBigInt: Schema.Schema<Snowflake, bigint>;
+/**
+ * @since 1.0.0
+ * @category Schemas
+ */
+export declare const SnowflakeFromString: Schema.Schema<Snowflake, string>;
+/**
+ * @since 1.0.0
+ * @category Epoch
+ */
+export declare const constEpochMillis: number;
+/**
+ * @since 1.0.0
+ * @category constructors
+ */
+export declare const make: (options: {
+    readonly machineId: MachineId;
+    readonly sequence: number;
+    readonly timestamp: number;
+}) => Snowflake;
+/**
+ * @since 1.0.0
+ * @category Parts
+ */
+export declare const timestamp: (snowflake: Snowflake) => number;
+/**
+ * @since 1.0.0
+ * @category Parts
+ */
+export declare const dateTime: (snowflake: Snowflake) => DateTime.Utc;
+/**
+ * @since 1.0.0
+ * @category Parts
+ */
+export declare const machineId: (snowflake: Snowflake) => MachineId;
+/**
+ * @since 1.0.0
+ * @category Parts
+ */
+export declare const sequence: (snowflake: Snowflake) => number;
+/**
+ * @since 1.0.0
+ * @category Parts
+ */
+export declare const toParts: (snowflake: Snowflake) => Snowflake.Parts;
+/**
+ * @since 1.0.0
+ * @category Generator
+ */
+export declare const makeGenerator: Effect.Effect<Snowflake.Generator>;
+declare const Generator_base: Context.TagClass<Generator, "@effect/cluster/Snowflake/Generator", Snowflake.Generator>;
+/**
+ * @since 1.0.0
+ * @category Generator
+ */
+export declare class Generator extends Generator_base {
+}
+/**
+ * @since 1.0.0
+ * @category Generator
+ */
+export declare const layerGenerator: Layer.Layer<Generator>;
+export {};
+//# sourceMappingURL=Snowflake.d.ts.map
\ No newline at end of file
diff --git a/dist/dts/Snowflake.d.ts.map b/dist/dts/Snowflake.d.ts.map
new file mode 100644
index 0000000000000000000000000000000000000000..14411fae55aead239213a40a091d0e6a59a31df5
--- /dev/null
+++ b/dist/dts/Snowflake.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"Snowflake.d.ts","sourceRoot":"","sources":["../../src/Snowflake.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,OAAO,KAAK,KAAK,KAAK,MAAM,cAAc,CAAA;AAC1C,OAAO,KAAK,OAAO,MAAM,gBAAgB,CAAA;AACzC,OAAO,KAAK,QAAQ,MAAM,iBAAiB,CAAA;AAC3C,OAAO,KAAK,MAAM,MAAM,eAAe,CAAA;AAEvC,OAAO,KAAK,KAAK,MAAM,cAAc,CAAA;AACrC,OAAO,KAAK,MAAM,MAAM,eAAe,CAAA;AACvC,OAAO,KAAK,EAAE,SAAS,EAAE,MAAM,gBAAgB,CAAA;AAE/C;;;GAGG;AACH,eAAO,MAAM,MAAM,EAAE,OAAO,MAAgD,CAAA;AAE5E;;;GAGG;AACH,MAAM,MAAM,MAAM,GAAG,OAAO,MAAM,CAAA;AAElC;;;GAGG;AACH,MAAM,MAAM,SAAS,GAAG,KAAK,CAAC,OAAO,CAAC,MAAM,EAAE,MAAM,CAAC,CAAA;AAErD;;;GAGG;AACH,eAAO,MAAM,SAAS,UAAW,MAAM,GAAG,MAAM,KAAG,SAC0B,CAAA;AAE7E;;;GAGG;AACH,MAAM,CAAC,OAAO,WAAW,SAAS,CAAC;IACjC;;;OAGG;IACH,UAAiB,KAAK;QACpB,QAAQ,CAAC,SAAS,EAAE,MAAM,CAAA;QAC1B,QAAQ,CAAC,SAAS,EAAE,SAAS,CAAA;QAC7B,QAAQ,CAAC,QAAQ,EAAE,MAAM,CAAA;KAC1B;IAED;;;OAGG;IACH,UAAiB,SAAS;QACxB,QAAQ,CAAC,UAAU,EAAE,MAAM,SAAS,CAAA;QACpC,QAAQ,CAAC,YAAY,EAAE,CAAC,SAAS,EAAE,SAAS,KAAK,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAA;KACrE;CACF;AAED;;;GAGG;AACH,eAAO,MAAM,mBAAmB,EAAE,MAAM,CAAC,MAAM,CAAC,SAAS,EAAE,MAAM,CAEhE,CAAA;AAED;;;GAGG;AACH,eAAO,MAAM,mBAAmB,EAAE,MAAM,CAAC,MAAM,CAAC,SAAS,EAAE,MAAM,CAEhE,CAAA;AAED;;;GAGG;AACH,eAAO,MAAM,gBAAgB,EAAE,MAA6B,CAAA;AAQ5D;;;GAGG;AACH,eAAO,MAAM,IAAI,YAAa;IAC5B,QAAQ,CAAC,SAAS,EAAE,SAAS,CAAA;IAC7B,QAAQ,CAAC,QAAQ,EAAE,MAAM,CAAA;IACzB,QAAQ,CAAC,SAAS,EAAE,MAAM,CAAA;CAC3B,KAAG,SAG+C,CAAA;AAEnD;;;GAGG;AACH,eAAO,MAAM,SAAS,cAAe,SAAS,KAAG,MAA6D,CAAA;AAE9G;;;GAGG;AACH,eAAO,MAAM,QAAQ,cAAe,SAAS,KAAG,QAAQ,CAAC,GAAgD,CAAA;AAEzG;;;GAGG;AACH,eAAO,MAAM,SAAS,cAAe,SAAS,KAAG,SACoB,CAAA;AAErE;;;GAGG;AACH,eAAO,MAAM,QAAQ,cAAe,SAAS,KAAG,MAA6C,CAAA;AAE7F;;;GAGG;AACH,eAAO,MAAM,OAAO,cAAe,SAAS,KAAG,SAAS,CAAC,KAIvD,CAAA;AAEF;;;GAGG;AACH,eAAO,MAAM,aAAa,EAAE,MAAM,CAAC,MAAM,CAAC,SAAS,CAAC,SAAS,CAoC3D,CAAA;;AAEF;;;GAGG;AACH,qBAAa,SAAU,SAAQ,cAG5B;CAAG;AAEN;;;GAGG;AACH,eAAO,MAAM,cAAc,EAAE,KAAK,CAAC,KAAK,CAAC,SAAS,CAA0C,CAAA"}
\ No newline at end of file
diff --git a/dist/dts/SocketRunner.d.ts b/dist/dts/SocketRunner.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..89f971f49bdbaf4568d2a5dccb32e95f43072b54
--- /dev/null
+++ b/dist/dts/SocketRunner.d.ts
@@ -0,0 +1,22 @@
+/**
+ * @since 1.0.0
+ */
+import { SocketServer } from "@effect/platform/SocketServer";
+import type * as RpcSerialization from "@effect/rpc/RpcSerialization";
+import * as Layer from "effect/Layer";
+import type { MessageStorage } from "./MessageStorage.js";
+import * as Runners from "./Runners.js";
+import * as Sharding from "./Sharding.js";
+import type { ShardingConfig } from "./ShardingConfig.js";
+import * as ShardStorage from "./ShardStorage.js";
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export declare const layer: Layer.Layer<Sharding.Sharding | Runners.Runners, never, Runners.RpcClientProtocol | ShardingConfig | RpcSerialization.RpcSerialization | SocketServer | MessageStorage | ShardStorage.ShardStorage>;
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export declare const layerClientOnly: Layer.Layer<Sharding.Sharding | Runners.Runners, never, Runners.RpcClientProtocol | ShardingConfig | MessageStorage>;
+//# sourceMappingURL=SocketRunner.d.ts.map
\ No newline at end of file
diff --git a/dist/dts/SocketRunner.d.ts.map b/dist/dts/SocketRunner.d.ts.map
new file mode 100644
index 0000000000000000000000000000000000000000..b697ab8de4a74636a79e725edd2a589eb3a3cd7d
--- /dev/null
+++ b/dist/dts/SocketRunner.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"SocketRunner.d.ts","sourceRoot":"","sources":["../../src/SocketRunner.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,OAAO,EAAE,YAAY,EAAE,MAAM,+BAA+B,CAAA;AAC5D,OAAO,KAAK,KAAK,gBAAgB,MAAM,8BAA8B,CAAA;AAGrE,OAAO,KAAK,KAAK,MAAM,cAAc,CAAA;AACrC,OAAO,KAAK,EAAE,cAAc,EAAE,MAAM,qBAAqB,CAAA;AACzD,OAAO,KAAK,OAAO,MAAM,cAAc,CAAA;AAEvC,OAAO,KAAK,QAAQ,MAAM,eAAe,CAAA;AACzC,OAAO,KAAK,EAAE,cAAc,EAAE,MAAM,qBAAqB,CAAA;AAEzD,OAAO,KAAK,YAAY,MAAM,mBAAmB,CAAA;AAcjD;;;GAGG;AACH,eAAO,MAAM,KAAK,EAAE,KAAK,CAAC,KAAK,CAC7B,QAAQ,CAAC,QAAQ,GAAG,OAAO,CAAC,OAAO,EACnC,KAAK,EACH,OAAO,CAAC,iBAAiB,GACzB,cAAc,GACd,gBAAgB,CAAC,gBAAgB,GACjC,YAAY,GACZ,cAAc,GACd,YAAY,CAAC,YAAY,CAI5B,CAAA;AAED;;;GAGG;AACH,eAAO,MAAM,eAAe,EAAE,KAAK,CAAC,KAAK,CACvC,QAAQ,CAAC,QAAQ,GAAG,OAAO,CAAC,OAAO,EACnC,KAAK,EACL,OAAO,CAAC,iBAAiB,GAAG,cAAc,GAAG,cAAc,CAK5D,CAAA"}
\ No newline at end of file
diff --git a/dist/dts/SocketShardManager.d.ts b/dist/dts/SocketShardManager.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..024190084646fded142b748db68882cfffb2a060
--- /dev/null
+++ b/dist/dts/SocketShardManager.d.ts
@@ -0,0 +1,17 @@
+/**
+ * @since 1.0.0
+ */
+import { SocketServer } from "@effect/platform/SocketServer";
+import type { RpcSerialization } from "@effect/rpc/RpcSerialization";
+import * as Layer from "effect/Layer";
+import type { RunnerHealth } from "./RunnerHealth.js";
+import * as Runners from "./Runners.js";
+import type { ShardingConfig } from "./ShardingConfig.js";
+import * as ShardManager from "./ShardManager.js";
+import type { ShardStorage } from "./ShardStorage.js";
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export declare const layer: Layer.Layer<ShardManager.ShardManager, never, ShardStorage | SocketServer | Runners.RpcClientProtocol | RpcSerialization | RunnerHealth | ShardManager.Config | ShardingConfig>;
+//# sourceMappingURL=SocketShardManager.d.ts.map
\ No newline at end of file
diff --git a/dist/dts/SocketShardManager.d.ts.map b/dist/dts/SocketShardManager.d.ts.map
new file mode 100644
index 0000000000000000000000000000000000000000..f8f4e4d89a59f5e2b54f4b0f69c360e7f469ea1d
--- /dev/null
+++ b/dist/dts/SocketShardManager.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"SocketShardManager.d.ts","sourceRoot":"","sources":["../../src/SocketShardManager.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,OAAO,EAAE,YAAY,EAAE,MAAM,+BAA+B,CAAA;AAC5D,OAAO,KAAK,EAAE,gBAAgB,EAAE,MAAM,8BAA8B,CAAA;AAGpE,OAAO,KAAK,KAAK,MAAM,cAAc,CAAA;AAErC,OAAO,KAAK,EAAE,YAAY,EAAE,MAAM,mBAAmB,CAAA;AACrD,OAAO,KAAK,OAAO,MAAM,cAAc,CAAA;AACvC,OAAO,KAAK,EAAE,cAAc,EAAE,MAAM,qBAAqB,CAAA;AACzD,OAAO,KAAK,YAAY,MAAM,mBAAmB,CAAA;AACjD,OAAO,KAAK,EAAE,YAAY,EAAE,MAAM,mBAAmB,CAAA;AAcrD;;;GAGG;AACH,eAAO,MAAM,KAAK,EAAE,KAAK,CAAC,KAAK,CAC7B,YAAY,CAAC,YAAY,EACzB,KAAK,EACH,YAAY,GACZ,YAAY,GACZ,OAAO,CAAC,iBAAiB,GACzB,gBAAgB,GAChB,YAAY,GACZ,YAAY,CAAC,MAAM,GACnB,cAAc,CAOjB,CAAA"}
\ No newline at end of file
diff --git a/dist/dts/SqlMessageStorage.d.ts b/dist/dts/SqlMessageStorage.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9bae05e30b8655bf15821560ca620b56263018a9
--- /dev/null
+++ b/dist/dts/SqlMessageStorage.d.ts
@@ -0,0 +1,43 @@
+/**
+ * @since 1.0.0
+ */
+import * as SqlClient from "@effect/sql/SqlClient";
+import type { SqlError } from "@effect/sql/SqlError";
+import type { DurationInput } from "effect/Duration";
+import * as Effect from "effect/Effect";
+import * as Layer from "effect/Layer";
+import { PersistenceError } from "./ClusterError.js";
+import * as MessageStorage from "./MessageStorage.js";
+import type * as Reply from "./Reply.js";
+import type { ShardingConfig } from "./ShardingConfig.js";
+import * as Snowflake from "./Snowflake.js";
+/**
+ * @since 1.0.0
+ * @category Constructors
+ */
+export declare const make: (options?: {
+    readonly prefix?: string | undefined;
+} | undefined) => Effect.Effect<{
+    readonly saveRequest: <R extends import("@effect/rpc/Rpc").Any>(envelope: import("./Message.js").OutgoingRequest<R>) => Effect.Effect<MessageStorage.SaveResult<R>, PersistenceError | import("./ClusterError.js").MalformedMessage>;
+    readonly saveEnvelope: (envelope: import("./Message.js").OutgoingEnvelope) => Effect.Effect<void, PersistenceError | import("./ClusterError.js").MalformedMessage>;
+    readonly saveReply: <R extends import("@effect/rpc/Rpc").Any>(reply: Reply.ReplyWithContext<R>) => Effect.Effect<void, PersistenceError | import("./ClusterError.js").MalformedMessage>;
+    readonly repliesFor: <R extends import("@effect/rpc/Rpc").Any>(requests: Iterable<import("./Message.js").OutgoingRequest<R>>) => Effect.Effect<Array<Reply.Reply<R>>, PersistenceError | import("./ClusterError.js").MalformedMessage>;
+    readonly registerReplyHandler: <R extends import("@effect/rpc/Rpc").Any>(message: import("./Message.js").OutgoingRequest<R>) => Effect.Effect<void>;
+    readonly unprocessedMessages: (shardIds: Iterable<import("./ShardId.js").ShardId>) => Effect.Effect<Array<import("./Message.js").Incoming<any>>, PersistenceError>;
+    readonly unprocessedMessagesById: <R extends import("@effect/rpc/Rpc").Any>(messageIds: Iterable<Snowflake.Snowflake>) => Effect.Effect<Array<import("./Message.js").Incoming<R>>, PersistenceError>;
+    readonly resetAddress: (address: import("./EntityAddress.js").EntityAddress) => Effect.Effect<void, PersistenceError>;
+}, SqlError, Snowflake.Generator | SqlClient.SqlClient>;
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export declare const layer: Layer.Layer<MessageStorage.MessageStorage, SqlError, SqlClient.SqlClient | ShardingConfig>;
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export declare const layerWith: (options: {
+    readonly prefix?: string | undefined;
+    readonly replyPollInterval?: DurationInput | undefined;
+}) => Layer.Layer<MessageStorage.MessageStorage, SqlError, SqlClient.SqlClient | ShardingConfig>;
+//# sourceMappingURL=SqlMessageStorage.d.ts.map
\ No newline at end of file
diff --git a/dist/dts/SqlMessageStorage.d.ts.map b/dist/dts/SqlMessageStorage.d.ts.map
new file mode 100644
index 0000000000000000000000000000000000000000..26d028190683d51c6bd5c42f6f6e4e55bc8d7f2f
--- /dev/null
+++ b/dist/dts/SqlMessageStorage.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"SqlMessageStorage.d.ts","sourceRoot":"","sources":["../../src/SqlMessageStorage.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,OAAO,KAAK,SAAS,MAAM,uBAAuB,CAAA;AAElD,OAAO,KAAK,EAAE,QAAQ,EAAE,MAAM,sBAAsB,CAAA;AAEpD,OAAO,KAAK,EAAE,aAAa,EAAE,MAAM,iBAAiB,CAAA;AACpD,OAAO,KAAK,MAAM,MAAM,eAAe,CAAA;AACvC,OAAO,KAAK,KAAK,MAAM,cAAc,CAAA;AAGrC,OAAO,EAAE,gBAAgB,EAAE,MAAM,mBAAmB,CAAA;AAEpD,OAAO,KAAK,cAAc,MAAM,qBAAqB,CAAA;AAErD,OAAO,KAAK,KAAK,KAAK,MAAM,YAAY,CAAA;AACxC,OAAO,KAAK,EAAE,cAAc,EAAE,MAAM,qBAAqB,CAAA;AACzD,OAAO,KAAK,SAAS,MAAM,gBAAgB,CAAA;AAE3C;;;GAGG;AACH,eAAO,MAAM,IAAI;sBACG,MAAM,GAAG,SAAS;;4HAaX,OAAQ,MAAM;kFAQ/B,OAAA,MAAI;yEAImB,MAAO,gBAC3B,QAAU,OACb,MAAF;qIASM,OAAQ,MAAM,OAClB,MAAA,KAAI;oIAQH,OAAQ,MAAM;0FAWf,OAAG,MAAM;qGAMT,UAAC,SAAS,MAAQ,OAClB,MAAA;oFAI8D,OAAS,MAAK;uDAypBpF,CAAA;AAEF;;;GAGG;AACH,eAAO,MAAM,KAAK,EAAE,KAAK,CAAC,KAAK,CAC7B,cAAc,CAAC,cAAc,EAC7B,QAAQ,EACR,SAAS,CAAC,SAAS,GAAG,cAAc,CAGrC,CAAA;AAED;;;GAGG;AACH,eAAO,MAAM,SAAS,YAAa;IACjC,QAAQ,CAAC,MAAM,CAAC,EAAE,MAAM,GAAG,SAAS,CAAA;IACpC,QAAQ,CAAC,iBAAiB,CAAC,EAAE,aAAa,GAAG,SAAS,CAAA;CACvD,KAAG,KAAK,CAAC,KAAK,CAAC,cAAc,CAAC,cAAc,EAAE,QAAQ,EAAE,SAAS,CAAC,SAAS,GAAG,cAAc,CAG1F,CAAA"}
\ No newline at end of file
diff --git a/dist/dts/SqlShardStorage.d.ts b/dist/dts/SqlShardStorage.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d31e9baf9026a5d641e5cea3d1eabeaeb162ce35
--- /dev/null
+++ b/dist/dts/SqlShardStorage.d.ts
@@ -0,0 +1,38 @@
+/**
+ * @since 1.0.0
+ */
+import * as SqlClient from "@effect/sql/SqlClient";
+import type { SqlError } from "@effect/sql/SqlError";
+import * as Effect from "effect/Effect";
+import * as Layer from "effect/Layer";
+import { PersistenceError } from "./ClusterError.js";
+import * as ShardStorage from "./ShardStorage.js";
+/**
+ * @since 1.0.0
+ * @category Constructors
+ */
+export declare const make: (options?: {
+    readonly prefix?: string | undefined;
+} | undefined) => Effect.Effect<{
+    readonly getAssignments: Effect.Effect<ReadonlyMap<import("./ShardId.js").ShardId, import("effect/Option").Option<import("./RunnerAddress.js").RunnerAddress>>, PersistenceError>;
+    readonly saveAssignments: (assignments: Iterable<readonly [import("./ShardId.js").ShardId, import("effect/Option").Option<import("./RunnerAddress.js").RunnerAddress>]>) => Effect.Effect<void, PersistenceError>;
+    readonly getRunners: Effect.Effect<Array<[import("./RunnerAddress.js").RunnerAddress, import("./Runner.js").Runner]>, PersistenceError>;
+    readonly saveRunners: (runners: Iterable<readonly [import("./RunnerAddress.js").RunnerAddress, import("./Runner.js").Runner]>) => Effect.Effect<void, PersistenceError>;
+    readonly acquire: (address: import("./RunnerAddress.js").RunnerAddress, shardIds: Iterable<import("./ShardId.js").ShardId>) => Effect.Effect<Array<import("./ShardId.js").ShardId>, PersistenceError>;
+    readonly refresh: (address: import("./RunnerAddress.js").RunnerAddress, shardIds: Iterable<import("./ShardId.js").ShardId>) => Effect.Effect<Array<import("./ShardId.js").ShardId>, PersistenceError>;
+    readonly release: (address: import("./RunnerAddress.js").RunnerAddress, shardId: import("./ShardId.js").ShardId) => Effect.Effect<void, PersistenceError>;
+    readonly releaseAll: (address: import("./RunnerAddress.js").RunnerAddress) => Effect.Effect<void, PersistenceError>;
+}, SqlError, SqlClient.SqlClient>;
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export declare const layer: Layer.Layer<ShardStorage.ShardStorage, SqlError, SqlClient.SqlClient>;
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export declare const layerWith: (options: {
+    readonly prefix?: string | undefined;
+}) => Layer.Layer<ShardStorage.ShardStorage, SqlError, SqlClient.SqlClient>;
+//# sourceMappingURL=SqlShardStorage.d.ts.map
\ No newline at end of file
diff --git a/dist/dts/SqlShardStorage.d.ts.map b/dist/dts/SqlShardStorage.d.ts.map
new file mode 100644
index 0000000000000000000000000000000000000000..1fd287e06e45054ba4f7224fa7639d9ca68835cb
--- /dev/null
+++ b/dist/dts/SqlShardStorage.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"SqlShardStorage.d.ts","sourceRoot":"","sources":["../../src/SqlShardStorage.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,OAAO,KAAK,SAAS,MAAM,uBAAuB,CAAA;AAClD,OAAO,KAAK,EAAE,QAAQ,EAAE,MAAM,sBAAsB,CAAA;AAEpD,OAAO,KAAK,MAAM,MAAM,eAAe,CAAA;AACvC,OAAO,KAAK,KAAK,MAAM,cAAc,CAAA;AACrC,OAAO,EAAE,gBAAgB,EAAE,MAAM,mBAAmB,CAAA;AACpD,OAAO,KAAK,YAAY,MAAM,mBAAmB,CAAA;AAEjD;;;GAGG;AACH,eAAO,MAAM,IAAI;sBACG,MAAM,GAAG,SAAS;;6BASpC,OAAK,MAAM;gLAUP,OAAG,MACL;yBAEU,OAAQ,MAAM;sIAUtB,OAAS,MACb;mIAUkC,OAElC,MAAK;mIAWmC,OAAQ,MACjD;wHAMgD,OACvC,MAAF;kFAOgB,OAAO,MAAM;iCAyLnC,CAAA;AAEF;;;GAGG;AACH,eAAO,MAAM,KAAK,EAAE,KAAK,CAAC,KAAK,CAC7B,YAAY,CAAC,YAAY,EACzB,QAAQ,EACR,SAAS,CAAC,SAAS,CAC8B,CAAA;AAEnD;;;GAGG;AACH,eAAO,MAAM,SAAS,YAAa;IACjC,QAAQ,CAAC,MAAM,CAAC,EAAE,MAAM,GAAG,SAAS,CAAA;CACrC,KAAG,KAAK,CAAC,KAAK,CAAC,YAAY,CAAC,YAAY,EAAE,QAAQ,EAAE,SAAS,CAAC,SAAS,CAChB,CAAA"}
\ No newline at end of file
diff --git a/dist/dts/SynchronizedClock.d.ts b/dist/dts/SynchronizedClock.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..adda8940bada07cf8dbe674dacc629e5cc0319f6
--- /dev/null
+++ b/dist/dts/SynchronizedClock.d.ts
@@ -0,0 +1,19 @@
+/**
+ * @since 1.0.0
+ */
+import * as Clock from "effect/Clock";
+import * as Effect from "effect/Effect";
+import * as Layer from "effect/Layer";
+import type { Scope } from "effect/Scope";
+import { ShardManagerClient } from "./ShardManager.js";
+/**
+ * @since 1.0.0
+ * @category Constructors
+ */
+export declare const make: (getRemoteTime: Effect.Effect<number, never, never>) => Effect.Effect<Clock.Clock, never, Scope>;
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export declare const layer: Layer.Layer<never, never, ShardManagerClient>;
+//# sourceMappingURL=SynchronizedClock.d.ts.map
\ No newline at end of file
diff --git a/dist/dts/SynchronizedClock.d.ts.map b/dist/dts/SynchronizedClock.d.ts.map
new file mode 100644
index 0000000000000000000000000000000000000000..98d925dcf2b3addd3ef56f54cc599e09e51e7ca1
--- /dev/null
+++ b/dist/dts/SynchronizedClock.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"SynchronizedClock.d.ts","sourceRoot":"","sources":["../../src/SynchronizedClock.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,OAAO,KAAK,KAAK,MAAM,cAAc,CAAA;AAErC,OAAO,KAAK,MAAM,MAAM,eAAe,CAAA;AACvC,OAAO,KAAK,KAAK,MAAM,cAAc,CAAA;AAErC,OAAO,KAAK,EAAE,KAAK,EAAE,MAAM,cAAc,CAAA;AACzC,OAAO,EAAE,kBAAkB,EAAE,MAAM,mBAAmB,CAAA;AAEtD;;;GAGG;AACH,eAAO,MAAM,IAAI,EAAE,CAAC,aAAa,EAAE,MAAM,CAAC,MAAM,CAAC,MAAM,EAAE,KAAK,EAAE,KAAK,CAAC,KAAK,MAAM,CAAC,MAAM,CACtF,KAAK,CAAC,KAAK,EACX,KAAK,EACL,KAAK,CAiDL,CAAA;AAEF;;;GAGG;AACH,eAAO,MAAM,KAAK,EAAE,KAAK,CAAC,KAAK,CAC7B,KAAK,EACL,KAAK,EACL,kBAAkB,CAKjB,CAAA"}
\ No newline at end of file
diff --git a/dist/dts/index.d.ts b/dist/dts/index.d.ts
index 0c9161b6c27d5aa767232126ce5881d133e8599d..2ff4de81f217f9b532379662bb486bbe4a41a756 100644
--- a/dist/dts/index.d.ts
+++ b/dist/dts/index.d.ts
@@ -1,79 +1,83 @@
 /**
  * @since 1.0.0
  */
-export * as AtLeastOnce from "./AtLeastOnce.js";
+export * as ClusterError from "./ClusterError.js";
 /**
  * @since 1.0.0
  */
-export * as AtLeastOnceStorage from "./AtLeastOnceStorage.js";
+export * as ClusterMetrics from "./ClusterMetrics.js";
 /**
  * @since 1.0.0
  */
-export * as Broadcaster from "./Broadcaster.js";
+export * as ClusterSchema from "./ClusterSchema.js";
 /**
  * @since 1.0.0
  */
-export * as ManagerConfig from "./ManagerConfig.js";
+export * as DeliverAt from "./DeliverAt.js";
 /**
  * @since 1.0.0
  */
-export * as Message from "./Message.js";
+export * as Entity from "./Entity.js";
+/**
+ * @since 1.0.0
+ */
+export * as EntityAddress from "./EntityAddress.js";
 /**
  * @since 1.0.0
  */
-export * as MessageState from "./MessageState.js";
+export * as EntityId from "./EntityId.js";
 /**
  * @since 1.0.0
  */
-export * as Messenger from "./Messenger.js";
+export * as EntityType from "./EntityType.js";
 /**
  * @since 1.0.0
  */
-export * as Pod from "./Pod.js";
+export * as Envelope from "./Envelope.js";
 /**
  * @since 1.0.0
  */
-export * as PodAddress from "./PodAddress.js";
+export * as HttpCommon from "./HttpCommon.js";
 /**
  * @since 1.0.0
  */
-export * as Pods from "./Pods.js";
+export * as HttpRunner from "./HttpRunner.js";
 /**
  * @since 1.0.0
  */
-export * as PodsHealth from "./PodsHealth.js";
+export * as HttpShardManager from "./HttpShardManager.js";
 /**
  * @since 1.0.0
  */
-export * as PoisonPill from "./PoisonPill.js";
+export * as Message from "./Message.js";
 /**
  * @since 1.0.0
  */
-export * as RecipientAddress from "./RecipientAddress.js";
+export * as MessageStorage from "./MessageStorage.js";
 /**
  * @since 1.0.0
  */
-export * as RecipientBehaviour from "./RecipientBehaviour.js";
+export * as Reply from "./Reply.js";
 /**
  * @since 1.0.0
  */
-export * as RecipientBehaviourContext from "./RecipientBehaviourContext.js";
+export * as Runner from "./Runner.js";
 /**
  * @since 1.0.0
  */
-export * as RecipientType from "./RecipientType.js";
+export * as RunnerAddress from "./RunnerAddress.js";
 /**
  * @since 1.0.0
  */
-export * as Serialization from "./Serialization.js";
+export * as RunnerHealth from "./RunnerHealth.js";
 /**
  * @since 1.0.0
  */
-export * as SerializedEnvelope from "./SerializedEnvelope.js";
+export * as RunnerServer from "./RunnerServer.js";
 /**
  * @since 1.0.0
  */
-export * as SerializedMessage from "./SerializedMessage.js";
+export * as Runners from "./Runners.js";
 /**
  * @since 1.0.0
  */
@@ -85,7 +89,7 @@ export * as ShardManager from "./ShardManager.js";
 /**
  * @since 1.0.0
  */
-export * as ShardManagerClient from "./ShardManagerClient.js";
+export * as ShardStorage from "./ShardStorage.js";
 /**
  * @since 1.0.0
  */
@@ -97,17 +101,37 @@ export * as ShardingConfig from "./ShardingConfig.js";
 /**
  * @since 1.0.0
  */
-export * as ShardingEvent from "./ShardingEvent.js";
+export * as ShardingRegistrationEvent from "./ShardingRegistrationEvent.js";
 /**
  * @since 1.0.0
  */
-export * as ShardingException from "./ShardingException.js";
+export * as Singleton from "./Singleton.js";
 /**
  * @since 1.0.0
  */
-export * as ShardingRegistrationEvent from "./ShardingRegistrationEvent.js";
+export * as SingletonAddress from "./SingletonAddress.js";
+/**
+ * @since 1.0.0
+ */
+export * as Snowflake from "./Snowflake.js";
+/**
+ * @since 1.0.0
+ */
+export * as SocketRunner from "./SocketRunner.js";
+/**
+ * @since 1.0.0
+ */
+export * as SocketShardManager from "./SocketShardManager.js";
+/**
+ * @since 1.0.0
+ */
+export * as SqlMessageStorage from "./SqlMessageStorage.js";
+/**
+ * @since 1.0.0
+ */
+export * as SqlShardStorage from "./SqlShardStorage.js";
 /**
  * @since 1.0.0
  */
-export * as Storage from "./Storage.js";
+export * as SynchronizedClock from "./SynchronizedClock.js";
 //# sourceMappingURL=index.d.ts.map
\ No newline at end of file
diff --git a/dist/dts/index.d.ts.map b/dist/dts/index.d.ts.map
index bb1703e23375f248bbee0058c92866168a0fc8ce..2b35104df1b756aeadf20d14396146145791749e 100644
--- a/dist/dts/index.d.ts.map
+++ b/dist/dts/index.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,OAAO,KAAK,WAAW,MAAM,kBAAkB,CAAA;AAE/C;;GAEG;AACH,OAAO,KAAK,kBAAkB,MAAM,yBAAyB,CAAA;AAE7D;;GAEG;AACH,OAAO,KAAK,WAAW,MAAM,kBAAkB,CAAA;AAE/C;;GAEG;AACH,OAAO,KAAK,aAAa,MAAM,oBAAoB,CAAA;AAEnD;;GAEG;AACH,OAAO,KAAK,OAAO,MAAM,cAAc,CAAA;AAEvC;;GAEG;AACH,OAAO,KAAK,YAAY,MAAM,mBAAmB,CAAA;AAEjD;;GAEG;AACH,OAAO,KAAK,SAAS,MAAM,gBAAgB,CAAA;AAE3C;;GAEG;AACH,OAAO,KAAK,GAAG,MAAM,UAAU,CAAA;AAE/B;;GAEG;AACH,OAAO,KAAK,UAAU,MAAM,iBAAiB,CAAA;AAE7C;;GAEG;AACH,OAAO,KAAK,IAAI,MAAM,WAAW,CAAA;AAEjC;;GAEG;AACH,OAAO,KAAK,UAAU,MAAM,iBAAiB,CAAA;AAE7C;;GAEG;AACH,OAAO,KAAK,UAAU,MAAM,iBAAiB,CAAA;AAE7C;;GAEG;AACH,OAAO,KAAK,gBAAgB,MAAM,uBAAuB,CAAA;AAEzD;;GAEG;AACH,OAAO,KAAK,kBAAkB,MAAM,yBAAyB,CAAA;AAE7D;;GAEG;AACH,OAAO,KAAK,yBAAyB,MAAM,gCAAgC,CAAA;AAE3E;;GAEG;AACH,OAAO,KAAK,aAAa,MAAM,oBAAoB,CAAA;AAEnD;;GAEG;AACH,OAAO,KAAK,aAAa,MAAM,oBAAoB,CAAA;AAEnD;;GAEG;AACH,OAAO,KAAK,kBAAkB,MAAM,yBAAyB,CAAA;AAE7D;;GAEG;AACH,OAAO,KAAK,iBAAiB,MAAM,wBAAwB,CAAA;AAE3D;;GAEG;AACH,OAAO,KAAK,OAAO,MAAM,cAAc,CAAA;AAEvC;;GAEG;AACH,OAAO,KAAK,YAAY,MAAM,mBAAmB,CAAA;AAEjD;;GAEG;AACH,OAAO,KAAK,kBAAkB,MAAM,yBAAyB,CAAA;AAE7D;;GAEG;AACH,OAAO,KAAK,QAAQ,MAAM,eAAe,CAAA;AAEzC;;GAEG;AACH,OAAO,KAAK,cAAc,MAAM,qBAAqB,CAAA;AAErD;;GAEG;AACH,OAAO,KAAK,aAAa,MAAM,oBAAoB,CAAA;AAEnD;;GAEG;AACH,OAAO,KAAK,iBAAiB,MAAM,wBAAwB,CAAA;AAE3D;;GAEG;AACH,OAAO,KAAK,yBAAyB,MAAM,gCAAgC,CAAA;AAE3E;;GAEG;AACH,OAAO,KAAK,OAAO,MAAM,cAAc,CAAA"}
\ No newline at end of file
+{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,OAAO,KAAK,YAAY,MAAM,mBAAmB,CAAA;AAEjD;;GAEG;AACH,OAAO,KAAK,cAAc,MAAM,qBAAqB,CAAA;AAErD;;GAEG;AACH,OAAO,KAAK,aAAa,MAAM,oBAAoB,CAAA;AAEnD;;GAEG;AACH,OAAO,KAAK,SAAS,MAAM,gBAAgB,CAAA;AAE3C;;GAEG;AACH,OAAO,KAAK,MAAM,MAAM,aAAa,CAAA;AAErC;;GAEG;AACH,OAAO,KAAK,aAAa,MAAM,oBAAoB,CAAA;AAEnD;;GAEG;AACH,OAAO,KAAK,QAAQ,MAAM,eAAe,CAAA;AAEzC;;GAEG;AACH,OAAO,KAAK,UAAU,MAAM,iBAAiB,CAAA;AAE7C;;GAEG;AACH,OAAO,KAAK,QAAQ,MAAM,eAAe,CAAA;AAEzC;;GAEG;AACH,OAAO,KAAK,UAAU,MAAM,iBAAiB,CAAA;AAE7C;;GAEG;AACH,OAAO,KAAK,UAAU,MAAM,iBAAiB,CAAA;AAE7C;;GAEG;AACH,OAAO,KAAK,gBAAgB,MAAM,uBAAuB,CAAA;AAEzD;;GAEG;AACH,OAAO,KAAK,OAAO,MAAM,cAAc,CAAA;AAEvC;;GAEG;AACH,OAAO,KAAK,cAAc,MAAM,qBAAqB,CAAA;AAErD;;GAEG;AACH,OAAO,KAAK,KAAK,MAAM,YAAY,CAAA;AAEnC;;GAEG;AACH,OAAO,KAAK,MAAM,MAAM,aAAa,CAAA;AAErC;;GAEG;AACH,OAAO,KAAK,aAAa,MAAM,oBAAoB,CAAA;AAEnD;;GAEG;AACH,OAAO,KAAK,YAAY,MAAM,mBAAmB,CAAA;AAEjD;;GAEG;AACH,OAAO,KAAK,YAAY,MAAM,mBAAmB,CAAA;AAEjD;;GAEG;AACH,OAAO,KAAK,OAAO,MAAM,cAAc,CAAA;AAEvC;;GAEG;AACH,OAAO,KAAK,OAAO,MAAM,cAAc,CAAA;AAEvC;;GAEG;AACH,OAAO,KAAK,YAAY,MAAM,mBAAmB,CAAA;AAEjD;;GAEG;AACH,OAAO,KAAK,YAAY,MAAM,mBAAmB,CAAA;AAEjD;;GAEG;AACH,OAAO,KAAK,QAAQ,MAAM,eAAe,CAAA;AAEzC;;GAEG;AACH,OAAO,KAAK,cAAc,MAAM,qBAAqB,CAAA;AAErD;;GAEG;AACH,OAAO,KAAK,yBAAyB,MAAM,gCAAgC,CAAA;AAE3E;;GAEG;AACH,OAAO,KAAK,SAAS,MAAM,gBAAgB,CAAA;AAE3C;;GAEG;AACH,OAAO,KAAK,gBAAgB,MAAM,uBAAuB,CAAA;AAEzD;;GAEG;AACH,OAAO,KAAK,SAAS,MAAM,gBAAgB,CAAA;AAE3C;;GAEG;AACH,OAAO,KAAK,YAAY,MAAM,mBAAmB,CAAA;AAEjD;;GAEG;AACH,OAAO,KAAK,kBAAkB,MAAM,yBAAyB,CAAA;AAE7D;;GAEG;AACH,OAAO,KAAK,iBAAiB,MAAM,wBAAwB,CAAA;AAE3D;;GAEG;AACH,OAAO,KAAK,eAAe,MAAM,sBAAsB,CAAA;AAEvD;;GAEG;AACH,OAAO,KAAK,iBAAiB,MAAM,wBAAwB,CAAA"}
\ No newline at end of file
diff --git a/dist/dts/internal/entityReaper.d.ts b/dist/dts/internal/entityReaper.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..bfc5617c7276d6de8bf2ff50533cbabdc0c1efe6
--- /dev/null
+++ b/dist/dts/internal/entityReaper.d.ts
@@ -0,0 +1,2 @@
+export {};
+//# sourceMappingURL=entityReaper.d.ts.map
\ No newline at end of file
diff --git a/dist/dts/internal/entityReaper.d.ts.map b/dist/dts/internal/entityReaper.d.ts.map
new file mode 100644
index 0000000000000000000000000000000000000000..d4b16be27da5f82756a429dc8624d2b3758e2af5
--- /dev/null
+++ b/dist/dts/internal/entityReaper.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"entityReaper.d.ts","sourceRoot":"","sources":["../../../src/internal/entityReaper.ts"],"names":[],"mappings":""}
\ No newline at end of file
diff --git a/dist/dts/internal/hash.d.ts b/dist/dts/internal/hash.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7cce305bbc4a145ddfb3a5257b5e0c3586b2f027
--- /dev/null
+++ b/dist/dts/internal/hash.d.ts
@@ -0,0 +1,2 @@
+export {};
+//# sourceMappingURL=hash.d.ts.map
\ No newline at end of file
diff --git a/dist/dts/internal/hash.d.ts.map b/dist/dts/internal/hash.d.ts.map
new file mode 100644
index 0000000000000000000000000000000000000000..4ce4f946240e182aab538c09fb0a3d7051663039
--- /dev/null
+++ b/dist/dts/internal/hash.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"hash.d.ts","sourceRoot":"","sources":["../../../src/internal/hash.ts"],"names":[],"mappings":""}
\ No newline at end of file
diff --git a/dist/dts/internal/interruptors.d.ts b/dist/dts/internal/interruptors.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52309badfeafacf928fe2524b4d76183bc553264
--- /dev/null
+++ b/dist/dts/internal/interruptors.d.ts
@@ -0,0 +1,2 @@
+export {};
+//# sourceMappingURL=interruptors.d.ts.map
\ No newline at end of file
diff --git a/dist/dts/internal/interruptors.d.ts.map b/dist/dts/internal/interruptors.d.ts.map
new file mode 100644
index 0000000000000000000000000000000000000000..0e5b56a7fa0060e10123a5837bf4eed1a0bd55d9
--- /dev/null
+++ b/dist/dts/internal/interruptors.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"interruptors.d.ts","sourceRoot":"","sources":["../../../src/internal/interruptors.ts"],"names":[],"mappings":""}
\ No newline at end of file
diff --git a/dist/dts/internal/resourceMap.d.ts b/dist/dts/internal/resourceMap.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..242a13e7413b6ea0c41bb2165b262826c1b51898
--- /dev/null
+++ b/dist/dts/internal/resourceMap.d.ts
@@ -0,0 +1,22 @@
+import * as Deferred from "effect/Deferred";
+import * as Effect from "effect/Effect";
+import * as MutableHashMap from "effect/MutableHashMap";
+import * as MutableRef from "effect/MutableRef";
+import * as Scope from "effect/Scope";
+export declare class ResourceMap<K, A, E> {
+    readonly lookup: (key: K, scope: Scope.Scope) => Effect.Effect<A, E>;
+    readonly entries: MutableHashMap.MutableHashMap<K, {
+        readonly scope: Scope.CloseableScope;
+        readonly deferred: Deferred.Deferred<A, E>;
+    }>;
+    readonly isClosed: MutableRef.MutableRef<boolean>;
+    constructor(lookup: (key: K, scope: Scope.Scope) => Effect.Effect<A, E>, entries: MutableHashMap.MutableHashMap<K, {
+        readonly scope: Scope.CloseableScope;
+        readonly deferred: Deferred.Deferred<A, E>;
+    }>, isClosed: MutableRef.MutableRef<boolean>);
+    static make: <K_1, A_1, E_1, R>(lookup: (key: K_1) => Effect.Effect<A_1, E_1, R>) => Effect.Effect<ResourceMap<K_1, A_1, E_1>, never, Scope.Scope | R>;
+    get(key: K): Effect.Effect<A, E>;
+    remove(key: K): Effect.Effect<void>;
+    removeIgnore(key: K): Effect.Effect<void>;
+}
+//# sourceMappingURL=resourceMap.d.ts.map
\ No newline at end of file
diff --git a/dist/dts/internal/resourceMap.d.ts.map b/dist/dts/internal/resourceMap.d.ts.map
new file mode 100644
index 0000000000000000000000000000000000000000..59c673b321ca84c9be81033d385468510e71f231
--- /dev/null
+++ b/dist/dts/internal/resourceMap.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"resourceMap.d.ts","sourceRoot":"","sources":["../../../src/internal/resourceMap.ts"],"names":[],"mappings":"AACA,OAAO,KAAK,QAAQ,MAAM,iBAAiB,CAAA;AAC3C,OAAO,KAAK,MAAM,MAAM,eAAe,CAAA;AAEvC,OAAO,KAAK,cAAc,MAAM,uBAAuB,CAAA;AACvD,OAAO,KAAK,UAAU,MAAM,mBAAmB,CAAA;AAE/C,OAAO,KAAK,KAAK,MAAM,cAAc,CAAA;AAErC,qBAAa,WAAW,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC;IAE5B,QAAQ,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,CAAC,EAAE,KAAK,EAAE,KAAK,CAAC,KAAK,KAAK,MAAM,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC;IACpE,QAAQ,CAAC,OAAO,EAAE,cAAc,CAAC,cAAc,CAAC,CAAC,EAAE;QACjD,QAAQ,CAAC,KAAK,EAAE,KAAK,CAAC,cAAc,CAAA;QACpC,QAAQ,CAAC,QAAQ,EAAE,QAAQ,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,CAAC,CAAA;KAC3C,CAAC;IACF,QAAQ,CAAC,QAAQ,EAAE,UAAU,CAAC,UAAU,CAAC,OAAO,CAAC;gBALxC,MAAM,EAAE,CAAC,GAAG,EAAE,CAAC,EAAE,KAAK,EAAE,KAAK,CAAC,KAAK,KAAK,MAAM,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,EAC3D,OAAO,EAAE,cAAc,CAAC,cAAc,CAAC,CAAC,EAAE;QACjD,QAAQ,CAAC,KAAK,EAAE,KAAK,CAAC,cAAc,CAAA;QACpC,QAAQ,CAAC,QAAQ,EAAE,QAAQ,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,CAAC,CAAA;KAC3C,CAAC,EACO,QAAQ,EAAE,UAAU,CAAC,UAAU,CAAC,OAAO,CAAC;IAGnD,MAAM,CAAC,IAAI,kBAAwC,CAAC,gBAAgB,GAAC,KAAK,MAAM,CAAC,MAAM,CAAC,GAAC,EAAE,GAAC,EAAE,CAAC,CAAC,uEA0B9F;IAEF,GAAG,CAAC,GAAG,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC;IAsBhC,MAAM,CAAC,GAAG,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC;IAWnC,YAAY,CAAC,GAAG,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC;CAQ1C"}
\ No newline at end of file
diff --git a/dist/dts/internal/resourceRef.d.ts b/dist/dts/internal/resourceRef.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5911f1c44e4d0fae42f79d57f38c88821e187e68
--- /dev/null
+++ b/dist/dts/internal/resourceRef.d.ts
@@ -0,0 +1,25 @@
+import * as Effect from "effect/Effect";
+import * as MutableRef from "effect/MutableRef";
+import * as Option from "effect/Option";
+import * as Scope from "effect/Scope";
+export type State<A> = {
+    readonly _tag: "Closed";
+} | {
+    readonly _tag: "Acquiring";
+    readonly scope: Scope.CloseableScope;
+} | {
+    readonly _tag: "Acquired";
+    readonly scope: Scope.CloseableScope;
+    readonly value: A;
+};
+export declare class ResourceRef<A, E = never> {
+    readonly state: MutableRef.MutableRef<State<A>>;
+    readonly acquire: (scope: Scope.Scope) => Effect.Effect<A, E>;
+    static from: <A_1, E_1>(parentScope: Scope.Scope, acquire: (scope: Scope.Scope) => Effect.Effect<A_1, E_1>) => Effect.Effect<ResourceRef<A_1, E_1>, E_1, never>;
+    constructor(state: MutableRef.MutableRef<State<A>>, acquire: (scope: Scope.Scope) => Effect.Effect<A, E>);
+    latch: Effect.Latch;
+    unsafeGet(): Option.Option<A>;
+    unsafeRebuild(): Effect.Effect<void, E>;
+    await: Effect.Effect<A>;
+}
+//# sourceMappingURL=resourceRef.d.ts.map
\ No newline at end of file
diff --git a/dist/dts/internal/resourceRef.d.ts.map b/dist/dts/internal/resourceRef.d.ts.map
new file mode 100644
index 0000000000000000000000000000000000000000..28235864a07a96fe9f601bf42eb56bc9458761a2
--- /dev/null
+++ b/dist/dts/internal/resourceRef.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"resourceRef.d.ts","sourceRoot":"","sources":["../../../src/internal/resourceRef.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,MAAM,MAAM,eAAe,CAAA;AAEvC,OAAO,KAAK,UAAU,MAAM,mBAAmB,CAAA;AAC/C,OAAO,KAAK,MAAM,MAAM,eAAe,CAAA;AACvC,OAAO,KAAK,KAAK,MAAM,cAAc,CAAA;AAGrC,MAAM,MAAM,KAAK,CAAC,CAAC,IAAI;IACrB,QAAQ,CAAC,IAAI,EAAE,QAAQ,CAAA;CACxB,GAAG;IACF,QAAQ,CAAC,IAAI,EAAE,WAAW,CAAA;IAC1B,QAAQ,CAAC,KAAK,EAAE,KAAK,CAAC,cAAc,CAAA;CACrC,GAAG;IACF,QAAQ,CAAC,IAAI,EAAE,UAAU,CAAA;IACzB,QAAQ,CAAC,KAAK,EAAE,KAAK,CAAC,cAAc,CAAA;IACpC,QAAQ,CAAC,KAAK,EAAE,CAAC,CAAA;CAClB,CAAA;AAED,qBAAa,WAAW,CAAC,CAAC,EAAE,CAAC,GAAG,KAAK;IA0BjC,QAAQ,CAAC,KAAK,EAAE,UAAU,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;IAC/C,QAAQ,CAAC,OAAO,EAAE,CAAC,KAAK,EAAE,KAAK,CAAC,KAAK,KAAK,MAAM,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC;IA1B/D,MAAM,CAAC,IAAI,wDAEQ,KAAK,CAAC,KAAK,KAAK,MAAM,CAAC,MAAM,CAAC,GAAC,EAAE,GAAC,CAAC,sDAoBpD;gBAGS,KAAK,EAAE,UAAU,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,EACtC,OAAO,EAAE,CAAC,KAAK,EAAE,KAAK,CAAC,KAAK,KAAK,MAAM,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC;IAG/D,KAAK,eAA+B;IAEpC,SAAS,IAAI,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC;IAO7B,aAAa,IAAI,MAAM,CAAC,MAAM,CAAC,IAAI,EAAE,CAAC,CAAC;IAqBvC,KAAK,EAAE,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,CAQrB;CACH"}
\ No newline at end of file
diff --git a/dist/dts/internal/shardManager.d.ts b/dist/dts/internal/shardManager.d.ts
index 7ddf68303c5fcda3ccbfe20ce4958492309933f0..325b8a036f699cb9976aca5738a5c6c3c6355511 100644
--- a/dist/dts/internal/shardManager.d.ts
+++ b/dist/dts/internal/shardManager.d.ts
@@ -1,12 +1,2 @@
-import * as Layer from "effect/Layer";
-import * as ManagerConfig from "../ManagerConfig.js";
-import * as Pods from "../Pods.js";
-import * as PodsHealth from "../PodsHealth.js";
-import type * as ShardManager from "../ShardManager.js";
-import * as Storage from "../Storage.js";
-/**
- * @since 1.0.0
- * @category layers
- */
-export declare const live: Layer.Layer<ShardManager.ShardManager, never, Pods.Pods | Storage.Storage | ManagerConfig.ManagerConfig | PodsHealth.PodsHealth>;
+export {};
 //# sourceMappingURL=shardManager.d.ts.map
\ No newline at end of file
diff --git a/dist/dts/internal/shardManager.d.ts.map b/dist/dts/internal/shardManager.d.ts.map
index 0ed4699c5c9513d91f74f305a2027cc8417d8457..389e3ac7d63502cb90d78d70d8671555c33cf210 100644
--- a/dist/dts/internal/shardManager.d.ts.map
+++ b/dist/dts/internal/shardManager.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"shardManager.d.ts","sourceRoot":"","sources":["../../../src/internal/shardManager.ts"],"names":[],"mappings":"AAWA,OAAO,KAAK,KAAK,MAAM,cAAc,CAAA;AAQrC,OAAO,KAAK,aAAa,MAAM,qBAAqB,CAAA;AAGpD,OAAO,KAAK,IAAI,MAAM,YAAY,CAAA;AAClC,OAAO,KAAK,UAAU,MAAM,kBAAkB,CAAA;AAI9C,OAAO,KAAK,KAAK,YAAY,MAAM,oBAAoB,CAAA;AACvD,OAAO,KAAK,OAAO,MAAM,eAAe,CAAA;AAifxC;;;GAGG;AACH,eAAO,MAAM,IAAI,kIA6DqB,CAAA"}
\ No newline at end of file
+{"version":3,"file":"shardManager.d.ts","sourceRoot":"","sources":["../../../src/internal/shardManager.ts"],"names":[],"mappings":""}
\ No newline at end of file
diff --git a/dist/esm/ClusterError.js b/dist/esm/ClusterError.js
new file mode 100644
index 0000000000000000000000000000000000000000..b349355873b69825e80b72c75f9c29c2da8ae4d4
--- /dev/null
+++ b/dist/esm/ClusterError.js
@@ -0,0 +1,164 @@
+/**
+ * @since 1.0.0
+ */
+import * as Cause from "effect/Cause";
+import * as Effect from "effect/Effect";
+import { hasProperty, isTagged } from "effect/Predicate";
+import * as Schema from "effect/Schema";
+import { EntityAddress } from "./EntityAddress.js";
+import { RunnerAddress } from "./RunnerAddress.js";
+import { SnowflakeFromString } from "./Snowflake.js";
+/**
+ * @since 1.0.0
+ * @category Symbols
+ */
+export const TypeId = /*#__PURE__*/Symbol.for("@effect/cluster/ClusterError");
+/**
+ * Represents an error that occurs when a Runner receives a message for an entity
+ * that it is not responsible for managing.
+ *
+ * @since 1.0.0
+ * @category errors
+ */
+export class EntityNotManagedByRunner extends /*#__PURE__*/Schema.TaggedError()("EntityNotManagedByRunner", {
+  address: EntityAddress
+}) {
+  /**
+   * @since 1.0.0
+   */
+  [TypeId] = TypeId;
+  /**
+   * @since 1.0.0
+   */
+  static is(u) {
+    return hasProperty(u, TypeId) && isTagged(u, "EntityNotManagedByRunner");
+  }
+}
+/**
+ * Represents an error that occurs when a message fails to be properly
+ * deserialized by an entity.
+ *
+ * @since 1.0.0
+ * @category errors
+ */
+export class MalformedMessage extends /*#__PURE__*/Schema.TaggedError()("MalformedMessage", {
+  cause: Schema.Defect
+}) {
+  /**
+   * @since 1.0.0
+   */
+  [TypeId] = TypeId;
+  /**
+   * @since 1.0.0
+   */
+  static is(u) {
+    return hasProperty(u, TypeId) && isTagged(u, "MalformedMessage");
+  }
+  /**
+   * @since 1.0.0
+   */
+  static refail = /*#__PURE__*/Effect.mapError(cause => new MalformedMessage({
+    cause
+  }));
+}
+/**
+ * Represents an error that occurs when a message fails to be persisted into
+ * cluster's mailbox storage.
+ *
+ * @since 1.0.0
+ * @category errors
+ */
+export class PersistenceError extends /*#__PURE__*/Schema.TaggedError()("PersistenceError", {
+  cause: Schema.Defect
+}) {
+  /**
+   * @since 1.0.0
+   */
+  [TypeId] = TypeId;
+  /**
+   * @since 1.0.0
+   */
+  static refail(effect) {
+    return Effect.catchAllCause(effect, cause => Effect.fail(new PersistenceError({
+      cause: Cause.squash(cause)
+    })));
+  }
+}
+/**
+ * Represents an error that occurs when a Runner is not registered with the shard
+ * manager.
+ *
+ * @since 1.0.0
+ * @category errors
+ */
+export class RunnerNotRegistered extends /*#__PURE__*/Schema.TaggedError()("RunnerNotRegistered", {
+  address: RunnerAddress
+}) {
+  /**
+   * @since 1.0.0
+   */
+  [TypeId] = TypeId;
+}
+/**
+ * Represents an error that occurs when a Runner is unresponsive.
+ *
+ * @since 1.0.0
+ * @category errors
+ */
+export class RunnerUnavailable extends /*#__PURE__*/Schema.TaggedError()("RunnerUnavailable", {
+  address: RunnerAddress
+}) {
+  /**
+   * @since 1.0.0
+   */
+  [TypeId] = TypeId;
+  /**
+   * @since 1.0.0
+   */
+  static is(u) {
+    return hasProperty(u, TypeId) && isTagged(u, "RunnerUnavailable");
+  }
+}
+/**
+ * Represents an error that occurs when the entities mailbox is full.
+ *
+ * @since 1.0.0
+ * @category errors
+ */
+export class MailboxFull extends /*#__PURE__*/Schema.TaggedError()("MailboxFull", {
+  address: EntityAddress
+}) {
+  /**
+   * @since 1.0.0
+   */
+  [TypeId] = TypeId;
+  /**
+   * @since 1.0.0
+   */
+  static is(u) {
+    return hasProperty(u, TypeId) && isTagged(u, "MailboxFull");
+  }
+}
+/**
+ * Represents an error that occurs when the entity is already processing a
+ * request.
+ *
+ * @since 1.0.0
+ * @category errors
+ */
+export class AlreadyProcessingMessage extends /*#__PURE__*/Schema.TaggedError()("AlreadyProcessingMessage", {
+  envelopeId: SnowflakeFromString,
+  address: EntityAddress
+}) {
+  /**
+   * @since 1.0.0
+   */
+  [TypeId] = TypeId;
+  /**
+   * @since 1.0.0
+   */
+  static is(u) {
+    return hasProperty(u, TypeId) && isTagged(u, "AlreadyProcessingMessage");
+  }
+}
+//# sourceMappingURL=ClusterError.js.map
\ No newline at end of file
diff --git a/dist/esm/ClusterError.js.map b/dist/esm/ClusterError.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..6b34613f17cc05fdbca05ff630e26d5af9ecaa96
--- /dev/null
+++ b/dist/esm/ClusterError.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"ClusterError.js","names":["Cause","Effect","hasProperty","isTagged","Schema","EntityAddress","RunnerAddress","SnowflakeFromString","TypeId","Symbol","for","EntityNotManagedByRunner","TaggedError","address","is","u","MalformedMessage","cause","Defect","refail","mapError","PersistenceError","effect","catchAllCause","fail","squash","RunnerNotRegistered","RunnerUnavailable","MailboxFull","AlreadyProcessingMessage","envelopeId"],"sources":["../../src/ClusterError.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/esm/ClusterMetrics.js b/dist/esm/ClusterMetrics.js
new file mode 100644
index 0000000000000000000000000000000000000000..714bb1f8208908171af63136eae7e91856c6a0dd
--- /dev/null
+++ b/dist/esm/ClusterMetrics.js
@@ -0,0 +1,54 @@
+/**
+ * @since 1.0.0
+ */
+import * as Metric from "effect/Metric";
+/**
+ * @since 1.0.0
+ * @category metrics
+ */
+export const shards = /*#__PURE__*/Metric.gauge("effect_cluster_shards");
+/**
+ * @since 1.0.0
+ * @category metrics
+ */
+export const entities = /*#__PURE__*/Metric.gauge("effect_cluster_entities", {
+  bigint: true
+});
+/**
+ * @since 1.0.0
+ * @category metrics
+ */
+export const mailboxSize = /*#__PURE__*/Metric.gauge("effect_cluster_mailbox_size", {
+  bigint: true
+});
+/**
+ * @since 1.0.0
+ * @category metrics
+ */
+export const singletons = /*#__PURE__*/Metric.gauge("effect_cluster_singletons");
+/**
+ * @since 1.0.0
+ * @category metrics
+ */
+export const runners = /*#__PURE__*/Metric.gauge("effect_cluster_runners");
+/**
+ * @since 1.0.0
+ * @category metrics
+ */
+export const assignedShards = /*#__PURE__*/Metric.gauge("effect_cluster_shards_assigned");
+/**
+ * @since 1.0.0
+ * @category metrics
+ */
+export const unassignedShards = /*#__PURE__*/Metric.gauge("effect_cluster_shards_unassigned");
+/**
+ * @since 1.0.0
+ * @category metrics
+ */
+export const rebalances = /*#__PURE__*/Metric.counter("effect_cluster_rebalances");
+/**
+ * @since 1.0.0
+ * @category metrics
+ */
+export const runnerHealthChecked = /*#__PURE__*/Metric.counter("effect_cluster_runner_health_checked");
+//# sourceMappingURL=ClusterMetrics.js.map
\ No newline at end of file
diff --git a/dist/esm/ClusterMetrics.js.map b/dist/esm/ClusterMetrics.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..ebb0fd6347b621e5300912a024015d2ab56aede0
--- /dev/null
+++ b/dist/esm/ClusterMetrics.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"ClusterMetrics.js","names":["Metric","shards","gauge","entities","bigint","mailboxSize","singletons","runners","assignedShards","unassignedShards","rebalances","counter","runnerHealthChecked"],"sources":["../../src/ClusterMetrics.ts"],"sourcesContent":[null],"mappings":"AAAA;;;AAGA,OAAO,KAAKA,MAAM,MAAM,eAAe;AAEvC;;;;AAIA,OAAO,MAAMC,MAAM,gBAAGD,MAAM,CAACE,KAAK,CAAC,uBAAuB,CAAC;AAE3D;;;;AAIA,OAAO,MAAMC,QAAQ,gBAAGH,MAAM,CAACE,KAAK,CAAC,yBAAyB,EAAE;EAC9DE,MAAM,EAAE;CACT,CAAC;AAEF;;;;AAIA,OAAO,MAAMC,WAAW,gBAAGL,MAAM,CAACE,KAAK,CAAC,6BAA6B,EAAE;EACrEE,MAAM,EAAE;CACT,CAAC;AAEF;;;;AAIA,OAAO,MAAME,UAAU,gBAAGN,MAAM,CAACE,KAAK,CAAC,2BAA2B,CAAC;AAEnE;;;;AAIA,OAAO,MAAMK,OAAO,gBAAGP,MAAM,CAACE,KAAK,CAAC,wBAAwB,CAAC;AAE7D;;;;AAIA,OAAO,MAAMM,cAAc,gBAAGR,MAAM,CAACE,KAAK,CAAC,gCAAgC,CAAC;AAE5E;;;;AAIA,OAAO,MAAMO,gBAAgB,gBAAGT,MAAM,CAACE,KAAK,CAAC,kCAAkC,CAAC;AAEhF;;;;AAIA,OAAO,MAAMQ,UAAU,gBAAGV,MAAM,CAACW,OAAO,CAAC,2BAA2B,CAAC;AAErE;;;;AAIA,OAAO,MAAMC,mBAAmB,gBAAGZ,MAAM,CAACW,OAAO,CAAC,sCAAsC,CAAC","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/esm/ClusterSchema.js b/dist/esm/ClusterSchema.js
new file mode 100644
index 0000000000000000000000000000000000000000..4b625ef2be40663211eca0daaaa798bc66ef814a
--- /dev/null
+++ b/dist/esm/ClusterSchema.js
@@ -0,0 +1,13 @@
+/**
+ * @since 1.0.0
+ */
+import * as Context from "effect/Context";
+import { constFalse } from "effect/Function";
+/**
+ * @since 1.0.0
+ * @category Annotations
+ */
+export class Persisted extends /*#__PURE__*/Context.Reference()("@effect/cluster/ClusterSchema/Persisted", {
+  defaultValue: constFalse
+}) {}
+//# sourceMappingURL=ClusterSchema.js.map
\ No newline at end of file
diff --git a/dist/esm/ClusterSchema.js.map b/dist/esm/ClusterSchema.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..cad4f045a0d2d5e90a104957401cd4cc4325d997
--- /dev/null
+++ b/dist/esm/ClusterSchema.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"ClusterSchema.js","names":["Context","constFalse","Persisted","Reference","defaultValue"],"sources":["../../src/ClusterSchema.ts"],"sourcesContent":[null],"mappings":"AAAA;;;AAGA,OAAO,KAAKA,OAAO,MAAM,gBAAgB;AACzC,SAASC,UAAU,QAAQ,iBAAiB;AAE5C;;;;AAIA,OAAM,MAAOC,SAAU,sBAAQF,OAAO,CAACG,SAAS,EAAa,CAAC,yCAAyC,EAAE;EACvGC,YAAY,EAAEH;CACf,CAAC","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/esm/DeliverAt.js b/dist/esm/DeliverAt.js
new file mode 100644
index 0000000000000000000000000000000000000000..ce5deeba3321317ef56be399f422e028b8e0cf7c
--- /dev/null
+++ b/dist/esm/DeliverAt.js
@@ -0,0 +1,22 @@
+import { hasProperty } from "effect/Predicate";
+/**
+ * @since 1.0.0
+ * @category symbols
+ */
+export const symbol = /*#__PURE__*/Symbol.for("@effect/cluster/DeliverAt");
+/**
+ * @since 1.0.0
+ * @category guards
+ */
+export const isDeliverAt = self => hasProperty(self, symbol);
+/**
+ * @since 1.0.0
+ * @category accessors
+ */
+export const toMillis = self => {
+  if (isDeliverAt(self)) {
+    return self[symbol]().epochMillis;
+  }
+  return null;
+};
+//# sourceMappingURL=DeliverAt.js.map
\ No newline at end of file
diff --git a/dist/esm/DeliverAt.js.map b/dist/esm/DeliverAt.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..a8b508e24580687607f79903e5b031e02523a3a9
--- /dev/null
+++ b/dist/esm/DeliverAt.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"DeliverAt.js","names":["hasProperty","symbol","Symbol","for","isDeliverAt","self","toMillis","epochMillis"],"sources":["../../src/DeliverAt.ts"],"sourcesContent":[null],"mappings":"AAIA,SAASA,WAAW,QAAQ,kBAAkB;AAE9C;;;;AAIA,OAAO,MAAMC,MAAM,gBAAkBC,MAAM,CAACC,GAAG,CAAC,2BAA2B,CAAC;AAU5E;;;;AAIA,OAAO,MAAMC,WAAW,GAAIC,IAAa,IAAwBL,WAAW,CAACK,IAAI,EAAEJ,MAAM,CAAC;AAE1F;;;;AAIA,OAAO,MAAMK,QAAQ,GAAID,IAAa,IAAmB;EACvD,IAAID,WAAW,CAACC,IAAI,CAAC,EAAE;IACrB,OAAOA,IAAI,CAACJ,MAAM,CAAC,EAAE,CAACM,WAAW;EACnC;EACA,OAAO,IAAI;AACb,CAAC","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/esm/Entity.js b/dist/esm/Entity.js
new file mode 100644
index 0000000000000000000000000000000000000000..e163393131441ea31d96d5b7ff5d112c67d9ecae
--- /dev/null
+++ b/dist/esm/Entity.js
@@ -0,0 +1,173 @@
+import * as RpcGroup from "@effect/rpc/RpcGroup";
+import * as Arr from "effect/Array";
+import * as Context from "effect/Context";
+import * as Data from "effect/Data";
+import * as Effect from "effect/Effect";
+import * as Equal from "effect/Equal";
+import * as Exit from "effect/Exit";
+import * as Hash from "effect/Hash";
+import * as Layer from "effect/Layer";
+import * as Mailbox from "effect/Mailbox";
+import * as Option from "effect/Option";
+import * as Predicate from "effect/Predicate";
+import { EntityType } from "./EntityType.js";
+/**
+ * @since 1.0.0
+ * @category type ids
+ */
+export const TypeId = /*#__PURE__*/Symbol.for("@effect/cluster/Entity");
+/**
+ * @since 1.0.0
+ * @category refinements
+ */
+export const isEntity = u => Predicate.hasProperty(u, TypeId);
+const Proto = {
+  [TypeId]: TypeId,
+  [Hash.symbol]() {
+    return Hash.structure({
+      type: this.type
+    });
+  },
+  [Equal.symbol](that) {
+    return isEntity(that) && this.type === that.type;
+  },
+  annotate(tag, value) {
+    return fromRpcGroup(this.type, this.protocol.annotate(tag, value));
+  },
+  annotateRpcs(tag, value) {
+    return fromRpcGroup(this.type, this.protocol.annotateRpcs(tag, value));
+  },
+  annotateContext(context) {
+    return fromRpcGroup(this.type, this.protocol.annotateContext(context));
+  },
+  annotateRpcsContext(context) {
+    return fromRpcGroup(this.type, this.protocol.annotateRpcsContext(context));
+  },
+  get client() {
+    return shardingTag.pipe(Effect.flatMap(sharding => sharding.makeClient(this)));
+  },
+  toLayer(build, options) {
+    return shardingTag.pipe(Effect.flatMap(sharding => sharding.registerEntity(this, Effect.isEffect(build) ? build : Effect.succeed(build), options)), Layer.effectDiscard);
+  },
+  toLayerMailbox(build, options) {
+    const buildHandlers = Effect.gen(this, function* () {
+      const behaviour = Effect.isEffect(build) ? yield* build : build;
+      const mailbox = yield* Mailbox.make();
+      // create the rpc handlers for the entity
+      const handler = envelope => {
+        return Effect.async(resume => {
+          mailbox.unsafeOffer(envelope);
+          resumes.set(envelope, resume);
+        });
+      };
+      const handlers = {};
+      for (const rpc of this.protocol.requests.keys()) {
+        handlers[rpc] = handler;
+      }
+      // make the Replier for the behaviour
+      const resumes = new Map();
+      const complete = (request, exit) => Effect.sync(() => {
+        const resume = resumes.get(request);
+        if (resume) {
+          resumes.delete(request);
+          resume(exit);
+        }
+      });
+      const replier = {
+        succeed: (request, value) => complete(request, Exit.succeed(value)),
+        fail: (request, error) => complete(request, Exit.fail(error)),
+        failCause: (request, cause) => complete(request, Exit.failCause(cause)),
+        complete
+      };
+      // fork the behaviour into the layer scope
+      yield* behaviour(mailbox, replier).pipe(Effect.catchAllCause(cause => {
+        const exit = Exit.failCause(cause);
+        for (const resume of resumes.values()) {
+          resume(exit);
+        }
+        return Effect.void;
+      }), Effect.interruptible, Effect.forkScoped);
+      return handlers;
+    });
+    return this.toLayer(buildHandlers, {
+      ...options,
+      concurrency: "unbounded"
+    });
+  }
+};
+/**
+ * Creates a new `Entity` of the specified `type` which will accept messages
+ * that adhere to the provided `RpcGroup`.
+ *
+ * @since 1.0.0
+ * @category constructors
+ */
+export const fromRpcGroup = (
+/**
+ * The entity type name.
+ */
+type,
+/**
+ * The schema definition for messages that the entity is capable of
+ * processing.
+ */
+protocol) => {
+  const self = Object.create(Proto);
+  self.type = EntityType.make(type);
+  self.protocol = protocol;
+  return self;
+};
+/**
+ * Creates a new `Entity` of the specified `type` which will accept messages
+ * that adhere to the provided schemas.
+ *
+ * @since 1.0.0
+ * @category constructors
+ */
+export const make = (
+/**
+ * The entity type name.
+ */
+type,
+/**
+ * The schema definition for messages that the entity is capable of
+ * processing.
+ */
+protocol) => fromRpcGroup(type, RpcGroup.make(...protocol));
+/**
+ * A Context.Tag to access the current entity address.
+ *
+ * @since 1.0.0
+ * @category context
+ */
+export class CurrentAddress extends /*#__PURE__*/Context.Tag("@effect/cluster/Entity/EntityAddress")() {}
+/**
+ * A Context.Tag to access the current Runner address.
+ *
+ * @since 1.0.0
+ * @category context
+ */
+export class CurrentRunnerAddress extends /*#__PURE__*/Context.Tag("@effect/cluster/Entity/RunnerAddress")() {}
+/**
+ * @since 1.0.0
+ * @category Request
+ */
+export class Request extends Data.Class {
+  /**
+   * @since 1.0.0
+   */
+  get lastSentChunkValue() {
+    return this.lastSentChunk.pipe(Option.map(chunk => Arr.lastNonEmpty(chunk.values)));
+  }
+  /**
+   * @since 1.0.0
+   */
+  get nextSequence() {
+    if (Option.isNone(this.lastSentChunk)) {
+      return 0;
+    }
+    return this.lastSentChunk.value.sequence + 1;
+  }
+}
+const shardingTag = /*#__PURE__*/Context.GenericTag("@effect/cluster/Sharding");
+//# sourceMappingURL=Entity.js.map
\ No newline at end of file
diff --git a/dist/esm/Entity.js.map b/dist/esm/Entity.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..0bcfe6a5804a458c9b4c5b37844624d57ef3c3fd
--- /dev/null
+++ b/dist/esm/Entity.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"Entity.js","names":["RpcGroup","Arr","Context","Data","Effect","Equal","Exit","Hash","Layer","Mailbox","Option","Predicate","EntityType","TypeId","Symbol","for","isEntity","u","hasProperty","Proto","symbol","structure","type","that","annotate","tag","value","fromRpcGroup","protocol","annotateRpcs","annotateContext","context","annotateRpcsContext","client","shardingTag","pipe","flatMap","sharding","makeClient","toLayer","build","options","registerEntity","isEffect","succeed","effectDiscard","toLayerMailbox","buildHandlers","gen","behaviour","mailbox","make","handler","envelope","async","resume","unsafeOffer","resumes","set","handlers","rpc","requests","keys","Map","complete","request","exit","sync","get","delete","replier","fail","error","failCause","cause","catchAllCause","values","void","interruptible","forkScoped","concurrency","self","Object","create","CurrentAddress","Tag","CurrentRunnerAddress","Request","Class","lastSentChunkValue","lastSentChunk","map","chunk","lastNonEmpty","nextSequence","isNone","sequence","GenericTag"],"sources":["../../src/Entity.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/esm/EntityAddress.js b/dist/esm/EntityAddress.js
new file mode 100644
index 0000000000000000000000000000000000000000..eac680e5a47f2ed6f8d1dab7b75589b5586dfc7d
--- /dev/null
+++ b/dist/esm/EntityAddress.js
@@ -0,0 +1,44 @@
+/**
+ * @since 1.0.0
+ */
+import * as Hash from "effect/Hash";
+import * as Schema from "effect/Schema";
+import { EntityId } from "./EntityId.js";
+import { EntityType } from "./EntityType.js";
+import { ShardId } from "./ShardId.js";
+const SymbolKey = "@effect/cluster/EntityAddress";
+/**
+ * @since 1.0.0
+ * @category type ids
+ */
+export const TypeId = /*#__PURE__*/Symbol.for(SymbolKey);
+/**
+ * Represents the unique address of an entity within the cluster.
+ *
+ * @since 1.0.0
+ * @category models
+ */
+export class EntityAddress extends /*#__PURE__*/Schema.Class(SymbolKey)({
+  shardId: ShardId,
+  entityType: EntityType,
+  entityId: EntityId
+}) {
+  /**
+   * @since 1.0.0
+   */
+  [TypeId] = TypeId;
+  /**
+   * @since 1.0.0
+   */
+  [Hash.symbol]() {
+    return Hash.cached(this)(Hash.string(`${this.shardId}:${this.entityType}:${this.entityId}`));
+  }
+}
+/**
+ * Represents the unique address of an entity within the cluster.
+ *
+ * @since 1.0.0
+ * @category schemas
+ */
+export const EntityAddressFromSelf = /*#__PURE__*/Schema.typeSchema(EntityAddress);
+//# sourceMappingURL=EntityAddress.js.map
\ No newline at end of file
diff --git a/dist/esm/EntityAddress.js.map b/dist/esm/EntityAddress.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..36da08b553535097a1b112c5631bc44409908637
--- /dev/null
+++ b/dist/esm/EntityAddress.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"EntityAddress.js","names":["Hash","Schema","EntityId","EntityType","ShardId","SymbolKey","TypeId","Symbol","for","EntityAddress","Class","shardId","entityType","entityId","symbol","cached","string","EntityAddressFromSelf","typeSchema"],"sources":["../../src/EntityAddress.ts"],"sourcesContent":[null],"mappings":"AAAA;;;AAGA,OAAO,KAAKA,IAAI,MAAM,aAAa;AACnC,OAAO,KAAKC,MAAM,MAAM,eAAe;AACvC,SAASC,QAAQ,QAAQ,eAAe;AACxC,SAASC,UAAU,QAAQ,iBAAiB;AAC5C,SAASC,OAAO,QAAQ,cAAc;AAEtC,MAAMC,SAAS,GAAG,+BAA+B;AAEjD;;;;AAIA,OAAO,MAAMC,MAAM,gBAAkBC,MAAM,CAACC,GAAG,CAACH,SAAS,CAAC;AAQ1D;;;;;;AAMA,OAAM,MAAOI,aAAc,sBAAQR,MAAM,CAACS,KAAK,CAAgBL,SAAS,CAAC,CAAC;EACxEM,OAAO,EAAEP,OAAO;EAChBQ,UAAU,EAAET,UAAU;EACtBU,QAAQ,EAAEX;CACX,CAAC;EACA;;;EAGS,CAACI,MAAM,IAAIA,MAAM;EAC1B;;;EAGA,CAACN,IAAI,CAACc,MAAM,IAAC;IACX,OAAOd,IAAI,CAACe,MAAM,CAAC,IAAI,CAAC,CAACf,IAAI,CAACgB,MAAM,CAAC,GAAG,IAAI,CAACL,OAAO,IAAI,IAAI,CAACC,UAAU,IAAI,IAAI,CAACC,QAAQ,EAAE,CAAC,CAAC;EAC9F;;AAGF;;;;;;AAMA,OAAO,MAAMI,qBAAqB,gBAAiChB,MAAM,CAACiB,UAAU,CAClFT,aAAa,CACd","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/esm/EntityId.js b/dist/esm/EntityId.js
new file mode 100644
index 0000000000000000000000000000000000000000..3c05bc7880fdfc770aef6cb98d771981e7399db7
--- /dev/null
+++ b/dist/esm/EntityId.js
@@ -0,0 +1,10 @@
+/**
+ * @since 1.0.0
+ */
+import * as Schema from "effect/Schema";
+/**
+ * @since 1.0.0
+ * @category constructors
+ */
+export const EntityId = /*#__PURE__*/Schema.NonEmptyTrimmedString.pipe( /*#__PURE__*/Schema.brand("EntityId"));
+//# sourceMappingURL=EntityId.js.map
\ No newline at end of file
diff --git a/dist/esm/EntityId.js.map b/dist/esm/EntityId.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..04a2ab00fbe1ce712db40259696b63ef5e14ee12
--- /dev/null
+++ b/dist/esm/EntityId.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"EntityId.js","names":["Schema","EntityId","NonEmptyTrimmedString","pipe","brand"],"sources":["../../src/EntityId.ts"],"sourcesContent":[null],"mappings":"AAAA;;;AAGA,OAAO,KAAKA,MAAM,MAAM,eAAe;AAEvC;;;;AAIA,OAAO,MAAMC,QAAQ,gBAAGD,MAAM,CAACE,qBAAqB,CAACC,IAAI,eAACH,MAAM,CAACI,KAAK,CAAC,UAAU,CAAC,CAAC","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/esm/EntityType.js b/dist/esm/EntityType.js
new file mode 100644
index 0000000000000000000000000000000000000000..9e40822d92c32c7a3f18af6c8fcdd0bce85c6f7f
--- /dev/null
+++ b/dist/esm/EntityType.js
@@ -0,0 +1,10 @@
+/**
+ * @since 1.0.0
+ */
+import * as Schema from "effect/Schema";
+/**
+ * @since 1.0.0
+ * @category constructors
+ */
+export const EntityType = /*#__PURE__*/Schema.NonEmptyTrimmedString.pipe( /*#__PURE__*/Schema.brand("EntityType"));
+//# sourceMappingURL=EntityType.js.map
\ No newline at end of file
diff --git a/dist/esm/EntityType.js.map b/dist/esm/EntityType.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..86dc295bdd9a8012b402ad7339fc99037a0c281e
--- /dev/null
+++ b/dist/esm/EntityType.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"EntityType.js","names":["Schema","EntityType","NonEmptyTrimmedString","pipe","brand"],"sources":["../../src/EntityType.ts"],"sourcesContent":[null],"mappings":"AAAA;;;AAGA,OAAO,KAAKA,MAAM,MAAM,eAAe;AAEvC;;;;AAIA,OAAO,MAAMC,UAAU,gBAAGD,MAAM,CAACE,qBAAqB,CAACC,IAAI,eAACH,MAAM,CAACI,KAAK,CAAC,YAAY,CAAC,CAAC","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/esm/Envelope.js b/dist/esm/Envelope.js
new file mode 100644
index 0000000000000000000000000000000000000000..ef2dc375fc9274bfc65cb1d21e1ba07b3ac74718
--- /dev/null
+++ b/dist/esm/Envelope.js
@@ -0,0 +1,154 @@
+/**
+ * @since 1.0.0
+ */
+import * as Headers from "@effect/platform/Headers";
+import * as Predicate from "effect/Predicate";
+import * as PrimaryKey from "effect/PrimaryKey";
+import * as Schema from "effect/Schema";
+import { EntityAddress, EntityAddressFromSelf } from "./EntityAddress.js";
+import { SnowflakeFromString } from "./Snowflake.js";
+/**
+ * @since 1.0.0
+ * @category type ids
+ */
+export const TypeId = /*#__PURE__*/Symbol.for("@effect/cluster/Envelope");
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export class AckChunk extends /*#__PURE__*/Schema.TaggedClass("@effect/cluster/Envelope/AckChunk")("AckChunk", {
+  id: SnowflakeFromString,
+  address: EntityAddress,
+  requestId: SnowflakeFromString,
+  replyId: SnowflakeFromString
+}) {
+  /**
+   * @since 1.0.0
+   */
+  [TypeId] = TypeId;
+  /**
+   * @since 1.0.0
+   */
+  withRequestId(requestId) {
+    return new AckChunk({
+      ...this,
+      requestId
+    });
+  }
+}
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export class Interrupt extends /*#__PURE__*/Schema.TaggedClass("@effect/cluster/Envelope/Interrupt")("Interrupt", {
+  id: SnowflakeFromString,
+  address: EntityAddress,
+  requestId: SnowflakeFromString
+}) {
+  /**
+   * @since 1.0.0
+   */
+  [TypeId] = TypeId;
+  /**
+   * @since 1.0.0
+   */
+  withRequestId(requestId) {
+    return new Interrupt({
+      ...this,
+      requestId
+    });
+  }
+}
+/**
+ * @since 1.0.0
+ * @category refinements
+ */
+export const isEnvelope = u => Predicate.hasProperty(u, TypeId);
+/**
+ * @since 1.0.0
+ * @category constructors
+ */
+export const makeRequest = options => ({
+  [TypeId]: TypeId,
+  _tag: "Request",
+  requestId: options.requestId,
+  tag: options.tag,
+  address: options.address,
+  payload: options.payload,
+  headers: options.headers,
+  traceId: options.traceId,
+  spanId: options.spanId,
+  sampled: options.sampled
+});
+/**
+ * @since 1.0.0
+ * @category serialization / deserialization
+ */
+export const EnvelopeFromSelf = /*#__PURE__*/Schema.declare(isEnvelope, {
+  identifier: "Envelope"
+});
+/**
+ * @since 1.0.0
+ * @category serialization / deserialization
+ */
+export const RequestFromSelf = /*#__PURE__*/Schema.declare(u => isEnvelope(u) && u._tag === "Request", {
+  identifier: "Envelope"
+});
+/**
+ * @since 1.0.0
+ * @category serialization / deserialization
+ */
+export const PartialEncodedRequest = /*#__PURE__*/Schema.Struct({
+  _tag: /*#__PURE__*/Schema.Literal("Request"),
+  requestId: SnowflakeFromString,
+  address: EntityAddress,
+  tag: Schema.String,
+  payload: Schema.Unknown,
+  headers: Headers.schema,
+  traceId: Schema.String,
+  spanId: Schema.String,
+  sampled: Schema.Boolean
+});
+/**
+ * @since 1.0.0
+ * @category serialization / deserialization
+ */
+export const PartialEncoded = /*#__PURE__*/Schema.Union(PartialEncodedRequest, AckChunk, Interrupt);
+/**
+ * @since 1.0.0
+ * @category serialization / deserialization
+ */
+export const PartialEncodedArray = /*#__PURE__*/Schema.mutable( /*#__PURE__*/Schema.Array(PartialEncoded));
+/**
+ * @since 1.0.0
+ * @category serialization / deserialization
+ */
+export const PartialEncodedRequestFromSelf = /*#__PURE__*/Schema.Struct({
+  _tag: /*#__PURE__*/Schema.Literal("Request"),
+  requestId: /*#__PURE__*/Schema.typeSchema(SnowflakeFromString),
+  address: EntityAddressFromSelf,
+  tag: Schema.String,
+  payload: Schema.Unknown,
+  headers: Headers.schemaFromSelf,
+  traceId: Schema.String,
+  spanId: Schema.String,
+  sampled: Schema.Boolean
+});
+/**
+ * @since 1.0.0
+ * @category serialization / deserialization
+ */
+export const PartialEncodedFromSelf = /*#__PURE__*/Schema.Union(PartialEncodedRequestFromSelf, /*#__PURE__*/Schema.typeSchema(AckChunk), /*#__PURE__*/Schema.typeSchema(Interrupt));
+/**
+ * @since 1.0.0
+ * @category primary key
+ */
+export const primaryKey = envelope => {
+  if (envelope._tag !== "Request" || !Predicate.hasProperty(envelope.payload, PrimaryKey.symbol)) {
+    return null;
+  }
+  const value = PrimaryKey.value(envelope.payload);
+  // hash the entity address to save space?
+  return `${envelope.address.entityType}/${envelope.address.entityId}/${envelope.tag}/${value}`;
+};
+//# sourceMappingURL=Envelope.js.map
\ No newline at end of file
diff --git a/dist/esm/Envelope.js.map b/dist/esm/Envelope.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..c62820ada3661125fca9efae64e6164554461e2a
--- /dev/null
+++ b/dist/esm/Envelope.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"Envelope.js","names":["Headers","Predicate","PrimaryKey","Schema","EntityAddress","EntityAddressFromSelf","SnowflakeFromString","TypeId","Symbol","for","AckChunk","TaggedClass","id","address","requestId","replyId","withRequestId","Interrupt","isEnvelope","u","hasProperty","makeRequest","options","_tag","tag","payload","headers","traceId","spanId","sampled","EnvelopeFromSelf","declare","identifier","RequestFromSelf","PartialEncodedRequest","Struct","Literal","String","Unknown","schema","Boolean","PartialEncoded","Union","PartialEncodedArray","mutable","Array","PartialEncodedRequestFromSelf","typeSchema","schemaFromSelf","PartialEncodedFromSelf","primaryKey","envelope","symbol","value","entityType","entityId"],"sources":["../../src/Envelope.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/esm/HttpCommon.js b/dist/esm/HttpCommon.js
new file mode 100644
index 0000000000000000000000000000000000000000..9f5fc9dcbb7db43a62768d2869f769b9f576b893
--- /dev/null
+++ b/dist/esm/HttpCommon.js
@@ -0,0 +1,38 @@
+/**
+ * @since 1.0.0
+ */
+import * as HttpClient from "@effect/platform/HttpClient";
+import * as HttpClientRequest from "@effect/platform/HttpClientRequest";
+import * as Socket from "@effect/platform/Socket";
+import * as RpcClient from "@effect/rpc/RpcClient";
+import * as RpcSerialization from "@effect/rpc/RpcSerialization";
+import * as Effect from "effect/Effect";
+import * as Layer from "effect/Layer";
+import { RpcClientProtocol } from "./Runners.js";
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layerClientProtocolHttp = options => Layer.effect(RpcClientProtocol, Effect.gen(function* () {
+  const serialization = yield* RpcSerialization.RpcSerialization;
+  const client = yield* HttpClient.HttpClient;
+  const https = options.https ?? false;
+  return address => {
+    const clientWithUrl = HttpClient.mapRequest(client, HttpClientRequest.prependUrl(`http${https ? "s" : ""}://${address.host}:${address.port}/${options.path}`));
+    return RpcClient.makeProtocolHttp(clientWithUrl).pipe(Effect.provideService(RpcSerialization.RpcSerialization, serialization));
+  };
+}));
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layerClientProtocolWebsocket = options => Layer.effect(RpcClientProtocol, Effect.gen(function* () {
+  const serialization = yield* RpcSerialization.RpcSerialization;
+  const https = options.https ?? false;
+  const constructor = yield* Socket.WebSocketConstructor;
+  return Effect.fnUntraced(function* (address) {
+    const socket = yield* Socket.makeWebSocket(`ws${https ? "s" : ""}://${address.host}:${address.port}/${options.path}`).pipe(Effect.provideService(Socket.WebSocketConstructor, constructor));
+    return yield* RpcClient.makeProtocolSocket.pipe(Effect.provideService(Socket.Socket, socket), Effect.provideService(RpcSerialization.RpcSerialization, serialization));
+  });
+}));
+//# sourceMappingURL=HttpCommon.js.map
\ No newline at end of file
diff --git a/dist/esm/HttpCommon.js.map b/dist/esm/HttpCommon.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..7079c0cfc80196df78deb2e4dc375fff77186bc8
--- /dev/null
+++ b/dist/esm/HttpCommon.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"HttpCommon.js","names":["HttpClient","HttpClientRequest","Socket","RpcClient","RpcSerialization","Effect","Layer","RpcClientProtocol","layerClientProtocolHttp","options","effect","gen","serialization","client","https","address","clientWithUrl","mapRequest","prependUrl","host","port","path","makeProtocolHttp","pipe","provideService","layerClientProtocolWebsocket","constructor","WebSocketConstructor","fnUntraced","socket","makeWebSocket","makeProtocolSocket"],"sources":["../../src/HttpCommon.ts"],"sourcesContent":[null],"mappings":"AAAA;;;AAGA,OAAO,KAAKA,UAAU,MAAM,6BAA6B;AACzD,OAAO,KAAKC,iBAAiB,MAAM,oCAAoC;AACvE,OAAO,KAAKC,MAAM,MAAM,yBAAyB;AACjD,OAAO,KAAKC,SAAS,MAAM,uBAAuB;AAClD,OAAO,KAAKC,gBAAgB,MAAM,8BAA8B;AAChE,OAAO,KAAKC,MAAM,MAAM,eAAe;AACvC,OAAO,KAAKC,KAAK,MAAM,cAAc;AACrC,SAASC,iBAAiB,QAAQ,cAAc;AAEhD;;;;AAIA,OAAO,MAAMC,uBAAuB,GAAIC,OAGvC,IAKCH,KAAK,CAACI,MAAM,CACVH,iBAAiB,EACjBF,MAAM,CAACM,GAAG,CAAC,aAAS;EAClB,MAAMC,aAAa,GAAG,OAAOR,gBAAgB,CAACA,gBAAgB;EAC9D,MAAMS,MAAM,GAAG,OAAOb,UAAU,CAACA,UAAU;EAC3C,MAAMc,KAAK,GAAGL,OAAO,CAACK,KAAK,IAAI,KAAK;EACpC,OAAQC,OAAO,IAAI;IACjB,MAAMC,aAAa,GAAGhB,UAAU,CAACiB,UAAU,CACzCJ,MAAM,EACNZ,iBAAiB,CAACiB,UAAU,CAAC,OAAOJ,KAAK,GAAG,GAAG,GAAG,EAAE,MAAMC,OAAO,CAACI,IAAI,IAAIJ,OAAO,CAACK,IAAI,IAAIX,OAAO,CAACY,IAAI,EAAE,CAAC,CAC1G;IACD,OAAOlB,SAAS,CAACmB,gBAAgB,CAACN,aAAa,CAAC,CAACO,IAAI,CACnDlB,MAAM,CAACmB,cAAc,CAACpB,gBAAgB,CAACA,gBAAgB,EAAEQ,aAAa,CAAC,CACxE;EACH,CAAC;AACH,CAAC,CAAC,CACH;AAEH;;;;AAIA,OAAO,MAAMa,4BAA4B,GAAIhB,OAG5C,IAKCH,KAAK,CAACI,MAAM,CACVH,iBAAiB,EACjBF,MAAM,CAACM,GAAG,CAAC,aAAS;EAClB,MAAMC,aAAa,GAAG,OAAOR,gBAAgB,CAACA,gBAAgB;EAC9D,MAAMU,KAAK,GAAGL,OAAO,CAACK,KAAK,IAAI,KAAK;EACpC,MAAMY,WAAW,GAAG,OAAOxB,MAAM,CAACyB,oBAAoB;EACtD,OAAOtB,MAAM,CAACuB,UAAU,CAAC,WAAUb,OAAO;IACxC,MAAMc,MAAM,GAAG,OAAO3B,MAAM,CAAC4B,aAAa,CACxC,KAAKhB,KAAK,GAAG,GAAG,GAAG,EAAE,MAAMC,OAAO,CAACI,IAAI,IAAIJ,OAAO,CAACK,IAAI,IAAIX,OAAO,CAACY,IAAI,EAAE,CAC1E,CAACE,IAAI,CACJlB,MAAM,CAACmB,cAAc,CAACtB,MAAM,CAACyB,oBAAoB,EAAED,WAAW,CAAC,CAChE;IACD,OAAO,OAAOvB,SAAS,CAAC4B,kBAAkB,CAACR,IAAI,CAC7ClB,MAAM,CAACmB,cAAc,CAACtB,MAAM,CAACA,MAAM,EAAE2B,MAAM,CAAC,EAC5CxB,MAAM,CAACmB,cAAc,CAACpB,gBAAgB,CAACA,gBAAgB,EAAEQ,aAAa,CAAC,CACxE;EACH,CAAC,CAAC;AACJ,CAAC,CAAC,CACH","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/esm/HttpRunner.js b/dist/esm/HttpRunner.js
new file mode 100644
index 0000000000000000000000000000000000000000..a1f8139d003e70a1ef9082d70cd3706566154b96
--- /dev/null
+++ b/dist/esm/HttpRunner.js
@@ -0,0 +1,98 @@
+import * as HttpRouter from "@effect/platform/HttpRouter";
+import * as HttpServer from "@effect/platform/HttpServer";
+import * as RpcServer from "@effect/rpc/RpcServer";
+import * as Effect from "effect/Effect";
+import * as Layer from "effect/Layer";
+import { layerClientProtocolHttp, layerClientProtocolWebsocket } from "./HttpCommon.js";
+import * as Runners from "./Runners.js";
+import * as RunnerServer from "./RunnerServer.js";
+import * as Sharding from "./Sharding.js";
+import * as ShardManager from "./ShardManager.js";
+import * as SynchronizedClock from "./SynchronizedClock.js";
+/**
+ * @since 1.0.0
+ * @category Http App
+ */
+export const toHttpApp = /*#__PURE__*/Effect.gen(function* () {
+  const handlers = yield* Layer.build(RunnerServer.layerHandlers);
+  return yield* RpcServer.toHttpApp(Runners.Rpcs, {
+    spanPrefix: "RunnerServer",
+    disableTracing: true
+  }).pipe(Effect.provide(handlers));
+});
+/**
+ * @since 1.0.0
+ * @category Http App
+ */
+export const toHttpAppWebsocket = /*#__PURE__*/Effect.gen(function* () {
+  const handlers = yield* Layer.build(RunnerServer.layerHandlers);
+  return yield* RpcServer.toHttpAppWebsocket(Runners.Rpcs, {
+    spanPrefix: "RunnerServer",
+    disableTracing: true
+  }).pipe(Effect.provide(handlers));
+});
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layerClient = /*#__PURE__*/Sharding.layer.pipe( /*#__PURE__*/Layer.provideMerge(Runners.layerRpc), /*#__PURE__*/Layer.provideMerge(SynchronizedClock.layer), /*#__PURE__*/Layer.provide(ShardManager.layerClientRpc));
+/**
+ * A HTTP layer for the `Runners` services, that adds a route to the provided
+ * `HttpRouter.Tag`.
+ *
+ * By default, it uses the `HttpRouter.Default` tag.
+ *
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layer = options => {
+  const layer = RunnerServer.layerWithClients.pipe(Layer.provide(RpcServer.layerProtocolHttp(options)));
+  return options.logAddress ? withLogAddress(layer) : layer;
+};
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layerWebsocketOptions = options => {
+  const layer = RunnerServer.layerWithClients.pipe(Layer.provide(RpcServer.layerProtocolWebsocket(options)));
+  return options.logAddress ? withLogAddress(layer) : layer;
+};
+const withLogAddress = layer => Layer.effectDiscard(HttpServer.addressFormattedWith(address => Effect.annotateLogs(Effect.logInfo(`Listening on: ${address}`), {
+  package: "@effect/cluster",
+  service: "Runner"
+}))).pipe(Layer.provideMerge(layer));
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layerHttp = /*#__PURE__*/HttpRouter.Default.serve().pipe( /*#__PURE__*/Layer.provideMerge( /*#__PURE__*/layer({
+  path: "/",
+  logAddress: true
+})), /*#__PURE__*/Layer.provide( /*#__PURE__*/layerClientProtocolHttp({
+  path: "/"
+})));
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layerHttpClientOnly = /*#__PURE__*/RunnerServer.layerClientOnly.pipe( /*#__PURE__*/Layer.provide( /*#__PURE__*/layerClientProtocolHttp({
+  path: "/"
+})));
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layerWebsocket = /*#__PURE__*/HttpRouter.Default.serve().pipe( /*#__PURE__*/Layer.provideMerge( /*#__PURE__*/layerWebsocketOptions({
+  path: "/",
+  logAddress: true
+})), /*#__PURE__*/Layer.provide( /*#__PURE__*/layerClientProtocolWebsocket({
+  path: "/"
+})));
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layerWebsocketClientOnly = /*#__PURE__*/RunnerServer.layerClientOnly.pipe( /*#__PURE__*/Layer.provide( /*#__PURE__*/layerClientProtocolWebsocket({
+  path: "/"
+})));
+//# sourceMappingURL=HttpRunner.js.map
\ No newline at end of file
diff --git a/dist/esm/HttpRunner.js.map b/dist/esm/HttpRunner.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..d39829fdb421efda194e8ea93d5d7da4ef15f0b9
--- /dev/null
+++ b/dist/esm/HttpRunner.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"HttpRunner.js","names":["HttpRouter","HttpServer","RpcServer","Effect","Layer","layerClientProtocolHttp","layerClientProtocolWebsocket","Runners","RunnerServer","Sharding","ShardManager","SynchronizedClock","toHttpApp","gen","handlers","build","layerHandlers","Rpcs","spanPrefix","disableTracing","pipe","provide","toHttpAppWebsocket","layerClient","layer","provideMerge","layerRpc","layerClientRpc","options","layerWithClients","layerProtocolHttp","logAddress","withLogAddress","layerWebsocketOptions","layerProtocolWebsocket","effectDiscard","addressFormattedWith","address","annotateLogs","logInfo","package","service","layerHttp","Default","serve","path","layerHttpClientOnly","layerClientOnly","layerWebsocket","layerWebsocketClientOnly"],"sources":["../../src/HttpRunner.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/esm/HttpShardManager.js b/dist/esm/HttpShardManager.js
new file mode 100644
index 0000000000000000000000000000000000000000..1d0d61c90f7311348f0da1bdc327648f2cbcf75e
--- /dev/null
+++ b/dist/esm/HttpShardManager.js
@@ -0,0 +1,128 @@
+import * as HttpRouter from "@effect/platform/HttpRouter";
+import * as HttpServer from "@effect/platform/HttpServer";
+import * as RpcServer from "@effect/rpc/RpcServer";
+import * as Effect from "effect/Effect";
+import { identity } from "effect/Function";
+import * as Layer from "effect/Layer";
+import { layerClientProtocolHttp, layerClientProtocolWebsocket } from "./HttpCommon.js";
+import * as MessageStorage from "./MessageStorage.js";
+import * as RunnerHealth from "./RunnerHealth.js";
+import * as Runners from "./Runners.js";
+import * as ShardManager from "./ShardManager.js";
+/**
+ * @since 1.0.0
+ * @category Http App
+ */
+export const toHttpApp = /*#__PURE__*/Effect.gen(function* () {
+  const handlers = yield* Layer.build(ShardManager.layerServerHandlers);
+  return yield* RpcServer.toHttpApp(ShardManager.Rpcs).pipe(Effect.provide(handlers));
+});
+/**
+ * @since 1.0.0
+ * @category Http App
+ */
+export const toHttpAppWebsocket = /*#__PURE__*/Effect.gen(function* () {
+  const handlers = yield* Layer.build(ShardManager.layerServerHandlers);
+  return yield* RpcServer.toHttpAppWebsocket(ShardManager.Rpcs).pipe(Effect.provide(handlers));
+});
+/**
+ * A layer for the `ShardManager` service, that does not run a server.
+ *
+ * It only provides the `Runners` rpc client.
+ *
+ * You can use this with the `toHttpApp` and `toHttpAppWebsocket` apis
+ * to run a complete `ShardManager` server.
+ *
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layerNoServerHttp = options => ShardManager.layer.pipe(Layer.provide(Runners.layerRpc.pipe(Layer.provide([layerClientProtocolHttp({
+  path: options.runnerPath,
+  https: options.runnerHttps
+}), MessageStorage.layerNoop]))));
+/**
+ * A layer for the `ShardManager` service, that does not run a server.
+ *
+ * It only provides the `Runners` rpc client.
+ *
+ * You can use this with the `toHttpApp` and `toHttpAppWebsocket` apis
+ * to run a complete `ShardManager` server.
+ *
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layerNoServerWebsocket = options => ShardManager.layer.pipe(Layer.provide(Runners.layerRpc.pipe(Layer.provide([layerClientProtocolWebsocket({
+  path: options.runnerPath,
+  https: options.runnerHttps
+}), MessageStorage.layerNoop]))));
+/**
+ * A HTTP layer for the `ShardManager` server, that adds a route to the provided
+ * `HttpRouter.Tag`.
+ *
+ * By default, it uses the `HttpRouter.Default` tag.
+ *
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layerHttpOptions = options => {
+  const routerTag = options.routerTag ?? HttpRouter.Default;
+  return routerTag.serve().pipe(options.logAddress ? withLogAddress : identity, Layer.merge(ShardManager.layerServer), Layer.provide(RpcServer.layerProtocolHttp(options)), Layer.provideMerge(layerNoServerHttp(options)));
+};
+/**
+ * A WebSocket layer for the `ShardManager` server, that adds a route to the provided
+ * `HttpRouter.Tag`.
+ *
+ * By default, it uses the `HttpRouter.Default` tag.
+ *
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layerWebsocketOptions = options => {
+  const routerTag = options.routerTag ?? HttpRouter.Default;
+  return routerTag.serve().pipe(options.logAddress ? withLogAddress : identity, Layer.merge(ShardManager.layerServer), Layer.provide(RpcServer.layerProtocolWebsocket(options)), Layer.provideMerge(layerNoServerWebsocket(options)));
+};
+const withLogAddress = layer => Layer.effectDiscard(HttpServer.addressFormattedWith(address => Effect.annotateLogs(Effect.logInfo(`Listening on: ${address}`), {
+  package: "@effect/cluster",
+  service: "ShardManager"
+}))).pipe(Layer.provideMerge(layer));
+/**
+ * A HTTP layer for the `ShardManager` server, that adds a route to the provided
+ * `HttpRouter.Tag`.
+ *
+ * By default, it uses the `HttpRouter.Default` tag.
+ *
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layerHttp = /*#__PURE__*/layerHttpOptions({
+  path: "/",
+  runnerPath: "/"
+});
+/**
+ * A Websocket layer for the `ShardManager` server, that adds a route to the provided
+ * `HttpRouter.Tag`.
+ *
+ * By default, it uses the `HttpRouter.Default` tag.
+ *
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layerWebsocket = /*#__PURE__*/layerWebsocketOptions({
+  path: "/",
+  runnerPath: "/"
+});
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layerRunnerHealthHttp = /*#__PURE__*/Layer.provide(RunnerHealth.layerRpc, /*#__PURE__*/layerClientProtocolHttp({
+  path: "/"
+}));
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layerRunnerHealthWebsocket = /*#__PURE__*/Layer.provide(RunnerHealth.layerRpc, /*#__PURE__*/layerClientProtocolWebsocket({
+  path: "/"
+}));
+//# sourceMappingURL=HttpShardManager.js.map
\ No newline at end of file
diff --git a/dist/esm/HttpShardManager.js.map b/dist/esm/HttpShardManager.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..b8b5381deea37193cccfc08889ab468bc172b895
--- /dev/null
+++ b/dist/esm/HttpShardManager.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"HttpShardManager.js","names":["HttpRouter","HttpServer","RpcServer","Effect","identity","Layer","layerClientProtocolHttp","layerClientProtocolWebsocket","MessageStorage","RunnerHealth","Runners","ShardManager","toHttpApp","gen","handlers","build","layerServerHandlers","Rpcs","pipe","provide","toHttpAppWebsocket","layerNoServerHttp","options","layer","layerRpc","path","runnerPath","https","runnerHttps","layerNoop","layerNoServerWebsocket","layerHttpOptions","routerTag","Default","serve","logAddress","withLogAddress","merge","layerServer","layerProtocolHttp","provideMerge","layerWebsocketOptions","layerProtocolWebsocket","effectDiscard","addressFormattedWith","address","annotateLogs","logInfo","package","service","layerHttp","layerWebsocket","layerRunnerHealthHttp","layerRunnerHealthWebsocket"],"sources":["../../src/HttpShardManager.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/esm/MachineId.js b/dist/esm/MachineId.js
new file mode 100644
index 0000000000000000000000000000000000000000..2705873196aefaad4d3faa970873391f38f158be
--- /dev/null
+++ b/dist/esm/MachineId.js
@@ -0,0 +1,17 @@
+/**
+ * @since 1.0.0
+ */
+import * as Schema from "effect/Schema";
+/**
+ * @since 1.0.0
+ * @category constructors
+ */
+export const MachineId = /*#__PURE__*/Schema.Int.pipe( /*#__PURE__*/Schema.brand("MachineId"), /*#__PURE__*/Schema.annotations({
+  pretty: () => machineId => `MachineId(${machineId})`
+}));
+/**
+ * @since 1.0.0
+ * @category Constructors
+ */
+export const make = shardId => MachineId.make(shardId);
+//# sourceMappingURL=MachineId.js.map
\ No newline at end of file
diff --git a/dist/esm/MachineId.js.map b/dist/esm/MachineId.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..1bc6a1efeeb113a3c2ecf6301eb9c003dc81fdea
--- /dev/null
+++ b/dist/esm/MachineId.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"MachineId.js","names":["Schema","MachineId","Int","pipe","brand","annotations","pretty","machineId","make","shardId"],"sources":["../../src/MachineId.ts"],"sourcesContent":[null],"mappings":"AAAA;;;AAGA,OAAO,KAAKA,MAAM,MAAM,eAAe;AAEvC;;;;AAIA,OAAO,MAAMC,SAAS,gBAAGD,MAAM,CAACE,GAAG,CAACC,IAAI,eACtCH,MAAM,CAACI,KAAK,CAAC,WAAW,CAAC,eACzBJ,MAAM,CAACK,WAAW,CAAC;EACjBC,MAAM,EAAEA,CAAA,KAAOC,SAAS,IAAK,aAAaA,SAAS;CACpD,CAAC,CACH;AAQD;;;;AAIA,OAAO,MAAMC,IAAI,GAAIC,OAAe,IAAgBR,SAAS,CAACO,IAAI,CAACC,OAAO,CAAC","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/esm/Message.js b/dist/esm/Message.js
index 9f96f582c1535c03461579c70c60388ed57e6f4b..2c62120c4f33631a2f368d355a166bf14a6ff3ca 100644
--- a/dist/esm/Message.js
+++ b/dist/esm/Message.js
@@ -1,33 +1,104 @@
-import * as internal from "./internal/message.js";
+import { FiberRef } from "effect";
+import * as Data from "effect/Data";
+import * as Effect from "effect/Effect";
+import * as Option from "effect/Option";
+import * as Schema from "effect/Schema";
+import { MalformedMessage } from "./ClusterError.js";
+import * as Envelope from "./Envelope.js";
 /**
  * @since 1.0.0
- * @category schemas
+ * @category incoming
  */
-export const TaggedMessage = internal.TaggedMessage_;
+export const incomingLocalFromOutgoing = self => {
+  if (self._tag === "OutgoingEnvelope") {
+    return new IncomingEnvelope({
+      envelope: self.envelope
+    });
+  }
+  return new IncomingRequestLocal({
+    envelope: self.envelope,
+    respond: self.respond,
+    lastSentReply: Option.none()
+  });
+};
 /**
  * @since 1.0.0
- * @category utils
+ * @category incoming
  */
-export const isMessageWithResult = internal.isMessageWithResult;
+export class IncomingRequest extends /*#__PURE__*/Data.TaggedClass("IncomingRequest") {}
 /**
- * Extracts the exit schema from a Message. This schema will be used to encode the remote exit of the Message processor.
- *
  * @since 1.0.0
- * @category utils
+ * @category outgoing
  */
-export const exitSchema = internal.exitSchema;
+export class IncomingRequestLocal extends /*#__PURE__*/Data.TaggedClass("IncomingRequestLocal") {}
 /**
- * Extracts the failure schema from a Message. This schema will be used to encode remote failures of the Message processor.
- *
  * @since 1.0.0
- * @category utils
+ * @category incoming
  */
-export const failureSchema = internal.failureSchema;
+export class IncomingEnvelope extends /*#__PURE__*/Data.TaggedClass("IncomingEnvelope") {}
 /**
- * Extracts the success schema from a Message. This schema will be used to encode the remote success of the Message processor.
- *
  * @since 1.0.0
- * @category utils
+ * @category outgoing
  */
-export const successSchema = internal.successSchema;
+export class OutgoingRequest extends /*#__PURE__*/Data.TaggedClass("OutgoingRequest") {
+  /**
+   * @since 1.0.0
+   */
+  encodedCache;
+}
+/**
+ * @since 1.0.0
+ * @category outgoing
+ */
+export class OutgoingEnvelope extends /*#__PURE__*/Data.TaggedClass("OutgoingEnvelope") {}
+/**
+ * @since 1.0.0
+ * @category serialization / deserialization
+ */
+export const serialize = message => {
+  if (message._tag !== "OutgoingRequest") {
+    return Effect.succeed(message.envelope);
+  }
+  return Effect.suspend(() => message.encodedCache ? Effect.succeed(message.encodedCache) : serializeRequest(message));
+};
+/**
+ * @since 1.0.0
+ * @category serialization / deserialization
+ */
+export const serializeEnvelope = message => Effect.flatMap(serialize(message), envelope => MalformedMessage.refail(Schema.encode(Envelope.PartialEncoded)(envelope)));
+/**
+ * @since 1.0.0
+ * @category serialization / deserialization
+ */
+export const serializeRequest = self => {
+  const rpc = self.rpc;
+  return Schema.encode(rpc.payloadSchema)(self.envelope.payload).pipe(Effect.locally(FiberRef.currentContext, self.context), MalformedMessage.refail, Effect.map(payload => ({
+    ...self.envelope,
+    payload
+  })));
+};
+/**
+ * @since 1.0.0
+ * @category serialization / deserialization
+ */
+export const deserializeLocal = (self, encoded) => {
+  if (encoded._tag !== "Request") {
+    return Effect.succeed(new IncomingEnvelope({
+      envelope: encoded
+    }));
+  } else if (self._tag !== "OutgoingRequest") {
+    return Effect.fail(new MalformedMessage({
+      cause: new Error("Can only deserialize a Request with an OutgoingRequest message")
+    }));
+  }
+  const rpc = self.rpc;
+  return Schema.decode(rpc.payloadSchema)(encoded.payload).pipe(Effect.locally(FiberRef.currentContext, self.context), MalformedMessage.refail, Effect.map(payload => new IncomingRequestLocal({
+    envelope: Envelope.makeRequest({
+      ...encoded,
+      payload
+    }),
+    lastSentReply: Option.none(),
+    respond: self.respond
+  })));
+};
 //# sourceMappingURL=Message.js.map
\ No newline at end of file
diff --git a/dist/esm/Message.js.map b/dist/esm/Message.js.map
index b132e6b97b8bd250b7d4e9614c3584bfd6bf1df0..0a0e316f312d71da837f384bec2d29307fb53f3b 100644
--- a/dist/esm/Message.js.map
+++ b/dist/esm/Message.js.map
@@ -1 +1 @@
-{"version":3,"file":"Message.js","names":["internal","TaggedMessage","TaggedMessage_","isMessageWithResult","exitSchema","failureSchema","successSchema"],"sources":["../../src/Message.ts"],"sourcesContent":[null],"mappings":"AAOA,OAAO,KAAKA,QAAQ,MAAM,uBAAuB;AAoFjD;;;;AAIA,OAAO,MAAMC,aAAa,GAAGD,QAAQ,CAACE,cAAc;AAEpD;;;;AAIA,OAAO,MAAMC,mBAAmB,GAC9BH,QAAQ,CAACG,mBAAmB;AAE9B;;;;;;AAMA,OAAO,MAAMC,UAAU,GAEwBJ,QAAQ,CAACI,UAAU;AAElE;;;;;;AAMA,OAAO,MAAMC,aAAa,GAEsBL,QAAQ,CAACK,aAAa;AAEtE;;;;;;AAMA,OAAO,MAAMC,aAAa,GAEwBN,QAAQ,CAACM,aAAa","ignoreList":[]}
\ No newline at end of file
+{"version":3,"file":"Message.js","names":["FiberRef","Data","Effect","Option","Schema","MalformedMessage","Envelope","incomingLocalFromOutgoing","self","_tag","IncomingEnvelope","envelope","IncomingRequestLocal","respond","lastSentReply","none","IncomingRequest","TaggedClass","OutgoingRequest","encodedCache","OutgoingEnvelope","serialize","message","succeed","suspend","serializeRequest","serializeEnvelope","flatMap","refail","encode","PartialEncoded","rpc","payloadSchema","payload","pipe","locally","currentContext","context","map","deserializeLocal","encoded","fail","cause","Error","decode","makeRequest"],"sources":["../../src/Message.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/esm/MessageStorage.js b/dist/esm/MessageStorage.js
new file mode 100644
index 0000000000000000000000000000000000000000..7b4df85a874e47e96f391ac3f690093757789657
--- /dev/null
+++ b/dist/esm/MessageStorage.js
@@ -0,0 +1,345 @@
+import * as Arr from "effect/Array";
+import * as Context from "effect/Context";
+import * as Data from "effect/Data";
+import * as Effect from "effect/Effect";
+import * as Exit from "effect/Exit";
+import * as FiberRef from "effect/FiberRef";
+import { globalValue } from "effect/GlobalValue";
+import * as Iterable from "effect/Iterable";
+import * as Layer from "effect/Layer";
+import * as Option from "effect/Option";
+import * as Schema from "effect/Schema";
+import { MalformedMessage } from "./ClusterError.js";
+import * as DeliverAt from "./DeliverAt.js";
+import * as Envelope from "./Envelope.js";
+import * as Message from "./Message.js";
+import * as Reply from "./Reply.js";
+import * as Snowflake from "./Snowflake.js";
+/**
+ * @since 1.0.0
+ * @category context
+ */
+export class MessageStorage extends /*#__PURE__*/Context.Tag("@effect/cluster/MessageStorage")() {}
+/**
+ * @since 1.0.0
+ * @category SaveResult
+ */
+export const SaveResult = /*#__PURE__*/Data.taggedEnum();
+/**
+ * @since 1.0.0
+ * @category SaveResult
+ */
+export const SaveResultEncoded = /*#__PURE__*/Data.taggedEnum();
+/**
+ * @since 1.0.0
+ * @category constructors
+ */
+export const make = storage => Effect.sync(() => {
+  const replyHandlers = new Map();
+  return MessageStorage.of({
+    ...storage,
+    registerReplyHandler: message => Effect.sync(() => {
+      replyHandlers.set(message.envelope.requestId, message.respond);
+    }),
+    saveReply(reply) {
+      return Effect.flatMap(storage.saveReply(reply), () => {
+        const handler = replyHandlers.get(reply.reply.requestId);
+        if (!handler) {
+          return Effect.void;
+        } else if (reply.reply._tag === "WithExit") {
+          replyHandlers.delete(reply.reply.requestId);
+        }
+        return handler(reply.reply);
+      });
+    }
+  });
+});
+/**
+ * @since 1.0.0
+ * @category constructors
+ */
+export const makeEncoded = /*#__PURE__*/Effect.fnUntraced(function* (encoded) {
+  const snowflakeGen = yield* Snowflake.Generator;
+  const clock = yield* Effect.clock;
+  const storage = yield* make({
+    saveRequest: message => Message.serializeEnvelope(message).pipe(Effect.flatMap(envelope => encoded.saveEnvelope({
+      envelope,
+      primaryKey: Envelope.primaryKey(message.envelope),
+      deliverAt: DeliverAt.toMillis(message.envelope.payload)
+    })), Effect.flatMap(result => {
+      if (result._tag === "Success" || result.lastReceivedReply._tag === "None") {
+        return Effect.succeed(result);
+      }
+      const duplicate = result;
+      const schema = Reply.Reply(message.rpc);
+      return Schema.decode(schema)(result.lastReceivedReply.value).pipe(Effect.locally(FiberRef.currentContext, message.context), MalformedMessage.refail, Effect.map(reply => SaveResult.Duplicate({
+        originalId: duplicate.originalId,
+        lastReceivedReply: Option.some(reply)
+      })));
+    })),
+    saveEnvelope: message => Message.serializeEnvelope(message).pipe(Effect.flatMap(envelope => encoded.saveEnvelope({
+      envelope,
+      primaryKey: null,
+      deliverAt: null
+    })), Effect.asVoid),
+    saveReply: reply => Effect.flatMap(Reply.serialize(reply), encoded.saveReply),
+    repliesFor: Effect.fnUntraced(function* (messages) {
+      const requestIds = Arr.empty();
+      const map = new Map();
+      for (const message of messages) {
+        const id = String(message.envelope.requestId);
+        requestIds.push(id);
+        map.set(id, message);
+      }
+      if (requestIds.length === 0) return [];
+      const encodedReplies = yield* encoded.repliesFor(requestIds);
+      return yield* decodeReplies(map, encodedReplies);
+    }),
+    unprocessedMessages: shardIds => {
+      const shards = Array.from(shardIds);
+      if (shards.length === 0) return Effect.succeed([]);
+      return Effect.flatMap(Effect.suspend(() => encoded.unprocessedMessages(shards, clock.unsafeCurrentTimeMillis())), decodeMessages);
+    },
+    unprocessedMessagesById(messageIds) {
+      const ids = Array.from(messageIds);
+      if (ids.length === 0) return Effect.succeed([]);
+      return Effect.flatMap(Effect.suspend(() => encoded.unprocessedMessagesById(ids, clock.unsafeCurrentTimeMillis())), decodeMessages);
+    },
+    resetAddress: address => encoded.resetAddress(address)
+  });
+  const decodeMessages = envelopes => {
+    const messages = [];
+    let index = 0;
+    // if we have a malformed message, we should not return it and update
+    // the storage with a defect
+    const decodeMessage = Effect.catchAll(Effect.suspend(() => {
+      const envelope = envelopes[index];
+      if (!envelope) return Effect.succeed(undefined);
+      return decodeEnvelopeWithReply(envelope);
+    }), error => {
+      const envelope = envelopes[index];
+      return storage.saveReply(Reply.ReplyWithContext.fromDefect({
+        id: snowflakeGen.unsafeNext(),
+        requestId: Snowflake.Snowflake(envelope.envelope.requestId),
+        defect: error.toString()
+      })).pipe(Effect.forkDaemon, Effect.asVoid);
+    });
+    return Effect.as(Effect.whileLoop({
+      while: () => index < envelopes.length,
+      body: () => decodeMessage,
+      step: message => {
+        const envelope = envelopes[index++];
+        if (!message) return;
+        messages.push(message.envelope._tag === "Request" ? new Message.IncomingRequest({
+          envelope: message.envelope,
+          lastSentReply: envelope.lastSentReply,
+          respond: storage.saveReply
+        }) : new Message.IncomingEnvelope({
+          envelope: message.envelope
+        }));
+      }
+    }), messages);
+  };
+  const decodeReplies = (messages, encodedReplies) => {
+    const replies = [];
+    const ignoredRequests = new Set();
+    let index = 0;
+    const decodeReply = Effect.catchAll(Effect.suspend(() => {
+      const reply = encodedReplies[index];
+      if (ignoredRequests.has(reply.requestId)) return Effect.void;
+      const message = messages.get(reply.requestId);
+      if (!message) return Effect.void;
+      const schema = Reply.Reply(message.rpc);
+      return Schema.decode(schema)(reply).pipe(Effect.locally(FiberRef.currentContext, message.context));
+    }), error => {
+      const reply = encodedReplies[index];
+      ignoredRequests.add(reply.requestId);
+      return Effect.succeed(new Reply.WithExit({
+        id: snowflakeGen.unsafeNext(),
+        requestId: Snowflake.Snowflake(reply.requestId),
+        exit: Exit.die(error)
+      }));
+    });
+    return Effect.as(Effect.whileLoop({
+      while: () => index < encodedReplies.length,
+      body: () => decodeReply,
+      step: reply => {
+        index++;
+        if (reply) replies.push(reply);
+      }
+    }), replies);
+  };
+  return storage;
+});
+/**
+ * @since 1.0.0
+ * @category Constructors
+ */
+export const noop = /*#__PURE__*/globalValue("@effect/cluster/MessageStorage/noop", () => Effect.runSync(make({
+  saveRequest: () => Effect.succeed(SaveResult.Success()),
+  saveEnvelope: () => Effect.void,
+  saveReply: () => Effect.void,
+  repliesFor: () => Effect.succeed([]),
+  unprocessedMessages: () => Effect.succeed([]),
+  unprocessedMessagesById: () => Effect.succeed([]),
+  resetAddress: () => Effect.void
+})));
+/**
+ * @since 1.0.0
+ * @category Memory
+ */
+export class MemoryDriver extends /*#__PURE__*/Effect.Service()("@effect/cluster/MessageStorage/MemoryDriver", {
+  dependencies: [Snowflake.layerGenerator],
+  effect: /*#__PURE__*/Effect.gen(function* () {
+    const requests = new Map();
+    const requestsByPrimaryKey = new Map();
+    const unprocessed = new Set();
+    const replyIds = new Set();
+    const journal = [];
+    const cursors = new WeakMap();
+    const unprocessedWith = predicate => {
+      const messages = [];
+      for (const envelope of unprocessed) {
+        if (!predicate(envelope)) {
+          continue;
+        }
+        if (envelope._tag === "Request") {
+          const entry = requests.get(envelope.requestId);
+          messages.push({
+            envelope,
+            lastSentReply: Option.fromNullable(entry?.replies[entry.replies.length - 1])
+          });
+        } else {
+          messages.push({
+            envelope,
+            lastSentReply: Option.none()
+          });
+        }
+      }
+      return messages;
+    };
+    const replyLatch = yield* Effect.makeLatch();
+    const encoded = {
+      saveEnvelope: ({
+        envelope,
+        primaryKey
+      }) => Effect.sync(() => {
+        const existing = primaryKey ? requestsByPrimaryKey.get(primaryKey) : envelope._tag === "Request" && requests.get(envelope.requestId);
+        if (existing) {
+          return SaveResultEncoded.Duplicate({
+            originalId: Snowflake.Snowflake(existing.envelope.requestId),
+            lastReceivedReply: existing.lastReceivedChunk
+          });
+        }
+        if (envelope._tag === "Request") {
+          const entry = {
+            envelope,
+            replies: [],
+            lastReceivedChunk: Option.none()
+          };
+          requests.set(envelope.requestId, entry);
+          if (primaryKey) {
+            requestsByPrimaryKey.set(primaryKey, entry);
+          }
+          unprocessed.add(envelope);
+        } else if (envelope._tag === "AckChunk") {
+          const entry = requests.get(envelope.requestId);
+          if (entry) {
+            entry.lastReceivedChunk = Arr.findFirst(entry.replies, r => r._tag === "Chunk" && r.id === envelope.replyId).pipe(Option.orElse(() => entry.lastReceivedChunk));
+          }
+        }
+        journal.push(envelope);
+        return SaveResultEncoded.Success();
+      }),
+      saveReply: reply => Effect.sync(() => {
+        const entry = requests.get(reply.requestId);
+        if (!entry || replyIds.has(reply.id)) return;
+        if (reply._tag === "WithExit") {
+          unprocessed.delete(entry.envelope);
+        }
+        entry.replies.push(reply);
+        replyIds.add(reply.id);
+        replyLatch.unsafeOpen();
+      }),
+      repliesFor: requestIds => Effect.sync(() => {
+        const replies = Arr.empty();
+        for (const requestId of requestIds) {
+          const request = requests.get(requestId);
+          if (!request) continue;else if (Option.isNone(request.lastReceivedChunk)) {
+            // eslint-disable-next-line no-restricted-syntax
+            replies.push(...request.replies);
+            continue;
+          }
+          const sequence = request.lastReceivedChunk.value.sequence;
+          for (const reply of request.replies) {
+            if (reply._tag === "Chunk" && reply.sequence <= sequence) {
+              continue;
+            }
+            replies.push(reply);
+          }
+        }
+        return replies;
+      }),
+      unprocessedMessages: shardIds => Effect.sync(() => {
+        if (unprocessed.size === 0) return [];
+        const messages = Arr.empty();
+        let index = journal.indexOf(Iterable.unsafeHead(unprocessed));
+        for (; index < journal.length; index++) {
+          const envelope = journal[index];
+          if (!shardIds.includes(envelope.address.shardId)) {
+            continue;
+          }
+          if (envelope._tag === "Request") {
+            const entry = requests.get(envelope.requestId);
+            messages.push({
+              envelope,
+              lastSentReply: Arr.last(entry.replies)
+            });
+          } else {
+            messages.push({
+              envelope,
+              lastSentReply: Option.none()
+            });
+          }
+        }
+        return messages;
+      }),
+      unprocessedMessagesById: ids => Effect.sync(() => {
+        const envelopeIds = new Set();
+        for (const id of ids) {
+          envelopeIds.add(String(id));
+        }
+        return unprocessedWith(envelope => envelopeIds.has(envelope.requestId));
+      }),
+      resetAddress: () => Effect.void
+    };
+    const storage = yield* makeEncoded(encoded);
+    return {
+      storage,
+      encoded,
+      requests,
+      requestsByPrimaryKey,
+      unprocessed,
+      replyIds,
+      journal,
+      cursors
+    };
+  })
+}) {}
+/**
+ * @since 1.0.0
+ * @category layers
+ */
+export const layerNoop = /*#__PURE__*/Layer.succeed(MessageStorage, noop);
+/**
+ * @since 1.0.0
+ * @category layers
+ */
+export const layerMemory = /*#__PURE__*/Layer.effect(MessageStorage, Effect.map(MemoryDriver, _ => _.storage)).pipe( /*#__PURE__*/Layer.provideMerge(MemoryDriver.Default));
+// --- internal ---
+const EnvelopeWithReply = /*#__PURE__*/Schema.Struct({
+  envelope: Envelope.PartialEncoded,
+  lastSentReply: /*#__PURE__*/Schema.OptionFromSelf(Reply.Encoded)
+});
+const decodeEnvelopeWithReply = /*#__PURE__*/Schema.decode(EnvelopeWithReply);
+//# sourceMappingURL=MessageStorage.js.map
\ No newline at end of file
diff --git a/dist/esm/MessageStorage.js.map b/dist/esm/MessageStorage.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..715d0d1c03ff3dcd758e680a0589d0074f42c684
--- /dev/null
+++ b/dist/esm/MessageStorage.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"MessageStorage.js","names":["Arr","Context","Data","Effect","Exit","FiberRef","globalValue","Iterable","Layer","Option","Schema","MalformedMessage","DeliverAt","Envelope","Message","Reply","Snowflake","MessageStorage","Tag","SaveResult","taggedEnum","SaveResultEncoded","make","storage","sync","replyHandlers","Map","of","registerReplyHandler","message","set","envelope","requestId","respond","saveReply","reply","flatMap","handler","get","void","_tag","delete","makeEncoded","fnUntraced","encoded","snowflakeGen","Generator","clock","saveRequest","serializeEnvelope","pipe","saveEnvelope","primaryKey","deliverAt","toMillis","payload","result","lastReceivedReply","succeed","duplicate","schema","rpc","decode","value","locally","currentContext","context","refail","map","Duplicate","originalId","some","asVoid","serialize","repliesFor","messages","requestIds","empty","id","String","push","length","encodedReplies","decodeReplies","unprocessedMessages","shardIds","shards","Array","from","suspend","unsafeCurrentTimeMillis","decodeMessages","unprocessedMessagesById","messageIds","ids","resetAddress","address","envelopes","index","decodeMessage","catchAll","undefined","decodeEnvelopeWithReply","error","ReplyWithContext","fromDefect","unsafeNext","defect","toString","forkDaemon","as","whileLoop","while","body","step","IncomingRequest","lastSentReply","IncomingEnvelope","replies","ignoredRequests","Set","decodeReply","has","add","WithExit","exit","die","noop","runSync","Success","MemoryDriver","Service","dependencies","layerGenerator","effect","gen","requests","requestsByPrimaryKey","unprocessed","replyIds","journal","cursors","WeakMap","unprocessedWith","predicate","entry","fromNullable","none","replyLatch","makeLatch","existing","lastReceivedChunk","findFirst","r","replyId","orElse","unsafeOpen","request","isNone","sequence","size","indexOf","unsafeHead","includes","shardId","last","envelopeIds","layerNoop","layerMemory","_","provideMerge","Default","EnvelopeWithReply","Struct","PartialEncoded","OptionFromSelf","Encoded"],"sources":["../../src/MessageStorage.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/esm/Reply.js b/dist/esm/Reply.js
new file mode 100644
index 0000000000000000000000000000000000000000..ab026fb7f15abd6f010ec6a76bbf306ccc83eaab
--- /dev/null
+++ b/dist/esm/Reply.js
@@ -0,0 +1,184 @@
+/**
+ * @since 1.0.0
+ */
+import * as Rpc from "@effect/rpc/Rpc";
+import * as Context from "effect/Context";
+import * as Data from "effect/Data";
+import * as Effect from "effect/Effect";
+import * as Exit from "effect/Exit";
+import * as FiberRef from "effect/FiberRef";
+import { identity } from "effect/Function";
+import { hasProperty } from "effect/Predicate";
+import * as Schema from "effect/Schema";
+import { MalformedMessage } from "./ClusterError.js";
+import { Snowflake, SnowflakeFromString } from "./Snowflake.js";
+/**
+ * @since 1.0.0
+ * @category type ids
+ */
+export const TypeId = /*#__PURE__*/Symbol.for("@effect/cluster/Reply");
+/**
+ * @since 1.0.0
+ * @category guards
+ */
+export const isReply = u => hasProperty(u, TypeId);
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export class ReplyWithContext extends /*#__PURE__*/Data.TaggedClass("ReplyWithContext") {
+  /**
+   * @since 1.0.0
+   */
+  static fromDefect(options) {
+    return new ReplyWithContext({
+      reply: new WithExit({
+        requestId: options.requestId,
+        id: options.id,
+        exit: Exit.die(Schema.encodeSync(Schema.Defect)(options.defect))
+      }),
+      context: Context.empty(),
+      rpc: neverRpc
+    });
+  }
+}
+const neverRpc = /*#__PURE__*/Rpc.make("Never", {
+  success: Schema.Never,
+  error: Schema.Never,
+  payload: {}
+});
+const schemaCache = /*#__PURE__*/new WeakMap();
+/**
+ * @since 1.0.0
+ * @category schemas
+ */
+export const Reply = rpc => {
+  if (schemaCache.has(rpc)) {
+    return schemaCache.get(rpc);
+  }
+  const schema = Schema.Union(WithExit.schema(rpc), Chunk.schema(rpc));
+  schemaCache.set(rpc, schema);
+  return schema;
+};
+/**
+ * @since 1.0.0
+ * @category schemas
+ */
+export const Encoded = /*#__PURE__*/Schema.Union( /*#__PURE__*/Schema.Struct({
+  _tag: /*#__PURE__*/Schema.Literal("WithExit"),
+  requestId: Schema.String,
+  id: Schema.String,
+  exit: Schema.Unknown
+}), /*#__PURE__*/Schema.Struct({
+  _tag: /*#__PURE__*/Schema.Literal("Chunk"),
+  requestId: Schema.String,
+  id: Schema.String,
+  sequence: Schema.Number,
+  values: /*#__PURE__*/Schema.Array(Schema.Unknown)
+}));
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export class Chunk extends /*#__PURE__*/Data.TaggedClass("Chunk") {
+  /**
+   * @since 1.0.0
+   */
+  [TypeId] = TypeId;
+  /**
+   * @since 1.0.0
+   */
+  static emptyFrom(requestId) {
+    return new Chunk({
+      requestId,
+      id: Snowflake(BigInt(0)),
+      sequence: 0,
+      values: [undefined]
+    });
+  }
+  /**
+   * @since 1.0.0
+   */
+  static schemaFromSelf = /*#__PURE__*/Schema.declare(u => isReply(u) && u._tag === "Chunk");
+  /**
+   * @since 1.0.0
+   */
+  static schema(rpc) {
+    const successSchema = rpc.successSchema.success;
+    if (!successSchema) {
+      return Schema.Never;
+    }
+    return Schema.transform(Schema.Struct({
+      _tag: Schema.Literal("Chunk"),
+      requestId: SnowflakeFromString,
+      id: SnowflakeFromString,
+      sequence: Schema.Number,
+      values: Schema.NonEmptyArray(successSchema)
+    }), Chunk.schemaFromSelf, {
+      decode: encoded => new Chunk(encoded),
+      encode: identity
+    });
+  }
+  /**
+   * @since 1.0.0
+   */
+  withRequestId(requestId) {
+    return new Chunk({
+      ...this,
+      requestId
+    });
+  }
+}
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export class WithExit extends /*#__PURE__*/Data.TaggedClass("WithExit") {
+  /**
+   * @since 1.0.0
+   */
+  [TypeId] = TypeId;
+  /**
+   * @since 1.0.0
+   */
+  static schema(rpc) {
+    return Schema.transform(Schema.Struct({
+      _tag: Schema.Literal("WithExit"),
+      requestId: SnowflakeFromString,
+      id: SnowflakeFromString,
+      exit: Rpc.exitSchema(rpc)
+    }), Schema.declare(u => isReply(u) && u._tag === "WithExit"), {
+      decode: encoded => new WithExit(encoded),
+      encode: identity
+    });
+  }
+  /**
+   * @since 1.0.0
+   */
+  withRequestId(requestId) {
+    return new WithExit({
+      ...this,
+      requestId
+    });
+  }
+}
+/**
+ * @since 1.0.0
+ * @category serialization / deserialization
+ */
+export const serialize = self => {
+  const schema = Reply(self.rpc);
+  return MalformedMessage.refail(Effect.locally(Schema.encode(schema)(self.reply), FiberRef.currentContext, self.context));
+};
+/**
+ * @since 1.0.0
+ * @category serialization / deserialization
+ */
+export const serializeLastReceived = self => {
+  if (self.lastReceivedReply._tag === "None") {
+    return Effect.succeedNone;
+  }
+  const schema = Reply(self.rpc);
+  return Effect.asSome(MalformedMessage.refail(Effect.locally(Schema.encode(schema)(self.lastReceivedReply.value), FiberRef.currentContext, self.context)));
+};
+//# sourceMappingURL=Reply.js.map
\ No newline at end of file
diff --git a/dist/esm/Reply.js.map b/dist/esm/Reply.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..44ee71e4b2c75e286a7bb8571ac4c004180cd08e
--- /dev/null
+++ b/dist/esm/Reply.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"Reply.js","names":["Rpc","Context","Data","Effect","Exit","FiberRef","identity","hasProperty","Schema","MalformedMessage","Snowflake","SnowflakeFromString","TypeId","Symbol","for","isReply","u","ReplyWithContext","TaggedClass","fromDefect","options","reply","WithExit","requestId","id","exit","die","encodeSync","Defect","defect","context","empty","rpc","neverRpc","make","success","Never","error","payload","schemaCache","WeakMap","Reply","has","get","schema","Union","Chunk","set","Encoded","Struct","_tag","Literal","String","Unknown","sequence","Number","values","Array","emptyFrom","BigInt","undefined","schemaFromSelf","declare","successSchema","transform","NonEmptyArray","decode","encoded","encode","withRequestId","exitSchema","serialize","self","refail","locally","currentContext","serializeLastReceived","lastReceivedReply","succeedNone","asSome","value"],"sources":["../../src/Reply.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/esm/Runner.js b/dist/esm/Runner.js
new file mode 100644
index 0000000000000000000000000000000000000000..aa9b051bc44842502497628742a2b68d066ab74c
--- /dev/null
+++ b/dist/esm/Runner.js
@@ -0,0 +1,68 @@
+/**
+ * @since 1.0.0
+ */
+import { NodeInspectSymbol } from "effect/Inspectable";
+import * as Pretty from "effect/Pretty";
+import * as Schema from "effect/Schema";
+import { RunnerAddress } from "./RunnerAddress.js";
+const SymbolKey = "@effect/cluster/Runner";
+/**
+ * @since 1.0.0
+ * @category type ids
+ */
+export const TypeId = /*#__PURE__*/Symbol.for(SymbolKey);
+/**
+ * A `Runner` represents a physical application server that is capable of running
+ * entities.
+ *
+ * Because a Runner represents a physical application server, a Runner must have a
+ * unique `address` which can be used to communicate with the server.
+ *
+ * The version of a Runner is used during rebalancing to give priority to newer
+ * application servers and slowly decommission older ones.
+ *
+ * @since 1.0.0
+ * @category models
+ */
+export class Runner extends /*#__PURE__*/Schema.Class(SymbolKey)({
+  address: RunnerAddress,
+  version: Schema.Int
+}) {
+  /**
+   * @since 1.0.0
+   */
+  static pretty = /*#__PURE__*/Pretty.make(this);
+  /**
+   * @since 1.0.0
+   */
+  [TypeId] = TypeId;
+  /**
+   * @since 1.0.0
+   */
+  static decodeSync = /*#__PURE__*/Schema.decodeSync( /*#__PURE__*/Schema.parseJson(Runner));
+  /**
+   * @since 1.0.0
+   */
+  static encodeSync = /*#__PURE__*/Schema.encodeSync( /*#__PURE__*/Schema.parseJson(Runner));
+  /**
+   * @since 1.0.0
+   */
+  [NodeInspectSymbol]() {
+    return this.toString();
+  }
+}
+/**
+ * A `Runner` represents a physical application server that is capable of running
+ * entities.
+ *
+ * Because a Runner represents a physical application server, a Runner must have a
+ * unique `address` which can be used to communicate with the server.
+ *
+ * The version of a Runner is used during rebalancing to give priority to newer
+ * application servers and slowly decommission older ones.
+ *
+ * @since 1.0.0
+ * @category Constructors
+ */
+export const make = props => new Runner(props);
+//# sourceMappingURL=Runner.js.map
\ No newline at end of file
diff --git a/dist/esm/Runner.js.map b/dist/esm/Runner.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..6d212b05dc74685b39e963a32155d1b103013197
--- /dev/null
+++ b/dist/esm/Runner.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"Runner.js","names":["NodeInspectSymbol","Pretty","Schema","RunnerAddress","SymbolKey","TypeId","Symbol","for","Runner","Class","address","version","Int","pretty","make","decodeSync","parseJson","encodeSync","toString","props"],"sources":["../../src/Runner.ts"],"sourcesContent":[null],"mappings":"AAAA;;;AAGA,SAASA,iBAAiB,QAAQ,oBAAoB;AACtD,OAAO,KAAKC,MAAM,MAAM,eAAe;AACvC,OAAO,KAAKC,MAAM,MAAM,eAAe;AACvC,SAASC,aAAa,QAAQ,oBAAoB;AAElD,MAAMC,SAAS,GAAG,wBAAwB;AAE1C;;;;AAIA,OAAO,MAAMC,MAAM,gBAAkBC,MAAM,CAACC,GAAG,CAACH,SAAS,CAAC;AAQ1D;;;;;;;;;;;;;AAaA,OAAM,MAAOI,MAAO,sBAAQN,MAAM,CAACO,KAAK,CAASL,SAAS,CAAC,CAAC;EAC1DM,OAAO,EAAEP,aAAa;EACtBQ,OAAO,EAAET,MAAM,CAACU;CACjB,CAAC;EACA;;;EAGA,OAAOC,MAAM,gBAAGZ,MAAM,CAACa,IAAI,CAAC,IAAI,CAAC;EAEjC;;;EAGS,CAACT,MAAM,IAAIA,MAAM;EAE1B;;;EAGA,OAAgBU,UAAU,gBAAGb,MAAM,CAACa,UAAU,eAACb,MAAM,CAACc,SAAS,CAACR,MAAM,CAAC,CAAC;EAExE;;;EAGA,OAAgBS,UAAU,gBAAGf,MAAM,CAACe,UAAU,eAACf,MAAM,CAACc,SAAS,CAACR,MAAM,CAAC,CAAC;EAExE;;;EAGA,CAACR,iBAAiB,IAAC;IACjB,OAAO,IAAI,CAACkB,QAAQ,EAAE;EACxB;;AAGF;;;;;;;;;;;;;AAaA,OAAO,MAAMJ,IAAI,GAAIK,KAGpB,IAAa,IAAIX,MAAM,CAACW,KAAK,CAAC","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/esm/RunnerAddress.js b/dist/esm/RunnerAddress.js
new file mode 100644
index 0000000000000000000000000000000000000000..a06a0b404ac3bdcef7b99b86249d39f5882114a5
--- /dev/null
+++ b/dist/esm/RunnerAddress.js
@@ -0,0 +1,52 @@
+/**
+ * @since 1.0.0
+ */
+import * as Hash from "effect/Hash";
+import { NodeInspectSymbol } from "effect/Inspectable";
+import * as Schema from "effect/Schema";
+const SymbolKey = "@effect/cluster/RunnerAddress";
+/**
+ * @since 1.0.0
+ * @category type ids
+ */
+export const TypeId = /*#__PURE__*/Symbol.for(SymbolKey);
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export class RunnerAddress extends /*#__PURE__*/Schema.Class(SymbolKey)({
+  host: Schema.NonEmptyString,
+  port: Schema.Int
+}) {
+  /**
+   * @since 1.0.0
+   */
+  [TypeId] = TypeId;
+  /**
+   * @since 1.0.0
+   */
+  [Hash.symbol]() {
+    return Hash.cached(this)(Hash.string(this.toString()));
+  }
+  /**
+   * @since 1.0.0
+   */
+  toString() {
+    return `RunnerAddress(${this.host}:${this.port})`;
+  }
+  /**
+   * @since 1.0.0
+   */
+  [NodeInspectSymbol]() {
+    return this.toString();
+  }
+}
+/**
+ * @since 1.0.0
+ * @category constructors
+ */
+export const make = (host, port) => new RunnerAddress({
+  host,
+  port
+});
+//# sourceMappingURL=RunnerAddress.js.map
\ No newline at end of file
diff --git a/dist/esm/RunnerAddress.js.map b/dist/esm/RunnerAddress.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..82a7f065022987ea5068f86e743a908838a1aa17
--- /dev/null
+++ b/dist/esm/RunnerAddress.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"RunnerAddress.js","names":["Hash","NodeInspectSymbol","Schema","SymbolKey","TypeId","Symbol","for","RunnerAddress","Class","host","NonEmptyString","port","Int","symbol","cached","string","toString","make"],"sources":["../../src/RunnerAddress.ts"],"sourcesContent":[null],"mappings":"AAAA;;;AAGA,OAAO,KAAKA,IAAI,MAAM,aAAa;AACnC,SAASC,iBAAiB,QAAQ,oBAAoB;AACtD,OAAO,KAAKC,MAAM,MAAM,eAAe;AAEvC,MAAMC,SAAS,GAAG,+BAA+B;AAEjD;;;;AAIA,OAAO,MAAMC,MAAM,gBAAkBC,MAAM,CAACC,GAAG,CAACH,SAAS,CAAC;AAQ1D;;;;AAIA,OAAM,MAAOI,aAAc,sBAAQL,MAAM,CAACM,KAAK,CAAgBL,SAAS,CAAC,CAAC;EACxEM,IAAI,EAAEP,MAAM,CAACQ,cAAc;EAC3BC,IAAI,EAAET,MAAM,CAACU;CACd,CAAC;EACA;;;EAGS,CAACR,MAAM,IAAIA,MAAM;EAE1B;;;EAGA,CAACJ,IAAI,CAACa,MAAM,IAAC;IACX,OAAOb,IAAI,CAACc,MAAM,CAAC,IAAI,CAAC,CAACd,IAAI,CAACe,MAAM,CAAC,IAAI,CAACC,QAAQ,EAAE,CAAC,CAAC;EACxD;EAEA;;;EAGAA,QAAQA,CAAA;IACN,OAAO,iBAAiB,IAAI,CAACP,IAAI,IAAI,IAAI,CAACE,IAAI,GAAG;EACnD;EAEA;;;EAGA,CAACV,iBAAiB,IAAC;IACjB,OAAO,IAAI,CAACe,QAAQ,EAAE;EACxB;;AAGF;;;;AAIA,OAAO,MAAMC,IAAI,GAAGA,CAACR,IAAY,EAAEE,IAAY,KAAoB,IAAIJ,aAAa,CAAC;EAAEE,IAAI;EAAEE;AAAI,CAAE,CAAC","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/esm/RunnerHealth.js b/dist/esm/RunnerHealth.js
new file mode 100644
index 0000000000000000000000000000000000000000..2cef898d4158d2183a86be541921a99b698ffcc6
--- /dev/null
+++ b/dist/esm/RunnerHealth.js
@@ -0,0 +1,58 @@
+/**
+ * @since 1.0.0
+ */
+import * as Context from "effect/Context";
+import * as Effect from "effect/Effect";
+import * as Layer from "effect/Layer";
+import * as MessageStorage from "./MessageStorage.js";
+import * as Runners from "./Runners.js";
+/**
+ * Represents the service used to check if a Runner is healthy.
+ *
+ * If a Runner is responsive, shards will not be re-assigned because the Runner may
+ * still be processing messages. If a Runner is not responsive, then its
+ * associated shards can and will be re-assigned to a different Runner.
+ *
+ * @since 1.0.0
+ * @category models
+ */
+export class RunnerHealth extends /*#__PURE__*/Context.Tag("@effect/cluster/RunnerHealth")() {}
+/**
+ * A layer which will **always** consider a Runner healthy.
+ *
+ * This is useful for testing.
+ *
+ * @since 1.0.0
+ * @category layers
+ */
+export const layerNoop = /*#__PURE__*/Layer.succeed(RunnerHealth, /*#__PURE__*/RunnerHealth.of({
+  isAlive: () => Effect.succeed(true)
+}));
+/**
+ * @since 1.0.0
+ * @category Constructors
+ */
+export const make = /*#__PURE__*/Effect.gen(function* () {
+  const runners = yield* Runners.Runners;
+  function isAlive(address) {
+    return Effect.isSuccess(Effect.timeout(runners.ping(address), 3000));
+  }
+  return RunnerHealth.of({
+    isAlive
+  });
+});
+/**
+ * A layer which will ping a Runner directly to check if it is healthy.
+ *
+ * @since 1.0.0
+ * @category layers
+ */
+export const layer = /*#__PURE__*/Layer.effect(RunnerHealth, make);
+/**
+ * A layer which will ping a Runner directly to check if it is healthy.
+ *
+ * @since 1.0.0
+ * @category layers
+ */
+export const layerRpc = /*#__PURE__*/layer.pipe( /*#__PURE__*/Layer.provide(Runners.layerRpc), /*#__PURE__*/Layer.provide(MessageStorage.layerNoop));
+//# sourceMappingURL=RunnerHealth.js.map
\ No newline at end of file
diff --git a/dist/esm/RunnerHealth.js.map b/dist/esm/RunnerHealth.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..dc371c8d7ab186a957d7164dddeeddf7ee32d04e
--- /dev/null
+++ b/dist/esm/RunnerHealth.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"RunnerHealth.js","names":["Context","Effect","Layer","MessageStorage","Runners","RunnerHealth","Tag","layerNoop","succeed","of","isAlive","make","gen","runners","address","isSuccess","timeout","ping","layer","effect","layerRpc","pipe","provide"],"sources":["../../src/RunnerHealth.ts"],"sourcesContent":[null],"mappings":"AAAA;;;AAGA,OAAO,KAAKA,OAAO,MAAM,gBAAgB;AACzC,OAAO,KAAKC,MAAM,MAAM,eAAe;AACvC,OAAO,KAAKC,KAAK,MAAM,cAAc;AACrC,OAAO,KAAKC,cAAc,MAAM,qBAAqB;AAErD,OAAO,KAAKC,OAAO,MAAM,cAAc;AAGvC;;;;;;;;;;AAUA,OAAM,MAAOC,YAAa,sBAAQL,OAAO,CAACM,GAAG,CAAC,8BAA8B,CAAC,EAK1E;AAEH;;;;;;;;AAQA,OAAO,MAAMC,SAAS,gBAAGL,KAAK,CAACM,OAAO,CACpCH,YAAY,eACZA,YAAY,CAACI,EAAE,CAAC;EACdC,OAAO,EAAEA,CAAA,KAAMT,MAAM,CAACO,OAAO,CAAC,IAAI;CACnC,CAAC,CACH;AAED;;;;AAIA,OAAO,MAAMG,IAAI,gBAIbV,MAAM,CAACW,GAAG,CAAC,aAAS;EACtB,MAAMC,OAAO,GAAG,OAAOT,OAAO,CAACA,OAAO;EAEtC,SAASM,OAAOA,CAACI,OAAsB;IACrC,OAAOb,MAAM,CAACc,SAAS,CAACd,MAAM,CAACe,OAAO,CAACH,OAAO,CAACI,IAAI,CAACH,OAAO,CAAC,EAAE,IAAI,CAAC,CAAC;EACtE;EAEA,OAAOT,YAAY,CAACI,EAAE,CAAC;IAAEC;EAAO,CAAE,CAAC;AACrC,CAAC,CAAC;AAEF;;;;;;AAMA,OAAO,MAAMQ,KAAK,gBAIdhB,KAAK,CAACiB,MAAM,CAACd,YAAY,EAAEM,IAAI,CAAC;AAEpC;;;;;;AAMA,OAAO,MAAMS,QAAQ,gBAIjBF,KAAK,CAACG,IAAI,eACZnB,KAAK,CAACoB,OAAO,CAAClB,OAAO,CAACgB,QAAQ,CAAC,eAC/BlB,KAAK,CAACoB,OAAO,CAACnB,cAAc,CAACI,SAAS,CAAC,CACxC","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/esm/RunnerServer.js b/dist/esm/RunnerServer.js
new file mode 100644
index 0000000000000000000000000000000000000000..3d863817072e2857096fc0180de2cab09d9d0bb1
--- /dev/null
+++ b/dist/esm/RunnerServer.js
@@ -0,0 +1,116 @@
+/**
+ * @since 1.0.0
+ */
+import * as RpcServer from "@effect/rpc/RpcServer";
+import * as Effect from "effect/Effect";
+import { constant } from "effect/Function";
+import * as Layer from "effect/Layer";
+import * as Mailbox from "effect/Mailbox";
+import * as Option from "effect/Option";
+import * as Message from "./Message.js";
+import * as Reply from "./Reply.js";
+import * as Runners from "./Runners.js";
+import * as Sharding from "./Sharding.js";
+import { ShardingConfig } from "./ShardingConfig.js";
+import * as ShardManager from "./ShardManager.js";
+import * as ShardStorage from "./ShardStorage.js";
+import * as SynchronizedClock from "./SynchronizedClock.js";
+const constVoid = /*#__PURE__*/constant(Effect.void);
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layerHandlers = /*#__PURE__*/Runners.Rpcs.toLayer( /*#__PURE__*/Effect.gen(function* () {
+  const sharding = yield* Sharding.Sharding;
+  return {
+    Ping: () => Effect.void,
+    Notify: ({
+      envelope
+    }) => sharding.notify(envelope._tag === "Request" ? new Message.IncomingRequest({
+      envelope,
+      respond: constVoid,
+      lastSentReply: Option.none()
+    }) : new Message.IncomingEnvelope({
+      envelope
+    })),
+    Effect: ({
+      request
+    }) => {
+      let resume;
+      let replyEncoded;
+      const message = new Message.IncomingRequest({
+        envelope: request,
+        lastSentReply: Option.none(),
+        respond(reply) {
+          return Effect.flatMap(Reply.serialize(reply), reply => {
+            if (resume) {
+              resume(Effect.succeed(reply));
+            } else {
+              replyEncoded = reply;
+            }
+            return Effect.void;
+          });
+        }
+      });
+      return Effect.zipRight(sharding.send(message), Effect.async(resume_ => {
+        if (replyEncoded) {
+          resume_(Effect.succeed(replyEncoded));
+        } else {
+          resume = resume_;
+        }
+      }));
+    },
+    Stream: ({
+      request
+    }) => Effect.flatMap(Mailbox.make(), mailbox => Effect.as(sharding.send(new Message.IncomingRequest({
+      envelope: request,
+      lastSentReply: Option.none(),
+      respond(reply) {
+        return Effect.flatMap(Reply.serialize(reply), reply => {
+          mailbox.unsafeOffer(reply);
+          return Effect.void;
+        });
+      }
+    })), mailbox)),
+    Envelope: ({
+      envelope
+    }) => sharding.send(new Message.IncomingEnvelope({
+      envelope
+    }))
+  };
+}));
+/**
+ * The `RunnerServer` recieves messages from other Runners and forwards them to the
+ * `Sharding` layer.
+ *
+ * It also responds to `Ping` requests.
+ *
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layer = /*#__PURE__*/RpcServer.layer(Runners.Rpcs, {
+  spanPrefix: "RunnerServer",
+  disableTracing: true
+}).pipe( /*#__PURE__*/Layer.provide(layerHandlers));
+/**
+ * A `RunnerServer` layer that includes the `Runners` & `Sharding` clients.
+ *
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layerWithClients = /*#__PURE__*/layer.pipe( /*#__PURE__*/Layer.provideMerge(Sharding.layer), /*#__PURE__*/Layer.provideMerge(Runners.layerRpc), /*#__PURE__*/Layer.provideMerge(SynchronizedClock.layer), /*#__PURE__*/Layer.provide(ShardManager.layerClientRpc));
+/**
+ * A `Runners` layer that is client only.
+ *
+ * It will not register with the ShardManager and recieve shard assignments,
+ * so this layer can be used to embed a cluster client inside another effect
+ * application.
+ *
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layerClientOnly = /*#__PURE__*/Sharding.layer.pipe( /*#__PURE__*/Layer.provideMerge(Runners.layerRpc), /*#__PURE__*/Layer.provide(ShardManager.layerClientRpc), /*#__PURE__*/Layer.provide(ShardStorage.layerNoop), /*#__PURE__*/Layer.updateService(ShardingConfig, config => ({
+  ...config,
+  runnerAddress: Option.none()
+})));
+//# sourceMappingURL=RunnerServer.js.map
\ No newline at end of file
diff --git a/dist/esm/RunnerServer.js.map b/dist/esm/RunnerServer.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..747df7ed1fa707bb419de3ad3dfd88fb7e30c984
--- /dev/null
+++ b/dist/esm/RunnerServer.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"RunnerServer.js","names":["RpcServer","Effect","constant","Layer","Mailbox","Option","Message","Reply","Runners","Sharding","ShardingConfig","ShardManager","ShardStorage","SynchronizedClock","constVoid","void","layerHandlers","Rpcs","toLayer","gen","sharding","Ping","Notify","envelope","notify","_tag","IncomingRequest","respond","lastSentReply","none","IncomingEnvelope","request","resume","replyEncoded","message","reply","flatMap","serialize","succeed","zipRight","send","async","resume_","Stream","make","mailbox","as","unsafeOffer","Envelope","layer","spanPrefix","disableTracing","pipe","provide","layerWithClients","provideMerge","layerRpc","layerClientRpc","layerClientOnly","layerNoop","updateService","config","runnerAddress"],"sources":["../../src/RunnerServer.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/esm/Runners.js b/dist/esm/Runners.js
new file mode 100644
index 0000000000000000000000000000000000000000..621cf04de552fe91626a87dd068e2021dd2479db
--- /dev/null
+++ b/dist/esm/Runners.js
@@ -0,0 +1,328 @@
+/**
+ * @since 1.0.0
+ */
+import * as Rpc from "@effect/rpc/Rpc";
+import * as RpcClient_ from "@effect/rpc/RpcClient";
+import * as RpcGroup from "@effect/rpc/RpcGroup";
+import * as RpcSchema from "@effect/rpc/RpcSchema";
+import * as Cause from "effect/Cause";
+import * as Context from "effect/Context";
+import * as Effect from "effect/Effect";
+import * as Exit from "effect/Exit";
+import * as FiberRef from "effect/FiberRef";
+import * as Layer from "effect/Layer";
+import * as RcMap from "effect/RcMap";
+import * as Schema from "effect/Schema";
+import { AlreadyProcessingMessage, EntityNotManagedByRunner, MailboxFull, PersistenceError, RunnerUnavailable } from "./ClusterError.js";
+import { Persisted } from "./ClusterSchema.js";
+import * as Envelope from "./Envelope.js";
+import * as Message from "./Message.js";
+import * as MessageStorage from "./MessageStorage.js";
+import * as Reply from "./Reply.js";
+import { ShardingConfig } from "./ShardingConfig.js";
+import * as Snowflake from "./Snowflake.js";
+/**
+ * @since 1.0.0
+ * @category context
+ */
+export class Runners extends /*#__PURE__*/Context.Tag("@effect/cluster/Runners")() {}
+/**
+ * @since 1.0.0
+ * @category Constructors
+ */
+export const make = /*#__PURE__*/Effect.fnUntraced(function* (options) {
+  const storage = yield* MessageStorage.MessageStorage;
+  const snowflakeGen = yield* Snowflake.Generator;
+  const config = yield* ShardingConfig;
+  const requestIdRewrites = new Map();
+  function notifyWith(message, afterPersist) {
+    const rpc = message.rpc;
+    const persisted = Context.get(rpc.annotations, Persisted);
+    if (!persisted) {
+      return Effect.dieMessage("Runners.notify only supports persisted messages");
+    }
+    if (message._tag === "OutgoingEnvelope") {
+      const rewriteId = requestIdRewrites.get(message.envelope.requestId);
+      const requestId = rewriteId ?? message.envelope.requestId;
+      const entry = storageRequests.get(requestId);
+      if (rewriteId) {
+        message = new Message.OutgoingEnvelope({
+          ...message,
+          envelope: message.envelope.withRequestId(rewriteId)
+        });
+      }
+      return storage.saveEnvelope(message).pipe(Effect.orDie, Effect.zipRight(entry ? Effect.zipRight(entry.latch.open, afterPersist(message, false)) : afterPersist(message, false)));
+    }
+    // For requests, after persisting the request, we need to check if the
+    // request is a duplicate. If it is, we need to resume from the last
+    // received reply.
+    //
+    // Otherwise, we notify the remote entity and then reply from storage.
+    return Effect.flatMap(Effect.orDie(storage.saveRequest(message)), MessageStorage.SaveResult.$match({
+      Success: () => afterPersist(message, false),
+      Duplicate: ({
+        lastReceivedReply,
+        originalId
+      }) => {
+        requestIdRewrites.set(message.envelope.requestId, originalId);
+        return afterPersist(new Message.OutgoingRequest({
+          ...message,
+          lastReceivedReply,
+          envelope: Envelope.makeRequest({
+            ...message.envelope,
+            requestId: originalId
+          }),
+          respond(reply) {
+            if (reply._tag === "WithExit") {
+              requestIdRewrites.delete(message.envelope.requestId);
+            }
+            return message.respond(reply.withRequestId(message.envelope.requestId));
+          }
+        }), true);
+      }
+    }));
+  }
+  const storageRequests = new Map();
+  const waitingStorageRequests = new Map();
+  const replyFromStorage = Effect.fnUntraced(function* (message) {
+    const entry = {
+      latch: Effect.unsafeMakeLatch(false),
+      replies: []
+    };
+    storageRequests.set(message.envelope.requestId, entry);
+    while (true) {
+      // wait for the storage loop to notify us
+      entry.latch.unsafeClose();
+      waitingStorageRequests.set(message.envelope.requestId, message);
+      yield* storageLatch.open;
+      yield* entry.latch.await;
+      // send the replies back
+      for (const reply of entry.replies) {
+        // we have reached the end
+        if (reply._tag === "WithExit") {
+          return yield* message.respond(reply);
+        }
+        entry.latch.unsafeClose();
+        yield* message.respond(reply);
+        yield* entry.latch.await;
+      }
+      entry.replies = [];
+    }
+  }, (effect, message) => Effect.ensuring(effect, Effect.sync(() => {
+    storageRequests.delete(message.envelope.requestId);
+    waitingStorageRequests.delete(message.envelope.requestId);
+  })));
+  const storageLatch = Effect.unsafeMakeLatch(false);
+  if (storage !== MessageStorage.noop) {
+    yield* Effect.gen(function* () {
+      while (true) {
+        yield* storageLatch.await;
+        storageLatch.unsafeClose();
+        const replies = yield* storage.repliesFor(waitingStorageRequests.values()).pipe(Effect.catchAllCause(cause => Effect.as(Effect.annotateLogs(Effect.logDebug(cause), {
+          package: "@effect/cluster",
+          module: "Runners",
+          fiber: "Read replies loop"
+        }), [])));
+        const foundRequests = new Set();
+        // put the replies into the storage requests and then open the latches
+        for (const reply of replies) {
+          const entry = storageRequests.get(reply.requestId);
+          if (!entry) continue;
+          entry.replies.push(reply);
+          waitingStorageRequests.delete(reply.requestId);
+          foundRequests.add(entry);
+        }
+        for (const entry of foundRequests) {
+          entry.latch.unsafeOpen();
+        }
+      }
+    }).pipe(Effect.interruptible, Effect.forkScoped);
+    yield* Effect.suspend(() => {
+      if (waitingStorageRequests.size === 0) {
+        return storageLatch.await;
+      }
+      return storageLatch.open;
+    }).pipe(Effect.delay(config.entityReplyPollInterval), Effect.forever, Effect.interruptible, Effect.forkScoped);
+  }
+  return Runners.of({
+    ...options,
+    sendLocal(options) {
+      const message = options.message;
+      if (!options.simulateRemoteSerialization) {
+        return options.send(Message.incomingLocalFromOutgoing(message));
+      }
+      return Message.serialize(message).pipe(Effect.flatMap(encoded => Message.deserializeLocal(message, encoded)), Effect.flatMap(options.send), Effect.catchTag("MalformedMessage", error => {
+        if (message._tag === "OutgoingEnvelope") {
+          return Effect.die(error);
+        }
+        return Effect.orDie(message.respond(new Reply.WithExit({
+          id: snowflakeGen.unsafeNext(),
+          requestId: message.envelope.requestId,
+          exit: Exit.die(error)
+        })));
+      }));
+    },
+    notify(options_) {
+      const {
+        discard,
+        message
+      } = options_;
+      return notifyWith(message, message => {
+        if (message._tag === "OutgoingEnvelope") {
+          return options.notify(options_);
+        }
+        return discard ? options.notify(options_) : options.notify(options_).pipe(Effect.fork, Effect.andThen(Effect.orDie(replyFromStorage(message))));
+      });
+    },
+    notifyLocal(options) {
+      return notifyWith(options.message, (message, duplicate) => {
+        if (options.discard || message._tag === "OutgoingEnvelope") {
+          return Effect.orDie(options.notify(Message.incomingLocalFromOutgoing(message)));
+        } else if (!duplicate) {
+          return storage.registerReplyHandler(message).pipe(Effect.andThen(Effect.orDie(options.notify(Message.incomingLocalFromOutgoing(message)))));
+        }
+        return Effect.orDie(options.notify(Message.incomingLocalFromOutgoing(message))).pipe(Effect.fork, Effect.andThen(Effect.orDie(replyFromStorage(message))));
+      });
+    }
+  });
+});
+/**
+ * @since 1.0.0
+ * @category No-op
+ */
+export const makeNoop = /*#__PURE__*/make({
+  send: ({
+    message
+  }) => Effect.fail(new EntityNotManagedByRunner({
+    address: message.envelope.address
+  })),
+  notify: () => Effect.void,
+  ping: () => Effect.void
+});
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layerNoop = /*#__PURE__*/Layer.scoped(Runners, makeNoop).pipe( /*#__PURE__*/Layer.provide([Snowflake.layerGenerator]));
+const rpcErrors = /*#__PURE__*/Schema.Union(EntityNotManagedByRunner, MailboxFull, AlreadyProcessingMessage, PersistenceError);
+/**
+ * @since 1.0.0
+ * @category Rpcs
+ */
+export class Rpcs extends /*#__PURE__*/RpcGroup.make( /*#__PURE__*/Rpc.make("Ping"), /*#__PURE__*/Rpc.make("Notify", {
+  payload: {
+    envelope: Envelope.PartialEncoded
+  },
+  success: Schema.Void,
+  error: EntityNotManagedByRunner
+}), /*#__PURE__*/Rpc.make("Effect", {
+  payload: {
+    request: Envelope.PartialEncodedRequest
+  },
+  success: Schema.Object,
+  error: rpcErrors
+}), /*#__PURE__*/Rpc.make("Stream", {
+  payload: {
+    request: Envelope.PartialEncodedRequest
+  },
+  error: rpcErrors,
+  success: Schema.Object,
+  stream: true
+}), /*#__PURE__*/Rpc.make("Envelope", {
+  payload: {
+    envelope: /*#__PURE__*/Schema.Union(Envelope.AckChunk, Envelope.Interrupt)
+  },
+  error: rpcErrors
+})) {}
+/**
+ * @since 1.0.0
+ * @category Rpcs
+ */
+export const makeRpcClient = /*#__PURE__*/RpcClient_.make(Rpcs, {
+  spanPrefix: "Runners",
+  disableTracing: true
+});
+/**
+ * @since 1.0.0
+ * @category constructors
+ */
+export const makeRpc = /*#__PURE__*/Effect.gen(function* () {
+  const makeClientProtocol = yield* RpcClientProtocol;
+  const snowflakeGen = yield* Snowflake.Generator;
+  const clients = yield* RcMap.make({
+    lookup: address => Effect.flatMap(makeClientProtocol(address), protocol => Effect.provideService(makeRpcClient, RpcClient_.Protocol, protocol)),
+    idleTimeToLive: "1 minute"
+  });
+  return yield* make({
+    ping(address) {
+      return RcMap.get(clients, address).pipe(Effect.flatMap(client => client.Ping()), Effect.catchAllCause(() => Effect.fail(new RunnerUnavailable({
+        address
+      }))), Effect.scoped);
+    },
+    send({
+      address,
+      message
+    }) {
+      if (message._tag === "OutgoingEnvelope") {
+        return RcMap.get(clients, address).pipe(Effect.flatMap(client => client.Envelope({
+          envelope: message.envelope
+        })), Effect.scoped, Effect.catchAllDefect(() => Effect.fail(new RunnerUnavailable({
+          address
+        }))));
+      }
+      const rpc = message.rpc;
+      const isStream = RpcSchema.isStreamSchema(rpc.successSchema);
+      if (!isStream) {
+        return Effect.matchEffect(Message.serializeRequest(message), {
+          onSuccess: request => RcMap.get(clients, address).pipe(Effect.flatMap(client => client.Effect({
+            request
+          })), Effect.flatMap(reply => Schema.decode(Reply.Reply(message.rpc))(reply).pipe(Effect.locally(FiberRef.currentContext, message.context), Effect.orDie)), Effect.flatMap(message.respond), Effect.scoped, Effect.catchAllDefect(() => Effect.fail(new RunnerUnavailable({
+            address
+          })))),
+          onFailure: error => message.respond(new Reply.WithExit({
+            id: snowflakeGen.unsafeNext(),
+            requestId: message.envelope.requestId,
+            exit: Exit.die(error)
+          }))
+        });
+      }
+      return Effect.matchEffect(Message.serializeRequest(message), {
+        onSuccess: request => RcMap.get(clients, address).pipe(Effect.flatMap(client => client.Stream({
+          request
+        }, {
+          asMailbox: true
+        })), Effect.flatMap(mailbox => {
+          const decode = Schema.decode(Reply.Reply(message.rpc));
+          return mailbox.take.pipe(Effect.flatMap(reply => Effect.orDie(decode(reply))), Effect.flatMap(message.respond), Effect.forever, Effect.locally(FiberRef.currentContext, message.context), Effect.catchIf(Cause.isNoSuchElementException, () => Effect.void), Effect.catchAllDefect(() => Effect.fail(new RunnerUnavailable({
+            address
+          }))));
+        }), Effect.scoped),
+        onFailure: error => message.respond(new Reply.WithExit({
+          id: snowflakeGen.unsafeNext(),
+          requestId: message.envelope.requestId,
+          exit: Exit.die(error)
+        }))
+      });
+    },
+    notify({
+      address,
+      message
+    }) {
+      const envelope = message.envelope;
+      return RcMap.get(clients, address).pipe(Effect.flatMap(client => client.Notify({
+        envelope
+      })), Effect.scoped, Effect.ignore);
+    }
+  });
+});
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layerRpc = /*#__PURE__*/Layer.scoped(Runners, makeRpc).pipe( /*#__PURE__*/Layer.provide(Snowflake.layerGenerator));
+/**
+ * @since 1.0.0
+ * @category Client
+ */
+export class RpcClientProtocol extends /*#__PURE__*/Context.Tag("@effect/cluster/Runners/RpcClientProtocol")() {}
+//# sourceMappingURL=Runners.js.map
\ No newline at end of file
diff --git a/dist/esm/Runners.js.map b/dist/esm/Runners.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..81b9b74bb2ca01c0860bbedfcb57d051b7f4e319
--- /dev/null
+++ b/dist/esm/Runners.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"Runners.js","names":["Rpc","RpcClient_","RpcGroup","RpcSchema","Cause","Context","Effect","Exit","FiberRef","Layer","RcMap","Schema","AlreadyProcessingMessage","EntityNotManagedByRunner","MailboxFull","PersistenceError","RunnerUnavailable","Persisted","Envelope","Message","MessageStorage","Reply","ShardingConfig","Snowflake","Runners","Tag","make","fnUntraced","options","storage","snowflakeGen","Generator","config","requestIdRewrites","Map","notifyWith","message","afterPersist","rpc","persisted","get","annotations","dieMessage","_tag","rewriteId","envelope","requestId","entry","storageRequests","OutgoingEnvelope","withRequestId","saveEnvelope","pipe","orDie","zipRight","latch","open","flatMap","saveRequest","SaveResult","$match","Success","Duplicate","lastReceivedReply","originalId","set","OutgoingRequest","makeRequest","respond","reply","delete","waitingStorageRequests","replyFromStorage","unsafeMakeLatch","replies","unsafeClose","storageLatch","await","effect","ensuring","sync","noop","gen","repliesFor","values","catchAllCause","cause","as","annotateLogs","logDebug","package","module","fiber","foundRequests","Set","push","add","unsafeOpen","interruptible","forkScoped","suspend","size","delay","entityReplyPollInterval","forever","of","sendLocal","simulateRemoteSerialization","send","incomingLocalFromOutgoing","serialize","encoded","deserializeLocal","catchTag","error","die","WithExit","id","unsafeNext","exit","notify","options_","discard","fork","andThen","notifyLocal","duplicate","registerReplyHandler","makeNoop","fail","address","void","ping","layerNoop","scoped","provide","layerGenerator","rpcErrors","Union","Rpcs","payload","PartialEncoded","success","Void","request","PartialEncodedRequest","Object","stream","AckChunk","Interrupt","makeRpcClient","spanPrefix","disableTracing","makeRpc","makeClientProtocol","RpcClientProtocol","clients","lookup","protocol","provideService","Protocol","idleTimeToLive","client","Ping","catchAllDefect","isStream","isStreamSchema","successSchema","matchEffect","serializeRequest","onSuccess","decode","locally","currentContext","context","onFailure","Stream","asMailbox","mailbox","take","catchIf","isNoSuchElementException","Notify","ignore","layerRpc"],"sources":["../../src/Runners.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/esm/ShardId.js b/dist/esm/ShardId.js
index 49eb3825e389562fdb105290d89762cdbd02fc62..96b376c4ca9d1b04cd88995a081d43547914cf7c 100644
--- a/dist/esm/ShardId.js
+++ b/dist/esm/ShardId.js
@@ -2,53 +2,16 @@
  * @since 1.0.0
  */
 import * as Schema from "effect/Schema";
-import { TypeIdSchema } from "./internal/utils.js";
-/** @internal */
-const ShardIdSymbolKey = "@effect/cluster/ShardId";
 /**
- * @since 1.0.0
- * @category symbols
- */
-export const ShardIdTypeId = /*#__PURE__*/Symbol.for(ShardIdSymbolKey);
-/** @internal */
-const ShardIdTypeIdSchema = /*#__PURE__*/TypeIdSchema(ShardIdSymbolKey, ShardIdTypeId);
-/**
- * A shard is a logical grouping of multiple entities. There could be thousands of entities in your system,
- * so instead of managing every single entity id, the shard manager group them by shard id, and when they are assigned
- * or moved around, we always move all the entities with the same shard id.
- *
- * @since 1.0.0
- * @category models
- */
-export class ShardId extends /*#__PURE__*/Schema.Class(ShardIdSymbolKey)({
-  [ShardIdTypeId]: /*#__PURE__*/Schema.propertySignature(ShardIdTypeIdSchema).pipe( /*#__PURE__*/Schema.fromKey(ShardIdSymbolKey)),
-  value: Schema.Number
-}) {
-  /**
-   * @since 1.0.0
-   */
-  toString() {
-    return `ShardId(${this.value})`;
-  }
-}
-/**
- * Constructs a shard id from its numerical value.
- * The shard id is currently built up by making the hash of the entity id, and then modulo the max amount of shards configured in ManagerConfig.
- *
  * @since 1.0.0
  * @category constructors
  */
-export function make(value) {
-  return new ShardId({
-    [ShardIdTypeId]: ShardIdTypeId,
-    value
-  });
-}
+export const ShardId = /*#__PURE__*/Schema.Int.pipe( /*#__PURE__*/Schema.brand("ShardId"), /*#__PURE__*/Schema.annotations({
+  pretty: () => shardId => `ShardId(${shardId})`
+}));
 /**
- * This is the schema for a ShardId.
- *
  * @since 1.0.0
- * @category schema
+ * @category Constructors
  */
-export const schema = /*#__PURE__*/Schema.asSchema(ShardId);
+export const make = shardId => ShardId.make(shardId);
 //# sourceMappingURL=ShardId.js.map
\ No newline at end of file
diff --git a/dist/esm/ShardId.js.map b/dist/esm/ShardId.js.map
index d278cfb5d1ec410da122d0000f6a1ae1aa8896d9..2da6d178ba273d761cb46e4d67075fee140a520f 100644
--- a/dist/esm/ShardId.js.map
+++ b/dist/esm/ShardId.js.map
@@ -1 +1 @@
-{"version":3,"file":"ShardId.js","names":["Schema","TypeIdSchema","ShardIdSymbolKey","ShardIdTypeId","Symbol","for","ShardIdTypeIdSchema","ShardId","Class","propertySignature","pipe","fromKey","value","Number","toString","make","schema","asSchema"],"sources":["../../src/ShardId.ts"],"sourcesContent":[null],"mappings":"AAAA;;;AAGA,OAAO,KAAKA,MAAM,MAAM,eAAe;AACvC,SAASC,YAAY,QAAQ,qBAAqB;AAElD;AACA,MAAMC,gBAAgB,GAAG,yBAAyB;AAElD;;;;AAIA,OAAO,MAAMC,aAAa,gBAAkBC,MAAM,CAACC,GAAG,CAACH,gBAAgB,CAAC;AAQxE;AACA,MAAMI,mBAAmB,gBAAGL,YAAY,CAACC,gBAAgB,EAAEC,aAAa,CAAC;AAEzE;;;;;;;;AAQA,OAAM,MAAOI,OAAQ,sBAAQP,MAAM,CAACQ,KAAK,CAAUN,gBAAgB,CAAC,CAAC;EACnE,CAACC,aAAa,gBAAGH,MAAM,CAACS,iBAAiB,CAACH,mBAAmB,CAAC,CAACI,IAAI,eAACV,MAAM,CAACW,OAAO,CAACT,gBAAgB,CAAC,CAAC;EACrGU,KAAK,EAAEZ,MAAM,CAACa;CACf,CAAC;EACA;;;EAGAC,QAAQA,CAAA;IACN,OAAO,WAAW,IAAI,CAACF,KAAK,GAAG;EACjC;;AAiBF;;;;;;;AAOA,OAAM,SAAUG,IAAIA,CAACH,KAAa;EAChC,OAAO,IAAIL,OAAO,CAAC;IAAE,CAACJ,aAAa,GAAGA,aAAa;IAAES;EAAK,CAAE,CAAC;AAC/D;AAEA;;;;;;AAMA,OAAO,MAAMI,MAAM,gBAGfhB,MAAM,CAACiB,QAAQ,CAACV,OAAO,CAAC","ignoreList":[]}
\ No newline at end of file
+{"version":3,"file":"ShardId.js","names":["Schema","ShardId","Int","pipe","brand","annotations","pretty","shardId","make"],"sources":["../../src/ShardId.ts"],"sourcesContent":[null],"mappings":"AAAA;;;AAGA,OAAO,KAAKA,MAAM,MAAM,eAAe;AAEvC;;;;AAIA,OAAO,MAAMC,OAAO,gBAAGD,MAAM,CAACE,GAAG,CAACC,IAAI,eACpCH,MAAM,CAACI,KAAK,CAAC,SAAS,CAAC,eACvBJ,MAAM,CAACK,WAAW,CAAC;EACjBC,MAAM,EAAEA,CAAA,KAAOC,OAAO,IAAK,WAAWA,OAAO;CAC9C,CAAC,CACH;AAQD;;;;AAIA,OAAO,MAAMC,IAAI,GAAID,OAAe,IAAcN,OAAO,CAACO,IAAI,CAACD,OAAO,CAAC","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/esm/ShardManager.js b/dist/esm/ShardManager.js
index e0c23bfc6bddd9e62962e53307c9dbd173ea76bb..ffa9a65d0e573e26aadda63219dba7e4025f1b82 100644
--- a/dist/esm/ShardManager.js
+++ b/dist/esm/ShardManager.js
@@ -1,17 +1,496 @@
-import * as internal from "./internal/shardManager.js";
 /**
  * @since 1.0.0
- * @category symbols
  */
-export const ShardManagerTypeId = internal.ShardManagerTypeId;
+import * as Rpc from "@effect/rpc/Rpc";
+import * as RpcClient from "@effect/rpc/RpcClient";
+import * as RpcGroup from "@effect/rpc/RpcGroup";
+import * as RpcServer from "@effect/rpc/RpcServer";
+import * as Arr from "effect/Array";
+import * as Clock from "effect/Clock";
+import * as Config_ from "effect/Config";
+import * as ConfigProvider from "effect/ConfigProvider";
+import * as Context from "effect/Context";
+import * as Data from "effect/Data";
+import * as Deferred from "effect/Deferred";
+import * as Duration from "effect/Duration";
+import * as Effect from "effect/Effect";
+import * as Equal from "effect/Equal";
+import * as FiberSet from "effect/FiberSet";
+import { identity } from "effect/Function";
+import * as Iterable from "effect/Iterable";
+import * as Layer from "effect/Layer";
+import * as Mailbox from "effect/Mailbox";
+import * as Metric from "effect/Metric";
+import * as MutableHashMap from "effect/MutableHashMap";
+import * as MutableHashSet from "effect/MutableHashSet";
+import * as Option from "effect/Option";
+import * as PubSub from "effect/PubSub";
+import * as Queue from "effect/Queue";
+import * as Schedule from "effect/Schedule";
+import * as Schema from "effect/Schema";
+import { RunnerNotRegistered } from "./ClusterError.js";
+import * as ClusterMetrics from "./ClusterMetrics.js";
+import { decideAssignmentsForUnassignedShards, decideAssignmentsForUnbalancedShards, RunnerWithMetadata, State } from "./internal/shardManager.js";
+import * as MachineId from "./MachineId.js";
+import { Runner } from "./Runner.js";
+import { RunnerAddress } from "./RunnerAddress.js";
+import { RunnerHealth } from "./RunnerHealth.js";
+import { RpcClientProtocol, Runners } from "./Runners.js";
+import { ShardId } from "./ShardId.js";
+import { ShardingConfig } from "./ShardingConfig.js";
+import { ShardStorage } from "./ShardStorage.js";
 /**
  * @since 1.0.0
- * @category context
+ * @category models
  */
-export const ShardManager = internal.shardManagerTag;
+export class ShardManager extends /*#__PURE__*/Context.Tag("@effect/cluster/ShardManager")() {}
 /**
  * @since 1.0.0
- * @category layers
+ * @category Config
  */
-export const live = internal.live;
+export class Config extends /*#__PURE__*/Context.Tag("@effect/cluster/ShardManager/Config")() {
+  /**
+   * @since 1.0.0
+   */
+  static defaults = {
+    rebalanceDebounce: /*#__PURE__*/Duration.millis(500),
+    rebalanceInterval: /*#__PURE__*/Duration.seconds(20),
+    rebalanceRetryInterval: /*#__PURE__*/Duration.seconds(10),
+    rebalanceRate: 2 / 100,
+    persistRetryCount: 100,
+    persistRetryInterval: /*#__PURE__*/Duration.seconds(3),
+    runnerHealthCheckInterval: /*#__PURE__*/Duration.minutes(1),
+    runnerPingTimeout: /*#__PURE__*/Duration.seconds(3)
+  };
+}
+/**
+ * @since 1.0.0
+ * @category Config
+ */
+export const configConfig = /*#__PURE__*/Config_.all({
+  rebalanceDebounce: /*#__PURE__*/Config_.duration("rebalanceDebounce").pipe( /*#__PURE__*/Config_.withDefault(Config.defaults.rebalanceDebounce), /*#__PURE__*/Config_.withDescription("The duration to wait before rebalancing shards after a change.")),
+  rebalanceInterval: /*#__PURE__*/Config_.duration("rebalanceInterval").pipe( /*#__PURE__*/Config_.withDefault(Config.defaults.rebalanceInterval), /*#__PURE__*/Config_.withDescription("The interval on which regular rebalancing of shards will occur.")),
+  rebalanceRetryInterval: /*#__PURE__*/Config_.duration("rebalanceRetryInterval").pipe( /*#__PURE__*/Config_.withDefault(Config.defaults.rebalanceRetryInterval), /*#__PURE__*/Config_.withDescription("The interval on which rebalancing of shards which failed to be rebalanced will be retried.")),
+  rebalanceRate: /*#__PURE__*/Config_.number("rebalanceRate").pipe( /*#__PURE__*/Config_.withDefault(Config.defaults.rebalanceRate), /*#__PURE__*/Config_.withDescription("The maximum ratio of shards to rebalance at once.")),
+  persistRetryCount: /*#__PURE__*/Config_.integer("persistRetryCount").pipe( /*#__PURE__*/Config_.withDefault(Config.defaults.persistRetryCount), /*#__PURE__*/Config_.withDescription("The number of times persistence of runners will be retried if it fails.")),
+  persistRetryInterval: /*#__PURE__*/Config_.duration("persistRetryInterval").pipe( /*#__PURE__*/Config_.withDefault(Config.defaults.persistRetryInterval), /*#__PURE__*/Config_.withDescription("The interval on which persistence of runners will be retried if it fails.")),
+  runnerHealthCheckInterval: /*#__PURE__*/Config_.duration("runnerHealthCheckInterval").pipe( /*#__PURE__*/Config_.withDefault(Config.defaults.runnerHealthCheckInterval), /*#__PURE__*/Config_.withDescription("The interval on which runner health will be checked.")),
+  runnerPingTimeout: /*#__PURE__*/Config_.duration("runnerPingTimeout").pipe( /*#__PURE__*/Config_.withDefault(Config.defaults.runnerPingTimeout), /*#__PURE__*/Config_.withDescription("The length of time to wait for a runner to respond to a ping."))
+});
+/**
+ * @since 1.0.0
+ * @category Config
+ */
+export const configFromEnv = /*#__PURE__*/configConfig.pipe( /*#__PURE__*/Effect.withConfigProvider( /*#__PURE__*/ConfigProvider.fromEnv().pipe(ConfigProvider.constantCase)));
+/**
+ * @since 1.0.0
+ * @category Config
+ */
+export const layerConfig = config => Layer.succeed(Config, {
+  ...Config.defaults,
+  ...config
+});
+/**
+ * @since 1.0.0
+ * @category Config
+ */
+export const layerConfigFromEnv = /*#__PURE__*/Layer.effect(Config, configFromEnv);
+/**
+ * Represents a client which can be used to communicate with the
+ * `ShardManager`.
+ *
+ * @since 1.0.0
+ * @category Client
+ */
+export class ShardManagerClient extends /*#__PURE__*/Context.Tag("@effect/cluster/ShardManager/ShardManagerClient")() {}
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export const ShardingEventSchema = /*#__PURE__*/Schema.Union( /*#__PURE__*/Schema.TaggedStruct("StreamStarted", {}), /*#__PURE__*/Schema.TaggedStruct("ShardsAssigned", {
+  address: RunnerAddress,
+  shards: /*#__PURE__*/Schema.Array(ShardId)
+}), /*#__PURE__*/Schema.TaggedStruct("ShardsUnassigned", {
+  address: RunnerAddress,
+  shards: /*#__PURE__*/Schema.Array(ShardId)
+}), /*#__PURE__*/Schema.TaggedStruct("RunnerRegistered", {
+  address: RunnerAddress
+}), /*#__PURE__*/Schema.TaggedStruct("RunnerUnregistered", {
+  address: RunnerAddress
+}));
+/**
+ * The messaging protocol for the `ShardManager`.
+ *
+ * @since 1.0.0
+ * @category Rpcs
+ */
+export class Rpcs extends /*#__PURE__*/RpcGroup.make( /*#__PURE__*/Rpc.make("Register", {
+  payload: {
+    runner: Runner
+  },
+  success: MachineId.MachineId
+}), /*#__PURE__*/Rpc.make("Unregister", {
+  payload: {
+    address: RunnerAddress
+  }
+}), /*#__PURE__*/Rpc.make("NotifyUnhealthyRunner", {
+  payload: {
+    address: RunnerAddress
+  }
+}), /*#__PURE__*/Rpc.make("GetAssignments", {
+  success: /*#__PURE__*/Schema.ReadonlyMap({
+    key: ShardId,
+    value: /*#__PURE__*/Schema.Option(RunnerAddress)
+  })
+}), /*#__PURE__*/Rpc.make("ShardingEvents", {
+  success: ShardingEventSchema,
+  stream: true
+}), /*#__PURE__*/Rpc.make("GetTime", {
+  success: Schema.Number
+})) {}
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export const ShardingEvent = /*#__PURE__*/Data.taggedEnum();
+/**
+ * @since 1.0.0
+ * @category Client
+ */
+export const makeClientLocal = /*#__PURE__*/Effect.gen(function* () {
+  const runnerAddress = yield* ShardingConfig;
+  const clock = yield* Effect.clock;
+  const shards = new Map();
+  for (let n = 1; n <= runnerAddress.numberOfShards; n++) {
+    shards.set(ShardId.make(n), runnerAddress.runnerAddress);
+  }
+  let machineId = 0;
+  return ShardManagerClient.of({
+    register: () => Effect.sync(() => MachineId.make(++machineId)),
+    unregister: () => Effect.void,
+    notifyUnhealthyRunner: () => Effect.void,
+    getAssignments: Effect.succeed(shards),
+    shardingEvents: Effect.gen(function* () {
+      const mailbox = yield* Mailbox.make();
+      yield* mailbox.offer(ShardingEvent.StreamStarted());
+      return mailbox;
+    }),
+    getTime: clock.currentTimeMillis
+  });
+});
+/**
+ * @since 1.0.0
+ * @category Client
+ */
+export const makeClientRpc = /*#__PURE__*/Effect.gen(function* () {
+  const config = yield* ShardingConfig;
+  const client = yield* RpcClient.make(Rpcs, {
+    spanPrefix: "ShardManagerClient",
+    disableTracing: true
+  });
+  return ShardManagerClient.of({
+    register: address => client.Register({
+      runner: Runner.make({
+        address,
+        version: config.serverVersion
+      })
+    }),
+    unregister: address => client.Unregister({
+      address
+    }),
+    notifyUnhealthyRunner: address => client.NotifyUnhealthyRunner({
+      address
+    }),
+    getAssignments: client.GetAssignments(),
+    shardingEvents: client.ShardingEvents({}, {
+      asMailbox: true
+    }),
+    getTime: client.GetTime()
+  });
+});
+/**
+ * @since 1.0.0
+ * @category Client
+ */
+export const layerClientLocal = /*#__PURE__*/Layer.effect(ShardManagerClient, makeClientLocal);
+/**
+ * @since 1.0.0
+ * @category Client
+ */
+export const layerClientRpc = /*#__PURE__*/Layer.scoped(ShardManagerClient, makeClientRpc).pipe( /*#__PURE__*/Layer.provide( /*#__PURE__*/Layer.scoped(RpcClient.Protocol, /*#__PURE__*/Effect.gen(function* () {
+  const config = yield* ShardingConfig;
+  const clientProtocol = yield* RpcClientProtocol;
+  return yield* clientProtocol(config.shardManagerAddress);
+}))));
+/**
+ * @since 1.0.0
+ * @category Constructors
+ */
+export const make = /*#__PURE__*/Effect.gen(function* () {
+  const storage = yield* ShardStorage;
+  const runnersApi = yield* Runners;
+  const runnerHealthApi = yield* RunnerHealth;
+  const clock = yield* Effect.clock;
+  const config = yield* Config;
+  const shardingConfig = yield* ShardingConfig;
+  const state = yield* Effect.orDie(State.fromStorage(shardingConfig.numberOfShards));
+  const scope = yield* Effect.scope;
+  const events = yield* PubSub.unbounded();
+  yield* Metric.incrementBy(ClusterMetrics.runners, MutableHashMap.size(state.runners));
+  for (const address of state.shards.values()) {
+    const metric = Option.isSome(address) ? Metric.tagged(ClusterMetrics.assignedShards, "address", address.toString()) : ClusterMetrics.unassignedShards;
+    yield* Metric.increment(metric);
+  }
+  function withRetry(effect) {
+    return effect.pipe(Effect.retry({
+      schedule: Schedule.spaced(config.persistRetryCount),
+      times: config.persistRetryCount
+    }), Effect.ignore);
+  }
+  const persistRunners = Effect.unsafeMakeSemaphore(1).withPermits(1)(withRetry(Effect.suspend(() => storage.saveRunners(Iterable.map(state.runners, ([address, runner]) => [address, runner.runner])))));
+  const persistAssignments = Effect.unsafeMakeSemaphore(1).withPermits(1)(withRetry(Effect.suspend(() => storage.saveAssignments(state.shards))));
+  const notifyUnhealthyRunner = Effect.fnUntraced(function* (address) {
+    if (!MutableHashMap.has(state.runners, address)) return;
+    yield* Metric.increment(Metric.tagged(ClusterMetrics.runnerHealthChecked, "runner_address", address.toString()));
+    if (!(yield* runnerHealthApi.isAlive(address))) {
+      yield* Effect.logWarning(`Runner at address '${address.toString()}' is not alive`);
+      yield* unregister(address);
+    }
+  });
+  function updateShardsState(shards, address) {
+    return Effect.suspend(() => {
+      if (Option.isSome(address) && !MutableHashMap.has(state.runners, address.value)) {
+        return Effect.fail(new RunnerNotRegistered({
+          address: address.value
+        }));
+      }
+      for (const shardId of shards) {
+        if (!state.shards.has(shardId)) continue;
+        state.shards.set(shardId, address);
+      }
+      return Effect.void;
+    });
+  }
+  const getAssignments = Effect.sync(() => state.shards);
+  let machineId = 0;
+  const register = Effect.fnUntraced(function* (runner) {
+    yield* Effect.logInfo(`Registering runner ${Runner.pretty(runner)}`);
+    const now = clock.unsafeCurrentTimeMillis();
+    MutableHashMap.set(state.runners, runner.address, RunnerWithMetadata({
+      runner,
+      registeredAt: now
+    }));
+    yield* Metric.increment(ClusterMetrics.runners);
+    yield* PubSub.publish(events, ShardingEvent.RunnerRegistered({
+      address: runner.address
+    }));
+    if (state.unassignedShards.length > 0) {
+      yield* rebalance(false);
+    }
+    yield* Effect.forkIn(persistRunners, scope);
+    return MachineId.make(++machineId);
+  });
+  const unregister = Effect.fnUntraced(function* (address) {
+    if (!MutableHashMap.has(state.runners, address)) return;
+    yield* Effect.logInfo("Unregistering runner at address:", address);
+    const unassignments = Arr.empty();
+    for (const [shard, runner] of state.shards) {
+      if (Option.isSome(runner) && Equal.equals(runner.value, address)) {
+        unassignments.push(shard);
+        state.shards.set(shard, Option.none());
+      }
+    }
+    MutableHashMap.remove(state.runners, address);
+    yield* Metric.incrementBy(ClusterMetrics.runners, -1);
+    if (unassignments.length > 0) {
+      yield* Metric.incrementBy(Metric.tagged(ClusterMetrics.unassignedShards, "runner_address", address.toString()), unassignments.length);
+      yield* PubSub.publish(events, ShardingEvent.RunnerUnregistered({
+        address
+      }));
+    }
+    yield* Effect.forkIn(persistRunners, scope);
+    yield* Effect.forkIn(rebalance(true), scope);
+  });
+  let rebalancing = false;
+  let nextRebalanceImmediate = false;
+  let rebalanceDeferred;
+  const rebalanceFibers = yield* FiberSet.make();
+  const rebalance = immmediate => Effect.withFiberRuntime(fiber => {
+    if (!rebalancing) {
+      rebalancing = true;
+      return rebalanceLoop(immmediate);
+    }
+    if (immmediate) {
+      nextRebalanceImmediate = true;
+    }
+    if (!rebalanceDeferred) {
+      rebalanceDeferred = Deferred.unsafeMake(fiber.id());
+    }
+    return Deferred.await(rebalanceDeferred);
+  });
+  const rebalanceLoop = immediate => Effect.suspend(() => {
+    const deferred = rebalanceDeferred;
+    rebalanceDeferred = undefined;
+    if (!immediate) {
+      immediate = nextRebalanceImmediate;
+      nextRebalanceImmediate = false;
+    }
+    return runRebalance(immediate).pipe(deferred ? Effect.intoDeferred(deferred) : identity, Effect.onExit(() => {
+      if (!rebalanceDeferred) {
+        rebalancing = false;
+        return Effect.void;
+      }
+      return Effect.forkIn(rebalanceLoop(), scope);
+    }));
+  });
+  const runRebalance = Effect.fn("ShardManager.rebalance")(function* (immediate) {
+    yield* Effect.annotateCurrentSpan("immmediate", immediate);
+    yield* Effect.sleep(config.rebalanceDebounce);
+    // Determine which shards to assign and unassign
+    const [assignments, unassignments, changes] = immediate || state.unassignedShards.length > 0 ? decideAssignmentsForUnassignedShards(state) : decideAssignmentsForUnbalancedShards(state, config.rebalanceRate);
+    yield* Effect.logDebug(`Rebalancing shards (immediate = ${immediate})`);
+    if (MutableHashSet.size(changes) === 0) return;
+    yield* Metric.increment(ClusterMetrics.rebalances);
+    // Ping runners first and remove unhealthy ones
+    const failedRunners = MutableHashSet.empty();
+    for (const address of changes) {
+      yield* FiberSet.run(rebalanceFibers, runnersApi.ping(address).pipe(Effect.timeout(config.runnerPingTimeout), Effect.catchAll(() => {
+        MutableHashSet.add(failedRunners, address);
+        MutableHashMap.remove(assignments, address);
+        MutableHashMap.remove(unassignments, address);
+        return Effect.void;
+      })));
+    }
+    yield* FiberSet.awaitEmpty(rebalanceFibers);
+    const failedUnassignments = new Set();
+    for (const [address, shards] of unassignments) {
+      yield* FiberSet.run(rebalanceFibers, updateShardsState(shards, Option.none()).pipe(Effect.matchEffect({
+        onFailure: () => {
+          MutableHashSet.add(failedRunners, address);
+          for (const shard of shards) {
+            failedUnassignments.add(shard);
+          }
+          // Remove failed runners from the assignments
+          MutableHashMap.remove(assignments, address);
+          return Effect.void;
+        },
+        onSuccess: () => {
+          const shardCount = shards.size;
+          return Metric.incrementBy(Metric.tagged(ClusterMetrics.assignedShards, "runner_address", address.toString()), -shardCount).pipe(Effect.zipRight(Metric.incrementBy(ClusterMetrics.unassignedShards, shardCount)), Effect.zipRight(PubSub.publish(events, ShardingEvent.ShardsUnassigned({
+            address,
+            shards: Array.from(shards)
+          }))));
+        }
+      })));
+    }
+    yield* FiberSet.awaitEmpty(rebalanceFibers);
+    // Remove failed shard unassignments from the assignments
+    MutableHashMap.forEach(assignments, (shards, address) => {
+      for (const shard of failedUnassignments) {
+        shards.delete(shard);
+      }
+      if (shards.size === 0) {
+        MutableHashMap.remove(assignments, address);
+      }
+    });
+    // Perform the assignments
+    for (const [address, shards] of assignments) {
+      yield* FiberSet.run(rebalanceFibers, updateShardsState(shards, Option.some(address)).pipe(Effect.matchEffect({
+        onFailure: () => {
+          MutableHashSet.add(failedRunners, address);
+          return Effect.void;
+        },
+        onSuccess: () => {
+          const shardCount = shards.size;
+          return Metric.incrementBy(Metric.tagged(ClusterMetrics.assignedShards, "runner_address", address.toString()), -shardCount).pipe(Effect.zipRight(Metric.incrementBy(ClusterMetrics.unassignedShards, -shardCount)), Effect.zipRight(PubSub.publish(events, ShardingEvent.ShardsAssigned({
+            address,
+            shards: Array.from(shards)
+          }))));
+        }
+      })));
+    }
+    yield* FiberSet.awaitEmpty(rebalanceFibers);
+    const wereFailures = MutableHashSet.size(failedRunners) > 0;
+    if (wereFailures) {
+      // Check if the failing runners are still reachable
+      yield* Effect.forEach(failedRunners, notifyUnhealthyRunner, {
+        discard: true
+      }).pipe(Effect.forkIn(scope));
+      yield* Effect.logWarning("Failed to rebalance runners: ", failedRunners);
+    }
+    if (wereFailures && immediate) {
+      // Try rebalancing again later if there were any failures
+      yield* Clock.sleep(config.rebalanceRetryInterval).pipe(Effect.zipRight(rebalance(immediate)), Effect.forkIn(scope));
+    }
+    yield* persistAssignments;
+  });
+  const checkRunnerHealth = Effect.suspend(() => Effect.forEach(MutableHashMap.keys(state.runners), notifyUnhealthyRunner, {
+    concurrency: "inherit",
+    discard: true
+  })).pipe(Effect.withConcurrency(4), Effect.asVoid);
+  yield* Effect.addFinalizer(() => persistAssignments.pipe(Effect.catchAllCause(cause => Effect.logWarning("Failed to persist assignments on shutdown", cause)), Effect.zipRight(persistRunners.pipe(Effect.catchAllCause(cause => Effect.logWarning("Failed to persist runners on shutdown", cause))))));
+  yield* Effect.forkIn(persistRunners, scope);
+  // Rebalance immediately if there are unassigned shards
+  yield* Effect.forkIn(rebalance(state.unassignedShards.length > 0), scope);
+  // Start a regular cluster rebalance at the configured interval
+  yield* rebalance(false).pipe(Effect.andThen(Effect.sleep(config.rebalanceInterval)), Effect.forever, Effect.forkIn(scope));
+  yield* checkRunnerHealth.pipe(Effect.andThen(Effect.sleep(config.runnerHealthCheckInterval)), Effect.forever, Effect.forkIn(scope));
+  yield* Effect.gen(function* () {
+    const queue = yield* PubSub.subscribe(events);
+    while (true) {
+      yield* Effect.logInfo("Shard manager event:", yield* Queue.take(queue));
+    }
+  }).pipe(Effect.forkIn(scope));
+  yield* Effect.logInfo("Shard manager initialized");
+  return ShardManager.of({
+    getAssignments,
+    shardingEvents: PubSub.subscribe(events),
+    register,
+    unregister,
+    rebalance,
+    notifyUnhealthyRunner,
+    checkRunnerHealth
+  });
+});
+/**
+ * @since 1.0.0
+ * @category layer
+ */
+export const layer = /*#__PURE__*/Layer.scoped(ShardManager, make);
+/**
+ * @since 1.0.0
+ * @category Server
+ */
+export const layerServerHandlers = /*#__PURE__*/Rpcs.toLayer( /*#__PURE__*/Effect.gen(function* () {
+  const shardManager = yield* ShardManager;
+  const clock = yield* Effect.clock;
+  return {
+    Register: ({
+      runner
+    }) => shardManager.register(runner),
+    Unregister: ({
+      address
+    }) => shardManager.unregister(address),
+    NotifyUnhealthyRunner: ({
+      address
+    }) => shardManager.notifyUnhealthyRunner(address),
+    GetAssignments: () => shardManager.getAssignments,
+    ShardingEvents: Effect.fnUntraced(function* () {
+      const queue = yield* shardManager.shardingEvents;
+      const mailbox = yield* Mailbox.make();
+      yield* mailbox.offer(ShardingEvent.StreamStarted());
+      yield* Queue.takeBetween(queue, 1, Number.MAX_SAFE_INTEGER).pipe(Effect.flatMap(events => mailbox.offerAll(events)), Effect.forever, Effect.forkScoped);
+      return mailbox;
+    }),
+    GetTime: () => clock.currentTimeMillis
+  };
+}));
+/**
+ * @since 1.0.0
+ * @category Server
+ */
+export const layerServer = /*#__PURE__*/RpcServer.layer(Rpcs, {
+  spanPrefix: "ShardManager",
+  disableTracing: true
+}).pipe( /*#__PURE__*/Layer.provide(layerServerHandlers));
 //# sourceMappingURL=ShardManager.js.map
\ No newline at end of file
diff --git a/dist/esm/ShardManager.js.map b/dist/esm/ShardManager.js.map
index 84f235f1e27b663254def67f8f2bbf2afc286568..d6e11851d6eaa53f762f0565ee96a9c63c34335b 100644
--- a/dist/esm/ShardManager.js.map
+++ b/dist/esm/ShardManager.js.map
@@ -1 +1 @@
-{"version":3,"file":"ShardManager.js","names":["internal","ShardManagerTypeId","ShardManager","shardManagerTag","live"],"sources":["../../src/ShardManager.ts"],"sourcesContent":[null],"mappings":"AAOA,OAAO,KAAKA,QAAQ,MAAM,4BAA4B;AAMtD;;;;AAIA,OAAO,MAAMC,kBAAkB,GAAkBD,QAAQ,CAACC,kBAAkB;AAQ5E;;;;AAIA,OAAO,MAAMC,YAAY,GAAGF,QAAQ,CAACG,eAAe;AAmBpD;;;;AAIA,OAAO,MAAMC,IAAI,GAAGJ,QAAQ,CAACI,IAAI","ignoreList":[]}
\ No newline at end of file
+{"version":3,"file":"ShardManager.js","names":["Rpc","RpcClient","RpcGroup","RpcServer","Arr","Clock","Config_","ConfigProvider","Context","Data","Deferred","Duration","Effect","Equal","FiberSet","identity","Iterable","Layer","Mailbox","Metric","MutableHashMap","MutableHashSet","Option","PubSub","Queue","Schedule","Schema","RunnerNotRegistered","ClusterMetrics","decideAssignmentsForUnassignedShards","decideAssignmentsForUnbalancedShards","RunnerWithMetadata","State","MachineId","Runner","RunnerAddress","RunnerHealth","RpcClientProtocol","Runners","ShardId","ShardingConfig","ShardStorage","ShardManager","Tag","Config","defaults","rebalanceDebounce","millis","rebalanceInterval","seconds","rebalanceRetryInterval","rebalanceRate","persistRetryCount","persistRetryInterval","runnerHealthCheckInterval","minutes","runnerPingTimeout","configConfig","all","duration","pipe","withDefault","withDescription","number","integer","configFromEnv","withConfigProvider","fromEnv","constantCase","layerConfig","config","succeed","layerConfigFromEnv","effect","ShardManagerClient","ShardingEventSchema","Union","TaggedStruct","address","shards","Array","Rpcs","make","payload","runner","success","ReadonlyMap","key","value","stream","Number","ShardingEvent","taggedEnum","makeClientLocal","gen","runnerAddress","clock","Map","n","numberOfShards","set","machineId","of","register","sync","unregister","void","notifyUnhealthyRunner","getAssignments","shardingEvents","mailbox","offer","StreamStarted","getTime","currentTimeMillis","makeClientRpc","client","spanPrefix","disableTracing","Register","version","serverVersion","Unregister","NotifyUnhealthyRunner","GetAssignments","ShardingEvents","asMailbox","GetTime","layerClientLocal","layerClientRpc","scoped","provide","Protocol","clientProtocol","shardManagerAddress","storage","runnersApi","runnerHealthApi","shardingConfig","state","orDie","fromStorage","scope","events","unbounded","incrementBy","runners","size","values","metric","isSome","tagged","assignedShards","toString","unassignedShards","increment","withRetry","retry","schedule","spaced","times","ignore","persistRunners","unsafeMakeSemaphore","withPermits","suspend","saveRunners","map","persistAssignments","saveAssignments","fnUntraced","has","runnerHealthChecked","isAlive","logWarning","updateShardsState","fail","shardId","logInfo","pretty","now","unsafeCurrentTimeMillis","registeredAt","publish","RunnerRegistered","length","rebalance","forkIn","unassignments","empty","shard","equals","push","none","remove","RunnerUnregistered","rebalancing","nextRebalanceImmediate","rebalanceDeferred","rebalanceFibers","immmediate","withFiberRuntime","fiber","rebalanceLoop","unsafeMake","id","await","immediate","deferred","undefined","runRebalance","intoDeferred","onExit","fn","annotateCurrentSpan","sleep","assignments","changes","logDebug","rebalances","failedRunners","run","ping","timeout","catchAll","add","awaitEmpty","failedUnassignments","Set","matchEffect","onFailure","onSuccess","shardCount","zipRight","ShardsUnassigned","from","forEach","delete","some","ShardsAssigned","wereFailures","discard","checkRunnerHealth","keys","concurrency","withConcurrency","asVoid","addFinalizer","catchAllCause","cause","andThen","forever","queue","subscribe","take","layer","layerServerHandlers","toLayer","shardManager","takeBetween","MAX_SAFE_INTEGER","flatMap","offerAll","forkScoped","layerServer"],"sources":["../../src/ShardManager.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/esm/ShardStorage.js b/dist/esm/ShardStorage.js
new file mode 100644
index 0000000000000000000000000000000000000000..59434c3b8153302ace43d03b947303dbfe962da1
--- /dev/null
+++ b/dist/esm/ShardStorage.js
@@ -0,0 +1,129 @@
+/**
+ * @since 1.0.0
+ */
+import * as Context from "effect/Context";
+import * as Effect from "effect/Effect";
+import * as Layer from "effect/Layer";
+import * as MutableHashMap from "effect/MutableHashMap";
+import * as Option from "effect/Option";
+import { Runner } from "./Runner.js";
+import { RunnerAddress } from "./RunnerAddress.js";
+import { ShardId } from "./ShardId.js";
+/**
+ * Represents a generic interface to the persistent storage required by the
+ * cluster.
+ *
+ * @since 1.0.0
+ * @category models
+ */
+export class ShardStorage extends /*#__PURE__*/Context.Tag("@effect/cluster/ShardStorage")() {}
+/**
+ * @since 1.0.0
+ * @category layers
+ */
+export const makeEncoded = /*#__PURE__*/Effect.fnUntraced(function* (encoded) {
+  const activeShards = new Set();
+  return ShardStorage.of({
+    getAssignments: Effect.map(encoded.getAssignments, assignments => {
+      const map = new Map();
+      for (const [shardId, runnerAddress] of assignments) {
+        map.set(ShardId.make(shardId), runnerAddress === null ? Option.none() : Option.some(decodeRunnerAddress(runnerAddress)));
+      }
+      return map;
+    }),
+    saveAssignments: assignments => encoded.saveAssignments(Array.from(assignments, ([shardId, runnerAddress]) => [shardId, Option.isNone(runnerAddress) ? null : encodeRunnerAddress(runnerAddress.value)])),
+    getRunners: Effect.gen(function* () {
+      const runners = yield* encoded.getRunners;
+      const results = new Array(runners.length);
+      for (let i = 0; i < runners.length; i++) {
+        const [address, runner] = runners[i];
+        results[i] = [decodeRunnerAddress(address), Runner.decodeSync(runner)];
+      }
+      return results;
+    }),
+    saveRunners: runners => Effect.suspend(() => encoded.saveRunners(Array.from(runners, ([address, runner]) => [encodeRunnerAddress(address), Runner.encodeSync(runner)]))),
+    acquire: (address, shardIds) => encoded.acquire(encodeRunnerAddress(address), Array.from(shardIds)),
+    refresh: (address, shardIds) => encoded.refresh(encodeRunnerAddress(address), Array.from(shardIds)),
+    release: Effect.fnUntraced(function* (address, shardId) {
+      activeShards.delete(shardId);
+      yield* encoded.release(encodeRunnerAddress(address), shardId).pipe(Effect.onError(() => Effect.sync(() => activeShards.add(shardId))));
+    }),
+    releaseAll: Effect.fnUntraced(function* (address) {
+      activeShards.clear();
+      yield* encoded.releaseAll(encodeRunnerAddress(address));
+    })
+  });
+});
+/**
+ * @since 1.0.0
+ * @category layers
+ */
+export const layerNoop = /*#__PURE__*/Layer.sync(ShardStorage, () => {
+  let acquired = [];
+  return ShardStorage.of({
+    getAssignments: Effect.succeed(new Map()),
+    saveAssignments: () => Effect.void,
+    getRunners: Effect.sync(() => []),
+    saveRunners: () => Effect.void,
+    acquire: (_address, shards) => {
+      acquired = Array.from(shards);
+      return Effect.succeed(Array.from(shards));
+    },
+    refresh: () => Effect.sync(() => acquired),
+    release: () => Effect.void,
+    releaseAll: () => Effect.void
+  });
+});
+/**
+ * @since 1.0.0
+ * @category constructors
+ */
+export const makeMemory = /*#__PURE__*/Effect.gen(function* () {
+  const assignments = new Map();
+  const runners = MutableHashMap.empty();
+  function saveAssignments(value) {
+    return Effect.sync(() => {
+      for (const [shardId, runnerAddress] of value) {
+        assignments.set(shardId, runnerAddress);
+      }
+    });
+  }
+  function saveRunners(value) {
+    return Effect.sync(() => {
+      for (const [address, runner] of value) {
+        MutableHashMap.set(runners, address, runner);
+      }
+    });
+  }
+  let acquired = [];
+  return ShardStorage.of({
+    getAssignments: Effect.sync(() => new Map(assignments)),
+    saveAssignments,
+    getRunners: Effect.sync(() => Array.from(runners)),
+    saveRunners,
+    acquire: (_address, shardIds) => {
+      acquired = Array.from(shardIds);
+      return Effect.succeed(Array.from(shardIds));
+    },
+    refresh: () => Effect.sync(() => acquired),
+    release: () => Effect.void,
+    releaseAll: () => Effect.void
+  });
+});
+/**
+ * @since 1.0.0
+ * @category layers
+ */
+export const layerMemory = /*#__PURE__*/Layer.effect(ShardStorage, makeMemory);
+// -------------------------------------------------------------------------------------
+// internal
+// -------------------------------------------------------------------------------------
+const encodeRunnerAddress = runnerAddress => `${runnerAddress.host}:${runnerAddress.port}`;
+const decodeRunnerAddress = runnerAddress => {
+  const [host, port] = runnerAddress.split(":");
+  return new RunnerAddress({
+    host,
+    port: Number(port)
+  });
+};
+//# sourceMappingURL=ShardStorage.js.map
\ No newline at end of file
diff --git a/dist/esm/ShardStorage.js.map b/dist/esm/ShardStorage.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..0d5097426be9b000c16b82afd3e10821af3062f8
--- /dev/null
+++ b/dist/esm/ShardStorage.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"ShardStorage.js","names":["Context","Effect","Layer","MutableHashMap","Option","Runner","RunnerAddress","ShardId","ShardStorage","Tag","makeEncoded","fnUntraced","encoded","activeShards","Set","of","getAssignments","map","assignments","Map","shardId","runnerAddress","set","make","none","some","decodeRunnerAddress","saveAssignments","Array","from","isNone","encodeRunnerAddress","value","getRunners","gen","runners","results","length","i","address","runner","decodeSync","saveRunners","suspend","encodeSync","acquire","shardIds","refresh","release","delete","pipe","onError","sync","add","releaseAll","clear","layerNoop","acquired","succeed","void","_address","shards","makeMemory","empty","layerMemory","effect","host","port","split","Number"],"sources":["../../src/ShardStorage.ts"],"sourcesContent":[null],"mappings":"AAAA;;;AAGA,OAAO,KAAKA,OAAO,MAAM,gBAAgB;AACzC,OAAO,KAAKC,MAAM,MAAM,eAAe;AACvC,OAAO,KAAKC,KAAK,MAAM,cAAc;AACrC,OAAO,KAAKC,cAAc,MAAM,uBAAuB;AACvD,OAAO,KAAKC,MAAM,MAAM,eAAe;AAEvC,SAASC,MAAM,QAAQ,aAAa;AACpC,SAASC,aAAa,QAAQ,oBAAoB;AAClD,SAASC,OAAO,QAAQ,cAAc;AAEtC;;;;;;;AAOA,OAAM,MAAOC,YAAa,sBAAQR,OAAO,CAACS,GAAG,CAAC,8BAA8B,CAAC,EAwDzE;AAuEJ;;;;AAIA,OAAO,MAAMC,WAAW,gBAAGT,MAAM,CAACU,UAAU,CAAC,WAAUC,OAAgB;EACrE,MAAMC,YAAY,GAAG,IAAIC,GAAG,EAAW;EAEvC,OAAON,YAAY,CAACO,EAAE,CAAC;IACrBC,cAAc,EAAEf,MAAM,CAACgB,GAAG,CAACL,OAAO,CAACI,cAAc,EAAGE,WAAW,IAAI;MACjE,MAAMD,GAAG,GAAG,IAAIE,GAAG,EAAyC;MAC5D,KAAK,MAAM,CAACC,OAAO,EAAEC,aAAa,CAAC,IAAIH,WAAW,EAAE;QAClDD,GAAG,CAACK,GAAG,CACLf,OAAO,CAACgB,IAAI,CAACH,OAAO,CAAC,EACrBC,aAAa,KAAK,IAAI,GAAGjB,MAAM,CAACoB,IAAI,EAAE,GAAGpB,MAAM,CAACqB,IAAI,CAACC,mBAAmB,CAACL,aAAa,CAAC,CAAC,CACzF;MACH;MACA,OAAOJ,GAAG;IACZ,CAAC,CAAC;IACFU,eAAe,EAAGT,WAAW,IAC3BN,OAAO,CAACe,eAAe,CACrBC,KAAK,CAACC,IAAI,CACRX,WAAW,EACX,CACE,CAACE,OAAO,EAAEC,aAAa,CAAC,KACrB,CAACD,OAAO,EAAEhB,MAAM,CAAC0B,MAAM,CAACT,aAAa,CAAC,GAAG,IAAI,GAAGU,mBAAmB,CAACV,aAAa,CAACW,KAAK,CAAC,CAAC,CAC/F,CACF;IACHC,UAAU,EAAEhC,MAAM,CAACiC,GAAG,CAAC,aAAS;MAC9B,MAAMC,OAAO,GAAG,OAAOvB,OAAO,CAACqB,UAAU;MACzC,MAAMG,OAAO,GAAG,IAAIR,KAAK,CAA0BO,OAAO,CAACE,MAAM,CAAC;MAClE,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,OAAO,CAACE,MAAM,EAAEC,CAAC,EAAE,EAAE;QACvC,MAAM,CAACC,OAAO,EAAEC,MAAM,CAAC,GAAGL,OAAO,CAACG,CAAC,CAAC;QACpCF,OAAO,CAACE,CAAC,CAAC,GAAG,CAACZ,mBAAmB,CAACa,OAAO,CAAC,EAAElC,MAAM,CAACoC,UAAU,CAACD,MAAM,CAAC,CAAC;MACxE;MACA,OAAOJ,OAAO;IAChB,CAAC,CAAC;IACFM,WAAW,EAAGP,OAAO,IACnBlC,MAAM,CAAC0C,OAAO,CAAC,MACb/B,OAAO,CAAC8B,WAAW,CACjBd,KAAK,CAACC,IAAI,CAACM,OAAO,EAAE,CAAC,CAACI,OAAO,EAAEC,MAAM,CAAC,KAAK,CAACT,mBAAmB,CAACQ,OAAO,CAAC,EAAElC,MAAM,CAACuC,UAAU,CAACJ,MAAM,CAAC,CAAC,CAAC,CACtG,CACF;IACHK,OAAO,EAAEA,CAACN,OAAO,EAAEO,QAAQ,KACzBlC,OAAO,CAACiC,OAAO,CAACd,mBAAmB,CAACQ,OAAO,CAAC,EAAEX,KAAK,CAACC,IAAI,CAACiB,QAAQ,CAAC,CAGjE;IACHC,OAAO,EAAEA,CAACR,OAAO,EAAEO,QAAQ,KAAKlC,OAAO,CAACmC,OAAO,CAAChB,mBAAmB,CAACQ,OAAO,CAAC,EAAEX,KAAK,CAACC,IAAI,CAACiB,QAAQ,CAAC,CAAQ;IAC1GE,OAAO,EAAE/C,MAAM,CAACU,UAAU,CAAC,WAAU4B,OAAO,EAAEnB,OAAO;MACnDP,YAAY,CAACoC,MAAM,CAAC7B,OAAO,CAAC;MAC5B,OAAOR,OAAO,CAACoC,OAAO,CAACjB,mBAAmB,CAACQ,OAAO,CAAC,EAAEnB,OAAO,CAAC,CAAC8B,IAAI,CAChEjD,MAAM,CAACkD,OAAO,CAAC,MAAMlD,MAAM,CAACmD,IAAI,CAAC,MAAMvC,YAAY,CAACwC,GAAG,CAACjC,OAAO,CAAC,CAAC,CAAC,CACnE;IACH,CAAC,CAAC;IACFkC,UAAU,EAAErD,MAAM,CAACU,UAAU,CAAC,WAAU4B,OAAO;MAC7C1B,YAAY,CAAC0C,KAAK,EAAE;MACpB,OAAO3C,OAAO,CAAC0C,UAAU,CAACvB,mBAAmB,CAACQ,OAAO,CAAC,CAAC;IACzD,CAAC;GACF,CAAC;AACJ,CAAC,CAAC;AAEF;;;;AAIA,OAAO,MAAMiB,SAAS,gBAA8BtD,KAAK,CAACkD,IAAI,CAC5D5C,YAAY,EACZ,MAAK;EACH,IAAIiD,QAAQ,GAAmB,EAAE;EACjC,OAAOjD,YAAY,CAACO,EAAE,CAAC;IACrBC,cAAc,EAAEf,MAAM,CAACyD,OAAO,CAAC,IAAIvC,GAAG,EAAE,CAAC;IACzCQ,eAAe,EAAEA,CAAA,KAAM1B,MAAM,CAAC0D,IAAI;IAClC1B,UAAU,EAAEhC,MAAM,CAACmD,IAAI,CAAC,MAAM,EAAE,CAAC;IACjCV,WAAW,EAAEA,CAAA,KAAMzC,MAAM,CAAC0D,IAAI;IAC9Bd,OAAO,EAAEA,CAACe,QAAQ,EAAEC,MAAM,KAAI;MAC5BJ,QAAQ,GAAG7B,KAAK,CAACC,IAAI,CAACgC,MAAM,CAAC;MAC7B,OAAO5D,MAAM,CAACyD,OAAO,CAAC9B,KAAK,CAACC,IAAI,CAACgC,MAAM,CAAC,CAAC;IAC3C,CAAC;IACDd,OAAO,EAAEA,CAAA,KAAM9C,MAAM,CAACmD,IAAI,CAAC,MAAMK,QAAQ,CAAC;IAC1CT,OAAO,EAAEA,CAAA,KAAM/C,MAAM,CAAC0D,IAAI;IAC1BL,UAAU,EAAEA,CAAA,KAAMrD,MAAM,CAAC0D;GAC1B,CAAC;AACJ,CAAC,CACF;AAED;;;;AAIA,OAAO,MAAMG,UAAU,gBAAG7D,MAAM,CAACiC,GAAG,CAAC,aAAS;EAC5C,MAAMhB,WAAW,GAAG,IAAIC,GAAG,EAAyC;EACpE,MAAMgB,OAAO,GAAGhC,cAAc,CAAC4D,KAAK,EAAyB;EAE7D,SAASpC,eAAeA,CAACK,KAAiE;IACxF,OAAO/B,MAAM,CAACmD,IAAI,CAAC,MAAK;MACtB,KAAK,MAAM,CAAChC,OAAO,EAAEC,aAAa,CAAC,IAAIW,KAAK,EAAE;QAC5Cd,WAAW,CAACI,GAAG,CAACF,OAAO,EAAEC,aAAa,CAAC;MACzC;IACF,CAAC,CAAC;EACJ;EAEA,SAASqB,WAAWA,CAACV,KAAiD;IACpE,OAAO/B,MAAM,CAACmD,IAAI,CAAC,MAAK;MACtB,KAAK,MAAM,CAACb,OAAO,EAAEC,MAAM,CAAC,IAAIR,KAAK,EAAE;QACrC7B,cAAc,CAACmB,GAAG,CAACa,OAAO,EAAEI,OAAO,EAAEC,MAAM,CAAC;MAC9C;IACF,CAAC,CAAC;EACJ;EAEA,IAAIiB,QAAQ,GAAmB,EAAE;EAEjC,OAAOjD,YAAY,CAACO,EAAE,CAAC;IACrBC,cAAc,EAAEf,MAAM,CAACmD,IAAI,CAAC,MAAM,IAAIjC,GAAG,CAACD,WAAW,CAAC,CAAC;IACvDS,eAAe;IACfM,UAAU,EAAEhC,MAAM,CAACmD,IAAI,CAAC,MAAMxB,KAAK,CAACC,IAAI,CAACM,OAAO,CAAC,CAAC;IAClDO,WAAW;IACXG,OAAO,EAAEA,CAACe,QAAQ,EAAEd,QAAQ,KAAI;MAC9BW,QAAQ,GAAG7B,KAAK,CAACC,IAAI,CAACiB,QAAQ,CAAC;MAC/B,OAAO7C,MAAM,CAACyD,OAAO,CAAC9B,KAAK,CAACC,IAAI,CAACiB,QAAQ,CAAC,CAAC;IAC7C,CAAC;IACDC,OAAO,EAAEA,CAAA,KAAM9C,MAAM,CAACmD,IAAI,CAAC,MAAMK,QAAQ,CAAC;IAC1CT,OAAO,EAAEA,CAAA,KAAM/C,MAAM,CAAC0D,IAAI;IAC1BL,UAAU,EAAEA,CAAA,KAAMrD,MAAM,CAAC0D;GAC1B,CAAC;AACJ,CAAC,CAAC;AAEF;;;;AAIA,OAAO,MAAMK,WAAW,gBAA8B9D,KAAK,CAAC+D,MAAM,CAACzD,YAAY,EAAEsD,UAAU,CAAC;AAE5F;AACA;AACA;AAEA,MAAM/B,mBAAmB,GAAIV,aAA4B,IAAK,GAAGA,aAAa,CAAC6C,IAAI,IAAI7C,aAAa,CAAC8C,IAAI,EAAE;AAE3G,MAAMzC,mBAAmB,GAAIL,aAAqB,IAAmB;EACnE,MAAM,CAAC6C,IAAI,EAAEC,IAAI,CAAC,GAAG9C,aAAa,CAAC+C,KAAK,CAAC,GAAG,CAAC;EAC7C,OAAO,IAAI9D,aAAa,CAAC;IAAE4D,IAAI;IAAEC,IAAI,EAAEE,MAAM,CAACF,IAAI;EAAC,CAAE,CAAC;AACxD,CAAC","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/esm/Sharding.js b/dist/esm/Sharding.js
index c8a7adb8d997169b2ac50fcdb3aa6a6591f3a7eb..32705fc974788dca136b614d78e90e7872c5598b 100644
--- a/dist/esm/Sharding.js
+++ b/dist/esm/Sharding.js
@@ -1,98 +1,742 @@
-import * as internal from "./internal/sharding.js";
+import * as RpcClient from "@effect/rpc/RpcClient";
+import { RequestId } from "@effect/rpc/RpcMessage";
+import * as Arr from "effect/Array";
+import * as Cause from "effect/Cause";
+import * as Context from "effect/Context";
+import * as Effect from "effect/Effect";
+import * as Equal from "effect/Equal";
+import * as Fiber from "effect/Fiber";
+import * as FiberHandle from "effect/FiberHandle";
+import * as FiberMap from "effect/FiberMap";
+import * as FiberRef from "effect/FiberRef";
+import { constant } from "effect/Function";
+import * as HashMap from "effect/HashMap";
+import * as Iterable from "effect/Iterable";
+import * as Layer from "effect/Layer";
+import * as MutableHashMap from "effect/MutableHashMap";
+import * as MutableRef from "effect/MutableRef";
+import * as Option from "effect/Option";
+import * as Predicate from "effect/Predicate";
+import * as PubSub from "effect/PubSub";
+import * as Schedule from "effect/Schedule";
+import * as Scope from "effect/Scope";
+import * as Stream from "effect/Stream";
+import { EntityNotManagedByRunner, RunnerUnavailable } from "./ClusterError.js";
+import { Persisted } from "./ClusterSchema.js";
+import { EntityAddress } from "./EntityAddress.js";
+import { EntityId } from "./EntityId.js";
+import * as Envelope from "./Envelope.js";
+import * as EntityManager from "./internal/entityManager.js";
+import { EntityReaper } from "./internal/entityReaper.js";
+import { hashString } from "./internal/hash.js";
+import { internalInterruptors } from "./internal/interruptors.js";
+import { ResourceMap } from "./internal/resourceMap.js";
+import * as Message from "./Message.js";
+import * as MessageStorage from "./MessageStorage.js";
+import * as Reply from "./Reply.js";
+import { Runners } from "./Runners.js";
+import { ShardId } from "./ShardId.js";
+import { ShardingConfig } from "./ShardingConfig.js";
+import { EntityRegistered, SingletonRegistered } from "./ShardingRegistrationEvent.js";
+import { ShardManagerClient } from "./ShardManager.js";
+import { ShardStorage } from "./ShardStorage.js";
+import { SingletonAddress } from "./SingletonAddress.js";
+import * as Snowflake from "./Snowflake.js";
 /**
  * @since 1.0.0
- * @category symbols
+ * @category models
  */
-export const ShardingTypeId = internal.ShardingTypeId;
+export class Sharding extends /*#__PURE__*/Context.Tag("@effect/cluster/Sharding")() {}
 /**
  * @since 1.0.0
- * @category context
+ * @category constructors
  */
-export const Tag = internal.shardingTag;
+export const make = /*#__PURE__*/Effect.gen(function* () {
+  const config = yield* ShardingConfig;
+  const runners = yield* Runners;
+  const shardManager = yield* ShardManagerClient;
+  const snowflakeGen = yield* Snowflake.Generator;
+  const shardingScope = yield* Effect.scope;
+  const isShutdown = MutableRef.make(false);
+  const storage = yield* MessageStorage.MessageStorage;
+  const storageEnabled = storage !== MessageStorage.noop;
+  const shardStorage = yield* ShardStorage;
+  const entityManagers = new Map();
+  const shardAssignments = MutableHashMap.empty();
+  const selfShards = new Set();
+  // the active shards are the ones that we have acquired the lock for
+  const acquiredShards = new Set();
+  const activeShardsLatch = yield* Effect.makeLatch(false);
+  const events = yield* PubSub.unbounded();
+  const getRegistrationEvents = Stream.fromPubSub(events);
+  const isLocalRunner = address => Option.isSome(config.runnerAddress) && Equal.equals(address, config.runnerAddress.value);
+  function getShardId(entityId) {
+    return ShardId.make(Math.abs(hashString(entityId) % config.numberOfShards) + 1);
+  }
+  function isEntityOnLocalShards(address) {
+    return acquiredShards.has(address.shardId);
+  }
+  // --- Shard acquisition ---
+  if (Option.isSome(config.runnerAddress)) {
+    const selfAddress = config.runnerAddress.value;
+    yield* Scope.addFinalizerExit(shardingScope, () => {
+      // the locks expire over time, so if this fails we ignore it
+      return Effect.ignore(shardStorage.releaseAll(selfAddress));
+    });
+    const releasingShards = new Set();
+    yield* Effect.gen(function* () {
+      while (true) {
+        yield* activeShardsLatch.await;
+        // if a shard is no longer assigned to this runner, we release it
+        for (const shardId of acquiredShards) {
+          if (selfShards.has(shardId)) continue;
+          acquiredShards.delete(shardId);
+          releasingShards.add(shardId);
+        }
+        // if a shard has been assigned to this runner, we acquire it
+        const unacquiredShards = new Set();
+        for (const shardId of selfShards) {
+          if (acquiredShards.has(shardId) || releasingShards.has(shardId)) continue;
+          unacquiredShards.add(shardId);
+        }
+        if (releasingShards.size > 0) {
+          yield* Effect.forkIn(syncSingletons, shardingScope);
+          yield* releaseShards;
+        }
+        if (unacquiredShards.size === 0) {
+          yield* activeShardsLatch.close;
+          continue;
+        }
+        const acquired = yield* shardStorage.acquire(selfAddress, unacquiredShards);
+        for (const shardId of acquired) {
+          acquiredShards.add(shardId);
+        }
+        if (acquired.length > 0) {
+          yield* storageReadLatch.open;
+          yield* Effect.forkIn(syncSingletons, shardingScope);
+        }
+        yield* Effect.sleep(1000);
+      }
+    }).pipe(Effect.catchAllCause(cause => Effect.logWarning("Could not acquire/release shards", cause)), Effect.repeat(Schedule.spaced(config.entityMessagePollInterval)), Effect.annotateLogs({
+      package: "@effect/cluster",
+      module: "Sharding",
+      fiber: "Shard acquisition loop",
+      runner: selfAddress
+    }), Effect.interruptible, Effect.forkIn(shardingScope));
+    // refresh the shard locks every minute
+    yield* Effect.suspend(() => shardStorage.refresh(selfAddress, [...acquiredShards, ...releasingShards])).pipe(Effect.flatMap(acquired => {
+      for (const shardId of acquiredShards) {
+        if (!acquired.includes(shardId)) {
+          acquiredShards.delete(shardId);
+          releasingShards.add(shardId);
+        }
+      }
+      return releasingShards.size > 0 ? Effect.andThen(Effect.forkIn(syncSingletons, shardingScope), releaseShards) : Effect.void;
+    }), Effect.retry({
+      times: 5,
+      schedule: Schedule.spaced(250)
+    }), Effect.catchAllCause(cause => Effect.logError("Could not refresh shard locks", cause).pipe(Effect.andThen(clearSelfShards))), Effect.delay("1 minute"), Effect.forever, Effect.interruptible, Effect.forkIn(shardingScope));
+    const releaseShardsLock = Effect.unsafeMakeSemaphore(1).withPermits(1);
+    const releaseShards = releaseShardsLock(Effect.suspend(() => Effect.forEach(releasingShards, shardId => Effect.forEach(entityManagers.values(), state => state.manager.interruptShard(shardId), {
+      concurrency: "unbounded",
+      discard: true
+    }).pipe(Effect.andThen(shardStorage.release(selfAddress, shardId)), Effect.annotateLogs({
+      runner: selfAddress
+    }), Effect.andThen(() => {
+      releasingShards.delete(shardId);
+    })), {
+      concurrency: "unbounded",
+      discard: true
+    })));
+  }
+  const clearSelfShards = Effect.suspend(() => {
+    selfShards.clear();
+    return activeShardsLatch.open;
+  });
+  // --- Singletons ---
+  const singletons = new Map();
+  const singletonFibers = yield* FiberMap.make();
+  const withSingletonLock = Effect.unsafeMakeSemaphore(1).withPermits(1);
+  const registerSingleton = Effect.fnUntraced(function* (name, run) {
+    const address = new SingletonAddress({
+      shardId: getShardId(EntityId.make(name)),
+      name
+    });
+    let map = singletons.get(address.shardId);
+    if (!map) {
+      map = MutableHashMap.empty();
+      singletons.set(address.shardId, map);
+    }
+    if (MutableHashMap.has(map, address)) {
+      return yield* Effect.dieMessage(`Singleton '${name}' is already registered`);
+    }
+    const context = yield* Effect.context();
+    const wrappedRun = run.pipe(Effect.locally(FiberRef.currentLogAnnotations, HashMap.empty()), Effect.andThen(Effect.never), Effect.scoped, Effect.provide(context), Effect.orDie, Effect.interruptible);
+    MutableHashMap.set(map, address, wrappedRun);
+    yield* PubSub.publish(events, SingletonRegistered({
+      address
+    }));
+    // start if we are on the right shard
+    if (acquiredShards.has(address.shardId)) {
+      yield* Effect.logDebug("Starting singleton", address);
+      yield* FiberMap.run(singletonFibers, address, wrappedRun);
+    }
+  }, withSingletonLock);
+  const syncSingletons = withSingletonLock(Effect.gen(function* () {
+    for (const [shardId, map] of singletons) {
+      for (const [address, run] of map) {
+        const running = FiberMap.unsafeHas(singletonFibers, address);
+        const shouldBeRunning = acquiredShards.has(shardId);
+        if (running && !shouldBeRunning) {
+          yield* Effect.logDebug("Stopping singleton", address);
+          internalInterruptors.add(yield* Effect.fiberId);
+          yield* FiberMap.remove(singletonFibers, address);
+        } else if (!running && shouldBeRunning) {
+          yield* Effect.logDebug("Starting singleton", address);
+          yield* FiberMap.run(singletonFibers, address, run);
+        }
+      }
+    }
+  }));
+  // --- Storage inbox ---
+  const storageReadLatch = yield* Effect.makeLatch(true);
+  const openStorageReadLatch = constant(storageReadLatch.open);
+  const storageReadLock = Effect.unsafeMakeSemaphore(1);
+  const withStorageReadLock = storageReadLock.withPermits(1);
+  if (storageEnabled && Option.isSome(config.runnerAddress)) {
+    const selfAddress = config.runnerAddress.value;
+    yield* Effect.gen(function* () {
+      yield* Effect.logDebug("Starting");
+      yield* Effect.addFinalizer(() => Effect.logDebug("Shutting down"));
+      // keep track of the last sent request ids to avoid duplicates
+      // we only keep the last 30 sets to avoid memory leaks
+      const sentRequestIds = new Set();
+      const sentRequestIdSets = new Set();
+      while (true) {
+        // wait for the next poll interval, or if we get notified of a change
+        yield* storageReadLatch.await;
+        // if we get notified of a change, ensure we start a read immediately
+        // next iteration
+        storageReadLatch.unsafeClose();
+        // the lock is used to ensure resuming entities have a garantee that no
+        // more items are added to the unprocessed set while the semaphore is
+        // acquired.
+        yield* storageReadLock.take(1);
+        const messages = yield* storage.unprocessedMessages(acquiredShards);
+        const currentSentRequestIds = new Set();
+        sentRequestIdSets.add(currentSentRequestIds);
+        const send = Effect.catchAllCause(Effect.suspend(() => {
+          const message = messages[index];
+          if (message._tag === "IncomingRequest") {
+            if (sentRequestIds.has(message.envelope.requestId)) {
+              return Effect.void;
+            }
+            sentRequestIds.add(message.envelope.requestId);
+            currentSentRequestIds.add(message.envelope.requestId);
+          }
+          const address = message.envelope.address;
+          const state = entityManagers.get(address.entityType);
+          if (!state || !acquiredShards.has(address.shardId)) {
+            return Effect.void;
+          }
+          const isProcessing = state.manager.isProcessingFor(message);
+          // If the message might affect a currently processing request, we
+          // send it to the entity manager to be processed.
+          if (message._tag === "IncomingEnvelope" && isProcessing) {
+            return state.manager.send(message);
+          } else if (isProcessing) {
+            return Effect.void;
+          }
+          // If the entity was resuming in another fiber, we add the message
+          // id to the unprocessed set.
+          const resumptionState = MutableHashMap.get(entityResumptionState, address);
+          if (Option.isSome(resumptionState)) {
+            resumptionState.value.unprocessed.add(message.envelope.requestId);
+            if (message.envelope._tag === "Interrupt") {
+              resumptionState.value.interrupts.set(message.envelope.requestId, message);
+            }
+            return Effect.void;
+          }
+          return state.manager.send(message);
+        }), cause => {
+          const message = messages[index];
+          const error = Cause.failureOption(cause);
+          // if we get a defect, then update storage
+          if (Option.isNone(error)) {
+            return storage.saveReply(Reply.ReplyWithContext.fromDefect({
+              id: snowflakeGen.unsafeNext(),
+              requestId: message.envelope.requestId,
+              defect: Cause.squash(cause)
+            }));
+          }
+          if (error.value._tag === "MailboxFull") {
+            // MailboxFull can only happen for requests, so this cast is safe
+            return resumeEntityFromStorage(message);
+          }
+          return Effect.void;
+        });
+        let index = 0;
+        yield* Effect.whileLoop({
+          while: () => index < messages.length,
+          step: () => index++,
+          body: constant(send)
+        });
+        // let the resuming entities check if they are done
+        yield* storageReadLock.release(1);
+        while (sentRequestIdSets.size > 30) {
+          const oldest = Iterable.unsafeHead(sentRequestIdSets);
+          sentRequestIdSets.delete(oldest);
+          for (const id of oldest) {
+            sentRequestIds.delete(id);
+          }
+        }
+      }
+    }).pipe(Effect.scoped, Effect.ensuring(storageReadLock.releaseAll), Effect.catchAllCause(cause => Effect.logWarning("Could not read messages from storage", cause)), Effect.repeat(Schedule.spaced(config.entityMessagePollInterval)), Effect.annotateLogs({
+      package: "@effect/cluster",
+      module: "Sharding",
+      fiber: "Storage read loop",
+      runner: selfAddress
+    }), Effect.interruptible, Effect.forkIn(shardingScope));
+    // open the storage latch every poll interval
+    yield* storageReadLatch.open.pipe(Effect.delay(config.entityMessagePollInterval), Effect.forever, Effect.interruptible, Effect.forkIn(shardingScope));
+    // Resume unprocessed messages for entities that reached a full mailbox.
+    const entityResumptionState = MutableHashMap.empty();
+    const resumeEntityFromStorage = lastReceivedMessage => {
+      const address = lastReceivedMessage.envelope.address;
+      const resumptionState = MutableHashMap.get(entityResumptionState, address);
+      if (Option.isSome(resumptionState)) {
+        resumptionState.value.unprocessed.add(lastReceivedMessage.envelope.requestId);
+        return Effect.void;
+      }
+      MutableHashMap.set(entityResumptionState, address, {
+        unprocessed: new Set([lastReceivedMessage.envelope.requestId]),
+        interrupts: new Map()
+      });
+      return resumeEntityFromStorageImpl(address);
+    };
+    const resumeEntityFromStorageImpl = Effect.fnUntraced(function* (address) {
+      const state = entityManagers.get(address.entityType);
+      if (!state) {
+        MutableHashMap.remove(entityResumptionState, address);
+        return;
+      }
+      const resumptionState = Option.getOrThrow(MutableHashMap.get(entityResumptionState, address));
+      let done = false;
+      while (!done) {
+        // if the shard is no longer assigned to this runner, we stop
+        if (!acquiredShards.has(address.shardId)) {
+          return;
+        }
+        // take a batch of unprocessed messages ids
+        const messageIds = Arr.empty();
+        for (const id of resumptionState.unprocessed) {
+          if (messageIds.length === 1024) break;
+          messageIds.push(id);
+        }
+        const messages = yield* storage.unprocessedMessagesById(messageIds);
+        // this should not happen, but we handle it just in case
+        if (messages.length === 0) {
+          yield* Effect.sleep(config.entityMessagePollInterval);
+          continue;
+        }
+        let index = 0;
+        const sendWithRetry = Effect.catchTags(Effect.suspend(() => {
+          if (!acquiredShards.has(address.shardId)) {
+            return Effect.fail(new EntityNotManagedByRunner({
+              address
+            }));
+          }
+          const message = messages[index];
+          // check if this is a request that was interrupted
+          const interrupt = message._tag === "IncomingRequest" && resumptionState.interrupts.get(message.envelope.requestId);
+          return interrupt ? Effect.flatMap(state.manager.send(message), () => {
+            resumptionState.interrupts.delete(message.envelope.requestId);
+            return state.manager.send(interrupt);
+          }) : state.manager.send(message);
+        }), {
+          MailboxFull: () => Effect.delay(sendWithRetry, config.sendRetryInterval),
+          AlreadyProcessingMessage: () => Effect.void
+        });
+        yield* Effect.whileLoop({
+          while: () => index < messages.length,
+          body: constant(sendWithRetry),
+          step: () => index++
+        });
+        for (const id of messageIds) {
+          resumptionState.unprocessed.delete(id);
+        }
+        if (resumptionState.unprocessed.size > 0) continue;
+        // if we have caught up to the main storage loop, we let it take over
+        yield* withStorageReadLock(Effect.sync(() => {
+          if (resumptionState.unprocessed.size === 0) {
+            MutableHashMap.remove(entityResumptionState, address);
+            done = true;
+          }
+        }));
+      }
+    }, Effect.retry({
+      while: e => e._tag === "PersistenceError",
+      schedule: Schedule.spaced(config.entityMessagePollInterval)
+    }), Effect.catchAllCause(cause => Effect.logError("Could not resume unprocessed messages", cause)), (effect, address) => Effect.annotateLogs(effect, {
+      package: "@effect/cluster",
+      module: "Sharding",
+      fiber: "Resuming unprocessed messages",
+      runner: selfAddress,
+      entity: address
+    }), (effect, address) => Effect.ensuring(effect, Effect.sync(() => MutableHashMap.remove(entityResumptionState, address))), Effect.interruptible, Effect.forkIn(shardingScope));
+  }
+  // --- Sending messages ---
+  const sendLocal = message => Effect.suspend(() => {
+    const address = message.envelope.address;
+    if (!isEntityOnLocalShards(address)) {
+      return Effect.fail(new EntityNotManagedByRunner({
+        address
+      }));
+    }
+    const state = entityManagers.get(address.entityType);
+    if (!state) {
+      return Effect.fail(new EntityNotManagedByRunner({
+        address
+      }));
+    }
+    return message._tag === "IncomingRequest" || message._tag === "IncomingEnvelope" ? state.manager.send(message) : runners.sendLocal({
+      message,
+      send: state.manager.sendLocal,
+      simulateRemoteSerialization: config.simulateRemoteSerialization
+    });
+  });
+  const notifyLocal = (message, discard) => Effect.suspend(() => {
+    const address = message.envelope.address;
+    if (!isEntityOnLocalShards(address)) {
+      return Effect.fail(new EntityNotManagedByRunner({
+        address
+      }));
+    }
+    const notify = storageEnabled ? openStorageReadLatch : () => Effect.dieMessage("Sharding.notifyLocal: storage is disabled");
+    return message._tag === "IncomingRequest" || message._tag === "IncomingEnvelope" ? notify() : runners.notifyLocal({
+      message,
+      notify,
+      discard
+    });
+  });
+  const isTransientError = Predicate.or(RunnerUnavailable.is, EntityNotManagedByRunner.is);
+  function sendOutgoing(message, discard, retries) {
+    return Effect.catchIf(Effect.suspend(() => {
+      const address = message.envelope.address;
+      const maybeRunner = MutableHashMap.get(shardAssignments, address.shardId);
+      if (Option.isNone(maybeRunner)) {
+        return Effect.fail(new EntityNotManagedByRunner({
+          address
+        }));
+      }
+      const runner = maybeRunner.value;
+      const rpc = message.rpc;
+      if (storageEnabled && Context.get(rpc.annotations, Persisted)) {
+        return isLocalRunner(runner) ? notifyLocal(message, discard) : runners.notify({
+          address: runner,
+          message,
+          discard
+        });
+      }
+      return isLocalRunner(runner) ? sendLocal(message) : runners.send({
+        address: runner,
+        message
+      });
+    }), isTransientError, error => {
+      if (retries === 0) {
+        return Effect.die(error);
+      }
+      return Effect.delay(sendOutgoing(message, discard, retries && retries - 1), config.sendRetryInterval);
+    });
+  }
+  // --- Shard Manager sync ---
+  const shardManagerTimeoutFiber = yield* FiberHandle.make().pipe(Scope.extend(shardingScope));
+  const startShardManagerTimeout = FiberHandle.run(shardManagerTimeoutFiber, Effect.flatMap(Effect.sleep(config.shardManagerUnavailableTimeout), () => {
+    MutableHashMap.clear(shardAssignments);
+    return clearSelfShards;
+  }), {
+    onlyIfMissing: true
+  });
+  const stopShardManagerTimeout = FiberHandle.clear(shardManagerTimeoutFiber);
+  // Every time the link to the shard manager is lost, we re-register the runner
+  // and re-subscribe to sharding events
+  yield* Effect.gen(function* () {
+    yield* Effect.logDebug("Registering with shard manager");
+    if (Option.isSome(config.runnerAddress)) {
+      const machineId = yield* shardManager.register(config.runnerAddress.value);
+      yield* snowflakeGen.setMachineId(machineId);
+    }
+    yield* stopShardManagerTimeout;
+    yield* Effect.logDebug("Subscribing to sharding events");
+    const mailbox = yield* shardManager.shardingEvents;
+    const startedLatch = yield* Effect.makeLatch(false);
+    const eventsFiber = yield* Effect.gen(function* () {
+      while (true) {
+        const [events] = yield* mailbox.takeAll;
+        for (const event of events) {
+          yield* Effect.logDebug("Received sharding event", event);
+          switch (event._tag) {
+            case "StreamStarted":
+              {
+                yield* startedLatch.open;
+                break;
+              }
+            case "ShardsAssigned":
+              {
+                for (const shard of event.shards) {
+                  MutableHashMap.set(shardAssignments, shard, event.address);
+                }
+                if (!MutableRef.get(isShutdown) && isLocalRunner(event.address)) {
+                  for (const shardId of event.shards) {
+                    if (selfShards.has(shardId)) continue;
+                    selfShards.add(shardId);
+                  }
+                  yield* activeShardsLatch.open;
+                }
+                break;
+              }
+            case "ShardsUnassigned":
+              {
+                for (const shard of event.shards) {
+                  MutableHashMap.remove(shardAssignments, shard);
+                }
+                if (isLocalRunner(event.address)) {
+                  for (const shard of event.shards) {
+                    selfShards.delete(shard);
+                  }
+                  yield* activeShardsLatch.open;
+                }
+                break;
+              }
+          }
+        }
+      }
+    }).pipe(Effect.forkScoped);
+    // Wait for the stream to be established
+    yield* startedLatch.await;
+    // perform a full sync every config.refreshAssignmentsInterval
+    const syncFiber = yield* syncAssignments.pipe(Effect.andThen(Effect.sleep(config.refreshAssignmentsInterval)), Effect.forever, Effect.forkScoped);
+    yield* Fiber.joinAll([eventsFiber, syncFiber]);
+  }).pipe(Effect.scoped, Effect.catchAllCause(cause => Effect.logDebug(cause)), Effect.zipRight(startShardManagerTimeout), Effect.repeat(Schedule.exponential(1000).pipe(Schedule.union(Schedule.spaced(10_000)))), Effect.annotateLogs({
+    package: "@effect/cluster",
+    module: "Sharding",
+    fiber: "ShardManager sync",
+    runner: config.runnerAddress
+  }), Effect.interruptible, Effect.forkIn(shardingScope));
+  const syncAssignments = Effect.gen(function* () {
+    const assignments = yield* shardManager.getAssignments;
+    yield* Effect.logDebug("Received shard assignments", assignments);
+    for (const [shardId, runner] of assignments) {
+      if (Option.isNone(runner)) {
+        MutableHashMap.remove(shardAssignments, shardId);
+        selfShards.delete(shardId);
+        continue;
+      }
+      MutableHashMap.set(shardAssignments, shardId, runner.value);
+      if (!isLocalRunner(runner.value)) {
+        selfShards.delete(shardId);
+        continue;
+      }
+      if (MutableRef.get(isShutdown) || selfShards.has(shardId)) {
+        continue;
+      }
+      selfShards.add(shardId);
+    }
+    yield* activeShardsLatch.open;
+  });
+  const clientRequests = new Map();
+  const clients = yield* ResourceMap.make(Effect.fnUntraced(function* (entity) {
+    const client = yield* RpcClient.makeNoSerialization(entity.protocol, {
+      supportsAck: true,
+      generateRequestId: () => RequestId(snowflakeGen.unsafeNext()),
+      onFromClient(options) {
+        const address = Context.unsafeGet(options.context, ClientAddressTag);
+        switch (options.message._tag) {
+          case "Request":
+            {
+              const fiber = Option.getOrThrow(Fiber.getCurrentFiber());
+              const id = Snowflake.Snowflake(options.message.id);
+              const rpc = entity.protocol.requests.get(options.message.tag);
+              let respond;
+              if (!options.discard) {
+                const entry = {
+                  rpc: rpc,
+                  context: fiber.currentContext
+                };
+                clientRequests.set(id, entry);
+                respond = makeClientRespond(entry, client.write);
+              } else {
+                respond = clientRespondDiscard;
+              }
+              return sendOutgoing(new Message.OutgoingRequest({
+                envelope: Envelope.makeRequest({
+                  requestId: id,
+                  address,
+                  tag: options.message.tag,
+                  payload: options.message.payload,
+                  headers: options.message.headers,
+                  traceId: options.message.traceId,
+                  spanId: options.message.spanId,
+                  sampled: options.message.sampled
+                }),
+                lastReceivedReply: Option.none(),
+                rpc,
+                context: fiber.currentContext,
+                respond
+              }), options.discard);
+            }
+          case "Ack":
+            {
+              const requestId = Snowflake.Snowflake(options.message.requestId);
+              const entry = clientRequests.get(requestId);
+              if (!entry) return Effect.void;
+              return sendOutgoing(new Message.OutgoingEnvelope({
+                envelope: new Envelope.AckChunk({
+                  id: snowflakeGen.unsafeNext(),
+                  address,
+                  requestId,
+                  replyId: entry.lastChunkId
+                }),
+                rpc: entry.rpc
+              }), false);
+            }
+          case "Interrupt":
+            {
+              const requestId = Snowflake.Snowflake(options.message.requestId);
+              const entry = clientRequests.get(requestId);
+              if (!entry) return Effect.void;
+              clientRequests.delete(requestId);
+              // for durable messages, we ignore interrupts on shutdown or as a
+              // result of a shard being resassigned
+              const isTransientInterrupt = MutableRef.get(isShutdown) || options.message.interruptors.some(id => internalInterruptors.has(id));
+              if (isTransientInterrupt && storageEnabled && Context.get(entry.rpc.annotations, Persisted)) {
+                return Effect.void;
+              }
+              return Effect.ignore(sendOutgoing(new Message.OutgoingEnvelope({
+                envelope: new Envelope.Interrupt({
+                  id: snowflakeGen.unsafeNext(),
+                  address,
+                  requestId
+                }),
+                rpc: entry.rpc
+              }), false, 3));
+            }
+        }
+        return Effect.void;
+      }
+    });
+    const wrappedClient = {};
+    for (const method of Object.keys(client.client)) {
+      wrappedClient[method] = function (payload, options) {
+        return client.client[method](payload, {
+          ...options,
+          context: options?.context ? Context.merge(options.context, this[currentClientAddress]) : this[currentClientAddress]
+        });
+      };
+    }
+    yield* Scope.addFinalizer(yield* Effect.scope, Effect.withFiberRuntime(fiber => {
+      internalInterruptors.add(fiber.id());
+      return Effect.void;
+    }));
+    return entityId => {
+      const id = EntityId.make(entityId);
+      return {
+        ...wrappedClient,
+        [currentClientAddress]: ClientAddressTag.context(EntityAddress.make({
+          shardId: getShardId(id),
+          entityId: id,
+          entityType: entity.type
+        }))
+      };
+    };
+  }));
+  const makeClient = entity => clients.get(entity);
+  const clientRespondDiscard = _reply => Effect.void;
+  const makeClientRespond = (entry, write) => reply => {
+    switch (reply._tag) {
+      case "Chunk":
+        {
+          entry.lastChunkId = reply.id;
+          return write({
+            _tag: "Chunk",
+            clientId: 0,
+            requestId: RequestId(reply.requestId),
+            values: reply.values
+          });
+        }
+      case "WithExit":
+        {
+          clientRequests.delete(reply.requestId);
+          return write({
+            _tag: "Exit",
+            clientId: 0,
+            requestId: RequestId(reply.requestId),
+            exit: reply.exit
+          });
+        }
+    }
+  };
+  // --- Entities ---
+  const context = yield* Effect.context();
+  const reaper = yield* EntityReaper;
+  const registerEntity = Effect.fnUntraced(function* (entity, build, options) {
+    if (entityManagers.has(entity.type)) return;
+    const scope = yield* Scope.make();
+    const manager = yield* EntityManager.make(entity, build, {
+      ...options,
+      storage,
+      runnerAddress: Option.getOrThrow(config.runnerAddress),
+      sharding
+    }).pipe(Effect.provide(context.pipe(Context.add(EntityReaper, reaper), Context.add(Scope.Scope, scope), Context.add(Snowflake.Generator, snowflakeGen))));
+    entityManagers.set(entity.type, {
+      entity,
+      scope,
+      manager
+    });
+    yield* Scope.addFinalizer(scope, Effect.sync(() => entityManagers.delete(entity.type)));
+    yield* PubSub.publish(events, EntityRegistered({
+      entity
+    }));
+  });
+  yield* Scope.addFinalizerExit(shardingScope, exit => Effect.forEach(entityManagers.values(), state => Effect.catchAllCause(Scope.close(state.scope, exit), cause => Effect.annotateLogs(Effect.logError("Error closing entity manager", cause), {
+    entity: state.entity.type
+  })), {
+    concurrency: "unbounded",
+    discard: true
+  }));
+  // --- Finalization ---
+  if (Option.isSome(config.runnerAddress)) {
+    const selfAddress = config.runnerAddress.value;
+    // Unregister runner from shard manager when scope is closed
+    yield* Scope.addFinalizer(shardingScope, Effect.gen(function* () {
+      yield* Effect.logDebug("Unregistering runner from shard manager", selfAddress);
+      yield* shardManager.unregister(selfAddress).pipe(Effect.catchAllCause(cause => Effect.logError("Error calling unregister with shard manager", cause)));
+      yield* clearSelfShards;
+    }));
+  }
+  yield* Scope.addFinalizer(shardingScope, Effect.withFiberRuntime(fiber => {
+    MutableRef.set(isShutdown, true);
+    internalInterruptors.add(fiber.id());
+    return Effect.void;
+  }));
+  const sharding = Sharding.of({
+    getRegistrationEvents,
+    getShardId,
+    isShutdown: Effect.sync(() => MutableRef.get(isShutdown)),
+    registerEntity,
+    registerSingleton,
+    makeClient,
+    send: sendLocal,
+    notify: message => notifyLocal(message, false)
+  });
+  return sharding;
+});
 /**
  * @since 1.0.0
  * @category layers
  */
-export const live = internal.live;
-/**
- * Notify the shard manager that shards can now be assigned to this pod.
- *
- * @since 1.0.0
- * @category utils
- */
-export const register = internal.register;
-/**
- * Notify the shard manager that shards must be unassigned from this pod.
- *
- * @since 1.0.0
- * @category utils
- */
-export const unregister = internal.unregister;
-/**
- * Same as `register`, but will automatically call `unregister` when the `Scope` is terminated.
- *
- * @since 1.0.0
- * @category utils
- */
-export const registerScoped = internal.registerScoped;
-/**
- * Start a computation that is guaranteed to run only on a single pod.
- * Each pod should call `registerSingleton` but only a single pod will actually run it at any given time.
- *
- * @since 1.0.0
- * @category utils
- */
-export const registerSingleton = internal.registerSingleton;
-/**
- * Register a new entity type, allowing pods to send messages to entities of this type.
- *
- * @since 1.0.0
- * @category utils
- */
-export const registerEntity = internal.registerEntity;
-/**
- * Register a new topic type, allowing pods to broadcast messages to subscribers.
- *
- * @since 1.0.0
- * @category utils
- */
-export const registerTopic = internal.registerTopic;
-/**
- * Get an object that allows sending messages to a given entity type.
- * You can provide a custom send timeout to override the one globally defined.
- *
- * @since 1.0.0
- * @category utils
- */
-export const messenger = internal.messenger;
-/**
- * Get an object that allows broadcasting messages to a given topic type.
- * You can provide a custom send timeout to override the one globally defined.
- *
- * @since 1.0.0
- * @category utils
- */
-export const broadcaster = internal.broadcaster;
-/**
- * Get the list of pods currently registered to the Shard Manager
- *
- * @since 1.0.0
- * @category utils
- */
-export const getPods = internal.getPods;
-/**
- * Sends a raw message to the local entity manager without performing reties.
- * Those are up to the caller.
- *
- * @since 1.0.0
- * @category utils
- */
-export const sendMessageToLocalEntityManagerWithoutRetries = internal.sendMessageToLocalEntityManagerWithoutRetries;
-/**
- * Gets the list of shardIds assigned to the current Pod
- *
- * @since 1.0.0
- * @category utils
- */
-export const getAssignedShardIds = internal.getAssignedShardIds;
+export const layer = /*#__PURE__*/Layer.scoped(Sharding, make).pipe( /*#__PURE__*/Layer.provide([Snowflake.layerGenerator, EntityReaper.Default]));
+// Utilities
+const ClientAddressTag = /*#__PURE__*/Context.GenericTag("@effect/cluster/Sharding/ClientAddress");
+const currentClientAddress = /*#__PURE__*/Symbol.for(ClientAddressTag.key);
 //# sourceMappingURL=Sharding.js.map
\ No newline at end of file
diff --git a/dist/esm/Sharding.js.map b/dist/esm/Sharding.js.map
index 01d5ae775c17c0ad5d4749e06884c73051d4313d..0707b0f427e7e2084f921c42bcabab99a6e11ce3 100644
--- a/dist/esm/Sharding.js.map
+++ b/dist/esm/Sharding.js.map
@@ -1 +1 @@
-{"version":3,"file":"Sharding.js","names":["internal","ShardingTypeId","Tag","shardingTag","live","register","unregister","registerScoped","registerSingleton","registerEntity","registerTopic","messenger","broadcaster","getPods","sendMessageToLocalEntityManagerWithoutRetries","getAssignedShardIds"],"sources":["../../src/Sharding.ts"],"sourcesContent":[null],"mappings":"AAQA,OAAO,KAAKA,QAAQ,MAAM,wBAAwB;AAelD;;;;AAIA,OAAO,MAAMC,cAAc,GAAkBD,QAAQ,CAACC,cAAc;AA0DpE;;;;AAIA,OAAO,MAAMC,GAAG,GAAGF,QAAQ,CAACG,WAAW;AAEvC;;;;AAIA,OAAO,MAAMC,IAAI,GAAGJ,QAAQ,CAACI,IAAI;AAEjC;;;;;;AAMA,OAAO,MAAMC,QAAQ,GAAyCL,QAAQ,CAACK,QAAQ;AAE/E;;;;;;AAMA,OAAO,MAAMC,UAAU,GAAyCN,QAAQ,CAACM,UAAU;AAEnF;;;;;;AAMA,OAAO,MAAMC,cAAc,GAAuDP,QAAQ,CAACO,cAAc;AAEzG;;;;;;;AAOA,OAAO,MAAMC,iBAAiB,GAGkBR,QAAQ,CAACQ,iBAAiB;AAE1E;;;;;;AAMA,OAAO,MAAMC,cAAc,GAMzBT,QAAQ,CAACS,cAAc;AAEzB;;;;;;AAMA,OAAO,MAAMC,aAAa,GAMxBV,QAAQ,CAACU,aAAa;AAExB;;;;;;;AAOA,OAAO,MAAMC,SAAS,GAEgCX,QAAQ,CAACW,SAAS;AAExE;;;;;;;AAOA,OAAO,MAAMC,WAAW,GAEgCZ,QAAQ,CAACY,WAAW;AAE5E;;;;;;AAMA,OAAO,MAAMC,OAAO,GAA2Eb,QAAQ,CAACa,OAAO;AAE/G;;;;;;;AAOA,OAAO,MAAMC,6CAA6C,GAMtDd,QAAQ,CAACc,6CAA6C;AAE1D;;;;;;AAMA,OAAO,MAAMC,mBAAmB,GAC9Bf,QAAQ,CAACe,mBAAmB","ignoreList":[]}
\ No newline at end of file
+{"version":3,"file":"Sharding.js","names":["RpcClient","RequestId","Arr","Cause","Context","Effect","Equal","Fiber","FiberHandle","FiberMap","FiberRef","constant","HashMap","Iterable","Layer","MutableHashMap","MutableRef","Option","Predicate","PubSub","Schedule","Scope","Stream","EntityNotManagedByRunner","RunnerUnavailable","Persisted","EntityAddress","EntityId","Envelope","EntityManager","EntityReaper","hashString","internalInterruptors","ResourceMap","Message","MessageStorage","Reply","Runners","ShardId","ShardingConfig","EntityRegistered","SingletonRegistered","ShardManagerClient","ShardStorage","SingletonAddress","Snowflake","Sharding","Tag","make","gen","config","runners","shardManager","snowflakeGen","Generator","shardingScope","scope","isShutdown","storage","storageEnabled","noop","shardStorage","entityManagers","Map","shardAssignments","empty","selfShards","Set","acquiredShards","activeShardsLatch","makeLatch","events","unbounded","getRegistrationEvents","fromPubSub","isLocalRunner","address","isSome","runnerAddress","equals","value","getShardId","entityId","Math","abs","numberOfShards","isEntityOnLocalShards","has","shardId","selfAddress","addFinalizerExit","ignore","releaseAll","releasingShards","await","delete","add","unacquiredShards","size","forkIn","syncSingletons","releaseShards","close","acquired","acquire","length","storageReadLatch","open","sleep","pipe","catchAllCause","cause","logWarning","repeat","spaced","entityMessagePollInterval","annotateLogs","package","module","fiber","runner","interruptible","suspend","refresh","flatMap","includes","andThen","void","retry","times","schedule","logError","clearSelfShards","delay","forever","releaseShardsLock","unsafeMakeSemaphore","withPermits","forEach","values","state","manager","interruptShard","concurrency","discard","release","clear","singletons","singletonFibers","withSingletonLock","registerSingleton","fnUntraced","name","run","map","get","set","dieMessage","context","wrappedRun","locally","currentLogAnnotations","never","scoped","provide","orDie","publish","logDebug","running","unsafeHas","shouldBeRunning","fiberId","remove","openStorageReadLatch","storageReadLock","withStorageReadLock","addFinalizer","sentRequestIds","sentRequestIdSets","unsafeClose","take","messages","unprocessedMessages","currentSentRequestIds","send","message","index","_tag","envelope","requestId","entityType","isProcessing","isProcessingFor","resumptionState","entityResumptionState","unprocessed","interrupts","error","failureOption","isNone","saveReply","ReplyWithContext","fromDefect","id","unsafeNext","defect","squash","resumeEntityFromStorage","whileLoop","while","step","body","oldest","unsafeHead","ensuring","lastReceivedMessage","resumeEntityFromStorageImpl","getOrThrow","done","messageIds","push","unprocessedMessagesById","sendWithRetry","catchTags","fail","interrupt","MailboxFull","sendRetryInterval","AlreadyProcessingMessage","sync","e","effect","entity","sendLocal","simulateRemoteSerialization","notifyLocal","notify","isTransientError","or","is","sendOutgoing","retries","catchIf","maybeRunner","rpc","annotations","die","shardManagerTimeoutFiber","extend","startShardManagerTimeout","shardManagerUnavailableTimeout","onlyIfMissing","stopShardManagerTimeout","machineId","register","setMachineId","mailbox","shardingEvents","startedLatch","eventsFiber","takeAll","event","shard","shards","forkScoped","syncFiber","syncAssignments","refreshAssignmentsInterval","joinAll","zipRight","exponential","union","assignments","getAssignments","clientRequests","clients","client","makeNoSerialization","protocol","supportsAck","generateRequestId","onFromClient","options","unsafeGet","ClientAddressTag","getCurrentFiber","requests","tag","respond","entry","currentContext","makeClientRespond","write","clientRespondDiscard","OutgoingRequest","makeRequest","payload","headers","traceId","spanId","sampled","lastReceivedReply","none","OutgoingEnvelope","AckChunk","replyId","lastChunkId","isTransientInterrupt","interruptors","some","Interrupt","wrappedClient","method","Object","keys","merge","currentClientAddress","withFiberRuntime","type","makeClient","_reply","reply","clientId","exit","reaper","registerEntity","build","sharding","unregister","of","layer","layerGenerator","Default","GenericTag","Symbol","for","key"],"sources":["../../src/Sharding.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/esm/ShardingConfig.js b/dist/esm/ShardingConfig.js
index 857f54b1f52b262d02346b312e856d79973578ad..1e4e1373f4cadc3e7c8368fdadb876d6d3162f63 100644
--- a/dist/esm/ShardingConfig.js
+++ b/dist/esm/ShardingConfig.js
@@ -1,33 +1,96 @@
-import * as internal from "./internal/shardingConfig.js";
 /**
  * @since 1.0.0
- * @category symbols
  */
-export const ShardingConfigTypeId = internal.ShardingConfigTypeId;
+import * as Config from "effect/Config";
+import * as ConfigProvider from "effect/ConfigProvider";
+import * as Context from "effect/Context";
+import * as Duration from "effect/Duration";
+import * as Effect from "effect/Effect";
+import * as Layer from "effect/Layer";
+import * as Option from "effect/Option";
+import { RunnerAddress } from "./RunnerAddress.js";
 /**
+ * Represents the configuration for the `Sharding` service on a given runner.
+ *
  * @since 1.0.0
- * @category context
+ * @category models
  */
-export const ShardingConfig = internal.shardingConfigTag;
+export class ShardingConfig extends /*#__PURE__*/Context.Tag("@effect/cluster/ShardingConfig")() {}
+const defaultRunnerAddress = /*#__PURE__*/RunnerAddress.make({
+  host: "localhost",
+  port: 34431
+});
 /**
- * Provides the default values for the ShardingConfig.
- *
  * @since 1.0.0
- * @category layers
+ * @category defaults
  */
-export const defaults = internal.defaults;
+export const defaults = {
+  runnerAddress: /*#__PURE__*/Option.some(defaultRunnerAddress),
+  serverVersion: 1,
+  numberOfShards: 300,
+  shardManagerAddress: /*#__PURE__*/RunnerAddress.make({
+    host: "localhost",
+    port: 8080
+  }),
+  shardManagerUnavailableTimeout: /*#__PURE__*/Duration.minutes(10),
+  entityMailboxCapacity: 4096,
+  entityMaxIdleTime: /*#__PURE__*/Duration.minutes(1),
+  entityTerminationTimeout: /*#__PURE__*/Duration.seconds(15),
+  entityMessagePollInterval: /*#__PURE__*/Duration.seconds(10),
+  entityReplyPollInterval: /*#__PURE__*/Duration.millis(200),
+  sendRetryInterval: /*#__PURE__*/Duration.millis(100),
+  refreshAssignmentsInterval: /*#__PURE__*/Duration.minutes(5),
+  simulateRemoteSerialization: true
+};
 /**
- * Provides the ShardingConfig, values that are omitted will be read from the defaults
- *
  * @since 1.0.0
- * @category layers
+ * @category Layers
  */
-export const withDefaults = internal.withDefaults;
+export const layer = options => Layer.succeed(ShardingConfig, {
+  ...defaults,
+  ...options
+});
+/**
+ * @since 1.0.0
+ * @category defaults
+ */
+export const layerDefaults = /*#__PURE__*/layer();
+/**
+ * @since 1.0.0
+ * @category Config
+ */
+export const config = /*#__PURE__*/Config.all({
+  runnerAddress: /*#__PURE__*/Config.all({
+    host: Config.string("host").pipe(Config.withDefault(defaultRunnerAddress.host), Config.withDescription("The hostname or IP address of the runner.")),
+    port: Config.integer("port").pipe(Config.withDefault(defaultRunnerAddress.port), Config.withDescription("The port used for inter-runner communication."))
+  }).pipe( /*#__PURE__*/Config.map(options => RunnerAddress.make(options)), Config.option),
+  serverVersion: /*#__PURE__*/Config.integer("serverVersion").pipe( /*#__PURE__*/Config.withDefault(defaults.serverVersion), /*#__PURE__*/Config.withDescription("The version of the current runner.")),
+  numberOfShards: /*#__PURE__*/Config.integer("numberOfShards").pipe( /*#__PURE__*/Config.withDefault(defaults.numberOfShards), /*#__PURE__*/Config.withDescription("The number of shards to allocate to a runner.")),
+  shardManagerAddress: /*#__PURE__*/Config.all({
+    host: Config.string("shardManagerHost").pipe(Config.withDefault(defaults.shardManagerAddress.host), Config.withDescription("The host of the shard manager.")),
+    port: Config.integer("shardManagerPort").pipe(Config.withDefault(defaults.shardManagerAddress.port), Config.withDescription("The port of the shard manager."))
+  }).pipe( /*#__PURE__*/Config.map(options => RunnerAddress.make(options))),
+  shardManagerUnavailableTimeout: /*#__PURE__*/Config.duration("shardManagerUnavailableTimeout").pipe( /*#__PURE__*/Config.withDefault(defaults.shardManagerUnavailableTimeout), /*#__PURE__*/Config.withDescription("If the shard is unavilable for this duration, all the shard assignments will be reset.")),
+  entityMailboxCapacity: /*#__PURE__*/Config.integer("entityMailboxCapacity").pipe( /*#__PURE__*/Config.withDefault(defaults.entityMailboxCapacity), /*#__PURE__*/Config.withDescription("The default capacity of the mailbox for entities.")),
+  entityMaxIdleTime: /*#__PURE__*/Config.duration("entityMaxIdleTime").pipe( /*#__PURE__*/Config.withDefault(defaults.entityMaxIdleTime), /*#__PURE__*/Config.withDescription("The maximum duration of inactivity (i.e. without receiving a message) after which an entity will be interrupted.")),
+  entityTerminationTimeout: /*#__PURE__*/Config.duration("entityTerminationTimeout").pipe( /*#__PURE__*/Config.withDefault(defaults.entityTerminationTimeout), /*#__PURE__*/Config.withDescription("The maximum duration of time to wait for an entity to terminate.")),
+  entityMessagePollInterval: /*#__PURE__*/Config.duration("entityMessagePollInterval").pipe( /*#__PURE__*/Config.withDefault(defaults.entityMessagePollInterval), /*#__PURE__*/Config.withDescription("The interval at which to poll for unprocessed messages from storage.")),
+  entityReplyPollInterval: /*#__PURE__*/Config.duration("entityReplyPollInterval").pipe( /*#__PURE__*/Config.withDefault(defaults.entityReplyPollInterval), /*#__PURE__*/Config.withDescription("The interval at which to poll for client replies from storage.")),
+  sendRetryInterval: /*#__PURE__*/Config.duration("sendRetryInterval").pipe( /*#__PURE__*/Config.withDefault(defaults.sendRetryInterval), /*#__PURE__*/Config.withDescription("The interval to retry a send if EntityNotManagedByRunner is returned.")),
+  refreshAssignmentsInterval: /*#__PURE__*/Config.duration("refreshAssignmentsInterval").pipe( /*#__PURE__*/Config.withDefault(defaults.refreshAssignmentsInterval), /*#__PURE__*/Config.withDescription("The interval at which to refresh shard assignments.")),
+  simulateRemoteSerialization: /*#__PURE__*/Config.boolean("simulateRemoteSerialization").pipe( /*#__PURE__*/Config.withDefault(defaults.simulateRemoteSerialization), /*#__PURE__*/Config.withDescription("Simulate serialization and deserialization to remote runners for local entities."))
+});
+/**
+ * @since 1.0.0
+ * @category Config
+ */
+export const configFromEnv = /*#__PURE__*/config.pipe( /*#__PURE__*/Effect.withConfigProvider( /*#__PURE__*/ConfigProvider.fromEnv().pipe(ConfigProvider.constantCase)));
 /**
- * Reads the ShardingConfig from the effect/ConfigProvider
- *
  * @since 1.0.0
- * @category layers
+ * @category Layers
  */
-export const fromConfig = internal.fromConfig;
+export const layerFromEnv = options => Layer.effect(ShardingConfig, options ? Effect.map(configFromEnv, config => ({
+  ...config,
+  ...options
+})) : configFromEnv);
 //# sourceMappingURL=ShardingConfig.js.map
\ No newline at end of file
diff --git a/dist/esm/ShardingConfig.js.map b/dist/esm/ShardingConfig.js.map
index 8ca8ee71017297f087599d7a4a93eb5b7e251056..80ba5d7be96a4d05bfc701e6b75ee7e2b2181897 100644
--- a/dist/esm/ShardingConfig.js.map
+++ b/dist/esm/ShardingConfig.js.map
@@ -1 +1 @@
-{"version":3,"file":"ShardingConfig.js","names":["internal","ShardingConfigTypeId","ShardingConfig","shardingConfigTag","defaults","withDefaults","fromConfig"],"sources":["../../src/ShardingConfig.ts"],"sourcesContent":[null],"mappings":"AAOA,OAAO,KAAKA,QAAQ,MAAM,8BAA8B;AAExD;;;;AAIA,OAAO,MAAMC,oBAAoB,GAAkBD,QAAQ,CAACC,oBAAoB;AAkChF;;;;AAIA,OAAO,MAAMC,cAAc,GAAgDF,QAAQ,CAACG,iBAAiB;AAErG;;;;;;AAMA,OAAO,MAAMC,QAAQ,GAAgCJ,QAAQ,CAACI,QAAQ;AAEtE;;;;;;AAMA,OAAO,MAAMC,YAAY,GAAsEL,QAAQ,CAACK,YAAY;AAEpH;;;;;;AAMA,OAAO,MAAMC,UAAU,GAAyDN,QAAQ,CAACM,UAAU","ignoreList":[]}
\ No newline at end of file
+{"version":3,"file":"ShardingConfig.js","names":["Config","ConfigProvider","Context","Duration","Effect","Layer","Option","RunnerAddress","ShardingConfig","Tag","defaultRunnerAddress","make","host","port","defaults","runnerAddress","some","serverVersion","numberOfShards","shardManagerAddress","shardManagerUnavailableTimeout","minutes","entityMailboxCapacity","entityMaxIdleTime","entityTerminationTimeout","seconds","entityMessagePollInterval","entityReplyPollInterval","millis","sendRetryInterval","refreshAssignmentsInterval","simulateRemoteSerialization","layer","options","succeed","layerDefaults","config","all","string","pipe","withDefault","withDescription","integer","map","option","duration","boolean","configFromEnv","withConfigProvider","fromEnv","constantCase","layerFromEnv","effect"],"sources":["../../src/ShardingConfig.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/esm/ShardingRegistrationEvent.js b/dist/esm/ShardingRegistrationEvent.js
index cb2db660594acc797fe236dc10a7dce7549dca4b..3f7d59232fae73686e8a48076af0863c04d90f73 100644
--- a/dist/esm/ShardingRegistrationEvent.js
+++ b/dist/esm/ShardingRegistrationEvent.js
@@ -1,36 +1,26 @@
 /**
- * Constructs and event that occurs when a new EntityType gets registered.
- *
  * @since 1.0.0
- * @category constructors
  */
-export function EntityRegistered(entityType) {
-  return {
-    _tag: "EntityRegistered",
-    entityType
-  };
-}
+import * as Data from "effect/Data";
 /**
- * Constructs a new event that occurs when a new Singleton is registered.
- *
  * @since 1.0.0
- * @category constructors
+ * @category pattern matching
  */
-export function SingletonRegistered(name) {
-  return {
-    _tag: "SingletonRegistered",
-    name
-  };
-}
-/**
- * Constructs a new event that occurs when a topic is Registered.
- * @since 1.0.0
- * @category constructors
- */
-export function TopicRegistered(topicType) {
-  return {
-    _tag: "TopicRegistered",
-    topicType
-  };
-}
+export const {
+  /**
+   * @since 1.0.0
+   * @category pattern matching
+   */
+  $match: match,
+  /**
+   * @since 1.0.0
+   * @category constructors
+   */
+  EntityRegistered,
+  /**
+   * @since 1.0.0
+   * @category constructors
+   */
+  SingletonRegistered
+} = /*#__PURE__*/Data.taggedEnum();
 //# sourceMappingURL=ShardingRegistrationEvent.js.map
\ No newline at end of file
diff --git a/dist/esm/ShardingRegistrationEvent.js.map b/dist/esm/ShardingRegistrationEvent.js.map
index a8d1c26a2e2482bfb8c002fdd4c66b290cd9b2a7..a7d2e0b7e2007c9e328eaedcd454014304213251 100644
--- a/dist/esm/ShardingRegistrationEvent.js.map
+++ b/dist/esm/ShardingRegistrationEvent.js.map
@@ -1 +1 @@
-{"version":3,"file":"ShardingRegistrationEvent.js","names":["EntityRegistered","entityType","_tag","SingletonRegistered","name","TopicRegistered","topicType"],"sources":["../../src/ShardingRegistrationEvent.ts"],"sourcesContent":[null],"mappings":"AAWA;;;;;;AAMA,OAAM,SAAUA,gBAAgBA,CAC9BC,UAAyC;EAEzC,OAAQ;IAAEC,IAAI,EAAE,kBAAkB;IAAED;EAAU,CAAE;AAClD;AAOA;;;;;;AAMA,OAAM,SAAUE,mBAAmBA,CAACC,IAAY;EAC9C,OAAQ;IAAEF,IAAI,EAAE,qBAAqB;IAAEE;EAAI,CAAE;AAC/C;AAOA;;;;;AAKA,OAAM,SAAUC,eAAeA,CAC7BC,SAAuC;EAEvC,OAAQ;IAAEJ,IAAI,EAAE,iBAAiB;IAAEI;EAAS,CAAE;AAChD","ignoreList":[]}
\ No newline at end of file
+{"version":3,"file":"ShardingRegistrationEvent.js","names":["Data","$match","match","EntityRegistered","SingletonRegistered","taggedEnum"],"sources":["../../src/ShardingRegistrationEvent.ts"],"sourcesContent":[null],"mappings":"AAAA;;;AAGA,OAAO,KAAKA,IAAI,MAAM,aAAa;AAqCnC;;;;AAIA,OAAO,MAAM;EACX;;;;EAIAC,MAAM,EAAEC,KAAK;EACb;;;;EAIAC,gBAAgB;EAChB;;;;EAIAC;AAAmB,CACpB,gBAAGJ,IAAI,CAACK,UAAU,EAA6B","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/esm/Singleton.js b/dist/esm/Singleton.js
new file mode 100644
index 0000000000000000000000000000000000000000..abe3cbc25d1bc84082b75108691f5ebd5627cb77
--- /dev/null
+++ b/dist/esm/Singleton.js
@@ -0,0 +1,15 @@
+/**
+ * @since 1.0.0
+ */
+import * as Effect from "effect/Effect";
+import * as Layer from "effect/Layer";
+import { Sharding } from "./Sharding.js";
+/**
+ * @since 1.0.0
+ * @category constructors
+ */
+export const make = (name, run) => Layer.effectDiscard(Effect.gen(function* () {
+  const sharding = yield* Sharding;
+  yield* sharding.registerSingleton(name, run);
+}));
+//# sourceMappingURL=Singleton.js.map
\ No newline at end of file
diff --git a/dist/esm/Singleton.js.map b/dist/esm/Singleton.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..9a35e303cb325ac4fc9d01c6e43061de5af393a1
--- /dev/null
+++ b/dist/esm/Singleton.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"Singleton.js","names":["Effect","Layer","Sharding","make","name","run","effectDiscard","gen","sharding","registerSingleton"],"sources":["../../src/Singleton.ts"],"sourcesContent":[null],"mappings":"AAAA;;;AAGA,OAAO,KAAKA,MAAM,MAAM,eAAe;AACvC,OAAO,KAAKC,KAAK,MAAM,cAAc;AAErC,SAASC,QAAQ,QAAQ,eAAe;AAExC;;;;AAIA,OAAO,MAAMC,IAAI,GAAGA,CAClBC,IAAY,EACZC,GAA8B,KAE9BJ,KAAK,CAACK,aAAa,CAACN,MAAM,CAACO,GAAG,CAAC,aAAS;EACtC,MAAMC,QAAQ,GAAG,OAAON,QAAQ;EAChC,OAAOM,QAAQ,CAACC,iBAAiB,CAACL,IAAI,EAAEC,GAAG,CAAC;AAC9C,CAAC,CAAC,CAAC","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/esm/SingletonAddress.js b/dist/esm/SingletonAddress.js
new file mode 100644
index 0000000000000000000000000000000000000000..143f162aaaad7c052bdbd139941b1d484cb496e7
--- /dev/null
+++ b/dist/esm/SingletonAddress.js
@@ -0,0 +1,40 @@
+/**
+ * @since 1.0.0
+ */
+import * as Equal from "effect/Equal";
+import * as Hash from "effect/Hash";
+import * as Schema from "effect/Schema";
+import { ShardId } from "./ShardId.js";
+/**
+ * @since 1.0.0
+ * @category Address
+ */
+export const TypeId = /*#__PURE__*/Symbol.for("@effect/cluster/SingletonAddress");
+/**
+ * Represents the unique address of an singleton within the cluster.
+ *
+ * @since 1.0.0
+ * @category Address
+ */
+export class SingletonAddress extends /*#__PURE__*/Schema.Class("@effect/cluster/SingletonAddress")({
+  shardId: ShardId,
+  name: Schema.NonEmptyTrimmedString
+}) {
+  /**
+   * @since 1.0.0
+   */
+  [TypeId] = TypeId;
+  /**
+   * @since 1.0.0
+   */
+  [Hash.symbol]() {
+    return Hash.cached(this)(Hash.string(`${this.shardId}:${this.name}`));
+  }
+  /**
+   * @since 1.0.0
+   */
+  [Equal.symbol](that) {
+    return this.shardId === that.shardId && this.name === that.name;
+  }
+}
+//# sourceMappingURL=SingletonAddress.js.map
\ No newline at end of file
diff --git a/dist/esm/SingletonAddress.js.map b/dist/esm/SingletonAddress.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..f2eefe2bad5a00725eca84e8892d999b603736ed
--- /dev/null
+++ b/dist/esm/SingletonAddress.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"SingletonAddress.js","names":["Equal","Hash","Schema","ShardId","TypeId","Symbol","for","SingletonAddress","Class","shardId","name","NonEmptyTrimmedString","symbol","cached","string","that"],"sources":["../../src/SingletonAddress.ts"],"sourcesContent":[null],"mappings":"AAAA;;;AAGA,OAAO,KAAKA,KAAK,MAAM,cAAc;AACrC,OAAO,KAAKC,IAAI,MAAM,aAAa;AACnC,OAAO,KAAKC,MAAM,MAAM,eAAe;AACvC,SAASC,OAAO,QAAQ,cAAc;AAEtC;;;;AAIA,OAAO,MAAMC,MAAM,gBAAkBC,MAAM,CAACC,GAAG,CAAC,kCAAkC,CAAC;AAQnF;;;;;;AAMA,OAAM,MAAOC,gBAAiB,sBAAQL,MAAM,CAACM,KAAK,CAAmB,kCAAkC,CAAC,CAAC;EACvGC,OAAO,EAAEN,OAAO;EAChBO,IAAI,EAAER,MAAM,CAACS;CACd,CAAC;EACA;;;EAGS,CAACP,MAAM,IAAIA,MAAM;EAC1B;;;EAGA,CAACH,IAAI,CAACW,MAAM,IAAC;IACX,OAAOX,IAAI,CAACY,MAAM,CAAC,IAAI,CAAC,CAACZ,IAAI,CAACa,MAAM,CAAC,GAAG,IAAI,CAACL,OAAO,IAAI,IAAI,CAACC,IAAI,EAAE,CAAC,CAAC;EACvE;EACA;;;EAGA,CAACV,KAAK,CAACY,MAAM,EAAEG,IAAsB;IACnC,OAAO,IAAI,CAACN,OAAO,KAAKM,IAAI,CAACN,OAAO,IAAI,IAAI,CAACC,IAAI,KAAKK,IAAI,CAACL,IAAI;EACjE","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/esm/Snowflake.js b/dist/esm/Snowflake.js
new file mode 100644
index 0000000000000000000000000000000000000000..90745e283734d6be40b300c5f523c984ced45444
--- /dev/null
+++ b/dist/esm/Snowflake.js
@@ -0,0 +1,117 @@
+import * as Context from "effect/Context";
+import * as DateTime from "effect/DateTime";
+import * as Effect from "effect/Effect";
+import { identity } from "effect/Function";
+import * as Layer from "effect/Layer";
+import * as Schema from "effect/Schema";
+/**
+ * @since 1.0.0
+ * @category Symbols
+ */
+export const TypeId = /*#__PURE__*/Symbol.for("@effect/cluster/Snowflake");
+/**
+ * @since 1.0.0
+ * @category Models
+ */
+export const Snowflake = input => typeof input === "string" ? BigInt(input) : input;
+/**
+ * @since 1.0.0
+ * @category Schemas
+ */
+export const SnowflakeFromBigInt = /*#__PURE__*/Schema.BigIntFromSelf.pipe( /*#__PURE__*/Schema.brand(TypeId));
+/**
+ * @since 1.0.0
+ * @category Schemas
+ */
+export const SnowflakeFromString = /*#__PURE__*/Schema.BigInt.pipe( /*#__PURE__*/Schema.brand(TypeId));
+/**
+ * @since 1.0.0
+ * @category Epoch
+ */
+export const constEpochMillis = /*#__PURE__*/Date.UTC(2025, 0, 1);
+const sinceUnixEpoch = constEpochMillis - /*#__PURE__*/Date.UTC(1970, 0, 1);
+const constBigInt12 = /*#__PURE__*/BigInt(12);
+const constBigInt22 = /*#__PURE__*/BigInt(22);
+const constBigInt1024 = /*#__PURE__*/BigInt(1024);
+const constBigInt4096 = /*#__PURE__*/BigInt(4096);
+/**
+ * @since 1.0.0
+ * @category constructors
+ */
+export const make = options => BigInt(options.timestamp - constEpochMillis) << constBigInt22 | BigInt(options.machineId % 1024) << constBigInt12 | BigInt(options.sequence % 4096);
+/**
+ * @since 1.0.0
+ * @category Parts
+ */
+export const timestamp = snowflake => Number(snowflake >> constBigInt22) + sinceUnixEpoch;
+/**
+ * @since 1.0.0
+ * @category Parts
+ */
+export const dateTime = snowflake => DateTime.unsafeMake(timestamp(snowflake));
+/**
+ * @since 1.0.0
+ * @category Parts
+ */
+export const machineId = snowflake => Number((snowflake >> constBigInt12) % constBigInt1024);
+/**
+ * @since 1.0.0
+ * @category Parts
+ */
+export const sequence = snowflake => Number(snowflake % constBigInt4096);
+/**
+ * @since 1.0.0
+ * @category Parts
+ */
+export const toParts = snowflake => ({
+  timestamp: timestamp(snowflake),
+  machineId: machineId(snowflake),
+  sequence: sequence(snowflake)
+});
+/**
+ * @since 1.0.0
+ * @category Generator
+ */
+export const makeGenerator = /*#__PURE__*/Effect.gen(function* () {
+  let machineId = Math.floor(Math.random() * 1024);
+  const clock = yield* Effect.clock;
+  let sequence = 0;
+  let sequenceAt = clock.unsafeCurrentTimeMillis();
+  return identity({
+    setMachineId: newMachineId => Effect.sync(() => {
+      machineId = newMachineId;
+    }),
+    unsafeNext() {
+      let now = clock.unsafeCurrentTimeMillis();
+      // account for clock drift, only allow time to move forward
+      if (now < sequenceAt) {
+        now = sequenceAt;
+      } else if (now > sequenceAt) {
+        // reset sequence if we're in a new millisecond
+        sequence = 0;
+        sequenceAt = now;
+      } else if (sequence >= 1024) {
+        // if we've hit the max sequence for this millisecond, go to the next
+        // millisecond
+        sequenceAt++;
+        sequence = 0;
+      }
+      return make({
+        machineId,
+        sequence: sequence++,
+        timestamp: sequenceAt
+      });
+    }
+  });
+});
+/**
+ * @since 1.0.0
+ * @category Generator
+ */
+export class Generator extends /*#__PURE__*/Context.Tag("@effect/cluster/Snowflake/Generator")() {}
+/**
+ * @since 1.0.0
+ * @category Generator
+ */
+export const layerGenerator = /*#__PURE__*/Layer.effect(Generator, makeGenerator);
+//# sourceMappingURL=Snowflake.js.map
\ No newline at end of file
diff --git a/dist/esm/Snowflake.js.map b/dist/esm/Snowflake.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..1e88ad34511f22be1e60fa1011e8d1167cf9d101
--- /dev/null
+++ b/dist/esm/Snowflake.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"Snowflake.js","names":["Context","DateTime","Effect","identity","Layer","Schema","TypeId","Symbol","for","Snowflake","input","BigInt","SnowflakeFromBigInt","BigIntFromSelf","pipe","brand","SnowflakeFromString","constEpochMillis","Date","UTC","sinceUnixEpoch","constBigInt12","constBigInt22","constBigInt1024","constBigInt4096","make","options","timestamp","machineId","sequence","snowflake","Number","dateTime","unsafeMake","toParts","makeGenerator","gen","Math","floor","random","clock","sequenceAt","unsafeCurrentTimeMillis","setMachineId","newMachineId","sync","unsafeNext","now","Generator","Tag","layerGenerator","effect"],"sources":["../../src/Snowflake.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/esm/SocketRunner.js b/dist/esm/SocketRunner.js
new file mode 100644
index 0000000000000000000000000000000000000000..630079a093f3ced47de77ef961ffffb25c522db7
--- /dev/null
+++ b/dist/esm/SocketRunner.js
@@ -0,0 +1,31 @@
+/**
+ * @since 1.0.0
+ */
+import { SocketServer } from "@effect/platform/SocketServer";
+import * as RpcServer from "@effect/rpc/RpcServer";
+import * as Effect from "effect/Effect";
+import * as Layer from "effect/Layer";
+import * as Runners from "./Runners.js";
+import * as RunnerServer from "./RunnerServer.js";
+import * as Sharding from "./Sharding.js";
+import * as ShardManager from "./ShardManager.js";
+import * as ShardStorage from "./ShardStorage.js";
+const withLogAddress = layer => Layer.effectDiscard(Effect.gen(function* () {
+  const server = yield* SocketServer;
+  const address = server.address._tag === "UnixAddress" ? server.address.path : `${server.address.hostname}:${server.address.port}`;
+  yield* Effect.annotateLogs(Effect.logInfo(`Listening on: ${address}`), {
+    package: "@effect/cluster",
+    service: "Runner"
+  });
+})).pipe(Layer.provideMerge(layer));
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layer = /*#__PURE__*/RunnerServer.layerWithClients.pipe(withLogAddress, /*#__PURE__*/Layer.provide(RpcServer.layerProtocolSocketServer));
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layerClientOnly = /*#__PURE__*/Sharding.layer.pipe( /*#__PURE__*/Layer.provideMerge(Runners.layerRpc), /*#__PURE__*/Layer.provide(ShardManager.layerClientRpc), /*#__PURE__*/Layer.provide(ShardStorage.layerNoop));
+//# sourceMappingURL=SocketRunner.js.map
\ No newline at end of file
diff --git a/dist/esm/SocketRunner.js.map b/dist/esm/SocketRunner.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..cb17862e42adf7d200aaaa78d6b72c1ae92a2ccf
--- /dev/null
+++ b/dist/esm/SocketRunner.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"SocketRunner.js","names":["SocketServer","RpcServer","Effect","Layer","Runners","RunnerServer","Sharding","ShardManager","ShardStorage","withLogAddress","layer","effectDiscard","gen","server","address","_tag","path","hostname","port","annotateLogs","logInfo","package","service","pipe","provideMerge","layerWithClients","provide","layerProtocolSocketServer","layerClientOnly","layerRpc","layerClientRpc","layerNoop"],"sources":["../../src/SocketRunner.ts"],"sourcesContent":[null],"mappings":"AAAA;;;AAGA,SAASA,YAAY,QAAQ,+BAA+B;AAE5D,OAAO,KAAKC,SAAS,MAAM,uBAAuB;AAClD,OAAO,KAAKC,MAAM,MAAM,eAAe;AACvC,OAAO,KAAKC,KAAK,MAAM,cAAc;AAErC,OAAO,KAAKC,OAAO,MAAM,cAAc;AACvC,OAAO,KAAKC,YAAY,MAAM,mBAAmB;AACjD,OAAO,KAAKC,QAAQ,MAAM,eAAe;AAEzC,OAAO,KAAKC,YAAY,MAAM,mBAAmB;AACjD,OAAO,KAAKC,YAAY,MAAM,mBAAmB;AAEjD,MAAMC,cAAc,GAAaC,KAA2B,IAC1DP,KAAK,CAACQ,aAAa,CAACT,MAAM,CAACU,GAAG,CAAC,aAAS;EACtC,MAAMC,MAAM,GAAG,OAAOb,YAAY;EAClC,MAAMc,OAAO,GAAGD,MAAM,CAACC,OAAO,CAACC,IAAI,KAAK,aAAa,GACjDF,MAAM,CAACC,OAAO,CAACE,IAAI,GACnB,GAAGH,MAAM,CAACC,OAAO,CAACG,QAAQ,IAAIJ,MAAM,CAACC,OAAO,CAACI,IAAI,EAAE;EACvD,OAAOhB,MAAM,CAACiB,YAAY,CAACjB,MAAM,CAACkB,OAAO,CAAC,iBAAiBN,OAAO,EAAE,CAAC,EAAE;IACrEO,OAAO,EAAE,iBAAiB;IAC1BC,OAAO,EAAE;GACV,CAAC;AACJ,CAAC,CAAC,CAAC,CAACC,IAAI,CAACpB,KAAK,CAACqB,YAAY,CAACd,KAAK,CAAC,CAAC;AAErC;;;;AAIA,OAAO,MAAMA,KAAK,gBASdL,YAAY,CAACoB,gBAAgB,CAACF,IAAI,CACpCd,cAAc,eACdN,KAAK,CAACuB,OAAO,CAACzB,SAAS,CAAC0B,yBAAyB,CAAC,CACnD;AAED;;;;AAIA,OAAO,MAAMC,eAAe,gBAIxBtB,QAAQ,CAACI,KAAK,CAACa,IAAI,eACrBpB,KAAK,CAACqB,YAAY,CAACpB,OAAO,CAACyB,QAAQ,CAAC,eACpC1B,KAAK,CAACuB,OAAO,CAACnB,YAAY,CAACuB,cAAc,CAAC,eAC1C3B,KAAK,CAACuB,OAAO,CAAClB,YAAY,CAACuB,SAAS,CAAC,CACtC","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/esm/SocketShardManager.js b/dist/esm/SocketShardManager.js
new file mode 100644
index 0000000000000000000000000000000000000000..0ea8cc2e8ff02ea11f4d565c44162450b71b19b3
--- /dev/null
+++ b/dist/esm/SocketShardManager.js
@@ -0,0 +1,24 @@
+/**
+ * @since 1.0.0
+ */
+import { SocketServer } from "@effect/platform/SocketServer";
+import * as RpcServer from "@effect/rpc/RpcServer";
+import * as Effect from "effect/Effect";
+import * as Layer from "effect/Layer";
+import * as MessageStorage from "./MessageStorage.js";
+import * as Runners from "./Runners.js";
+import * as ShardManager from "./ShardManager.js";
+const withLogAddress = layer => Layer.effectDiscard(Effect.gen(function* () {
+  const server = yield* SocketServer;
+  const address = server.address._tag === "UnixAddress" ? server.address.path : `${server.address.hostname}:${server.address.port}`;
+  yield* Effect.annotateLogs(Effect.logInfo(`Listening on: ${address}`), {
+    package: "@effect/cluster",
+    service: "ShardManager"
+  });
+})).pipe(Layer.provideMerge(layer));
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layer = /*#__PURE__*/ShardManager.layerServer.pipe(withLogAddress, /*#__PURE__*/Layer.provide(RpcServer.layerProtocolSocketServer), /*#__PURE__*/Layer.provideMerge(ShardManager.layer), /*#__PURE__*/Layer.provide(Runners.layerRpc), /*#__PURE__*/Layer.provide(MessageStorage.layerNoop));
+//# sourceMappingURL=SocketShardManager.js.map
\ No newline at end of file
diff --git a/dist/esm/SocketShardManager.js.map b/dist/esm/SocketShardManager.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..385553f3a02df6195d34ac3b1373fefaed9440e6
--- /dev/null
+++ b/dist/esm/SocketShardManager.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"SocketShardManager.js","names":["SocketServer","RpcServer","Effect","Layer","MessageStorage","Runners","ShardManager","withLogAddress","layer","effectDiscard","gen","server","address","_tag","path","hostname","port","annotateLogs","logInfo","package","service","pipe","provideMerge","layerServer","provide","layerProtocolSocketServer","layerRpc","layerNoop"],"sources":["../../src/SocketShardManager.ts"],"sourcesContent":[null],"mappings":"AAAA;;;AAGA,SAASA,YAAY,QAAQ,+BAA+B;AAE5D,OAAO,KAAKC,SAAS,MAAM,uBAAuB;AAClD,OAAO,KAAKC,MAAM,MAAM,eAAe;AACvC,OAAO,KAAKC,KAAK,MAAM,cAAc;AACrC,OAAO,KAAKC,cAAc,MAAM,qBAAqB;AAErD,OAAO,KAAKC,OAAO,MAAM,cAAc;AAEvC,OAAO,KAAKC,YAAY,MAAM,mBAAmB;AAGjD,MAAMC,cAAc,GAAaC,KAA2B,IAC1DL,KAAK,CAACM,aAAa,CAACP,MAAM,CAACQ,GAAG,CAAC,aAAS;EACtC,MAAMC,MAAM,GAAG,OAAOX,YAAY;EAClC,MAAMY,OAAO,GAAGD,MAAM,CAACC,OAAO,CAACC,IAAI,KAAK,aAAa,GACjDF,MAAM,CAACC,OAAO,CAACE,IAAI,GACnB,GAAGH,MAAM,CAACC,OAAO,CAACG,QAAQ,IAAIJ,MAAM,CAACC,OAAO,CAACI,IAAI,EAAE;EACvD,OAAOd,MAAM,CAACe,YAAY,CAACf,MAAM,CAACgB,OAAO,CAAC,iBAAiBN,OAAO,EAAE,CAAC,EAAE;IACrEO,OAAO,EAAE,iBAAiB;IAC1BC,OAAO,EAAE;GACV,CAAC;AACJ,CAAC,CAAC,CAAC,CAACC,IAAI,CAAClB,KAAK,CAACmB,YAAY,CAACd,KAAK,CAAC,CAAC;AAErC;;;;AAIA,OAAO,MAAMA,KAAK,gBAUdF,YAAY,CAACiB,WAAW,CAACF,IAAI,CAC/Bd,cAAc,eACdJ,KAAK,CAACqB,OAAO,CAACvB,SAAS,CAACwB,yBAAyB,CAAC,eAClDtB,KAAK,CAACmB,YAAY,CAAChB,YAAY,CAACE,KAAK,CAAC,eACtCL,KAAK,CAACqB,OAAO,CAACnB,OAAO,CAACqB,QAAQ,CAAC,eAC/BvB,KAAK,CAACqB,OAAO,CAACpB,cAAc,CAACuB,SAAS,CAAC,CACxC","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/esm/SqlMessageStorage.js b/dist/esm/SqlMessageStorage.js
new file mode 100644
index 0000000000000000000000000000000000000000..c2d97371d690c98754acc5600b98c8b625224ca8
--- /dev/null
+++ b/dist/esm/SqlMessageStorage.js
@@ -0,0 +1,658 @@
+/**
+ * @since 1.0.0
+ */
+import * as SqlClient from "@effect/sql/SqlClient";
+import * as Arr from "effect/Array";
+import * as Effect from "effect/Effect";
+import * as Layer from "effect/Layer";
+import * as Option from "effect/Option";
+import * as Schedule from "effect/Schedule";
+import { PersistenceError } from "./ClusterError.js";
+import * as MessageStorage from "./MessageStorage.js";
+import { SaveResultEncoded } from "./MessageStorage.js";
+import * as Snowflake from "./Snowflake.js";
+/**
+ * @since 1.0.0
+ * @category Constructors
+ */
+export const make = /*#__PURE__*/Effect.fnUntraced(function* (options) {
+  const sql = (yield* SqlClient.SqlClient).withoutTransforms();
+  const prefix = options?.prefix ?? "cluster";
+  const table = name => `${prefix}_${name}`;
+  const messageKindAckChunk = sql.literal(String(messageKind.AckChunk));
+  const replyKindWithExit = sql.literal(String(replyKind.WithExit));
+  const messagesTable = table("messages");
+  const messagesTableSql = sql(messagesTable);
+  const repliesTable = table("replies");
+  const repliesTableSql = sql(repliesTable);
+  yield* sql.onDialectOrElse({
+    mssql: () => sql`
+        IF OBJECT_ID(N'${messagesTableSql}', N'U') IS NULL
+        CREATE TABLE ${messagesTableSql} (
+          id BIGINT PRIMARY KEY,
+          rowid BIGINT IDENTITY(1,1),
+          message_id VARCHAR(255),
+          shard_id INT NOT NULL,
+          entity_type VARCHAR(255) NOT NULL,
+          entity_id VARCHAR(255) NOT NULL,
+          kind INT NOT NULL,
+          tag VARCHAR(255),
+          payload TEXT,
+          headers TEXT,
+          trace_id VARCHAR(255),
+          span_id VARCHAR(255),
+          sampled BIT,
+          processed BIT NOT NULL DEFAULT 0,
+          request_id BIGINT NOT NULL,
+          reply_id BIGINT,
+          last_reply_id BIGINT,
+          last_read DATETIME,
+          deliver_at BIGINT,
+          UNIQUE (message_id),
+          FOREIGN KEY (request_id) REFERENCES ${messagesTableSql} (id) ON DELETE CASCADE
+        )
+      `,
+    mysql: () => sql`
+        CREATE TABLE IF NOT EXISTS ${messagesTableSql} (
+          id BIGINT NOT NULL,
+          rowid BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,
+          message_id VARCHAR(255),
+          shard_id INT NOT NULL,
+          entity_type VARCHAR(255) NOT NULL,
+          entity_id VARCHAR(255) NOT NULL,
+          kind INT NOT NULL,
+          tag VARCHAR(255),
+          payload TEXT,
+          headers TEXT,
+          trace_id VARCHAR(255),
+          span_id VARCHAR(255),
+          sampled BOOLEAN,
+          processed BOOLEAN NOT NULL DEFAULT FALSE,
+          request_id BIGINT NOT NULL,
+          reply_id BIGINT,
+          last_reply_id BIGINT,
+          last_read DATETIME,
+          deliver_at BIGINT,
+          UNIQUE (id),
+          UNIQUE (message_id),
+          FOREIGN KEY (request_id) REFERENCES ${messagesTableSql} (id) ON DELETE CASCADE
+        )
+      `,
+    pg: () => sql`
+        CREATE TABLE IF NOT EXISTS ${messagesTableSql} (
+          id BIGINT PRIMARY KEY,
+          rowid BIGSERIAL,
+          message_id VARCHAR(255),
+          shard_id INT NOT NULL,
+          entity_type VARCHAR(255) NOT NULL,
+          entity_id VARCHAR(255) NOT NULL,
+          kind INT NOT NULL,
+          tag VARCHAR(255),
+          payload TEXT,
+          headers TEXT,
+          trace_id VARCHAR(255),
+          span_id VARCHAR(255),
+          sampled BOOLEAN,
+          processed BOOLEAN NOT NULL DEFAULT FALSE,
+          request_id BIGINT NOT NULL,
+          reply_id BIGINT,
+          last_reply_id BIGINT,
+          last_read TIMESTAMP,
+          deliver_at BIGINT,
+          UNIQUE (message_id),
+          FOREIGN KEY (request_id) REFERENCES ${messagesTableSql} (id) ON DELETE CASCADE
+        )
+      `.pipe(Effect.ignore),
+    orElse: () =>
+    // sqlite
+    sql`
+        CREATE TABLE IF NOT EXISTS ${messagesTableSql} (
+          id INTEGER PRIMARY KEY,
+          message_id TEXT,
+          shard_id INTEGER NOT NULL,
+          entity_type TEXT NOT NULL,
+          entity_id TEXT NOT NULL,
+          kind INTEGER NOT NULL,
+          tag TEXT,
+          payload TEXT,
+          headers TEXT,
+          trace_id TEXT,
+          span_id TEXT,
+          sampled BOOLEAN,
+          processed BOOLEAN NOT NULL DEFAULT FALSE,
+          request_id INTEGER NOT NULL,
+          reply_id INTEGER,
+          last_reply_id INTEGER,
+          last_read TEXT,
+          deliver_at INTEGER,
+          UNIQUE (message_id),
+          FOREIGN KEY (request_id) REFERENCES ${messagesTableSql} (id) ON DELETE CASCADE
+        )
+      `
+  });
+  // Add message indexes optimized for the specific query patterns
+  const shardLookupIndex = `${messagesTable}_shard_idx`;
+  const requestIdLookupIndex = `${messagesTable}_request_id_idx`;
+  yield* sql.onDialectOrElse({
+    mssql: () => sql`
+        IF NOT EXISTS (SELECT * FROM sys.indexes WHERE name = ${shardLookupIndex})
+        CREATE INDEX ${sql(shardLookupIndex)} 
+        ON ${messagesTableSql} (shard_id, processed, last_read, deliver_at);
+
+        IF NOT EXISTS (SELECT * FROM sys.indexes WHERE name = ${requestIdLookupIndex})
+        CREATE INDEX ${sql(requestIdLookupIndex)}
+        ON ${messagesTableSql} (request_id);
+      `,
+    mysql: () => sql`
+        CREATE INDEX ${sql(shardLookupIndex)}
+        ON ${messagesTableSql} (shard_id, processed, last_read, deliver_at);
+
+        CREATE INDEX ${sql(requestIdLookupIndex)}
+        ON ${messagesTableSql} (request_id);
+      `.unprepared.pipe(Effect.ignore),
+    pg: () => sql`
+        CREATE INDEX IF NOT EXISTS ${sql(shardLookupIndex)}
+        ON ${messagesTableSql} (shard_id, processed, last_read, deliver_at);
+
+        CREATE INDEX IF NOT EXISTS ${sql(requestIdLookupIndex)}
+        ON ${messagesTableSql} (request_id);
+      `.pipe(Effect.tapDefect(error => Effect.annotateLogs(Effect.logDebug("Failed to create indexes", error), {
+      package: "@effect/cluster",
+      module: "SqlMessageStorage"
+    })), Effect.retry({
+      schedule: Schedule.spaced(1000)
+    })),
+    orElse: () =>
+    // sqlite
+    Effect.all([sql`
+          CREATE INDEX IF NOT EXISTS ${sql(shardLookupIndex)}
+          ON ${messagesTableSql} (shard_id, processed, last_read, deliver_at)
+        `, sql`
+          CREATE INDEX IF NOT EXISTS ${sql(requestIdLookupIndex)}
+          ON ${messagesTableSql} (request_id)
+        `]).pipe(sql.withTransaction)
+  });
+  yield* sql.onDialectOrElse({
+    mssql: () => sql`
+        IF OBJECT_ID(N'${repliesTableSql}', N'U') IS NULL
+        CREATE TABLE ${repliesTableSql} (
+          id BIGINT PRIMARY KEY,
+          rowid BIGINT IDENTITY(1,1),
+          kind INT,
+          request_id BIGINT NOT NULL,
+          payload TEXT NOT NULL,
+          sequence INT,
+          acked BIT NOT NULL DEFAULT 0,
+          CONSTRAINT ${sql(repliesTable + "_one_exit")} UNIQUE (request_id, kind),
+          CONSTRAINT ${sql(repliesTable + "_sequence")} UNIQUE (request_id, sequence),
+          FOREIGN KEY (request_id) REFERENCES ${messagesTableSql} (id) ON DELETE CASCADE
+        )
+      `,
+    mysql: () => sql`
+        CREATE TABLE IF NOT EXISTS ${repliesTableSql} (
+          id BIGINT NOT NULL,
+          rowid BIGINT AUTO_INCREMENT PRIMARY KEY,
+          kind INT,
+          request_id BIGINT NOT NULL,
+          payload TEXT NOT NULL,
+          sequence INT,
+          acked BOOLEAN NOT NULL DEFAULT FALSE,
+          UNIQUE (id),
+          UNIQUE (request_id, kind),
+          UNIQUE (request_id, sequence),
+          FOREIGN KEY (request_id) REFERENCES ${messagesTableSql} (id) ON DELETE CASCADE
+        )
+      `,
+    pg: () => sql`
+        CREATE TABLE IF NOT EXISTS ${repliesTableSql} (
+          id BIGINT PRIMARY KEY,
+          rowid BIGSERIAL,
+          kind INT,
+          request_id BIGINT NOT NULL,
+          payload TEXT NOT NULL,
+          sequence INT,
+          acked BOOLEAN NOT NULL DEFAULT FALSE,
+          UNIQUE (request_id, kind),
+          UNIQUE (request_id, sequence),
+          FOREIGN KEY (request_id) REFERENCES ${messagesTableSql} (id) ON DELETE CASCADE
+        )
+      `,
+    orElse: () =>
+    // sqlite
+    sql`
+        CREATE TABLE IF NOT EXISTS ${repliesTableSql} (
+          id INTEGER PRIMARY KEY,
+          kind INTEGER,
+          request_id INTEGER NOT NULL,
+          payload TEXT NOT NULL,
+          sequence INTEGER,
+          acked BOOLEAN NOT NULL DEFAULT FALSE,
+          UNIQUE (request_id, kind),
+          UNIQUE (request_id, sequence),
+          FOREIGN KEY (request_id) REFERENCES ${messagesTableSql} (id) ON DELETE CASCADE
+        )
+      `
+  });
+  // Add reply indexes optimized for request_id lookups
+  const replyLookupIndex = `${repliesTable}_request_lookup_idx`;
+  yield* sql.onDialectOrElse({
+    mssql: () => sql`
+        IF NOT EXISTS (SELECT * FROM sys.indexes WHERE name = ${replyLookupIndex})
+        CREATE INDEX ${sql(replyLookupIndex)}
+        ON ${repliesTableSql} (request_id, kind, acked);
+      `,
+    mysql: () => sql`
+        CREATE INDEX ${sql(replyLookupIndex)}
+        ON ${repliesTableSql} (request_id, kind, acked);
+      `.unprepared.pipe(Effect.ignore),
+    pg: () => sql`
+        CREATE INDEX IF NOT EXISTS ${sql(replyLookupIndex)}
+        ON ${repliesTableSql} (request_id, kind, acked);
+`.pipe(Effect.tapDefect(error => Effect.annotateLogs(Effect.logDebug("Failed to create indexes", error), {
+      package: "@effect/cluster",
+      module: "SqlMessageStorage"
+    })), Effect.retry({
+      schedule: Schedule.spaced(1000)
+    })),
+    orElse: () =>
+    // sqlite
+    sql`
+        CREATE INDEX IF NOT EXISTS ${sql(replyLookupIndex)}
+        ON ${repliesTableSql} (request_id, kind, acked);
+      `
+  });
+  const envelopeToRow = (envelope, message_id, deliver_at) => {
+    switch (envelope._tag) {
+      case "Request":
+        return {
+          id: envelope.requestId,
+          message_id,
+          shard_id: envelope.address.shardId,
+          entity_type: envelope.address.entityType,
+          entity_id: envelope.address.entityId,
+          kind: messageKind.Request,
+          tag: envelope.tag,
+          payload: JSON.stringify(envelope.payload),
+          headers: JSON.stringify(envelope.headers),
+          trace_id: envelope.traceId,
+          span_id: envelope.spanId,
+          sampled: supportsBooleans ? envelope.sampled : envelope.sampled ? 1 : 0,
+          request_id: envelope.requestId,
+          reply_id: null,
+          deliver_at
+        };
+      case "AckChunk":
+        return {
+          id: envelope.id,
+          message_id,
+          shard_id: envelope.address.shardId,
+          entity_type: envelope.address.entityType,
+          entity_id: envelope.address.entityId,
+          kind: messageKind.AckChunk,
+          tag: null,
+          payload: null,
+          headers: null,
+          trace_id: null,
+          span_id: null,
+          sampled: null,
+          request_id: envelope.requestId,
+          reply_id: envelope.replyId,
+          deliver_at
+        };
+      case "Interrupt":
+        return {
+          id: envelope.id,
+          message_id,
+          shard_id: envelope.address.shardId,
+          entity_type: envelope.address.entityType,
+          entity_id: envelope.address.entityId,
+          kind: messageKind.Interrupt,
+          payload: null,
+          tag: null,
+          headers: null,
+          trace_id: null,
+          span_id: null,
+          sampled: null,
+          request_id: envelope.requestId,
+          reply_id: null,
+          deliver_at
+        };
+    }
+  };
+  const replyToRow = reply => ({
+    id: reply.id,
+    kind: replyKind[reply._tag],
+    request_id: reply.requestId,
+    payload: reply._tag === "WithExit" ? JSON.stringify(reply.exit) : JSON.stringify(reply.values),
+    sequence: reply._tag === "Chunk" ? reply.sequence : null
+  });
+  const supportsBooleans = sql.onDialectOrElse({
+    mssql: () => false,
+    sqlite: () => false,
+    orElse: () => true
+  });
+  const messageFromRow = row => {
+    switch (Number(row.kind)) {
+      case 0:
+        return {
+          envelope: {
+            _tag: "Request",
+            requestId: String(row.id),
+            address: {
+              shardId: Number(row.shard_id),
+              entityType: row.entity_type,
+              entityId: row.entity_id
+            },
+            tag: row.tag,
+            payload: JSON.parse(row.payload),
+            headers: JSON.parse(row.headers),
+            traceId: row.trace_id,
+            spanId: row.span_id,
+            sampled: !!row.sampled
+          },
+          lastSentReply: row.reply_reply_id ? Option.some({
+            _tag: "Chunk",
+            id: String(row.reply_reply_id),
+            requestId: String(row.request_id),
+            sequence: Number(row.reply_sequence),
+            values: JSON.parse(row.reply_payload)
+          }) : Option.none()
+        };
+      case 1:
+        return {
+          envelope: {
+            _tag: "AckChunk",
+            id: String(row.id),
+            requestId: String(row.request_id),
+            replyId: String(row.reply_id),
+            address: {
+              shardId: Number(row.shard_id),
+              entityType: row.entity_type,
+              entityId: row.entity_id
+            }
+          },
+          lastSentReply: Option.none()
+        };
+      case 2:
+        return {
+          envelope: {
+            _tag: "Interrupt",
+            id: String(row.id),
+            requestId: String(row.request_id),
+            address: {
+              shardId: Number(row.shard_id),
+              entityType: row.entity_type,
+              entityId: row.entity_id
+            }
+          },
+          lastSentReply: Option.none()
+        };
+    }
+  };
+  const sqlFalse = sql.literal(supportsBooleans ? "FALSE" : "0");
+  const sqlTrue = sql.literal(supportsBooleans ? "TRUE" : "1");
+  const insertEnvelope = sql.onDialectOrElse({
+    pg: () => (row, message_id) => sql`
+        WITH inserted AS (
+          INSERT INTO ${messagesTableSql} ${sql.insert(row)}
+          ON CONFLICT (message_id) DO NOTHING
+          RETURNING id
+        ),
+        existing AS (
+          SELECT m.id, r.id as reply_id, r.kind as reply_kind, r.payload as reply_payload, r.sequence as reply_sequence
+          FROM ${messagesTableSql} m
+          LEFT JOIN ${repliesTableSql} r ON r.id = m.last_reply_id
+          WHERE m.message_id = ${message_id}
+          AND NOT EXISTS (SELECT 1 FROM inserted)
+        )
+        SELECT * FROM existing
+      `,
+    mysql: () => (row, message_id) => sql`
+        SELECT m.id, r.id as reply_id, r.kind as reply_kind, r.payload as reply_payload, r.sequence as reply_sequence
+        FROM ${messagesTableSql} m
+        LEFT JOIN ${repliesTableSql} r ON r.id = m.last_reply_id
+        WHERE m.message_id = ${message_id};
+        INSERT INTO ${messagesTableSql} ${sql.insert(row)}
+        ON DUPLICATE KEY UPDATE id = id;
+      `.unprepared.pipe(
+    // we need 2 queries for mysql, so we need to run them in a
+    // transaction with retries
+    sql.withTransaction, Effect.retry({
+      times: 3
+    }), Effect.map(([rows]) => rows)),
+    mssql: () => (row, message_id) => sql`
+        MERGE ${messagesTableSql} WITH (HOLDLOCK) AS target
+        USING (SELECT ${message_id} as message_id) AS source
+        ON target.message_id = source.message_id
+        WHEN NOT MATCHED THEN
+          INSERT ${sql.insert(row)}
+        OUTPUT
+          inserted.id,
+          CASE
+            WHEN inserted.id IS NULL THEN (
+              SELECT r.id, r.kind, r.payload
+              FROM ${repliesTableSql} r
+              WHERE r.id = target.last_reply_id
+            )
+          END as reply_id,
+          CASE
+            WHEN inserted.id IS NULL THEN (
+              SELECT r.kind
+              FROM ${repliesTableSql} r
+              WHERE r.id = target.last_reply_id
+            )
+          END as reply_kind,
+          CASE
+            WHEN inserted.id IS NULL THEN (
+              SELECT r.payload
+              FROM ${repliesTableSql} r
+              WHERE r.id = target.last_reply_id
+            )
+          END as reply_payload,
+          CASE
+            WHEN inserted.id IS NULL THEN (
+              SELECT r.sequence
+              FROM ${repliesTableSql} r
+              WHERE r.id = target.last_reply_id
+            )
+          END as reply_sequence;
+      `,
+    orElse: () => (row, message_id) => sql`
+        SELECT m.id, r.id as reply_id, r.kind as reply_kind, r.payload as reply_payload, r.sequence as reply_sequence
+        FROM ${messagesTableSql} m
+        LEFT JOIN ${repliesTableSql} r ON r.id = m.last_reply_id
+        WHERE m.message_id = ${message_id}
+      `.pipe(Effect.tap(sql`INSERT OR IGNORE INTO ${messagesTableSql} ${sql.insert(row)}`), sql.withTransaction, Effect.retry({
+      times: 3
+    }))
+  });
+  const fiveMinutesAgo = sql.onDialectOrElse({
+    mssql: () => sql.literal(`DATEADD(MINUTE, -5, GETDATE())`),
+    mysql: () => sql.literal(`NOW() - INTERVAL 5 MINUTE`),
+    pg: () => sql.literal(`NOW() - INTERVAL '5 minutes'`),
+    orElse: () => sql.literal(`DATETIME('now', '-5 minute')`)
+  });
+  const sqlNowString = sql.onDialectOrElse({
+    pg: () => "NOW()",
+    mysql: () => "NOW()",
+    mssql: () => "GETDATE()",
+    orElse: () => "CURRENT_TIMESTAMP"
+  });
+  const sqlNow = sql.literal(sqlNowString);
+  const getUnprocessedMessages = sql.onDialectOrElse({
+    pg: () => (shardIds, now) => sql`
+        UPDATE ${messagesTableSql} m
+        SET last_read = ${sqlNow}
+        FROM (
+          SELECT m.*
+          FROM ${messagesTableSql} m
+          WHERE m.shard_id IN (${sql.literal(shardIds.map(String).join(","))})
+          AND NOT EXISTS (
+            SELECT 1 FROM ${repliesTableSql}
+            WHERE request_id = m.request_id
+            AND (kind = ${replyKindWithExit} OR acked = ${sqlFalse})
+          )
+          AND m.processed = ${sqlFalse}
+          AND (m.last_read IS NULL OR m.last_read < ${fiveMinutesAgo})
+          AND (m.deliver_at IS NULL OR m.deliver_at <= ${sql.literal(String(now))})
+          ORDER BY m.rowid ASC
+          FOR UPDATE
+        ) AS ids
+        LEFT JOIN ${repliesTableSql} r ON r.id = ids.last_reply_id
+        WHERE m.id = ids.id
+        RETURNING ids.*, r.id as reply_reply_id, r.kind as reply_kind, r.payload as reply_payload, r.sequence as reply_sequence
+      `,
+    orElse: () => (shardIds, now) => sql`
+        SELECT m.*, r.id as reply_reply_id, r.kind as reply_kind, r.payload as reply_payload, r.sequence as reply_sequence
+        FROM ${messagesTableSql} m
+        LEFT JOIN ${repliesTableSql} r ON r.id = m.last_reply_id
+        WHERE m.shard_id IN (${sql.literal(shardIds.map(String).join(","))})
+        AND NOT EXISTS (
+          SELECT 1 FROM ${repliesTableSql}
+          WHERE request_id = m.request_id
+          AND (kind = ${replyKindWithExit} OR acked = ${sqlFalse})
+        )
+        AND processed = ${sqlFalse}
+        AND (m.last_read IS NULL OR m.last_read < ${fiveMinutesAgo})
+        AND (m.deliver_at IS NULL OR m.deliver_at <= ${sql.literal(String(now))})
+        ORDER BY m.rowid ASC
+      `.unprepared.pipe(Effect.tap(rows => {
+      if (rows.length === 0) {
+        return Effect.void;
+      }
+      return sql`
+            UPDATE ${messagesTableSql}
+            SET last_read = ${sqlNow}
+            WHERE id IN (${sql.literal(rows.map(row => row.id).join(","))})
+          `.unprepared;
+    }), sql.withTransaction)
+  });
+  return yield* MessageStorage.makeEncoded({
+    saveEnvelope: ({
+      deliverAt,
+      envelope,
+      primaryKey
+    }) => Effect.suspend(() => {
+      const row = envelopeToRow(envelope, primaryKey, deliverAt);
+      let insert = primaryKey ? insertEnvelope(row, primaryKey) : Effect.as(sql`INSERT INTO ${messagesTableSql} ${sql.insert(row)}`.unprepared, []);
+      if (envelope._tag === "AckChunk") {
+        insert = sql`UPDATE ${repliesTableSql} SET acked = ${sqlTrue} WHERE id = ${envelope.replyId}`.pipe(Effect.andThen(sql`UPDATE ${messagesTableSql} SET processed = ${sqlTrue} WHERE processed = ${sqlFalse} AND request_id = ${envelope.requestId} AND kind = ${messageKindAckChunk}`), Effect.andThen(insert), sql.withTransaction);
+      }
+      return insert.pipe(Effect.map(rows => {
+        if (rows.length === 0) {
+          return SaveResultEncoded.Success();
+        }
+        const row = rows[0];
+        return SaveResultEncoded.Duplicate({
+          originalId: Snowflake.Snowflake(row.id),
+          lastReceivedReply: row.reply_id ? Option.some({
+            id: String(row.reply_id),
+            requestId: String(row.id),
+            _tag: row.reply_kind === replyKind.WithExit ? "WithExit" : "Chunk",
+            ...(row.reply_kind === replyKind.WithExit ? {
+              exit: JSON.parse(row.reply_payload)
+            } : {
+              sequence: Number(row.reply_sequence),
+              values: JSON.parse(row.reply_payload)
+            })
+          }) : Option.none()
+        });
+      }));
+    }).pipe(Effect.provideService(SqlClient.SafeIntegers, true), PersistenceError.refail),
+    saveReply: reply => Effect.suspend(() => {
+      const row = replyToRow(reply);
+      const update = reply._tag === "Chunk" ? sql`UPDATE ${messagesTableSql} SET last_reply_id = ${reply.id} WHERE id = ${reply.requestId}` : sql`UPDATE ${messagesTableSql} SET processed = ${sqlTrue}, last_reply_id = NULL WHERE request_id = ${reply.requestId}`;
+      return update.unprepared.pipe(Effect.andThen(sql`INSERT INTO ${repliesTableSql} ${sql.insert(row)}`), sql.withTransaction);
+    }).pipe(Effect.asVoid, PersistenceError.refail),
+    repliesFor: requestIds =>
+    // replies where:
+    // - the request is in the list
+    // - the kind is WithExit
+    // - or the kind is Chunk and has not been acked yet
+    sql`
+        SELECT id, kind, request_id, payload, sequence
+        FROM ${repliesTableSql}
+        WHERE request_id IN (${sql.literal(requestIds.join(","))})
+        AND (
+          kind = ${replyKindWithExit}
+          OR (
+            kind IS NULL
+            AND acked = ${sqlFalse}
+          )
+        )
+        ORDER BY rowid ASC
+      `.unprepared.pipe(Effect.provideService(SqlClient.SafeIntegers, true), Effect.map(Arr.map(row => row.kind === replyKind.WithExit ? {
+      _tag: "WithExit",
+      id: String(row.id),
+      requestId: String(row.request_id),
+      exit: JSON.parse(row.payload)
+    } : {
+      _tag: "Chunk",
+      id: String(row.id),
+      requestId: String(row.request_id),
+      values: JSON.parse(row.payload),
+      sequence: Number(row.sequence)
+    })), PersistenceError.refail),
+    unprocessedMessages: Effect.fnUntraced(function* (shardIds, now) {
+      const rows = yield* getUnprocessedMessages(shardIds, now);
+      if (rows.length === 0) {
+        return [];
+      }
+      const messages = new Array(rows.length);
+      const ids = new Array(rows.length);
+      for (let i = 0; i < rows.length; i++) {
+        messages[i] = messageFromRow(rows[i]);
+        ids[i] = String(rows[i].id);
+      }
+      return messages;
+    }, Effect.provideService(SqlClient.SafeIntegers, true), PersistenceError.refail),
+    unprocessedMessagesById(ids, now) {
+      const idArr = Array.from(ids, id => String(id));
+      return sql`
+        SELECT m.*, r.id as reply_id, r.kind as reply_kind, r.payload as reply_payload, r.sequence as reply_sequence
+        FROM ${messagesTableSql} m
+        LEFT JOIN ${repliesTableSql} r ON r.id = m.last_reply_id
+        WHERE m.id IN (${sql.literal(idArr.join(","))})
+        AND NOT EXISTS (
+          SELECT 1 FROM ${repliesTableSql}
+          WHERE request_id = m.request_id
+          AND (kind = ${replyKindWithExit} OR acked = ${sqlFalse})
+        )
+        AND m.processed = ${sqlFalse}
+        AND (m.deliver_at IS NULL OR m.deliver_at <= ${sql.literal(String(now))})
+        ORDER BY m.rowid ASC
+      `.unprepared.pipe(Effect.map(Arr.map(messageFromRow)), Effect.provideService(SqlClient.SafeIntegers, true), PersistenceError.refail);
+    },
+    resetAddress: address => sql`
+        UPDATE ${messagesTableSql}
+        SET last_read = NULL
+        WHERE processed = ${sqlFalse}
+        AND shard_id = ${address.shardId}
+        AND entity_type = ${address.entityType}
+        AND entity_id = ${address.entityId}
+`.pipe(Effect.asVoid, PersistenceError.refail)
+  });
+});
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layer = /*#__PURE__*/Layer.scoped(MessageStorage.MessageStorage, make()).pipe( /*#__PURE__*/Layer.provide(Snowflake.layerGenerator));
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layerWith = options => Layer.scoped(MessageStorage.MessageStorage, make(options)).pipe(Layer.provide(Snowflake.layerGenerator));
+// -------------------------------------------------------------------------------------------------
+// internal
+// -------------------------------------------------------------------------------------------------
+const messageKind = {
+  "Request": 0,
+  "AckChunk": 1,
+  "Interrupt": 2
+};
+const replyKind = {
+  "WithExit": 0,
+  "Chunk": null
+};
+//# sourceMappingURL=SqlMessageStorage.js.map
\ No newline at end of file
diff --git a/dist/esm/SqlMessageStorage.js.map b/dist/esm/SqlMessageStorage.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..6e5692f8f3243db47ce908dfd7edf0428caf2dbd
--- /dev/null
+++ b/dist/esm/SqlMessageStorage.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"SqlMessageStorage.js","names":["SqlClient","Arr","Effect","Layer","Option","Schedule","PersistenceError","MessageStorage","SaveResultEncoded","Snowflake","make","fnUntraced","options","sql","withoutTransforms","prefix","table","name","messageKindAckChunk","literal","String","messageKind","AckChunk","replyKindWithExit","replyKind","WithExit","messagesTable","messagesTableSql","repliesTable","repliesTableSql","onDialectOrElse","mssql","mysql","pg","pipe","ignore","orElse","shardLookupIndex","requestIdLookupIndex","unprepared","tapDefect","error","annotateLogs","logDebug","package","module","retry","schedule","spaced","all","withTransaction","replyLookupIndex","envelopeToRow","envelope","message_id","deliver_at","_tag","id","requestId","shard_id","address","shardId","entity_type","entityType","entity_id","entityId","kind","Request","tag","payload","JSON","stringify","headers","trace_id","traceId","span_id","spanId","sampled","supportsBooleans","request_id","reply_id","replyId","Interrupt","replyToRow","reply","exit","values","sequence","sqlite","messageFromRow","row","Number","parse","lastSentReply","reply_reply_id","some","reply_sequence","reply_payload","none","sqlFalse","sqlTrue","insertEnvelope","insert","times","map","rows","tap","fiveMinutesAgo","sqlNowString","sqlNow","getUnprocessedMessages","shardIds","now","join","length","void","makeEncoded","saveEnvelope","deliverAt","primaryKey","suspend","as","andThen","Success","Duplicate","originalId","lastReceivedReply","reply_kind","provideService","SafeIntegers","refail","saveReply","update","asVoid","repliesFor","requestIds","unprocessedMessages","messages","Array","ids","i","unprocessedMessagesById","idArr","from","resetAddress","layer","scoped","provide","layerGenerator","layerWith"],"sources":["../../src/SqlMessageStorage.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/esm/SqlShardStorage.js b/dist/esm/SqlShardStorage.js
new file mode 100644
index 0000000000000000000000000000000000000000..7c659b297db873dea2d077ab53bc5ae38063612b
--- /dev/null
+++ b/dist/esm/SqlShardStorage.js
@@ -0,0 +1,218 @@
+/**
+ * @since 1.0.0
+ */
+import * as SqlClient from "@effect/sql/SqlClient";
+import * as Arr from "effect/Array";
+import * as Effect from "effect/Effect";
+import * as Layer from "effect/Layer";
+import { PersistenceError } from "./ClusterError.js";
+import * as ShardStorage from "./ShardStorage.js";
+/**
+ * @since 1.0.0
+ * @category Constructors
+ */
+export const make = /*#__PURE__*/Effect.fnUntraced(function* (options) {
+  const sql = (yield* SqlClient.SqlClient).withoutTransforms();
+  const prefix = options?.prefix ?? "cluster";
+  const table = name => `${prefix}_${name}`;
+  const runnersTable = table("runners");
+  const runnersTableSql = sql(runnersTable);
+  yield* sql.onDialectOrElse({
+    mssql: () => sql`
+        IF OBJECT_ID(N'${runnersTableSql}', N'U') IS NULL
+        CREATE TABLE ${runnersTableSql} (
+          address VARCHAR(255) PRIMARY KEY,
+          runner TEXT NOT NULL
+        )
+      `,
+    mysql: () => sql`
+        CREATE TABLE IF NOT EXISTS ${runnersTableSql} (
+          address VARCHAR(255) PRIMARY KEY,
+          runner TEXT NOT NULL
+        )
+      `,
+    pg: () => sql`
+        CREATE TABLE IF NOT EXISTS ${runnersTableSql} (
+          address VARCHAR(255) PRIMARY KEY,
+          runner TEXT NOT NULL
+        )
+      `,
+    orElse: () =>
+    // sqlite
+    sql`
+        CREATE TABLE IF NOT EXISTS ${runnersTableSql} (
+          address TEXT PRIMARY KEY,
+          runner TEXT NOT NULL
+        )
+      `
+  });
+  const shardsTable = table("shards");
+  const shardsTableSql = sql(shardsTable);
+  yield* sql.onDialectOrElse({
+    mssql: () => sql`
+        IF OBJECT_ID(N'${shardsTableSql}', N'U') IS NULL
+        CREATE TABLE ${shardsTableSql} (
+          shard_id INT PRIMARY KEY,
+          address VARCHAR(255)
+        )
+      `,
+    mysql: () => sql`
+        CREATE TABLE IF NOT EXISTS ${shardsTableSql} (
+          shard_id INT PRIMARY KEY,
+          address VARCHAR(255)
+        )
+      `,
+    pg: () => sql`
+        CREATE TABLE IF NOT EXISTS ${shardsTableSql} (
+          shard_id INT PRIMARY KEY,
+          address VARCHAR(255)
+        )
+      `,
+    orElse: () =>
+    // sqlite
+    sql`
+        CREATE TABLE IF NOT EXISTS ${shardsTableSql} (
+          shard_id INTEGER PRIMARY KEY,
+          address TEXT
+        )
+      `
+  });
+  const locksTable = table("locks");
+  const locksTableSql = sql(locksTable);
+  yield* sql.onDialectOrElse({
+    mssql: () => sql`
+        IF OBJECT_ID(N'${locksTableSql}', N'U') IS NULL
+        CREATE TABLE ${locksTableSql} (
+          shard_id INT PRIMARY KEY,
+          address VARCHAR(255) NOT NULL,
+          acquired_at DATETIME NOT NULL
+        )
+      `,
+    mysql: () => sql`
+        CREATE TABLE IF NOT EXISTS ${locksTableSql} (
+          shard_id INT PRIMARY KEY,
+          address VARCHAR(255) NOT NULL,
+          acquired_at DATETIME NOT NULL
+        )
+      `,
+    pg: () => sql`
+        CREATE TABLE IF NOT EXISTS ${locksTableSql} (
+          shard_id INT PRIMARY KEY,
+          address VARCHAR(255) NOT NULL,
+          acquired_at TIMESTAMP NOT NULL
+        )
+      `,
+    orElse: () =>
+    // sqlite
+    sql`
+        CREATE TABLE IF NOT EXISTS ${locksTableSql} (
+          shard_id INTEGER PRIMARY KEY,
+          address TEXT NOT NULL,
+          acquired_at DATETIME NOT NULL
+        )
+      `
+  });
+  const sqlNowString = sql.onDialectOrElse({
+    pg: () => "NOW()",
+    mysql: () => "NOW()",
+    mssql: () => "GETDATE()",
+    orElse: () => "CURRENT_TIMESTAMP"
+  });
+  const sqlNow = sql.literal(sqlNowString);
+  const lockExpiresAt = sql.onDialectOrElse({
+    pg: () => sql`${sqlNow} - INTERVAL '120 seconds'`,
+    mysql: () => sql`DATE_SUB(${sqlNow}, INTERVAL 120 SECOND)`,
+    mssql: () => sql`DATEADD(SECOND, -120, ${sqlNow})`,
+    orElse: () => sql`datetime(${sqlNow}, '-120 seconds')`
+  });
+  const acquireLock = sql.onDialectOrElse({
+    pg: () => (address, values) => sql`
+        INSERT INTO ${locksTableSql} (shard_id, address, acquired_at) VALUES ${sql.csv(values)}
+        ON CONFLICT (shard_id) DO UPDATE
+        SET address = ${address}, acquired_at = ${sqlNow}
+        WHERE ${locksTableSql}.address = ${address}
+          OR ${locksTableSql}.acquired_at < ${lockExpiresAt}
+      `,
+    mysql: () => (_address, values) => sql`
+        INSERT INTO ${locksTableSql} (shard_id, address, acquired_at) VALUES ${sql.csv(values)}
+        ON DUPLICATE KEY UPDATE
+        address = IF(address = VALUES(address) OR acquired_at < ${lockExpiresAt}, VALUES(address), address),
+        acquired_at = IF(address = VALUES(address) OR acquired_at < ${lockExpiresAt}, VALUES(acquired_at), acquired_at)
+      `.unprepared,
+    mssql: () => (_address, values) => sql`
+        MERGE ${locksTableSql} WITH (HOLDLOCK) AS target
+        USING (SELECT * FROM (VALUES ${sql.csv(values)})) AS source (shard_id, address, acquired_at)
+        ON target.shard_id = source.shard_id
+        WHEN MATCHED AND (target.address = source.address OR DATEDIFF(SECOND, target.acquired_at, ${sqlNow}) > 120) THEN
+          UPDATE SET address = source.address, acquired_at = source.acquired_at
+        WHEN NOT MATCHED THEN
+          INSERT (shard_id, address, acquired_at)
+          VALUES (source.shard_id, source.address, source.acquired_at);
+      `,
+    orElse: () => (address, values) =>
+    // sqlite
+    sql`
+        WITH source(shard_id, address, acquired_at) AS (VALUES ${sql.csv(values)})
+        INSERT INTO ${locksTableSql} (shard_id, address, acquired_at)
+        SELECT source.shard_id, source.address, source.acquired_at
+        FROM source
+        WHERE NOT EXISTS (
+          SELECT 1 FROM ${locksTableSql}
+          WHERE shard_id = source.shard_id
+          AND address != ${address}
+          AND (strftime('%s', ${sqlNow}) - strftime('%s', acquired_at)) <= 120
+        )
+        ON CONFLICT(shard_id) DO UPDATE
+        SET address = ${address}, acquired_at = ${sqlNow}
+      `
+  });
+  const forUpdate = sql.onDialectOrElse({
+    sqlite: () => sql.literal(""),
+    orElse: () => sql.literal("FOR UPDATE")
+  });
+  return yield* ShardStorage.makeEncoded({
+    getAssignments: sql`SELECT shard_id, address FROM ${shardsTableSql} ORDER BY shard_id`.values.pipe(PersistenceError.refail),
+    saveAssignments: assignments => {
+      const remove = sql`DELETE FROM ${shardsTableSql}`;
+      if (assignments.length === 0) {
+        return PersistenceError.refail(remove);
+      }
+      const values = assignments.map(([shardId, address]) => sql`(${shardId}, ${address})`);
+      return remove.pipe(Effect.andThen(sql`INSERT INTO ${shardsTableSql} (shard_id, address) VALUES ${sql.csv(values)}`.unprepared), sql.withTransaction, PersistenceError.refail);
+    },
+    getRunners: sql`SELECT address, runner FROM ${runnersTableSql}`.values.pipe(PersistenceError.refail, Effect.map(Arr.map(([address, runner]) => [String(address), String(runner)]))),
+    saveRunners: runners => {
+      const remove = sql`DELETE FROM ${runnersTableSql}`;
+      if (runners.length === 0) {
+        return PersistenceError.refail(remove);
+      }
+      const values = runners.map(([address, runner]) => sql`(${address}, ${runner})`);
+      const insert = sql`INSERT INTO ${runnersTableSql} (address, runner) VALUES ${sql.csv(values)}`.unprepared;
+      return remove.pipe(Effect.andThen(insert), sql.withTransaction, PersistenceError.refail);
+    },
+    acquire: Effect.fnUntraced(function* (address, shardIds) {
+      const values = shardIds.map(shardId => sql`(${shardId}, ${address}, ${sqlNow})`);
+      yield* acquireLock(address, values);
+      const currentLocks = yield* sql`
+          SELECT shard_id FROM ${sql(locksTable)}
+          WHERE address = ${address} AND ${sql.in("shard_id", shardIds)}
+          ${forUpdate}
+        `;
+      return currentLocks.map(row => row.shard_id);
+    }, sql.withTransaction, PersistenceError.refail),
+    refresh: (address, shardIds) => sql`UPDATE ${locksTableSql} SET acquired_at = ${sqlNow} WHERE address = ${address} AND ${sql.in("shard_id", shardIds)}`.pipe(Effect.andThen(sql`SELECT shard_id FROM ${locksTableSql} WHERE address = ${address} AND acquired_at >= ${lockExpiresAt} ${forUpdate}`.values), Effect.map(rows => rows.map(row => Number(row[0]))), PersistenceError.refail),
+    release: (address, shardId) => sql`DELETE FROM ${locksTableSql} WHERE address = ${address} AND shard_id = ${shardId}`.pipe(PersistenceError.refail),
+    releaseAll: address => sql`DELETE FROM ${locksTableSql} WHERE address = ${address}`.pipe(PersistenceError.refail)
+  });
+});
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layer = /*#__PURE__*/Layer.effect(ShardStorage.ShardStorage, /*#__PURE__*/make());
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layerWith = options => Layer.scoped(ShardStorage.ShardStorage, make(options));
+//# sourceMappingURL=SqlShardStorage.js.map
\ No newline at end of file
diff --git a/dist/esm/SqlShardStorage.js.map b/dist/esm/SqlShardStorage.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..3e8660d716b3da4f7daa540406e7e95e069f8751
--- /dev/null
+++ b/dist/esm/SqlShardStorage.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"SqlShardStorage.js","names":["SqlClient","Arr","Effect","Layer","PersistenceError","ShardStorage","make","fnUntraced","options","sql","withoutTransforms","prefix","table","name","runnersTable","runnersTableSql","onDialectOrElse","mssql","mysql","pg","orElse","shardsTable","shardsTableSql","locksTable","locksTableSql","sqlNowString","sqlNow","literal","lockExpiresAt","acquireLock","address","values","csv","_address","unprepared","forUpdate","sqlite","makeEncoded","getAssignments","pipe","refail","saveAssignments","assignments","remove","length","map","shardId","andThen","withTransaction","getRunners","runner","String","saveRunners","runners","insert","acquire","shardIds","currentLocks","in","row","shard_id","refresh","rows","Number","release","releaseAll","layer","effect","layerWith","scoped"],"sources":["../../src/SqlShardStorage.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/esm/SynchronizedClock.js b/dist/esm/SynchronizedClock.js
new file mode 100644
index 0000000000000000000000000000000000000000..dc6a861d959be1d0beb59ca296e74ad4d06dcda2
--- /dev/null
+++ b/dist/esm/SynchronizedClock.js
@@ -0,0 +1,57 @@
+/**
+ * @since 1.0.0
+ */
+import * as Clock from "effect/Clock";
+import * as Duration from "effect/Duration";
+import * as Effect from "effect/Effect";
+import * as Layer from "effect/Layer";
+import * as Schedule from "effect/Schedule";
+import { ShardManagerClient } from "./ShardManager.js";
+/**
+ * @since 1.0.0
+ * @category Constructors
+ */
+export const make = /*#__PURE__*/Effect.fnUntraced(function* (getRemoteTime) {
+  const clock = yield* Effect.clock;
+  let driftMillis = 0;
+  let driftNanos = BigInt(0);
+  yield* getRemoteTime.pipe(Effect.timed, Effect.map(([duration, shardManagerTime]) => {
+    const halfTrip = Duration.unsafeDivide(duration, 2);
+    shardManagerTime = shardManagerTime + Duration.toMillis(halfTrip) + 1;
+    const selfTime = clock.unsafeCurrentTimeMillis();
+    return shardManagerTime - selfTime;
+  }), Effect.replicateEffect(5), Effect.flatMap(drifts => {
+    drifts.sort();
+    const drift = (driftMillis + drifts[2]) / 2;
+    driftMillis = Math.round(drift);
+    driftNanos = BigInt(Math.round(drift * 1_000_000));
+    return Effect.logDebug("Current drift", driftMillis);
+  }), Effect.andThen(Effect.sleep(Duration.minutes(5))), Effect.forever, Effect.sandbox, Effect.retry(Schedule.spaced(Duration.minutes(1))), Effect.annotateLogs({
+    package: "@effect/cluster",
+    service: "SynchronizedClock"
+  }), Effect.forkScoped);
+  function unsafeCurrentTimeMillis() {
+    return clock.unsafeCurrentTimeMillis() + driftMillis;
+  }
+  function unsafeCurrentTimeNanos() {
+    return clock.unsafeCurrentTimeNanos() + driftNanos;
+  }
+  return Clock.Clock.of({
+    [Clock.ClockTypeId]: Clock.ClockTypeId,
+    sleep: clock.sleep,
+    unsafeCurrentTimeMillis,
+    unsafeCurrentTimeNanos,
+    currentTimeMillis: Effect.sync(unsafeCurrentTimeMillis),
+    currentTimeNanos: Effect.sync(unsafeCurrentTimeNanos)
+  });
+});
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layer = /*#__PURE__*/Layer.unwrapScoped( /*#__PURE__*/Effect.gen(function* () {
+  const shardManager = yield* ShardManagerClient;
+  const clock = yield* make(shardManager.getTime);
+  return Layer.setClock(clock);
+}));
+//# sourceMappingURL=SynchronizedClock.js.map
\ No newline at end of file
diff --git a/dist/esm/SynchronizedClock.js.map b/dist/esm/SynchronizedClock.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..1b1a934f66c51e3b7edbb1d76f7f58c867dfbedf
--- /dev/null
+++ b/dist/esm/SynchronizedClock.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"SynchronizedClock.js","names":["Clock","Duration","Effect","Layer","Schedule","ShardManagerClient","make","fnUntraced","getRemoteTime","clock","driftMillis","driftNanos","BigInt","pipe","timed","map","duration","shardManagerTime","halfTrip","unsafeDivide","toMillis","selfTime","unsafeCurrentTimeMillis","replicateEffect","flatMap","drifts","sort","drift","Math","round","logDebug","andThen","sleep","minutes","forever","sandbox","retry","spaced","annotateLogs","package","service","forkScoped","unsafeCurrentTimeNanos","of","ClockTypeId","currentTimeMillis","sync","currentTimeNanos","layer","unwrapScoped","gen","shardManager","getTime","setClock"],"sources":["../../src/SynchronizedClock.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/esm/index.js b/dist/esm/index.js
index dbfa4c964c0a3814c63af48c84e521463f113956..b8d851ce8f26b7523845cd1910cf2ac22e559aa1 100644
--- a/dist/esm/index.js
+++ b/dist/esm/index.js
@@ -1,79 +1,83 @@
 /**
  * @since 1.0.0
  */
-export * as AtLeastOnce from "./AtLeastOnce.js";
+export * as ClusterError from "./ClusterError.js";
 /**
  * @since 1.0.0
  */
-export * as AtLeastOnceStorage from "./AtLeastOnceStorage.js";
+export * as ClusterMetrics from "./ClusterMetrics.js";
 /**
  * @since 1.0.0
  */
-export * as Broadcaster from "./Broadcaster.js";
+export * as ClusterSchema from "./ClusterSchema.js";
 /**
  * @since 1.0.0
  */
-export * as ManagerConfig from "./ManagerConfig.js";
+export * as DeliverAt from "./DeliverAt.js";
 /**
  * @since 1.0.0
  */
-export * as Message from "./Message.js";
+export * as Entity from "./Entity.js";
+/**
+ * @since 1.0.0
+ */
+export * as EntityAddress from "./EntityAddress.js";
 /**
  * @since 1.0.0
  */
-export * as MessageState from "./MessageState.js";
+export * as EntityId from "./EntityId.js";
 /**
  * @since 1.0.0
  */
-export * as Messenger from "./Messenger.js";
+export * as EntityType from "./EntityType.js";
 /**
  * @since 1.0.0
  */
-export * as Pod from "./Pod.js";
+export * as Envelope from "./Envelope.js";
 /**
  * @since 1.0.0
  */
-export * as PodAddress from "./PodAddress.js";
+export * as HttpCommon from "./HttpCommon.js";
 /**
  * @since 1.0.0
  */
-export * as Pods from "./Pods.js";
+export * as HttpRunner from "./HttpRunner.js";
 /**
  * @since 1.0.0
  */
-export * as PodsHealth from "./PodsHealth.js";
+export * as HttpShardManager from "./HttpShardManager.js";
 /**
  * @since 1.0.0
  */
-export * as PoisonPill from "./PoisonPill.js";
+export * as Message from "./Message.js";
 /**
  * @since 1.0.0
  */
-export * as RecipientAddress from "./RecipientAddress.js";
+export * as MessageStorage from "./MessageStorage.js";
 /**
  * @since 1.0.0
  */
-export * as RecipientBehaviour from "./RecipientBehaviour.js";
+export * as Reply from "./Reply.js";
 /**
  * @since 1.0.0
  */
-export * as RecipientBehaviourContext from "./RecipientBehaviourContext.js";
+export * as Runner from "./Runner.js";
 /**
  * @since 1.0.0
  */
-export * as RecipientType from "./RecipientType.js";
+export * as RunnerAddress from "./RunnerAddress.js";
 /**
  * @since 1.0.0
  */
-export * as Serialization from "./Serialization.js";
+export * as RunnerHealth from "./RunnerHealth.js";
 /**
  * @since 1.0.0
  */
-export * as SerializedEnvelope from "./SerializedEnvelope.js";
+export * as RunnerServer from "./RunnerServer.js";
 /**
  * @since 1.0.0
  */
-export * as SerializedMessage from "./SerializedMessage.js";
+export * as Runners from "./Runners.js";
 /**
  * @since 1.0.0
  */
@@ -85,7 +89,7 @@ export * as ShardManager from "./ShardManager.js";
 /**
  * @since 1.0.0
  */
-export * as ShardManagerClient from "./ShardManagerClient.js";
+export * as ShardStorage from "./ShardStorage.js";
 /**
  * @since 1.0.0
  */
@@ -97,17 +101,37 @@ export * as ShardingConfig from "./ShardingConfig.js";
 /**
  * @since 1.0.0
  */
-export * as ShardingEvent from "./ShardingEvent.js";
+export * as ShardingRegistrationEvent from "./ShardingRegistrationEvent.js";
 /**
  * @since 1.0.0
  */
-export * as ShardingException from "./ShardingException.js";
+export * as Singleton from "./Singleton.js";
 /**
  * @since 1.0.0
  */
-export * as ShardingRegistrationEvent from "./ShardingRegistrationEvent.js";
+export * as SingletonAddress from "./SingletonAddress.js";
+/**
+ * @since 1.0.0
+ */
+export * as Snowflake from "./Snowflake.js";
+/**
+ * @since 1.0.0
+ */
+export * as SocketRunner from "./SocketRunner.js";
+/**
+ * @since 1.0.0
+ */
+export * as SocketShardManager from "./SocketShardManager.js";
+/**
+ * @since 1.0.0
+ */
+export * as SqlMessageStorage from "./SqlMessageStorage.js";
+/**
+ * @since 1.0.0
+ */
+export * as SqlShardStorage from "./SqlShardStorage.js";
 /**
  * @since 1.0.0
  */
-export * as Storage from "./Storage.js";
+export * as SynchronizedClock from "./SynchronizedClock.js";
 //# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/dist/esm/index.js.map b/dist/esm/index.js.map
index ce998a52083750e4b2d551b04e1823f88830aee7..c50fad926df2236eac147f77da991349a988881a 100644
--- a/dist/esm/index.js.map
+++ b/dist/esm/index.js.map
@@ -1 +1 @@
-{"version":3,"file":"index.js","names":["AtLeastOnce","AtLeastOnceStorage","Broadcaster","ManagerConfig","Message","MessageState","Messenger","Pod","PodAddress","Pods","PodsHealth","PoisonPill","RecipientAddress","RecipientBehaviour","RecipientBehaviourContext","RecipientType","Serialization","SerializedEnvelope","SerializedMessage","ShardId","ShardManager","ShardManagerClient","Sharding","ShardingConfig","ShardingEvent","ShardingException","ShardingRegistrationEvent","Storage"],"sources":["../../src/index.ts"],"sourcesContent":[null],"mappings":"AAAA;;;AAGA,OAAO,KAAKA,WAAW,MAAM,kBAAkB;AAE/C;;;AAGA,OAAO,KAAKC,kBAAkB,MAAM,yBAAyB;AAE7D;;;AAGA,OAAO,KAAKC,WAAW,MAAM,kBAAkB;AAE/C;;;AAGA,OAAO,KAAKC,aAAa,MAAM,oBAAoB;AAEnD;;;AAGA,OAAO,KAAKC,OAAO,MAAM,cAAc;AAEvC;;;AAGA,OAAO,KAAKC,YAAY,MAAM,mBAAmB;AAEjD;;;AAGA,OAAO,KAAKC,SAAS,MAAM,gBAAgB;AAE3C;;;AAGA,OAAO,KAAKC,GAAG,MAAM,UAAU;AAE/B;;;AAGA,OAAO,KAAKC,UAAU,MAAM,iBAAiB;AAE7C;;;AAGA,OAAO,KAAKC,IAAI,MAAM,WAAW;AAEjC;;;AAGA,OAAO,KAAKC,UAAU,MAAM,iBAAiB;AAE7C;;;AAGA,OAAO,KAAKC,UAAU,MAAM,iBAAiB;AAE7C;;;AAGA,OAAO,KAAKC,gBAAgB,MAAM,uBAAuB;AAEzD;;;AAGA,OAAO,KAAKC,kBAAkB,MAAM,yBAAyB;AAE7D;;;AAGA,OAAO,KAAKC,yBAAyB,MAAM,gCAAgC;AAE3E;;;AAGA,OAAO,KAAKC,aAAa,MAAM,oBAAoB;AAEnD;;;AAGA,OAAO,KAAKC,aAAa,MAAM,oBAAoB;AAEnD;;;AAGA,OAAO,KAAKC,kBAAkB,MAAM,yBAAyB;AAE7D;;;AAGA,OAAO,KAAKC,iBAAiB,MAAM,wBAAwB;AAE3D;;;AAGA,OAAO,KAAKC,OAAO,MAAM,cAAc;AAEvC;;;AAGA,OAAO,KAAKC,YAAY,MAAM,mBAAmB;AAEjD;;;AAGA,OAAO,KAAKC,kBAAkB,MAAM,yBAAyB;AAE7D;;;AAGA,OAAO,KAAKC,QAAQ,MAAM,eAAe;AAEzC;;;AAGA,OAAO,KAAKC,cAAc,MAAM,qBAAqB;AAErD;;;AAGA,OAAO,KAAKC,aAAa,MAAM,oBAAoB;AAEnD;;;AAGA,OAAO,KAAKC,iBAAiB,MAAM,wBAAwB;AAE3D;;;AAGA,OAAO,KAAKC,yBAAyB,MAAM,gCAAgC;AAE3E;;;AAGA,OAAO,KAAKC,OAAO,MAAM,cAAc","ignoreList":[]}
\ No newline at end of file
+{"version":3,"file":"index.js","names":["ClusterError","ClusterMetrics","ClusterSchema","DeliverAt","Entity","EntityAddress","EntityId","EntityType","Envelope","HttpCommon","HttpRunner","HttpShardManager","Message","MessageStorage","Reply","Runner","RunnerAddress","RunnerHealth","RunnerServer","Runners","ShardId","ShardManager","ShardStorage","Sharding","ShardingConfig","ShardingRegistrationEvent","Singleton","SingletonAddress","Snowflake","SocketRunner","SocketShardManager","SqlMessageStorage","SqlShardStorage","SynchronizedClock"],"sources":["../../src/index.ts"],"sourcesContent":[null],"mappings":"AAAA;;;AAGA,OAAO,KAAKA,YAAY,MAAM,mBAAmB;AAEjD;;;AAGA,OAAO,KAAKC,cAAc,MAAM,qBAAqB;AAErD;;;AAGA,OAAO,KAAKC,aAAa,MAAM,oBAAoB;AAEnD;;;AAGA,OAAO,KAAKC,SAAS,MAAM,gBAAgB;AAE3C;;;AAGA,OAAO,KAAKC,MAAM,MAAM,aAAa;AAErC;;;AAGA,OAAO,KAAKC,aAAa,MAAM,oBAAoB;AAEnD;;;AAGA,OAAO,KAAKC,QAAQ,MAAM,eAAe;AAEzC;;;AAGA,OAAO,KAAKC,UAAU,MAAM,iBAAiB;AAE7C;;;AAGA,OAAO,KAAKC,QAAQ,MAAM,eAAe;AAEzC;;;AAGA,OAAO,KAAKC,UAAU,MAAM,iBAAiB;AAE7C;;;AAGA,OAAO,KAAKC,UAAU,MAAM,iBAAiB;AAE7C;;;AAGA,OAAO,KAAKC,gBAAgB,MAAM,uBAAuB;AAEzD;;;AAGA,OAAO,KAAKC,OAAO,MAAM,cAAc;AAEvC;;;AAGA,OAAO,KAAKC,cAAc,MAAM,qBAAqB;AAErD;;;AAGA,OAAO,KAAKC,KAAK,MAAM,YAAY;AAEnC;;;AAGA,OAAO,KAAKC,MAAM,MAAM,aAAa;AAErC;;;AAGA,OAAO,KAAKC,aAAa,MAAM,oBAAoB;AAEnD;;;AAGA,OAAO,KAAKC,YAAY,MAAM,mBAAmB;AAEjD;;;AAGA,OAAO,KAAKC,YAAY,MAAM,mBAAmB;AAEjD;;;AAGA,OAAO,KAAKC,OAAO,MAAM,cAAc;AAEvC;;;AAGA,OAAO,KAAKC,OAAO,MAAM,cAAc;AAEvC;;;AAGA,OAAO,KAAKC,YAAY,MAAM,mBAAmB;AAEjD;;;AAGA,OAAO,KAAKC,YAAY,MAAM,mBAAmB;AAEjD;;;AAGA,OAAO,KAAKC,QAAQ,MAAM,eAAe;AAEzC;;;AAGA,OAAO,KAAKC,cAAc,MAAM,qBAAqB;AAErD;;;AAGA,OAAO,KAAKC,yBAAyB,MAAM,gCAAgC;AAE3E;;;AAGA,OAAO,KAAKC,SAAS,MAAM,gBAAgB;AAE3C;;;AAGA,OAAO,KAAKC,gBAAgB,MAAM,uBAAuB;AAEzD;;;AAGA,OAAO,KAAKC,SAAS,MAAM,gBAAgB;AAE3C;;;AAGA,OAAO,KAAKC,YAAY,MAAM,mBAAmB;AAEjD;;;AAGA,OAAO,KAAKC,kBAAkB,MAAM,yBAAyB;AAE7D;;;AAGA,OAAO,KAAKC,iBAAiB,MAAM,wBAAwB;AAE3D;;;AAGA,OAAO,KAAKC,eAAe,MAAM,sBAAsB;AAEvD;;;AAGA,OAAO,KAAKC,iBAAiB,MAAM,wBAAwB","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/esm/internal/entityManager.js b/dist/esm/internal/entityManager.js
index 9390766a46079e75fd7b93acdf5d5f0f0451acd5..603a63c45c7c9ae1a346efd8907313c80391c546 100644
--- a/dist/esm/internal/entityManager.js
+++ b/dist/esm/internal/entityManager.js
@@ -1,159 +1,328 @@
-import * as Clock from "effect/Clock";
+import { RequestId } from "@effect/rpc/RpcMessage";
+import * as RpcServer from "@effect/rpc/RpcServer";
+import * as Arr from "effect/Array";
+import * as Cause from "effect/Cause";
+import * as Context from "effect/Context";
 import * as Duration from "effect/Duration";
 import * as Effect from "effect/Effect";
 import * as Exit from "effect/Exit";
-import * as Fiber from "effect/Fiber";
-import { pipe } from "effect/Function";
+import * as FiberRef from "effect/FiberRef";
+import { identity } from "effect/Function";
 import * as HashMap from "effect/HashMap";
-import * as HashSet from "effect/HashSet";
+import * as Metric from "effect/Metric";
 import * as Option from "effect/Option";
+import * as Schedule from "effect/Schedule";
+import * as Schema from "effect/Schema";
 import * as Scope from "effect/Scope";
-import * as RefSynchronized from "effect/SynchronizedRef";
+import { AlreadyProcessingMessage, EntityNotManagedByRunner, MailboxFull, MalformedMessage } from "../ClusterError.js";
+import * as ClusterMetrics from "../ClusterMetrics.js";
+import { Persisted } from "../ClusterSchema.js";
+import { CurrentAddress, CurrentRunnerAddress, Request } from "../Entity.js";
+import * as Envelope from "../Envelope.js";
 import * as Message from "../Message.js";
-import * as MessageState from "../MessageState.js";
-import * as RecipientBehaviourContext from "../RecipientBehaviourContext.js";
-import * as ShardingException from "../ShardingException.js";
-import * as EntityState from "./entityState.js";
+import * as MessageStorage from "../MessageStorage.js";
+import * as Reply from "../Reply.js";
+import { ShardingConfig } from "../ShardingConfig.js";
+import * as Snowflake from "../Snowflake.js";
+import { EntityReaper } from "./entityReaper.js";
+import { internalInterruptors } from "./interruptors.js";
+import { ResourceMap } from "./resourceMap.js";
+import { ResourceRef } from "./resourceRef.js";
 /** @internal */
-const EntityManagerSymbolKey = "@effect/cluster/EntityManager";
-/** @internal */
-export const EntityManagerTypeId = /*#__PURE__*/Symbol.for(EntityManagerSymbolKey);
-/** @internal */
-export function make(recipientType, recipientBehaviour, sharding, config, serialization, options = {}) {
-  return Effect.gen(function* () {
-    const entityMaxIdle = options.entityMaxIdleTime || Option.none();
-    const env = yield* Effect.context();
-    const entityStates = yield* RefSynchronized.make(HashMap.empty());
-    function startExpirationFiber(recipientAddress) {
-      const maxIdleMillis = pipe(entityMaxIdle, Option.getOrElse(() => config.entityMaxIdleTime), Duration.toMillis);
-      function sleep(duration) {
-        return pipe(Effect.Do, Effect.zipLeft(Clock.sleep(Duration.millis(duration))), Effect.bind("cdt", () => Clock.currentTimeMillis), Effect.bind("map", () => RefSynchronized.get(entityStates)), Effect.let("lastReceivedAt", ({
-          map
-        }) => pipe(HashMap.get(map, recipientAddress), Option.map(_ => _.lastReceivedAt), Option.getOrElse(() => 0))), Effect.let("remaining", ({
-          cdt,
-          lastReceivedAt
-        }) => maxIdleMillis - cdt + lastReceivedAt), Effect.tap(_ => _.remaining > 0 ? sleep(_.remaining) : Effect.void));
-      }
-      return pipe(sleep(maxIdleMillis), Effect.zipRight(forkEntityTermination(recipientAddress)), Effect.asVoid, Effect.interruptible, Effect.annotateLogs("entityId", recipientAddress), Effect.annotateLogs("recipientType", recipientType.name), Effect.forkDaemon);
-    }
-    /**
-     * Performs proper termination of the entity, interrupting the expiration timer, closing the scope and failing pending replies
-     */
-    function terminateEntity(recipientAddress) {
-      return pipe(
-      // get the things to cleanup
-      RefSynchronized.get(entityStates), Effect.map(HashMap.get(recipientAddress)), Effect.flatMap(Option.match({
-        // there is no entity state to cleanup
-        onNone: () => Effect.void,
-        // found it!
-        onSome: entityState => pipe(
-        // interrupt the expiration timer
-        Fiber.interrupt(entityState.expirationFiber),
-        // close the scope of the entity,
-        Effect.ensuring(Scope.close(entityState.executionScope, Exit.void)),
-        // remove the entry from the map
-        Effect.ensuring(RefSynchronized.update(entityStates, HashMap.remove(recipientAddress))),
-        // log error if happens
-        Effect.catchAllCause(Effect.logError), Effect.asVoid, Effect.annotateLogs("entityId", recipientAddress.entityId), Effect.annotateLogs("recipientType", recipientAddress.recipientTypeName))
-      })));
-    }
-    /**
-     * Begins entity termination (if needed) and return the fiber to wait for completed termination (if any)
-     */
-    function forkEntityTermination(recipientAddress) {
-      return RefSynchronized.modifyEffect(entityStates, entityStatesMap => pipe(HashMap.get(entityStatesMap, recipientAddress), Option.match({
-        // if no entry is found, the entity has succefully shut down
-        onNone: () => Effect.succeed([Option.none(), entityStatesMap]),
-        // there is an entry, so we should begin termination
-        onSome: entityState => pipe(entityState.terminationFiber, Option.match({
-          // termination has already begun, keep everything as-is
-          onSome: () => Effect.succeed([entityState.terminationFiber, entityStatesMap]),
-          // begin to terminate the queue
-          onNone: () => pipe(terminateEntity(recipientAddress), Effect.forkDaemon, Effect.map(terminationFiber => [Option.some(terminationFiber), HashMap.modify(entityStatesMap, recipientAddress, EntityState.withTerminationFiber(terminationFiber))]))
-        }))
-      })));
+export const make = /*#__PURE__*/Effect.fnUntraced(function* (entity, buildHandlers, options) {
+  const config = yield* ShardingConfig;
+  const snowflakeGen = yield* Snowflake.Generator;
+  const managerScope = yield* Effect.scope;
+  const storageEnabled = options.storage !== MessageStorage.noop;
+  const mailboxCapacity = options.mailboxCapacity ?? config.entityMailboxCapacity;
+  const clock = yield* Effect.clock;
+  const context = yield* Effect.context();
+  const activeServers = new Map();
+  const entities = yield* ResourceMap.make(Effect.fnUntraced(function* (address) {
+    if (yield* options.sharding.isShutdown) {
+      return yield* new EntityNotManagedByRunner({
+        address
+      });
     }
-    function getOrCreateEntityState(recipientAddress) {
-      return RefSynchronized.modifyEffect(entityStates, map => pipe(HashMap.get(map, recipientAddress), Option.match({
-        onSome: entityState => pipe(entityState.terminationFiber, Option.match({
-          // offer exists, delay the interruption fiber and return the offer
-          onNone: () => pipe(Clock.currentTimeMillis, Effect.map(cdt => [Option.some(entityState), HashMap.modify(map, recipientAddress, EntityState.withLastReceivedAd(cdt))])),
-          // the queue is shutting down, stash and retry
-          onSome: () => Effect.succeed([Option.none(), map])
-        })),
-        onNone: () => Effect.flatMap(sharding.isShuttingDown, isGoingDown => {
-          if (isGoingDown) {
-            // don't start any fiber while sharding is shutting down
-            return Effect.fail(new ShardingException.EntityNotManagedByThisPodException({
-              recipientAddress
-            }));
-          } else {
-            // offer doesn't exist, create a new one
-            return Effect.gen(function* () {
-              const executionScope = yield* Scope.make();
-              const expirationFiber = yield* startExpirationFiber(recipientAddress);
-              const cdt = yield* Clock.currentTimeMillis;
-              const forkShutdown = pipe(forkEntityTermination(recipientAddress), Effect.asVoid);
-              const shardId = sharding.getShardId(recipientAddress);
-              const sendAndGetState = yield* pipe(recipientBehaviour, Effect.map(offer => envelope => pipe(serialization.decode(recipientType.schema, envelope.body), Effect.flatMap(message => pipe(offer(message), Effect.flatMap(_ => MessageState.mapEffect(_, value => serialization.encode(Message.exitSchema(message), value))))))), Scope.extend(executionScope), Effect.provideService(RecipientBehaviourContext.RecipientBehaviourContext, RecipientBehaviourContext.make({
-                recipientAddress,
-                shardId,
-                recipientType: recipientType,
-                forkShutdown
-              })), Effect.provide(env));
-              const entityState = EntityState.make({
-                sendAndGetState,
-                expirationFiber,
-                executionScope,
-                terminationFiber: Option.none(),
-                lastReceivedAt: cdt
-              });
-              return [Option.some(entityState), HashMap.set(map, recipientAddress, entityState)];
-            });
+    const scope = yield* Effect.scope;
+    const endLatch = yield* Effect.makeLatch();
+    // on shutdown, reset the storage for the entity
+    yield* Scope.addFinalizer(scope, Effect.ignore(options.storage.resetAddress(address)));
+    const activeRequests = new Map();
+    let defectRequestIds = [];
+    // the server is stored in a ref, so if there is a defect, we can
+    // swap the server without losing the active requests
+    const writeRef = yield* ResourceRef.from(scope, Effect.fnUntraced(function* (scope) {
+      let isShuttingDown = false;
+      // Initiate the behavior for the entity
+      const handlers = yield* entity.protocol.toHandlersContext(buildHandlers).pipe(Effect.provide(context.pipe(Context.add(CurrentAddress, address), Context.add(CurrentRunnerAddress, options.runnerAddress), Context.add(Scope.Scope, scope))), Effect.locally(FiberRef.currentLogAnnotations, HashMap.empty()));
+      const server = yield* RpcServer.makeNoSerialization(entity.protocol, {
+        spanPrefix: `${entity.type}(${address.entityId})`,
+        concurrency: options.concurrency ?? 1,
+        onFromServer(response) {
+          switch (response._tag) {
+            case "Exit":
+              {
+                const request = activeRequests.get(response.requestId);
+                if (!request) return Effect.void;
+                // For durable messages, ignore interrupts during shutdown.
+                // They will be retried when the entity is restarted.
+                if (storageEnabled && isShuttingDown && Context.get(request.rpc.annotations, Persisted) && Exit.isInterrupted(response.exit)) {
+                  return Effect.void;
+                }
+                return retryRespond(4, Effect.suspend(() => request.message.respond(new Reply.WithExit({
+                  requestId: Snowflake.Snowflake(response.requestId),
+                  id: snowflakeGen.unsafeNext(),
+                  exit: response.exit
+                })))).pipe(Effect.flatMap(() => {
+                  activeRequests.delete(response.requestId);
+                  // ensure that the reaper does not remove the entity as we haven't
+                  // been "idle" yet
+                  if (activeRequests.size === 0) {
+                    state.lastActiveCheck = clock.unsafeCurrentTimeMillis();
+                  }
+                  return Effect.void;
+                }), Effect.orDie);
+              }
+            case "Chunk":
+              {
+                const request = activeRequests.get(response.requestId);
+                if (!request) return Effect.void;
+                const sequence = request.sequence;
+                request.sequence++;
+                return Effect.orDie(retryRespond(4, Effect.suspend(() => {
+                  const reply = new Reply.Chunk({
+                    requestId: Snowflake.Snowflake(response.requestId),
+                    id: snowflakeGen.unsafeNext(),
+                    sequence,
+                    values: response.values
+                  });
+                  request.lastSentChunk = Option.some(reply);
+                  return request.message.respond(reply);
+                })));
+              }
+            case "Defect":
+              {
+                const effect = writeRef.unsafeRebuild();
+                defectRequestIds = Array.from(activeRequests.keys());
+                return Effect.logError("Defect in entity, restarting", Cause.die(response.defect)).pipe(Effect.andThen(effect.pipe(Effect.tapErrorCause(Effect.logError), Effect.retry(Schedule.spaced(500)))), Effect.annotateLogs({
+                  module: "EntityManager",
+                  address,
+                  runner: options.runnerAddress
+                }));
+              }
+            case "ClientEnd":
+              {
+                return endLatch.open;
+              }
           }
-        })
-      })));
-    }
-    function sendAndGetState(envelope) {
-      return pipe(Effect.Do, Effect.tap(() => {
-        // first, verify that this entity should be handled by this pod
-        if (recipientType._tag === "EntityType") {
-          return Effect.asVoid(Effect.unlessEffect(Effect.fail(new ShardingException.EntityNotManagedByThisPodException({
-            recipientAddress: envelope.recipientAddress
-          })), sharding.isEntityOnLocalShards(envelope.recipientAddress)));
-        } else if (recipientType._tag === "TopicType") {
-          return Effect.void;
         }
-        return Effect.die("Unhandled recipientType");
-      }), Effect.bind("maybeEntityState", () => getOrCreateEntityState(envelope.recipientAddress)), Effect.flatMap(_ => pipe(_.maybeEntityState, Option.match({
-        onNone: () => pipe(Effect.sleep(Duration.millis(100)), Effect.flatMap(() => sendAndGetState(envelope))),
-        onSome: entityState => {
-          return entityState.sendAndGetState(envelope);
+      }).pipe(Scope.extend(scope), Effect.provide(handlers));
+      yield* Scope.addFinalizer(scope, Effect.sync(() => {
+        isShuttingDown = true;
+      }));
+      for (const id of defectRequestIds) {
+        const {
+          lastSentChunk,
+          message
+        } = activeRequests.get(id);
+        yield* server.write(0, {
+          ...message.envelope,
+          id: RequestId(message.envelope.requestId),
+          tag: message.envelope.tag,
+          payload: new Request({
+            ...message.envelope,
+            lastSentChunk
+          })
+        });
+      }
+      defectRequestIds = [];
+      return server.write;
+    }));
+    const state = {
+      address,
+      mailboxGauge: ClusterMetrics.mailboxSize.pipe(Metric.tagged("type", entity.type), Metric.tagged("entityId", address.entityId)),
+      write(clientId, message) {
+        if (writeRef.state.current._tag !== "Acquired") {
+          return Effect.flatMap(writeRef.await, write => write(clientId, message));
         }
-      }))));
+        return writeRef.state.current.value(clientId, message);
+      },
+      activeRequests,
+      lastActiveCheck: clock.unsafeCurrentTimeMillis()
+    };
+    // During shutdown, signal that no more messages will be processed
+    // and wait for the fiber to complete.
+    //
+    // If the termination timeout is reached, let the server clean itself up
+    yield* Scope.addFinalizer(scope, Effect.withFiberRuntime(fiber => {
+      activeServers.delete(address.entityId);
+      internalInterruptors.add(fiber.id());
+      return state.write(0, {
+        _tag: "Eof"
+      }).pipe(Effect.andThen(Effect.interruptible(endLatch.await)), Effect.timeoutOption(config.entityTerminationTimeout));
+    }));
+    activeServers.set(address.entityId, state);
+    return state;
+  }, Effect.locally(FiberRef.currentLogAnnotations, HashMap.empty())));
+  const reaper = yield* EntityReaper;
+  const maxIdleTime = Duration.toMillis(options.maxIdleTime ?? config.entityMaxIdleTime);
+  if (Number.isFinite(maxIdleTime)) {
+    yield* reaper.register({
+      maxIdleTime,
+      servers: activeServers,
+      entities
+    });
+  }
+  // update metrics for active servers
+  const gauge = ClusterMetrics.entities.pipe(Metric.tagged("type", entity.type));
+  yield* Effect.sync(() => {
+    gauge.unsafeUpdate(BigInt(activeServers.size), []);
+    for (const state of activeServers.values()) {
+      state.mailboxGauge.unsafeUpdate(BigInt(state.activeRequests.size), []);
     }
-    const terminateAllEntities = pipe(RefSynchronized.get(entityStates), Effect.map(HashMap.keySet), Effect.flatMap(terminateEntities));
-    function terminateEntities(entitiesToTerminate) {
-      return pipe(entitiesToTerminate, Effect.forEach(recipientAddress => pipe(forkEntityTermination(recipientAddress), Effect.flatMap(_ => Option.match(_, {
-        onNone: () => Effect.void,
-        onSome: terminationFiber => pipe(Fiber.await(terminationFiber), Effect.timeout(config.entityTerminationTimeout), Effect.match({
-          onFailure: () => Effect.logError(`Entity ${recipientAddress} termination is taking more than expected entityTerminationTimeout (${Duration.toMillis(config.entityTerminationTimeout)}ms).`),
-          onSuccess: () => Effect.logDebug(`Entity ${recipientAddress} cleaned up.`)
-        }), Effect.asVoid)
-      }))), {
-        concurrency: "inherit"
-      }), Effect.asVoid);
+  }).pipe(Effect.andThen(Effect.sleep(1000)), Effect.forever, Effect.forkIn(managerScope));
+  function sendLocal(message) {
+    return Effect.locally(Effect.flatMap(entities.get(message.envelope.address), server => {
+      switch (message._tag) {
+        case "IncomingRequestLocal":
+          {
+            // If the request is already running, then we might have more than
+            // one sender for the same request. In this case, the other senders
+            // should resume from storage only.
+            let entry = server.activeRequests.get(message.envelope.requestId);
+            if (entry) {
+              return Effect.fail(new AlreadyProcessingMessage({
+                envelopeId: message.envelope.requestId,
+                address: message.envelope.address
+              }));
+            }
+            if (mailboxCapacity !== "unbounded" && server.activeRequests.size >= mailboxCapacity) {
+              return Effect.fail(new MailboxFull({
+                address: message.envelope.address
+              }));
+            }
+            entry = {
+              rpc: entity.protocol.requests.get(message.envelope.tag),
+              message,
+              lastSentChunk: message.lastSentReply,
+              sequence: Option.match(message.lastSentReply, {
+                onNone: () => 0,
+                onSome: reply => reply._tag === "Chunk" ? reply.sequence + 1 : 0
+              })
+            };
+            server.activeRequests.set(message.envelope.requestId, entry);
+            return server.write(0, {
+              ...message.envelope,
+              id: RequestId(message.envelope.requestId),
+              payload: new Request({
+                ...message.envelope,
+                lastSentChunk: message.lastSentReply
+              })
+            });
+          }
+        case "IncomingEnvelope":
+          {
+            const entry = server.activeRequests.get(message.envelope.requestId);
+            if (!entry) {
+              return Effect.fail(new EntityNotManagedByRunner({
+                address: message.envelope.address
+              }));
+            } else if (message.envelope._tag === "AckChunk" && Option.isSome(entry.lastSentChunk) && message.envelope.replyId !== entry.lastSentChunk.value.id) {
+              return Effect.void;
+            }
+            return server.write(0, message.envelope._tag === "AckChunk" ? {
+              _tag: "Ack",
+              requestId: RequestId(message.envelope.requestId)
+            } : {
+              _tag: "Interrupt",
+              requestId: RequestId(message.envelope.requestId),
+              interruptors: []
+            });
+          }
+      }
+    }), FiberRef.currentLogAnnotations, HashMap.empty());
+  }
+  const interruptShard = shardId => Effect.suspend(function loop() {
+    const toInterrupt = new Set();
+    for (const state of activeServers.values()) {
+      if (shardId === state.address.shardId) {
+        toInterrupt.add(state);
+      }
     }
-    function terminateEntitiesOnShards(shards) {
-      return pipe(RefSynchronized.modify(entityStates, entities => [HashMap.filter(entities, (_, recipientAddress) => HashSet.has(shards, sharding.getShardId(recipientAddress))), entities]), Effect.map(HashMap.keySet), Effect.flatMap(terminateEntities));
+    if (toInterrupt.size === 0) {
+      return Effect.void;
     }
-    const self = {
-      [EntityManagerTypeId]: EntityManagerTypeId,
-      sendAndGetState,
-      terminateAllEntities,
-      terminateEntitiesOnShards
-    };
-    return self;
+    return Effect.flatMap(Effect.forEach(toInterrupt, state => entities.removeIgnore(state.address), {
+      concurrency: "unbounded",
+      discard: true
+    }), loop);
+  });
+  const decodeMessage = Schema.decode(makeMessageSchema(entity));
+  return identity({
+    interruptShard,
+    isProcessingFor(message) {
+      const state = activeServers.get(message.envelope.address.entityId);
+      if (!state) return false;
+      return state.activeRequests.has(message.envelope.requestId);
+    },
+    sendLocal,
+    send: message => decodeMessage(message).pipe(Effect.matchEffect({
+      onFailure: cause => {
+        if (message._tag === "IncomingEnvelope") {
+          return Effect.die(new MalformedMessage({
+            cause
+          }));
+        }
+        return Effect.orDie(message.respond(new Reply.ReplyWithContext({
+          reply: new Reply.WithExit({
+            id: snowflakeGen.unsafeNext(),
+            requestId: message.envelope.requestId,
+            exit: Exit.die(new MalformedMessage({
+              cause
+            }))
+          }),
+          rpc: entity.protocol.requests.get(message.envelope.tag),
+          context
+        })));
+      },
+      onSuccess: decoded => {
+        if (decoded._tag === "IncomingEnvelope") {
+          return sendLocal(new Message.IncomingEnvelope(decoded));
+        }
+        const request = message;
+        const rpc = entity.protocol.requests.get(decoded.envelope.tag);
+        return sendLocal(new Message.IncomingRequestLocal({
+          envelope: decoded.envelope,
+          lastSentReply: decoded.lastSentReply,
+          respond: reply => request.respond(new Reply.ReplyWithContext({
+            reply,
+            rpc,
+            context
+          }))
+        }));
+      }
+    }), Effect.provide(context))
   });
-}
+});
+const makeMessageSchema = entity => {
+  const requests = Arr.empty();
+  for (const rpc of entity.protocol.requests.values()) {
+    requests.push(Schema.TaggedStruct("IncomingRequest", {
+      envelope: Schema.transform(Schema.Struct({
+        ...Envelope.PartialEncodedRequestFromSelf.fields,
+        tag: Schema.Literal(rpc._tag),
+        payload: rpc.payloadSchema
+      }), Envelope.RequestFromSelf, {
+        decode: encoded => Envelope.makeRequest(encoded),
+        encode: identity
+      }),
+      lastSentReply: Schema.OptionFromSelf(Reply.Reply(rpc))
+    }));
+  }
+  return Schema.Union(...requests, Schema.TaggedStruct("IncomingEnvelope", {
+    envelope: Schema.Union(Schema.typeSchema(Envelope.AckChunk), Schema.typeSchema(Envelope.Interrupt))
+  }));
+};
+const retryRespond = (times, effect) => times === 0 ? effect : Effect.catchAll(effect, () => Effect.delay(retryRespond(times - 1, effect), 200));
 //# sourceMappingURL=entityManager.js.map
\ No newline at end of file
diff --git a/dist/esm/internal/entityManager.js.map b/dist/esm/internal/entityManager.js.map
index 84b63c6fb6c173d9730f07a8c92064672c6834a8..bd037552de98dc08038e7ad2040fb408bc593c4f 100644
--- a/dist/esm/internal/entityManager.js.map
+++ b/dist/esm/internal/entityManager.js.map
@@ -1 +1 @@
-{"version":3,"file":"entityManager.js","names":["Clock","Duration","Effect","Exit","Fiber","pipe","HashMap","HashSet","Option","Scope","RefSynchronized","Message","MessageState","RecipientBehaviourContext","ShardingException","EntityState","EntityManagerSymbolKey","EntityManagerTypeId","Symbol","for","make","recipientType","recipientBehaviour","sharding","config","serialization","options","gen","entityMaxIdle","entityMaxIdleTime","none","env","context","entityStates","empty","startExpirationFiber","recipientAddress","maxIdleMillis","getOrElse","toMillis","sleep","duration","Do","zipLeft","millis","bind","currentTimeMillis","get","let","map","_","lastReceivedAt","cdt","tap","remaining","void","zipRight","forkEntityTermination","asVoid","interruptible","annotateLogs","name","forkDaemon","terminateEntity","flatMap","match","onNone","onSome","entityState","interrupt","expirationFiber","ensuring","close","executionScope","update","remove","catchAllCause","logError","entityId","recipientTypeName","modifyEffect","entityStatesMap","succeed","terminationFiber","some","modify","withTerminationFiber","getOrCreateEntityState","withLastReceivedAd","isShuttingDown","isGoingDown","fail","EntityNotManagedByThisPodException","forkShutdown","shardId","getShardId","sendAndGetState","offer","envelope","decode","schema","body","message","mapEffect","value","encode","exitSchema","extend","provideService","provide","set","_tag","unlessEffect","isEntityOnLocalShards","die","maybeEntityState","terminateAllEntities","keySet","terminateEntities","entitiesToTerminate","forEach","await","timeout","entityTerminationTimeout","onFailure","onSuccess","logDebug","concurrency","terminateEntitiesOnShards","shards","entities","filter","has","self"],"sources":["../../../src/internal/entityManager.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
+{"version":3,"file":"entityManager.js","names":["RequestId","RpcServer","Arr","Cause","Context","Duration","Effect","Exit","FiberRef","identity","HashMap","Metric","Option","Schedule","Schema","Scope","AlreadyProcessingMessage","EntityNotManagedByRunner","MailboxFull","MalformedMessage","ClusterMetrics","Persisted","CurrentAddress","CurrentRunnerAddress","Request","Envelope","Message","MessageStorage","Reply","ShardingConfig","Snowflake","EntityReaper","internalInterruptors","ResourceMap","ResourceRef","make","fnUntraced","entity","buildHandlers","options","config","snowflakeGen","Generator","managerScope","scope","storageEnabled","storage","noop","mailboxCapacity","entityMailboxCapacity","clock","context","activeServers","Map","entities","address","sharding","isShutdown","endLatch","makeLatch","addFinalizer","ignore","resetAddress","activeRequests","defectRequestIds","writeRef","from","isShuttingDown","handlers","protocol","toHandlersContext","pipe","provide","add","runnerAddress","locally","currentLogAnnotations","empty","server","makeNoSerialization","spanPrefix","type","entityId","concurrency","onFromServer","response","_tag","request","get","requestId","void","rpc","annotations","isInterrupted","exit","retryRespond","suspend","message","respond","WithExit","id","unsafeNext","flatMap","delete","size","state","lastActiveCheck","unsafeCurrentTimeMillis","orDie","sequence","reply","Chunk","values","lastSentChunk","some","effect","unsafeRebuild","Array","keys","logError","die","defect","andThen","tapErrorCause","retry","spaced","annotateLogs","module","runner","open","extend","sync","write","envelope","tag","payload","mailboxGauge","mailboxSize","tagged","clientId","current","await","value","withFiberRuntime","fiber","interruptible","timeoutOption","entityTerminationTimeout","set","reaper","maxIdleTime","toMillis","entityMaxIdleTime","Number","isFinite","register","servers","gauge","unsafeUpdate","BigInt","sleep","forever","forkIn","sendLocal","entry","fail","envelopeId","requests","lastSentReply","match","onNone","onSome","isSome","replyId","interruptors","interruptShard","shardId","loop","toInterrupt","Set","forEach","removeIgnore","discard","decodeMessage","decode","makeMessageSchema","isProcessingFor","has","send","matchEffect","onFailure","cause","ReplyWithContext","onSuccess","decoded","IncomingEnvelope","IncomingRequestLocal","push","TaggedStruct","transform","Struct","PartialEncodedRequestFromSelf","fields","Literal","payloadSchema","RequestFromSelf","encoded","makeRequest","encode","OptionFromSelf","Union","typeSchema","AckChunk","Interrupt","times","catchAll","delay"],"sources":["../../../src/internal/entityManager.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/esm/internal/entityReaper.js b/dist/esm/internal/entityReaper.js
new file mode 100644
index 0000000000000000000000000000000000000000..a540f0b6a1820fb5f6cc522a20e3a02eed239841
--- /dev/null
+++ b/dist/esm/internal/entityReaper.js
@@ -0,0 +1,38 @@
+import * as Effect from "effect/Effect";
+/** @internal */
+export class EntityReaper extends /*#__PURE__*/Effect.Service()("@effect/cluster/EntityReaper", {
+  scoped: /*#__PURE__*/Effect.gen(function* () {
+    let currentResolution = 30_000;
+    const registered = [];
+    const latch = yield* Effect.makeLatch();
+    const register = options => Effect.suspend(() => {
+      currentResolution = Math.max(Math.min(currentResolution, options.maxIdleTime), 5000);
+      registered.push(options);
+      return latch.open;
+    });
+    const clock = yield* Effect.clock;
+    yield* Effect.gen(function* () {
+      while (true) {
+        yield* Effect.sleep(currentResolution);
+        const now = clock.unsafeCurrentTimeMillis();
+        for (const {
+          entities,
+          maxIdleTime,
+          servers
+        } of registered) {
+          for (const state of servers.values()) {
+            const duration = now - state.lastActiveCheck;
+            if (state.activeRequests.size > 0 || duration < maxIdleTime) {
+              continue;
+            }
+            yield* Effect.fork(entities.removeIgnore(state.address));
+          }
+        }
+      }
+    }).pipe(latch.whenOpen, Effect.interruptible, Effect.forkScoped);
+    return {
+      register
+    };
+  })
+}) {}
+//# sourceMappingURL=entityReaper.js.map
\ No newline at end of file
diff --git a/dist/esm/internal/entityReaper.js.map b/dist/esm/internal/entityReaper.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..40fa56b4e35efd99392f8ba96b467f5cd759ceca
--- /dev/null
+++ b/dist/esm/internal/entityReaper.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"entityReaper.js","names":["Effect","EntityReaper","Service","scoped","gen","currentResolution","registered","latch","makeLatch","register","options","suspend","Math","max","min","maxIdleTime","push","open","clock","sleep","now","unsafeCurrentTimeMillis","entities","servers","state","values","duration","lastActiveCheck","activeRequests","size","fork","removeIgnore","address","pipe","whenOpen","interruptible","forkScoped"],"sources":["../../../src/internal/entityReaper.ts"],"sourcesContent":[null],"mappings":"AAAA,OAAO,KAAKA,MAAM,MAAM,eAAe;AAOvC;AACA,OAAM,MAAOC,YAAa,sBAAQD,MAAM,CAACE,OAAO,EAAgB,CAAC,8BAA8B,EAAE;EAC/FC,MAAM,eAAEH,MAAM,CAACI,GAAG,CAAC,aAAS;IAC1B,IAAIC,iBAAiB,GAAG,MAAM;IAC9B,MAAMC,UAAU,GAIX,EAAE;IACP,MAAMC,KAAK,GAAG,OAAOP,MAAM,CAACQ,SAAS,EAAE;IAEvC,MAAMC,QAAQ,GAAIC,OAIjB,IACCV,MAAM,CAACW,OAAO,CAAC,MAAK;MAClBN,iBAAiB,GAAGO,IAAI,CAACC,GAAG,CAACD,IAAI,CAACE,GAAG,CAACT,iBAAiB,EAAEK,OAAO,CAACK,WAAW,CAAC,EAAE,IAAI,CAAC;MACpFT,UAAU,CAACU,IAAI,CAACN,OAAO,CAAC;MACxB,OAAOH,KAAK,CAACU,IAAI;IACnB,CAAC,CAAC;IAEJ,MAAMC,KAAK,GAAG,OAAOlB,MAAM,CAACkB,KAAK;IACjC,OAAOlB,MAAM,CAACI,GAAG,CAAC,aAAS;MACzB,OAAO,IAAI,EAAE;QACX,OAAOJ,MAAM,CAACmB,KAAK,CAACd,iBAAiB,CAAC;QACtC,MAAMe,GAAG,GAAGF,KAAK,CAACG,uBAAuB,EAAE;QAC3C,KAAK,MAAM;UAAEC,QAAQ;UAAEP,WAAW;UAAEQ;QAAO,CAAE,IAAIjB,UAAU,EAAE;UAC3D,KAAK,MAAMkB,KAAK,IAAID,OAAO,CAACE,MAAM,EAAE,EAAE;YACpC,MAAMC,QAAQ,GAAGN,GAAG,GAAGI,KAAK,CAACG,eAAe;YAC5C,IAAIH,KAAK,CAACI,cAAc,CAACC,IAAI,GAAG,CAAC,IAAIH,QAAQ,GAAGX,WAAW,EAAE;cAC3D;YACF;YACA,OAAOf,MAAM,CAAC8B,IAAI,CAACR,QAAQ,CAACS,YAAY,CAACP,KAAK,CAACQ,OAAO,CAAC,CAAC;UAC1D;QACF;MACF;IACF,CAAC,CAAC,CAACC,IAAI,CACL1B,KAAK,CAAC2B,QAAQ,EACdlC,MAAM,CAACmC,aAAa,EACpBnC,MAAM,CAACoC,UAAU,CAClB;IAED,OAAO;MAAE3B;IAAQ,CAAW;EAC9B,CAAC;CACF,CAAC","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/esm/internal/hash.js b/dist/esm/internal/hash.js
new file mode 100644
index 0000000000000000000000000000000000000000..7618cf391ff5580dabb1600449eedb30f5c56630
--- /dev/null
+++ b/dist/esm/internal/hash.js
@@ -0,0 +1,12 @@
+/** @internal */
+export const hashOptimize = n => n & 0xbfffffff | n >>> 1 & 0x40000000;
+/** @internal */
+export const hashString = str => {
+  let h = 5381,
+    i = str.length;
+  while (i) {
+    h = h * 33 ^ str.charCodeAt(--i);
+  }
+  return hashOptimize(h);
+};
+//# sourceMappingURL=hash.js.map
\ No newline at end of file
diff --git a/dist/esm/internal/hash.js.map b/dist/esm/internal/hash.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..512ef6c584216aade7b653826bc7e58f35c71298
--- /dev/null
+++ b/dist/esm/internal/hash.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"hash.js","names":["hashOptimize","n","hashString","str","h","i","length","charCodeAt"],"sources":["../../../src/internal/hash.ts"],"sourcesContent":[null],"mappings":"AAAA;AACA,OAAO,MAAMA,YAAY,GAAIC,CAAS,IAAcA,CAAC,GAAG,UAAU,GAAMA,CAAC,KAAK,CAAC,GAAI,UAAW;AAE9F;AACA,OAAO,MAAMC,UAAU,GAAIC,GAAW,IAAI;EACxC,IAAIC,CAAC,GAAG,IAAI;IAAEC,CAAC,GAAGF,GAAG,CAACG,MAAM;EAC5B,OAAOD,CAAC,EAAE;IACRD,CAAC,GAAIA,CAAC,GAAG,EAAE,GAAID,GAAG,CAACI,UAAU,CAAC,EAAEF,CAAC,CAAC;EACpC;EACA,OAAOL,YAAY,CAACI,CAAC,CAAC;AACxB,CAAC","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/esm/internal/interruptors.js b/dist/esm/internal/interruptors.js
new file mode 100644
index 0000000000000000000000000000000000000000..bb90c64f59207b88ad7626c14211a1883e038d15
--- /dev/null
+++ b/dist/esm/internal/interruptors.js
@@ -0,0 +1,3 @@
+/** @internal */
+export const internalInterruptors = /*#__PURE__*/new WeakSet();
+//# sourceMappingURL=interruptors.js.map
\ No newline at end of file
diff --git a/dist/esm/internal/interruptors.js.map b/dist/esm/internal/interruptors.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..9cfcb01c2412c5a996b0548d89605992f110d99a
--- /dev/null
+++ b/dist/esm/internal/interruptors.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"interruptors.js","names":["internalInterruptors","WeakSet"],"sources":["../../../src/internal/interruptors.ts"],"sourcesContent":[null],"mappings":"AAEA;AACA,OAAO,MAAMA,oBAAoB,gBAAG,IAAIC,OAAO,EAAW","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/esm/internal/resourceMap.js b/dist/esm/internal/resourceMap.js
new file mode 100644
index 0000000000000000000000000000000000000000..479a4965c8827ffe84e6cf9730cc60d815d8f50f
--- /dev/null
+++ b/dist/esm/internal/resourceMap.js
@@ -0,0 +1,79 @@
+import * as Context from "effect/Context";
+import * as Deferred from "effect/Deferred";
+import * as Effect from "effect/Effect";
+import * as Exit from "effect/Exit";
+import * as MutableHashMap from "effect/MutableHashMap";
+import * as MutableRef from "effect/MutableRef";
+import * as Option from "effect/Option";
+import * as Scope from "effect/Scope";
+export class ResourceMap {
+  lookup;
+  entries;
+  isClosed;
+  constructor(lookup, entries, isClosed) {
+    this.lookup = lookup;
+    this.entries = entries;
+    this.isClosed = isClosed;
+  }
+  static make = /*#__PURE__*/Effect.fnUntraced(function* (lookup) {
+    const scope = yield* Effect.scope;
+    const context = yield* Effect.context();
+    const isClosed = MutableRef.make(false);
+    const entries = MutableHashMap.empty();
+    yield* Scope.addFinalizerExit(scope, exit => {
+      MutableRef.set(isClosed, true);
+      return Effect.forEach(entries, ([key, {
+        scope
+      }]) => {
+        MutableHashMap.remove(entries, key);
+        return Effect.exit(Scope.close(scope, exit));
+      }, {
+        concurrency: "unbounded",
+        discard: true
+      });
+    });
+    return new ResourceMap((key, scope) => Effect.provide(lookup(key), Context.add(context, Scope.Scope, scope)), entries, isClosed);
+  });
+  get(key) {
+    return Effect.withFiberRuntime(fiber => {
+      if (MutableRef.get(this.isClosed)) {
+        return Effect.interrupt;
+      }
+      const existing = MutableHashMap.get(this.entries, key);
+      if (Option.isSome(existing)) {
+        return Deferred.await(existing.value.deferred);
+      }
+      const scope = Effect.runSync(Scope.make());
+      const deferred = Deferred.unsafeMake(fiber.id());
+      MutableHashMap.set(this.entries, key, {
+        scope,
+        deferred
+      });
+      return Effect.onExit(this.lookup(key, scope), exit => {
+        if (exit._tag === "Success") {
+          return Deferred.done(deferred, exit);
+        }
+        MutableHashMap.remove(this.entries, key);
+        return Deferred.done(deferred, exit);
+      });
+    });
+  }
+  remove(key) {
+    return Effect.suspend(() => {
+      const entry = MutableHashMap.get(this.entries, key);
+      if (Option.isNone(entry)) {
+        return Effect.void;
+      }
+      MutableHashMap.remove(this.entries, key);
+      return Scope.close(entry.value.scope, Exit.void);
+    });
+  }
+  removeIgnore(key) {
+    return Effect.catchAllCause(this.remove(key), cause => Effect.annotateLogs(Effect.logDebug(cause), {
+      module: "ResourceMap",
+      method: "removeIgnore",
+      key
+    }));
+  }
+}
+//# sourceMappingURL=resourceMap.js.map
\ No newline at end of file
diff --git a/dist/esm/internal/resourceMap.js.map b/dist/esm/internal/resourceMap.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..f0243f638cd6d46432c3fa15a5ac274374b4e7a8
--- /dev/null
+++ b/dist/esm/internal/resourceMap.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"resourceMap.js","names":["Context","Deferred","Effect","Exit","MutableHashMap","MutableRef","Option","Scope","ResourceMap","lookup","entries","isClosed","constructor","make","fnUntraced","scope","context","empty","addFinalizerExit","exit","set","forEach","key","remove","close","concurrency","discard","provide","add","get","withFiberRuntime","fiber","interrupt","existing","isSome","await","value","deferred","runSync","unsafeMake","id","onExit","_tag","done","suspend","entry","isNone","void","removeIgnore","catchAllCause","cause","annotateLogs","logDebug","module","method"],"sources":["../../../src/internal/resourceMap.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/esm/internal/resourceRef.js b/dist/esm/internal/resourceRef.js
new file mode 100644
index 0000000000000000000000000000000000000000..d0513e29865f24cdb82773a2d206ddf947420460
--- /dev/null
+++ b/dist/esm/internal/resourceRef.js
@@ -0,0 +1,83 @@
+import * as Effect from "effect/Effect";
+import * as Exit from "effect/Exit";
+import * as MutableRef from "effect/MutableRef";
+import * as Option from "effect/Option";
+import * as Scope from "effect/Scope";
+import { internalInterruptors } from "./interruptors.js";
+export class ResourceRef {
+  state;
+  acquire;
+  static from = /*#__PURE__*/Effect.fnUntraced(function* (parentScope, acquire) {
+    const state = MutableRef.make({
+      _tag: "Closed"
+    });
+    yield* Scope.addFinalizerExit(parentScope, exit => {
+      const s = MutableRef.get(state);
+      if (s._tag === "Closed") {
+        return Effect.void;
+      }
+      const scope = s.scope;
+      MutableRef.set(state, {
+        _tag: "Closed"
+      });
+      return Scope.close(scope, exit);
+    });
+    const scope = yield* Scope.make();
+    MutableRef.set(state, {
+      _tag: "Acquiring",
+      scope
+    });
+    const value = yield* acquire(scope);
+    MutableRef.set(state, {
+      _tag: "Acquired",
+      scope,
+      value
+    });
+    return new ResourceRef(state, acquire);
+  });
+  constructor(state, acquire) {
+    this.state = state;
+    this.acquire = acquire;
+  }
+  latch = /*#__PURE__*/Effect.unsafeMakeLatch(true);
+  unsafeGet() {
+    if (this.state.current._tag === "Acquired") {
+      return Option.some(this.state.current.value);
+    }
+    return Option.none();
+  }
+  unsafeRebuild() {
+    const s = this.state.current;
+    if (s._tag === "Closed") {
+      return Effect.interrupt;
+    }
+    const prevScope = s.scope;
+    const scope = Effect.runSync(Scope.make());
+    this.latch.unsafeClose();
+    MutableRef.set(this.state, {
+      _tag: "Acquiring",
+      scope
+    });
+    return Effect.fiberIdWith(fiberId => {
+      internalInterruptors.add(fiberId);
+      return Scope.close(prevScope, Exit.void);
+    }).pipe(Effect.andThen(this.acquire(scope)), Effect.flatMap(value => {
+      MutableRef.set(this.state, {
+        _tag: "Acquired",
+        scope,
+        value
+      });
+      return this.latch.open;
+    }));
+  }
+  await = /*#__PURE__*/Effect.suspend(() => {
+    const s = this.state.current;
+    if (s._tag === "Closed") {
+      return Effect.interrupt;
+    } else if (s._tag === "Acquired") {
+      return Effect.succeed(s.value);
+    }
+    return Effect.zipRight(this.latch.await, this.await);
+  });
+}
+//# sourceMappingURL=resourceRef.js.map
\ No newline at end of file
diff --git a/dist/esm/internal/resourceRef.js.map b/dist/esm/internal/resourceRef.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..f7dbbeb8f60a3f039aeeb1119fcac113cba27ed5
--- /dev/null
+++ b/dist/esm/internal/resourceRef.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"resourceRef.js","names":["Effect","Exit","MutableRef","Option","Scope","internalInterruptors","ResourceRef","state","acquire","from","fnUntraced","parentScope","make","_tag","addFinalizerExit","exit","s","get","void","scope","set","close","value","constructor","latch","unsafeMakeLatch","unsafeGet","current","some","none","unsafeRebuild","interrupt","prevScope","runSync","unsafeClose","fiberIdWith","fiberId","add","pipe","andThen","flatMap","open","await","suspend","succeed","zipRight"],"sources":["../../../src/internal/resourceRef.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/dist/esm/internal/shardManager.js b/dist/esm/internal/shardManager.js
index 62842aace898f2678334c7b1a6930f7e816d4952..bfdc90708c77e0cf0097ff7c2cea8027a887a61a 100644
--- a/dist/esm/internal/shardManager.js
+++ b/dist/esm/internal/shardManager.js
@@ -1,256 +1,240 @@
-/**
- * @since 1.0.0
- */
-import * as Chunk from "effect/Chunk";
+import * as Arr from "effect/Array";
 import * as Clock from "effect/Clock";
-import { GenericTag } from "effect/Context";
 import * as Effect from "effect/Effect";
-import { equals } from "effect/Equal";
-import { pipe } from "effect/Function";
-import * as HashMap from "effect/HashMap";
-import * as HashSet from "effect/HashSet";
-import * as Layer from "effect/Layer";
-import * as List from "effect/List";
+import { constFalse } from "effect/Function";
+import * as MutableHashMap from "effect/MutableHashMap";
+import * as MutableHashSet from "effect/MutableHashSet";
 import * as Option from "effect/Option";
-import * as PubSub from "effect/PubSub";
-import * as Schedule from "effect/Schedule";
-import * as Stream from "effect/Stream";
-import * as RefSynchronized from "effect/SynchronizedRef";
-import * as ManagerConfig from "../ManagerConfig.js";
-import * as Pods from "../Pods.js";
-import * as PodsHealth from "../PodsHealth.js";
-import * as ShardId from "../ShardId.js";
-import * as ShardingEvent from "../ShardingEvent.js";
-import * as ShardingException from "../ShardingException.js";
-import * as Storage from "../Storage.js";
-import * as PodWithMetadata from "./podWithMetadata.js";
-import * as ShardManagerState from "./shardManagerState.js";
-import { groupBy, minByOption } from "./utils.js";
+import * as Order from "effect/Order";
+import { RunnerHealth } from "../RunnerHealth.js";
+import { ShardId } from "../ShardId.js";
+import { ShardStorage } from "../ShardStorage.js";
 /** @internal */
-const ShardManagerSymbolKey = "@effect/cluster/ShardManager";
-/** @internal */
-export const ShardManagerTypeId = /*#__PURE__*/Symbol.for(ShardManagerSymbolKey);
-/** @internal */
-export const shardManagerTag = /*#__PURE__*/GenericTag(ShardManagerSymbolKey);
-/** @internal */
-function make(layerScope, stateRef, rebalanceSemaphore, eventsHub, healthApi, podApi, stateRepository, config) {
-  const getAssignments = pipe(RefSynchronized.get(stateRef), Effect.map(_ => _.shards));
-  const getShardingEvents = Stream.fromPubSub(eventsHub);
-  function register(pod) {
-    return pipe(Effect.logDebug("Registering " + pod.address + "@" + pod.version), Effect.zipRight(RefSynchronized.updateAndGetEffect(stateRef, state => pipe(Effect.flatMap(Effect.clock, _ => _.currentTimeMillis), Effect.map(cdt => ShardManagerState.make(HashMap.set(state.pods, pod.address, PodWithMetadata.make(pod, cdt)), state.shards))))), Effect.zipLeft(PubSub.publish(eventsHub, ShardingEvent.PodRegistered(pod.address))), Effect.flatMap(state => Effect.when(rebalance(false), () => HashSet.size(state.unassignedShards) > 0)), Effect.zipRight(Effect.forkIn(layerScope)(persistPods)), Effect.asVoid);
+export class State {
+  runners;
+  shards;
+  static fromStorage = /*#__PURE__*/Effect.fnUntraced(function* (numberOfShards) {
+    const storage = yield* ShardStorage;
+    const runnerHealth = yield* RunnerHealth;
+    // Fetch registered runners and shard assignments from cluster storage
+    const storedRunners = yield* storage.getRunners;
+    const storedAssignments = yield* storage.getAssignments;
+    // Determine which runners are still alive
+    const deadRunners = Arr.empty();
+    const aliveRunners = MutableHashMap.empty();
+    yield* Effect.forEach(storedRunners, ([address, runner]) => Effect.map(runnerHealth.isAlive(address), isAlive => {
+      if (isAlive) {
+        MutableHashMap.set(aliveRunners, address, runner);
+      } else {
+        deadRunners.push(runner);
+      }
+    }), {
+      concurrency: "unbounded",
+      discard: true
+    });
+    if (deadRunners.length > 0) {
+      yield* Effect.logWarning("Ignoring runners that are no longer considered alive:", deadRunners);
+    }
+    // Determine which shards remain unassigned to a runner
+    const assignedShards = new Map();
+    const invalidAssignments = Arr.empty();
+    for (const [shard, address] of storedAssignments) {
+      if (Option.isSome(address) && MutableHashMap.has(aliveRunners, address.value)) {
+        assignedShards.set(shard, address.value);
+      } else if (Option.isSome(address)) {
+        invalidAssignments.push([shard, address.value]);
+      }
+    }
+    if (invalidAssignments.length > 0) {
+      yield* Effect.logWarning("Ignoring shard assignments for runners that are no longer considered alive: ", invalidAssignments);
+    }
+    // Construct the initial state
+    const now = yield* Clock.currentTimeMillis;
+    const runnerState = MutableHashMap.empty();
+    for (const [address, runner] of aliveRunners) {
+      MutableHashMap.set(runnerState, address, RunnerWithMetadata({
+        runner,
+        registeredAt: now
+      }));
+    }
+    const shardState = new Map();
+    for (let n = 1; n <= numberOfShards; n++) {
+      const shardId = ShardId.make(n);
+      shardState.set(shardId, Option.fromNullable(assignedShards.get(shardId)));
+    }
+    return new State(runnerState, shardState);
+  });
+  constructor(runners, shards) {
+    this.runners = runners;
+    this.shards = shards;
   }
-  function stateHasPod(podAddress) {
-    return pipe(RefSynchronized.get(stateRef), Effect.map(_ => HashMap.has(_.pods, podAddress)));
+  get maxVersion() {
+    if (MutableHashMap.size(this.runners) === 0) return Option.none();
+    let version = undefined;
+    for (const [, meta] of this.runners) {
+      if (version === undefined || meta.runner.version > version) {
+        version = meta.runner.version;
+      }
+    }
+    return Option.some(version);
   }
-  function notifyUnhealthyPod(podAddress) {
-    return pipe(Effect.whenEffect(pipe(PubSub.publish(eventsHub, ShardingEvent.PodHealthChecked(podAddress)), Effect.zipRight(Effect.unlessEffect(Effect.zipRight(Effect.logWarning(`${podAddress} is not alive, unregistering`), unregister(podAddress)), healthApi.isAlive(podAddress)))), stateHasPod(podAddress)), Effect.asVoid);
+  allRunnersHaveVersion(version) {
+    return version.pipe(Option.map(max => Arr.every(this.runnerVersions, version => version === max)), Option.getOrElse(constFalse));
   }
-  const checkAllPodsHealth = pipe(RefSynchronized.get(stateRef), Effect.map(_ => HashMap.keySet(_.pods)), Effect.flatMap(_ => Effect.forEach(_, notifyUnhealthyPod, {
-    concurrency: 4,
-    discard: true
-  })));
-  function unregister(podAddress) {
-    const eff = pipe(Effect.Do, Effect.zipLeft(Effect.logDebug(`Unregistering ${podAddress}`)), Effect.bind("unassignments", _ => pipe(stateRef, RefSynchronized.modify(state => [pipe(state.shards, HashMap.filter(pod => equals(pod)(Option.some(podAddress))), HashMap.keySet), {
-      ...state,
-      pods: HashMap.remove(state.pods, podAddress),
-      shards: HashMap.map(state.shards, _ => equals(_)(Option.some(podAddress)) ? Option.none() : _)
-    }]))), Effect.tap(_ => PubSub.publish(eventsHub, ShardingEvent.PodUnregistered(podAddress))), Effect.tap(_ => Effect.when(PubSub.publish(eventsHub, ShardingEvent.ShardsUnassigned(podAddress, _.unassignments)), () => HashSet.size(_.unassignments) > 0)), Effect.zipLeft(Effect.forkIn(layerScope)(persistPods)), Effect.zipLeft(Effect.forkIn(layerScope)(rebalance(true))));
-    return Effect.asVoid(Effect.whenEffect(eff, stateHasPod(podAddress)));
+  get shardsPerRunner() {
+    const shards = MutableHashMap.empty();
+    if (MutableHashMap.isEmpty(this.runners)) return shards;
+    MutableHashMap.forEach(this.runners, (_, address) => {
+      MutableHashMap.set(shards, address, new Set());
+    });
+    for (const [shard, address] of this.shards) {
+      if (Option.isNone(address)) continue;
+      const shardIds = Option.getOrUndefined(MutableHashMap.get(shards, address.value));
+      shardIds.add(shard);
+    }
+    return shards;
   }
-  function withRetry(zio) {
-    return pipe(zio, Effect.retry(pipe(Schedule.spaced(config.persistRetryInterval), Schedule.andThen(Schedule.recurs(config.persistRetryCount)))), Effect.ignore);
+  get averageShardsPerRunner() {
+    const runnerCount = MutableHashMap.size(this.runners);
+    return runnerCount > 0 ? this.shards.size / runnerCount : 0;
   }
-  const persistAssignments = withRetry(pipe(RefSynchronized.get(stateRef), Effect.flatMap(state => stateRepository.saveAssignments(state.shards))));
-  const persistPods = withRetry(pipe(RefSynchronized.get(stateRef), Effect.flatMap(state => stateRepository.savePods(HashMap.map(state.pods, v => v.pod)))));
-  function updateShardsState(shards, pod) {
-    return RefSynchronized.updateEffect(stateRef, state => {
-      if (Option.isSome(pod) && !HashMap.has(state.pods, pod.value)) {
-        return Effect.fail(new ShardingException.PodNoLongerRegisteredException({
-          podAddress: pod.value
-        }));
+  get unassignedShards() {
+    const shardIds = [];
+    for (const [shard, address] of this.shards) {
+      if (Option.isNone(address)) {
+        shardIds.push(shard);
       }
-      return Effect.succeed({
-        ...state,
-        shards: pipe(state.shards, HashMap.map((assignment, shard) => HashSet.has(shards, shard) ? pod : assignment))
-      });
-    });
+    }
+    return shardIds;
   }
-  function rebalance(rebalanceImmediately) {
-    const algo = Effect.gen(function* () {
-      const state = yield* RefSynchronized.get(stateRef);
-      const [assignments, unassignments] = rebalanceImmediately || HashSet.size(state.unassignedShards) > 0 ? decideAssignmentsForUnassignedShards(state) : decideAssignmentsForUnbalancedShards(state, config.rebalanceRate);
-      const areChanges = HashMap.size(assignments) > 0 || HashMap.size(unassignments) > 0;
-      if (areChanges) {
-        yield* Effect.logDebug("Rebalance (rebalanceImmidiately=" + JSON.stringify(rebalanceImmediately) + ")");
-      }
-      const failedPingedPods = yield* pipe(HashSet.union(HashMap.keySet(assignments), HashMap.keySet(unassignments)), Effect.forEach(pod => pipe(podApi.ping(pod), Effect.timeout(config.pingTimeout), Effect.match({
-        onFailure: () => Chunk.fromIterable([pod]),
-        onSuccess: () => Chunk.empty()
-      })), {
-        concurrency: "inherit"
-      }), Effect.map(Chunk.fromIterable), Effect.map(_ => Chunk.flatten(_)), Effect.map(HashSet.fromIterable));
-      const shardsToRemove = pipe(List.fromIterable(assignments), List.appendAll(List.fromIterable(unassignments)), List.filter(([pod, __]) => HashSet.has(failedPingedPods, pod)), List.map(([_, shards]) => List.fromIterable(shards)), List.flatMap(_ => _),
-      // TODO: List is missing flatMap
-      HashSet.fromIterable);
-      const readyAssignments = pipe(assignments, HashMap.map(HashSet.difference(shardsToRemove)), HashMap.filter(__ => HashSet.size(__) > 0));
-      const readyUnassignments = pipe(unassignments, HashMap.map(HashSet.difference(shardsToRemove)), HashMap.filter(__ => HashSet.size(__) > 0));
-      const [failedUnassignedPods, failedUnassignedShards] = yield* pipe(Effect.forEach(readyUnassignments, ([pod, shards]) => pipe(podApi.unassignShards(pod, shards), Effect.zipRight(updateShardsState(shards, Option.none())), Effect.matchEffect({
-        onFailure: () => Effect.succeed([HashSet.fromIterable([pod]), shards]),
-        onSuccess: () => pipe(PubSub.publish(eventsHub, ShardingEvent.ShardsUnassigned(pod, shards)), Effect.as([HashSet.empty(), HashSet.empty()]))
-      })), {
-        concurrency: "inherit"
-      }), Effect.map(Chunk.fromIterable), Effect.map(_ => Chunk.unzip(_)), Effect.map(([pods, shards]) => [Chunk.map(pods, Chunk.fromIterable), Chunk.map(shards, Chunk.fromIterable)]), Effect.map(([pods, shards]) => [HashSet.fromIterable(Chunk.flatten(pods)), HashSet.fromIterable(Chunk.flatten(shards))]));
-      // remove assignments of shards that couldn't be unassigned, as well as faulty pods.
-      const filteredAssignments = pipe(HashMap.removeMany(readyAssignments, failedUnassignedPods), HashMap.map((shards, __) => HashSet.difference(shards, failedUnassignedShards)));
-      // then do the assignments
-      const failedAssignedPods = yield* pipe(Effect.forEach(filteredAssignments, ([pod, shards]) => pipe(podApi.assignShards(pod, shards), Effect.zipRight(updateShardsState(shards, Option.some(pod))), Effect.matchEffect({
-        onFailure: () => Effect.succeed(Chunk.fromIterable([pod])),
-        onSuccess: () => pipe(PubSub.publish(eventsHub, ShardingEvent.ShardsAssigned(pod, shards)), Effect.as(Chunk.empty()))
-      })), {
-        concurrency: "inherit"
-      }), Effect.map(Chunk.fromIterable), Effect.map(_ => Chunk.flatten(_)), Effect.map(HashSet.fromIterable));
-      const failedPods = HashSet.union(HashSet.union(failedPingedPods, failedUnassignedPods), failedAssignedPods);
-      // check if failing pods are still up
-      yield* Effect.forkIn(layerScope)(Effect.forEach(failedPods, _ => notifyUnhealthyPod(_), {
-        discard: true
-      }));
-      if (HashSet.size(failedPods) > 0) {
-        yield* Effect.logDebug("Failed to rebalance pods: " + failedPods + " failed pinged: " + failedPingedPods + " failed assigned: " + failedAssignedPods + " failed unassigned: " + failedUnassignedPods);
-      }
-      // retry rebalancing later if there was any failure
-      if (HashSet.size(failedPods) > 0 && rebalanceImmediately) {
-        yield* pipe(Effect.sleep(config.rebalanceRetryInterval), Effect.zipRight(rebalance(rebalanceImmediately)), Effect.forkIn(layerScope));
-      }
-      // persist state changes to Redis
-      if (areChanges) {
-        yield* Effect.forkIn(layerScope)(persistAssignments);
-      }
-    });
-    return rebalanceSemaphore.withPermits(1)(algo);
+  get runnerVersions() {
+    const runnerVersions = [];
+    for (const [, meta] of this.runners) {
+      runnerVersions.push(meta.runner.version);
+    }
+    return runnerVersions;
   }
-  return {
-    getAssignments,
-    getShardingEvents,
-    register,
-    unregister,
-    persistPods,
-    rebalance,
-    notifyUnhealthyPod,
-    checkAllPodsHealth
-  };
 }
 /** @internal */
+export const RunnerWithMetadata = runner => runner;
+/** @internal */
 export function decideAssignmentsForUnassignedShards(state) {
-  return pickNewPods(List.fromIterable(state.unassignedShards), state, true, 1);
+  return pickNewRunners(state.unassignedShards, state, true, 1);
 }
+const allocationOrder = /*#__PURE__*/Order.combine( /*#__PURE__*/Order.mapInput(Order.number, ([, shards]) => shards), /*#__PURE__*/Order.mapInput(Order.number, ([,, registeredAt]) => registeredAt));
 /** @internal */
-export function decideAssignmentsForUnbalancedShards(state, rebalanceRate) {
-  // don't do regular rebalance in the middle of a rolling update
-  const extraShardsToAllocate = state.allPodsHaveMaxVersion ? pipe(state.shardsPerPod, HashMap.flatMap((shards, _) => {
-    // count how many extra shards compared to the average
-    const extraShards = Math.max(HashSet.size(shards) - state.averageShardsPerPod.value, 0);
-    return pipe(HashMap.empty(), HashMap.set(_, HashSet.fromIterable(List.take(List.fromIterable(shards), extraShards))));
-  }), HashSet.fromIterable, HashSet.map(_ => _[1]), HashSet.flatMap(_ => _)) : HashSet.empty();
-  /*
-        TODO: port sortBy
-       val sortedShardsToRebalance = extraShardsToAllocate.toList.sortBy { shard =>
-      // handle unassigned shards first, then shards on the pods with most shards, then shards on old pods
-      state.shards.get(shard).flatten.fold((Int.MinValue, OffsetDateTime.MIN)) { pod =>
-        (
-          state.shardsPerPod.get(pod).fold(Int.MinValue)(-_.size),
-          state.pods.get(pod).fold(OffsetDateTime.MIN)(_.registered)
-        )
+export function decideAssignmentsForUnbalancedShards(state, rate) {
+  const shardsPerRunner = state.shardsPerRunner;
+  const maxVersion = state.maxVersion;
+  const extraShardsToAllocate = Arr.empty();
+  if (state.allRunnersHaveVersion(maxVersion)) {
+    const averageShardsPerRunner = state.averageShardsPerRunner;
+    MutableHashMap.forEach(shardsPerRunner, shards => {
+      // Count how many extra shards there are compared to the average
+      const extraShards = Math.max(0, shards.size - averageShardsPerRunner);
+      for (const shard of takeRandom(shards, extraShards)) {
+        const maybeAddress = state.shards.get(shard) ?? Option.none();
+        if (Option.isNone(maybeAddress)) {
+          extraShardsToAllocate.push([shard, Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER]);
+          continue;
+        }
+        const address = maybeAddress.value;
+        extraShardsToAllocate.push([shard, Option.match(MutableHashMap.get(shardsPerRunner, address), {
+          onNone: () => Number.MIN_SAFE_INTEGER,
+          onSome: shards => -shards.size
+        }), Option.match(MutableHashMap.get(state.runners, address), {
+          onNone: () => Number.MIN_SAFE_INTEGER,
+          onSome: meta => meta.registeredAt
+        })]);
       }
-    }
-  * */
-  const sortedShardsToRebalance = List.fromIterable(extraShardsToAllocate);
-  return pickNewPods(sortedShardsToRebalance, state, false, rebalanceRate);
+    });
+  }
+  const sortedShardsToRebalance = extraShardsToAllocate.sort(allocationOrder).map(([shard]) => shard);
+  return pickNewRunners(sortedShardsToRebalance, state, false, rate, shardsPerRunner, maxVersion);
 }
-function pickNewPods(shardsToRebalance, state, rebalanceImmediately, rebalanceRate) {
-  const [_, assignments] = pipe(List.reduce(shardsToRebalance, [state.shardsPerPod, List.empty()], ([shardsPerPod, assignments], shard) => {
-    const unassignedPods = pipe(assignments, List.flatMap(([shard, _]) => pipe(HashMap.get(state.shards, shard), Option.flatten, Option.toArray, List.fromIterable)));
-    // find pod with least amount of shards
-    return pipe(
-    // keep only pods with the max version
-    HashMap.filter(shardsPerPod, (_, pod) => {
-      const maxVersion = state.maxVersion;
-      if (Option.isNone(maxVersion)) return true;
-      return pipe(HashMap.get(state.pods, pod), Option.map(PodWithMetadata.extractVersion), Option.map(_ => PodWithMetadata.compareVersion(_, maxVersion.value) === 0), Option.getOrElse(() => false));
-    }),
-    // don't assign too many shards to the same pods, unless we need rebalance immediately
-    HashMap.filter((_, pod) => {
-      if (rebalanceImmediately) return true;
-      return pipe(assignments, List.filter(([_, p]) => equals(p)(pod)), List.size) < HashMap.size(state.shards) * rebalanceRate;
-    }),
-    // don't assign to a pod that was unassigned in the same rebalance
-    HashMap.filter((_, pod) => !Option.isSome(List.findFirst(unassignedPods, equals(pod)))), minByOption(([_, pods]) => HashSet.size(pods)), Option.match({
-      onNone: () => [shardsPerPod, assignments],
-      onSome: ([pod, shards]) => {
-        const oldPod = Option.flatten(HashMap.get(state.shards, shard));
-        // if old pod is same as new pod, don't change anything
-        if (equals(oldPod)(pod)) {
-          return [shardsPerPod, assignments];
-          // if the new pod has more, as much, or only 1 less shard than the old pod, don't change anything
-        } else if (Option.match(HashMap.get(shardsPerPod, pod), {
-          onNone: () => 0,
-          onSome: HashSet.size
-        }) + 1 >= Option.match(oldPod, {
-          onNone: () => Number.MAX_SAFE_INTEGER,
-          onSome: _ => Option.match(HashMap.get(shardsPerPod, _), {
-            onNone: () => 0,
-            onSome: HashSet.size
-          })
-        })) {
-          return [shardsPerPod, assignments];
-          // otherwise, create a new assignment
-        } else {
-          const unassigned = Option.match(oldPod, {
-            onNone: () => shardsPerPod,
-            onSome: oldPod => HashMap.modify(shardsPerPod, oldPod, HashSet.remove(shard))
-          });
-          return [HashMap.modify(unassigned, pod, _ => HashSet.add(shards, shard)), List.prepend(assignments, [shard, pod])];
-        }
+function pickNewRunners(shardsToRebalance, state, immediate, rate, shardsPerRunner = state.shardsPerRunner, maybeMaxVersion = state.maxVersion) {
+  const addressAssignments = MutableHashMap.empty();
+  const unassignments = MutableHashMap.empty();
+  const changes = MutableHashSet.empty();
+  if (Option.isNone(maybeMaxVersion)) {
+    return [addressAssignments, unassignments, changes];
+  }
+  const maxVersion = maybeMaxVersion.value;
+  for (const shardId of shardsToRebalance) {
+    // Find the runner with the fewest assigned shards
+    let candidate;
+    let candidateShards;
+    for (const [address, shards] of shardsPerRunner) {
+      // Keep only runners with the maximum version
+      const maybeRunnerMeta = MutableHashMap.get(state.runners, address);
+      if (Option.isNone(maybeRunnerMeta)) continue;
+      const runnerMeta = maybeRunnerMeta.value;
+      if (runnerMeta.runner.version !== maxVersion) continue;
+      // Do not assign to a runner that has unassignments in the same rebalance
+      if (MutableHashMap.has(unassignments, address)) continue;
+      // Do not assign too many shards to each runner unless rebalancing must
+      // occur immediately
+      if (!immediate) {
+        const assignmentCount = Option.getOrUndefined(MutableHashMap.get(addressAssignments, address))?.size ?? 0;
+        if (assignmentCount >= state.shards.size * rate) continue;
+      }
+      if (candidate === undefined || shards.size < candidateShards.size) {
+        candidate = address;
+        candidateShards = shards;
+      }
+    }
+    if (!candidate || !candidateShards) break;
+    // If the old runner is the same as the new runner, do nothing
+    const oldRunner = Option.getOrUndefined(state.shards.get(shardId) ?? Option.none());
+    if (oldRunner && oldRunner.toString() === candidate.toString()) {
+      continue;
+    }
+    const oldShards = oldRunner && Option.getOrUndefined(MutableHashMap.get(shardsPerRunner, oldRunner));
+    // If the new runner has one less, as many, or more shards than the
+    // old runner, do not change anything
+    if (oldShards && candidateShards.size + 1 >= oldShards.size) continue;
+    // Otherwise create a new assignment
+    MutableHashMap.modifyAt(addressAssignments, candidate, Option.match({
+      onNone: () => Option.some(new Set([shardId])),
+      onSome: shards => {
+        shards.add(shardId);
+        return Option.some(shards);
       }
     }));
-  }));
-  const unassignments = List.flatMap(assignments, ([shard, _]) => pipe(Option.flatten(HashMap.get(state.shards, shard)), Option.map(_ => [shard, _]), Option.match({
-    onNone: List.empty,
-    onSome: List.of
-  })));
-  const assignmentsPerPod = pipe(assignments, groupBy(([_, pod]) => pod), HashMap.map(HashSet.map(([shardId, _]) => shardId)));
-  const unassignmentsPerPod = pipe(unassignments, groupBy(([_, pod]) => pod), HashMap.map(HashSet.map(([shardId, _]) => shardId)));
-  return [assignmentsPerPod, unassignmentsPerPod];
+    if (oldRunner) {
+      MutableHashMap.modifyAt(unassignments, oldRunner, Option.match({
+        onNone: () => Option.some(new Set([shardId])),
+        onSome: shards => {
+          shards.add(shardId);
+          return Option.some(shards);
+        }
+      }));
+    }
+    // Move the shard to the new runner
+    candidateShards.add(shardId);
+    if (oldShards) {
+      oldShards.delete(shardId);
+    }
+    // Track changes
+    MutableHashSet.add(changes, candidate);
+    if (oldRunner) MutableHashSet.add(changes, oldRunner);
+  }
+  return [addressAssignments, unassignments, changes];
+}
+function takeRandom(self, n) {
+  const array = Array.from(self);
+  let currentIndex = array.length;
+  while (currentIndex != 0) {
+    const randomIndex = Math.floor(Math.random() * currentIndex);
+    currentIndex = currentIndex - 1;
+    swap(array, currentIndex, randomIndex);
+  }
+  return n < array.length ? array.slice(0, n) : array;
+}
+function swap(array, i, j) {
+  const tmp = array[i];
+  array[i] = array[j];
+  array[j] = tmp;
+  return array;
 }
-/**
- * @since 1.0.0
- * @category layers
- */
-export const live = /*#__PURE__*/Effect.gen(function* () {
-  const config = yield* ManagerConfig.ManagerConfig;
-  const stateRepository = yield* Storage.Storage;
-  const healthApi = yield* PodsHealth.PodsHealth;
-  const podsApi = yield* Pods.Pods;
-  const layerScope = yield* Effect.scope;
-  const pods = yield* stateRepository.getPods;
-  const assignments = yield* stateRepository.getAssignments;
-  const filteredPods = yield* pipe(Effect.filter(pods, ([podAddress]) => healthApi.isAlive(podAddress), {
-    concurrency: "inherit"
-  }), Effect.map(HashMap.fromIterable));
-  const filteredAssignments = HashMap.filter(assignments, pod => Option.isSome(pod) && HashMap.has(filteredPods, pod.value));
-  const cdt = yield* Clock.currentTimeMillis;
-  const initialState = ShardManagerState.make(HashMap.map(filteredPods, pod => PodWithMetadata.make(pod, cdt)), HashMap.union(filteredAssignments, pipe(Chunk.range(1, config.numberOfShards), Chunk.map(n => [ShardId.make(n), Option.none()]), HashMap.fromIterable)));
-  const state = yield* RefSynchronized.make(initialState);
-  const rebalanceSemaphore = yield* Effect.makeSemaphore(1);
-  const eventsHub = yield* PubSub.unbounded();
-  const shardManager = make(layerScope, state, rebalanceSemaphore, eventsHub, healthApi, podsApi, stateRepository, config);
-  yield* Effect.forkIn(layerScope)(shardManager.persistPods);
-  // rebalance immediately if there are unassigned shards
-  yield* shardManager.rebalance(HashSet.size(initialState.unassignedShards) > 0);
-  // start a regular rebalance at the given interval
-  yield* pipe(shardManager.rebalance(false), Effect.repeat(Schedule.spaced(config.rebalanceInterval)), Effect.forkIn(layerScope));
-  // log info events
-  yield* pipe(shardManager.getShardingEvents, Stream.mapEffect(_ => Effect.logDebug(JSON.stringify(_))), Stream.runDrain, Effect.forkIn(layerScope));
-  yield* Effect.logDebug("Shard Manager loaded");
-  return shardManager;
-}).pipe( /*#__PURE__*/Layer.scoped(shardManagerTag));
 //# sourceMappingURL=shardManager.js.map
\ No newline at end of file
diff --git a/dist/esm/internal/shardManager.js.map b/dist/esm/internal/shardManager.js.map
index 0220b5dac4f9175c726eae88b50a668a3022e948..0ad1c8af0504db85c1184f14b93f5b6e9c852ec3 100644
--- a/dist/esm/internal/shardManager.js.map
+++ b/dist/esm/internal/shardManager.js.map
@@ -1 +1 @@
-{"version":3,"file":"shardManager.js","names":["Chunk","Clock","GenericTag","Effect","equals","pipe","HashMap","HashSet","Layer","List","Option","PubSub","Schedule","Stream","RefSynchronized","ManagerConfig","Pods","PodsHealth","ShardId","ShardingEvent","ShardingException","Storage","PodWithMetadata","ShardManagerState","groupBy","minByOption","ShardManagerSymbolKey","ShardManagerTypeId","Symbol","for","shardManagerTag","make","layerScope","stateRef","rebalanceSemaphore","eventsHub","healthApi","podApi","stateRepository","config","getAssignments","get","map","_","shards","getShardingEvents","fromPubSub","register","pod","logDebug","address","version","zipRight","updateAndGetEffect","state","flatMap","clock","currentTimeMillis","cdt","set","pods","zipLeft","publish","PodRegistered","when","rebalance","size","unassignedShards","forkIn","persistPods","asVoid","stateHasPod","podAddress","has","notifyUnhealthyPod","whenEffect","PodHealthChecked","unlessEffect","logWarning","unregister","isAlive","checkAllPodsHealth","keySet","forEach","concurrency","discard","eff","Do","bind","modify","filter","some","remove","none","tap","PodUnregistered","ShardsUnassigned","unassignments","withRetry","zio","retry","spaced","persistRetryInterval","andThen","recurs","persistRetryCount","ignore","persistAssignments","saveAssignments","savePods","v","updateShardsState","updateEffect","isSome","value","fail","PodNoLongerRegisteredException","succeed","assignment","shard","rebalanceImmediately","algo","gen","assignments","decideAssignmentsForUnassignedShards","decideAssignmentsForUnbalancedShards","rebalanceRate","areChanges","JSON","stringify","failedPingedPods","union","ping","timeout","pingTimeout","match","onFailure","fromIterable","onSuccess","empty","flatten","shardsToRemove","appendAll","__","readyAssignments","difference","readyUnassignments","failedUnassignedPods","failedUnassignedShards","unassignShards","matchEffect","as","unzip","filteredAssignments","removeMany","failedAssignedPods","assignShards","ShardsAssigned","failedPods","sleep","rebalanceRetryInterval","withPermits","pickNewPods","extraShardsToAllocate","allPodsHaveMaxVersion","shardsPerPod","extraShards","Math","max","averageShardsPerPod","take","sortedShardsToRebalance","shardsToRebalance","reduce","unassignedPods","toArray","maxVersion","isNone","extractVersion","compareVersion","getOrElse","p","findFirst","onNone","onSome","oldPod","Number","MAX_SAFE_INTEGER","unassigned","add","prepend","of","assignmentsPerPod","shardId","unassignmentsPerPod","live","podsApi","scope","getPods","filteredPods","initialState","range","numberOfShards","n","makeSemaphore","unbounded","shardManager","repeat","rebalanceInterval","mapEffect","runDrain","scoped"],"sources":["../../../src/internal/shardManager.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
+{"version":3,"file":"shardManager.js","names":["Arr","Clock","Effect","constFalse","MutableHashMap","MutableHashSet","Option","Order","RunnerHealth","ShardId","ShardStorage","State","runners","shards","fromStorage","fnUntraced","numberOfShards","storage","runnerHealth","storedRunners","getRunners","storedAssignments","getAssignments","deadRunners","empty","aliveRunners","forEach","address","runner","map","isAlive","set","push","concurrency","discard","length","logWarning","assignedShards","Map","invalidAssignments","shard","isSome","has","value","now","currentTimeMillis","runnerState","RunnerWithMetadata","registeredAt","shardState","n","shardId","make","fromNullable","get","constructor","maxVersion","size","none","version","undefined","meta","some","allRunnersHaveVersion","pipe","max","every","runnerVersions","getOrElse","shardsPerRunner","isEmpty","_","Set","isNone","shardIds","getOrUndefined","add","averageShardsPerRunner","runnerCount","unassignedShards","decideAssignmentsForUnassignedShards","state","pickNewRunners","allocationOrder","combine","mapInput","number","decideAssignmentsForUnbalancedShards","rate","extraShardsToAllocate","extraShards","Math","takeRandom","maybeAddress","Number","MIN_SAFE_INTEGER","match","onNone","onSome","sortedShardsToRebalance","sort","shardsToRebalance","immediate","maybeMaxVersion","addressAssignments","unassignments","changes","candidate","candidateShards","maybeRunnerMeta","runnerMeta","assignmentCount","oldRunner","toString","oldShards","modifyAt","delete","self","array","Array","from","currentIndex","randomIndex","floor","random","swap","slice","i","j","tmp"],"sources":["../../../src/internal/shardManager.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/package.json b/package.json
index e2e0c749cc00f311cbe344dabec2a7d5dbde2d55..bbcd8fb6eb9d40da79e35a6084691a6f66b3ba6b 100644
--- a/package.json
+++ b/package.json
@@ -10,8 +10,10 @@
   },
   "sideEffects": [],
   "peerDependencies": {
-    "effect": "^3.13.12",
-    "@effect/sql": "^0.32.3"
+    "@effect/platform": "*",
+    "@effect/rpc": "*",
+    "@effect/sql": "^0.32.3",
+    "effect": "^3.13.12"
   },
   "publishConfig": {
     "provenance": true
@@ -26,100 +28,110 @@
       "import": "./dist/esm/index.js",
       "default": "./dist/cjs/index.js"
     },
-    "./AtLeastOnce": {
-      "types": "./dist/dts/AtLeastOnce.d.ts",
-      "import": "./dist/esm/AtLeastOnce.js",
-      "default": "./dist/cjs/AtLeastOnce.js"
+    "./ClusterError": {
+      "types": "./dist/dts/ClusterError.d.ts",
+      "import": "./dist/esm/ClusterError.js",
+      "default": "./dist/cjs/ClusterError.js"
     },
-    "./AtLeastOnceStorage": {
-      "types": "./dist/dts/AtLeastOnceStorage.d.ts",
-      "import": "./dist/esm/AtLeastOnceStorage.js",
-      "default": "./dist/cjs/AtLeastOnceStorage.js"
+    "./ClusterMetrics": {
+      "types": "./dist/dts/ClusterMetrics.d.ts",
+      "import": "./dist/esm/ClusterMetrics.js",
+      "default": "./dist/cjs/ClusterMetrics.js"
     },
-    "./Broadcaster": {
-      "types": "./dist/dts/Broadcaster.d.ts",
-      "import": "./dist/esm/Broadcaster.js",
-      "default": "./dist/cjs/Broadcaster.js"
+    "./ClusterSchema": {
+      "types": "./dist/dts/ClusterSchema.d.ts",
+      "import": "./dist/esm/ClusterSchema.js",
+      "default": "./dist/cjs/ClusterSchema.js"
     },
-    "./ManagerConfig": {
-      "types": "./dist/dts/ManagerConfig.d.ts",
-      "import": "./dist/esm/ManagerConfig.js",
-      "default": "./dist/cjs/ManagerConfig.js"
+    "./DeliverAt": {
+      "types": "./dist/dts/DeliverAt.d.ts",
+      "import": "./dist/esm/DeliverAt.js",
+      "default": "./dist/cjs/DeliverAt.js"
+    },
+    "./Entity": {
+      "types": "./dist/dts/Entity.d.ts",
+      "import": "./dist/esm/Entity.js",
+      "default": "./dist/cjs/Entity.js"
+    },
+    "./EntityAddress": {
+      "types": "./dist/dts/EntityAddress.d.ts",
+      "import": "./dist/esm/EntityAddress.js",
+      "default": "./dist/cjs/EntityAddress.js"
+    },
+    "./EntityId": {
+      "types": "./dist/dts/EntityId.d.ts",
+      "import": "./dist/esm/EntityId.js",
+      "default": "./dist/cjs/EntityId.js"
+    },
+    "./EntityType": {
+      "types": "./dist/dts/EntityType.d.ts",
+      "import": "./dist/esm/EntityType.js",
+      "default": "./dist/cjs/EntityType.js"
+    },
+    "./Envelope": {
+      "types": "./dist/dts/Envelope.d.ts",
+      "import": "./dist/esm/Envelope.js",
+      "default": "./dist/cjs/Envelope.js"
+    },
+    "./HttpCommon": {
+      "types": "./dist/dts/HttpCommon.d.ts",
+      "import": "./dist/esm/HttpCommon.js",
+      "default": "./dist/cjs/HttpCommon.js"
+    },
+    "./HttpRunner": {
+      "types": "./dist/dts/HttpRunner.d.ts",
+      "import": "./dist/esm/HttpRunner.js",
+      "default": "./dist/cjs/HttpRunner.js"
+    },
+    "./HttpShardManager": {
+      "types": "./dist/dts/HttpShardManager.d.ts",
+      "import": "./dist/esm/HttpShardManager.js",
+      "default": "./dist/cjs/HttpShardManager.js"
+    },
+    "./MachineId": {
+      "types": "./dist/dts/MachineId.d.ts",
+      "import": "./dist/esm/MachineId.js",
+      "default": "./dist/cjs/MachineId.js"
     },
     "./Message": {
       "types": "./dist/dts/Message.d.ts",
       "import": "./dist/esm/Message.js",
       "default": "./dist/cjs/Message.js"
     },
-    "./MessageState": {
-      "types": "./dist/dts/MessageState.d.ts",
-      "import": "./dist/esm/MessageState.js",
-      "default": "./dist/cjs/MessageState.js"
-    },
-    "./Messenger": {
-      "types": "./dist/dts/Messenger.d.ts",
-      "import": "./dist/esm/Messenger.js",
-      "default": "./dist/cjs/Messenger.js"
-    },
-    "./Pod": {
-      "types": "./dist/dts/Pod.d.ts",
-      "import": "./dist/esm/Pod.js",
-      "default": "./dist/cjs/Pod.js"
-    },
-    "./PodAddress": {
-      "types": "./dist/dts/PodAddress.d.ts",
-      "import": "./dist/esm/PodAddress.js",
-      "default": "./dist/cjs/PodAddress.js"
-    },
-    "./Pods": {
-      "types": "./dist/dts/Pods.d.ts",
-      "import": "./dist/esm/Pods.js",
-      "default": "./dist/cjs/Pods.js"
-    },
-    "./PodsHealth": {
-      "types": "./dist/dts/PodsHealth.d.ts",
-      "import": "./dist/esm/PodsHealth.js",
-      "default": "./dist/cjs/PodsHealth.js"
-    },
-    "./PoisonPill": {
-      "types": "./dist/dts/PoisonPill.d.ts",
-      "import": "./dist/esm/PoisonPill.js",
-      "default": "./dist/cjs/PoisonPill.js"
-    },
-    "./RecipientAddress": {
-      "types": "./dist/dts/RecipientAddress.d.ts",
-      "import": "./dist/esm/RecipientAddress.js",
-      "default": "./dist/cjs/RecipientAddress.js"
-    },
-    "./RecipientBehaviour": {
-      "types": "./dist/dts/RecipientBehaviour.d.ts",
-      "import": "./dist/esm/RecipientBehaviour.js",
-      "default": "./dist/cjs/RecipientBehaviour.js"
-    },
-    "./RecipientBehaviourContext": {
-      "types": "./dist/dts/RecipientBehaviourContext.d.ts",
-      "import": "./dist/esm/RecipientBehaviourContext.js",
-      "default": "./dist/cjs/RecipientBehaviourContext.js"
-    },
-    "./RecipientType": {
-      "types": "./dist/dts/RecipientType.d.ts",
-      "import": "./dist/esm/RecipientType.js",
-      "default": "./dist/cjs/RecipientType.js"
-    },
-    "./Serialization": {
-      "types": "./dist/dts/Serialization.d.ts",
-      "import": "./dist/esm/Serialization.js",
-      "default": "./dist/cjs/Serialization.js"
-    },
-    "./SerializedEnvelope": {
-      "types": "./dist/dts/SerializedEnvelope.d.ts",
-      "import": "./dist/esm/SerializedEnvelope.js",
-      "default": "./dist/cjs/SerializedEnvelope.js"
-    },
-    "./SerializedMessage": {
-      "types": "./dist/dts/SerializedMessage.d.ts",
-      "import": "./dist/esm/SerializedMessage.js",
-      "default": "./dist/cjs/SerializedMessage.js"
+    "./MessageStorage": {
+      "types": "./dist/dts/MessageStorage.d.ts",
+      "import": "./dist/esm/MessageStorage.js",
+      "default": "./dist/cjs/MessageStorage.js"
+    },
+    "./Reply": {
+      "types": "./dist/dts/Reply.d.ts",
+      "import": "./dist/esm/Reply.js",
+      "default": "./dist/cjs/Reply.js"
+    },
+    "./Runner": {
+      "types": "./dist/dts/Runner.d.ts",
+      "import": "./dist/esm/Runner.js",
+      "default": "./dist/cjs/Runner.js"
+    },
+    "./RunnerAddress": {
+      "types": "./dist/dts/RunnerAddress.d.ts",
+      "import": "./dist/esm/RunnerAddress.js",
+      "default": "./dist/cjs/RunnerAddress.js"
+    },
+    "./RunnerHealth": {
+      "types": "./dist/dts/RunnerHealth.d.ts",
+      "import": "./dist/esm/RunnerHealth.js",
+      "default": "./dist/cjs/RunnerHealth.js"
+    },
+    "./RunnerServer": {
+      "types": "./dist/dts/RunnerServer.d.ts",
+      "import": "./dist/esm/RunnerServer.js",
+      "default": "./dist/cjs/RunnerServer.js"
+    },
+    "./Runners": {
+      "types": "./dist/dts/Runners.d.ts",
+      "import": "./dist/esm/Runners.js",
+      "default": "./dist/cjs/Runners.js"
     },
     "./ShardId": {
       "types": "./dist/dts/ShardId.d.ts",
@@ -131,10 +143,10 @@
       "import": "./dist/esm/ShardManager.js",
       "default": "./dist/cjs/ShardManager.js"
     },
-    "./ShardManagerClient": {
-      "types": "./dist/dts/ShardManagerClient.d.ts",
-      "import": "./dist/esm/ShardManagerClient.js",
-      "default": "./dist/cjs/ShardManagerClient.js"
+    "./ShardStorage": {
+      "types": "./dist/dts/ShardStorage.d.ts",
+      "import": "./dist/esm/ShardStorage.js",
+      "default": "./dist/cjs/ShardStorage.js"
     },
     "./Sharding": {
       "types": "./dist/dts/Sharding.d.ts",
@@ -146,85 +158,116 @@
       "import": "./dist/esm/ShardingConfig.js",
       "default": "./dist/cjs/ShardingConfig.js"
     },
-    "./ShardingEvent": {
-      "types": "./dist/dts/ShardingEvent.d.ts",
-      "import": "./dist/esm/ShardingEvent.js",
-      "default": "./dist/cjs/ShardingEvent.js"
-    },
-    "./ShardingException": {
-      "types": "./dist/dts/ShardingException.d.ts",
-      "import": "./dist/esm/ShardingException.js",
-      "default": "./dist/cjs/ShardingException.js"
-    },
     "./ShardingRegistrationEvent": {
       "types": "./dist/dts/ShardingRegistrationEvent.d.ts",
       "import": "./dist/esm/ShardingRegistrationEvent.js",
       "default": "./dist/cjs/ShardingRegistrationEvent.js"
     },
-    "./Storage": {
-      "types": "./dist/dts/Storage.d.ts",
-      "import": "./dist/esm/Storage.js",
-      "default": "./dist/cjs/Storage.js"
+    "./Singleton": {
+      "types": "./dist/dts/Singleton.d.ts",
+      "import": "./dist/esm/Singleton.js",
+      "default": "./dist/cjs/Singleton.js"
+    },
+    "./SingletonAddress": {
+      "types": "./dist/dts/SingletonAddress.d.ts",
+      "import": "./dist/esm/SingletonAddress.js",
+      "default": "./dist/cjs/SingletonAddress.js"
+    },
+    "./Snowflake": {
+      "types": "./dist/dts/Snowflake.d.ts",
+      "import": "./dist/esm/Snowflake.js",
+      "default": "./dist/cjs/Snowflake.js"
+    },
+    "./SocketRunner": {
+      "types": "./dist/dts/SocketRunner.d.ts",
+      "import": "./dist/esm/SocketRunner.js",
+      "default": "./dist/cjs/SocketRunner.js"
+    },
+    "./SocketShardManager": {
+      "types": "./dist/dts/SocketShardManager.d.ts",
+      "import": "./dist/esm/SocketShardManager.js",
+      "default": "./dist/cjs/SocketShardManager.js"
+    },
+    "./SqlMessageStorage": {
+      "types": "./dist/dts/SqlMessageStorage.d.ts",
+      "import": "./dist/esm/SqlMessageStorage.js",
+      "default": "./dist/cjs/SqlMessageStorage.js"
+    },
+    "./SqlShardStorage": {
+      "types": "./dist/dts/SqlShardStorage.d.ts",
+      "import": "./dist/esm/SqlShardStorage.js",
+      "default": "./dist/cjs/SqlShardStorage.js"
+    },
+    "./SynchronizedClock": {
+      "types": "./dist/dts/SynchronizedClock.d.ts",
+      "import": "./dist/esm/SynchronizedClock.js",
+      "default": "./dist/cjs/SynchronizedClock.js"
     }
   },
   "typesVersions": {
     "*": {
-      "AtLeastOnce": [
-        "./dist/dts/AtLeastOnce.d.ts"
+      "ClusterError": [
+        "./dist/dts/ClusterError.d.ts"
       ],
-      "AtLeastOnceStorage": [
-        "./dist/dts/AtLeastOnceStorage.d.ts"
+      "ClusterMetrics": [
+        "./dist/dts/ClusterMetrics.d.ts"
       ],
-      "Broadcaster": [
-        "./dist/dts/Broadcaster.d.ts"
+      "ClusterSchema": [
+        "./dist/dts/ClusterSchema.d.ts"
       ],
-      "ManagerConfig": [
-        "./dist/dts/ManagerConfig.d.ts"
+      "DeliverAt": [
+        "./dist/dts/DeliverAt.d.ts"
       ],
-      "Message": [
-        "./dist/dts/Message.d.ts"
+      "Entity": [
+        "./dist/dts/Entity.d.ts"
+      ],
+      "EntityAddress": [
+        "./dist/dts/EntityAddress.d.ts"
+      ],
+      "EntityId": [
+        "./dist/dts/EntityId.d.ts"
       ],
-      "MessageState": [
-        "./dist/dts/MessageState.d.ts"
+      "EntityType": [
+        "./dist/dts/EntityType.d.ts"
       ],
-      "Messenger": [
-        "./dist/dts/Messenger.d.ts"
+      "Envelope": [
+        "./dist/dts/Envelope.d.ts"
       ],
-      "Pod": [
-        "./dist/dts/Pod.d.ts"
+      "HttpCommon": [
+        "./dist/dts/HttpCommon.d.ts"
       ],
-      "PodAddress": [
-        "./dist/dts/PodAddress.d.ts"
+      "HttpRunner": [
+        "./dist/dts/HttpRunner.d.ts"
       ],
-      "Pods": [
-        "./dist/dts/Pods.d.ts"
+      "HttpShardManager": [
+        "./dist/dts/HttpShardManager.d.ts"
       ],
-      "PodsHealth": [
-        "./dist/dts/PodsHealth.d.ts"
+      "MachineId": [
+        "./dist/dts/MachineId.d.ts"
       ],
-      "PoisonPill": [
-        "./dist/dts/PoisonPill.d.ts"
+      "Message": [
+        "./dist/dts/Message.d.ts"
       ],
-      "RecipientAddress": [
-        "./dist/dts/RecipientAddress.d.ts"
+      "MessageStorage": [
+        "./dist/dts/MessageStorage.d.ts"
       ],
-      "RecipientBehaviour": [
-        "./dist/dts/RecipientBehaviour.d.ts"
+      "Reply": [
+        "./dist/dts/Reply.d.ts"
       ],
-      "RecipientBehaviourContext": [
-        "./dist/dts/RecipientBehaviourContext.d.ts"
+      "Runner": [
+        "./dist/dts/Runner.d.ts"
       ],
-      "RecipientType": [
-        "./dist/dts/RecipientType.d.ts"
+      "RunnerAddress": [
+        "./dist/dts/RunnerAddress.d.ts"
       ],
-      "Serialization": [
-        "./dist/dts/Serialization.d.ts"
+      "RunnerHealth": [
+        "./dist/dts/RunnerHealth.d.ts"
       ],
-      "SerializedEnvelope": [
-        "./dist/dts/SerializedEnvelope.d.ts"
+      "RunnerServer": [
+        "./dist/dts/RunnerServer.d.ts"
       ],
-      "SerializedMessage": [
-        "./dist/dts/SerializedMessage.d.ts"
+      "Runners": [
+        "./dist/dts/Runners.d.ts"
       ],
       "ShardId": [
         "./dist/dts/ShardId.d.ts"
@@ -232,8 +275,8 @@
       "ShardManager": [
         "./dist/dts/ShardManager.d.ts"
       ],
-      "ShardManagerClient": [
-        "./dist/dts/ShardManagerClient.d.ts"
+      "ShardStorage": [
+        "./dist/dts/ShardStorage.d.ts"
       ],
       "Sharding": [
         "./dist/dts/Sharding.d.ts"
@@ -241,17 +284,32 @@
       "ShardingConfig": [
         "./dist/dts/ShardingConfig.d.ts"
       ],
-      "ShardingEvent": [
-        "./dist/dts/ShardingEvent.d.ts"
-      ],
-      "ShardingException": [
-        "./dist/dts/ShardingException.d.ts"
-      ],
       "ShardingRegistrationEvent": [
         "./dist/dts/ShardingRegistrationEvent.d.ts"
       ],
-      "Storage": [
-        "./dist/dts/Storage.d.ts"
+      "Singleton": [
+        "./dist/dts/Singleton.d.ts"
+      ],
+      "SingletonAddress": [
+        "./dist/dts/SingletonAddress.d.ts"
+      ],
+      "Snowflake": [
+        "./dist/dts/Snowflake.d.ts"
+      ],
+      "SocketRunner": [
+        "./dist/dts/SocketRunner.d.ts"
+      ],
+      "SocketShardManager": [
+        "./dist/dts/SocketShardManager.d.ts"
+      ],
+      "SqlMessageStorage": [
+        "./dist/dts/SqlMessageStorage.d.ts"
+      ],
+      "SqlShardStorage": [
+        "./dist/dts/SqlShardStorage.d.ts"
+      ],
+      "SynchronizedClock": [
+        "./dist/dts/SynchronizedClock.d.ts"
       ]
     }
   }
diff --git a/src/ClusterError.ts b/src/ClusterError.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d2123a425cfd97a5f05a3a08c6abf470787423af
--- /dev/null
+++ b/src/ClusterError.ts
@@ -0,0 +1,193 @@
+/**
+ * @since 1.0.0
+ */
+import * as Cause from "effect/Cause"
+import * as Effect from "effect/Effect"
+import { hasProperty, isTagged } from "effect/Predicate"
+import * as Schema from "effect/Schema"
+import { EntityAddress } from "./EntityAddress.js"
+import { RunnerAddress } from "./RunnerAddress.js"
+import { SnowflakeFromString } from "./Snowflake.js"
+
+/**
+ * @since 1.0.0
+ * @category Symbols
+ */
+export const TypeId: unique symbol = Symbol.for("@effect/cluster/ClusterError")
+
+/**
+ * @since 1.0.0
+ * @category Symbols
+ */
+export type TypeId = typeof TypeId
+
+/**
+ * Represents an error that occurs when a Runner receives a message for an entity
+ * that it is not responsible for managing.
+ *
+ * @since 1.0.0
+ * @category errors
+ */
+export class EntityNotManagedByRunner extends Schema.TaggedError<EntityNotManagedByRunner>()(
+  "EntityNotManagedByRunner",
+  { address: EntityAddress }
+) {
+  /**
+   * @since 1.0.0
+   */
+  readonly [TypeId] = TypeId
+
+  /**
+   * @since 1.0.0
+   */
+  static is(u: unknown): u is EntityNotManagedByRunner {
+    return hasProperty(u, TypeId) && isTagged(u, "EntityNotManagedByRunner")
+  }
+}
+
+/**
+ * Represents an error that occurs when a message fails to be properly
+ * deserialized by an entity.
+ *
+ * @since 1.0.0
+ * @category errors
+ */
+export class MalformedMessage extends Schema.TaggedError<MalformedMessage>()(
+  "MalformedMessage",
+  { cause: Schema.Defect }
+) {
+  /**
+   * @since 1.0.0
+   */
+  readonly [TypeId] = TypeId
+
+  /**
+   * @since 1.0.0
+   */
+  static is(u: unknown): u is MalformedMessage {
+    return hasProperty(u, TypeId) && isTagged(u, "MalformedMessage")
+  }
+
+  /**
+   * @since 1.0.0
+   */
+  static refail: <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<
+    A,
+    MalformedMessage,
+    R
+  > = Effect.mapError((cause) => new MalformedMessage({ cause }))
+}
+
+/**
+ * Represents an error that occurs when a message fails to be persisted into
+ * cluster's mailbox storage.
+ *
+ * @since 1.0.0
+ * @category errors
+ */
+export class PersistenceError extends Schema.TaggedError<PersistenceError>()(
+  "PersistenceError",
+  { cause: Schema.Defect }
+) {
+  /**
+   * @since 1.0.0
+   */
+  readonly [TypeId] = TypeId
+
+  /**
+   * @since 1.0.0
+   */
+  static refail<A, E, R>(effect: Effect.Effect<A, E, R>): Effect.Effect<A, PersistenceError, R> {
+    return Effect.catchAllCause(effect, (cause) => Effect.fail(new PersistenceError({ cause: Cause.squash(cause) })))
+  }
+}
+
+/**
+ * Represents an error that occurs when a Runner is not registered with the shard
+ * manager.
+ *
+ * @since 1.0.0
+ * @category errors
+ */
+export class RunnerNotRegistered extends Schema.TaggedError<RunnerNotRegistered>()(
+  "RunnerNotRegistered",
+  { address: RunnerAddress }
+) {
+  /**
+   * @since 1.0.0
+   */
+  readonly [TypeId] = TypeId
+}
+
+/**
+ * Represents an error that occurs when a Runner is unresponsive.
+ *
+ * @since 1.0.0
+ * @category errors
+ */
+export class RunnerUnavailable extends Schema.TaggedError<RunnerUnavailable>()(
+  "RunnerUnavailable",
+  { address: RunnerAddress }
+) {
+  /**
+   * @since 1.0.0
+   */
+  readonly [TypeId] = TypeId
+
+  /**
+   * @since 1.0.0
+   */
+  static is(u: unknown): u is RunnerUnavailable {
+    return hasProperty(u, TypeId) && isTagged(u, "RunnerUnavailable")
+  }
+}
+
+/**
+ * Represents an error that occurs when the entities mailbox is full.
+ *
+ * @since 1.0.0
+ * @category errors
+ */
+export class MailboxFull extends Schema.TaggedError<MailboxFull>()(
+  "MailboxFull",
+  { address: EntityAddress }
+) {
+  /**
+   * @since 1.0.0
+   */
+  readonly [TypeId] = TypeId
+
+  /**
+   * @since 1.0.0
+   */
+  static is(u: unknown): u is MailboxFull {
+    return hasProperty(u, TypeId) && isTagged(u, "MailboxFull")
+  }
+}
+
+/**
+ * Represents an error that occurs when the entity is already processing a
+ * request.
+ *
+ * @since 1.0.0
+ * @category errors
+ */
+export class AlreadyProcessingMessage extends Schema.TaggedError<AlreadyProcessingMessage>()(
+  "AlreadyProcessingMessage",
+  {
+    envelopeId: SnowflakeFromString,
+    address: EntityAddress
+  }
+) {
+  /**
+   * @since 1.0.0
+   */
+  readonly [TypeId] = TypeId
+
+  /**
+   * @since 1.0.0
+   */
+  static is(u: unknown): u is AlreadyProcessingMessage {
+    return hasProperty(u, TypeId) && isTagged(u, "AlreadyProcessingMessage")
+  }
+}
diff --git a/src/ClusterMetrics.ts b/src/ClusterMetrics.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c5019ae8bc1cd3e55927b717a456b3e88583784c
--- /dev/null
+++ b/src/ClusterMetrics.ts
@@ -0,0 +1,62 @@
+/**
+ * @since 1.0.0
+ */
+import * as Metric from "effect/Metric"
+
+/**
+ * @since 1.0.0
+ * @category metrics
+ */
+export const shards = Metric.gauge("effect_cluster_shards")
+
+/**
+ * @since 1.0.0
+ * @category metrics
+ */
+export const entities = Metric.gauge("effect_cluster_entities", {
+  bigint: true
+})
+
+/**
+ * @since 1.0.0
+ * @category metrics
+ */
+export const mailboxSize = Metric.gauge("effect_cluster_mailbox_size", {
+  bigint: true
+})
+
+/**
+ * @since 1.0.0
+ * @category metrics
+ */
+export const singletons = Metric.gauge("effect_cluster_singletons")
+
+/**
+ * @since 1.0.0
+ * @category metrics
+ */
+export const runners = Metric.gauge("effect_cluster_runners")
+
+/**
+ * @since 1.0.0
+ * @category metrics
+ */
+export const assignedShards = Metric.gauge("effect_cluster_shards_assigned")
+
+/**
+ * @since 1.0.0
+ * @category metrics
+ */
+export const unassignedShards = Metric.gauge("effect_cluster_shards_unassigned")
+
+/**
+ * @since 1.0.0
+ * @category metrics
+ */
+export const rebalances = Metric.counter("effect_cluster_rebalances")
+
+/**
+ * @since 1.0.0
+ * @category metrics
+ */
+export const runnerHealthChecked = Metric.counter("effect_cluster_runner_health_checked")
diff --git a/src/ClusterSchema.ts b/src/ClusterSchema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9dbb3cf4847f98363138e3da34e4f60c488014af
--- /dev/null
+++ b/src/ClusterSchema.ts
@@ -0,0 +1,13 @@
+/**
+ * @since 1.0.0
+ */
+import * as Context from "effect/Context"
+import { constFalse } from "effect/Function"
+
+/**
+ * @since 1.0.0
+ * @category Annotations
+ */
+export class Persisted extends Context.Reference<Persisted>()("@effect/cluster/ClusterSchema/Persisted", {
+  defaultValue: constFalse
+}) {}
diff --git a/src/DeliverAt.ts b/src/DeliverAt.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c0e51288122a4489cf9d4b5e410e7d9e3c73d407
--- /dev/null
+++ b/src/DeliverAt.ts
@@ -0,0 +1,36 @@
+/**
+ * @since 1.0.0
+ */
+import type { DateTime } from "effect/DateTime"
+import { hasProperty } from "effect/Predicate"
+
+/**
+ * @since 1.0.0
+ * @category symbols
+ */
+export const symbol: unique symbol = Symbol.for("@effect/cluster/DeliverAt")
+
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export interface DeliverAt {
+  [symbol](): DateTime
+}
+
+/**
+ * @since 1.0.0
+ * @category guards
+ */
+export const isDeliverAt = (self: unknown): self is DeliverAt => hasProperty(self, symbol)
+
+/**
+ * @since 1.0.0
+ * @category accessors
+ */
+export const toMillis = (self: unknown): number | null => {
+  if (isDeliverAt(self)) {
+    return self[symbol]().epochMillis
+  }
+  return null
+}
diff --git a/src/Entity.ts b/src/Entity.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3523e387b84c3aa199ca221e4f2095bbe6ace5e6
--- /dev/null
+++ b/src/Entity.ts
@@ -0,0 +1,438 @@
+/**
+ * @since 1.0.0
+ */
+import type * as Rpc from "@effect/rpc/Rpc"
+import type * as RpcClient from "@effect/rpc/RpcClient"
+import * as RpcGroup from "@effect/rpc/RpcGroup"
+import * as Arr from "effect/Array"
+import type * as Cause from "effect/Cause"
+import * as Context from "effect/Context"
+import * as Data from "effect/Data"
+import type { DurationInput } from "effect/Duration"
+import * as Effect from "effect/Effect"
+import * as Equal from "effect/Equal"
+import * as Exit from "effect/Exit"
+import * as Hash from "effect/Hash"
+import * as Layer from "effect/Layer"
+import * as Mailbox from "effect/Mailbox"
+import * as Option from "effect/Option"
+import * as Predicate from "effect/Predicate"
+import type { Scope } from "effect/Scope"
+import type * as Stream from "effect/Stream"
+import type { AlreadyProcessingMessage, MailboxFull, PersistenceError } from "./ClusterError.js"
+import type { EntityAddress } from "./EntityAddress.js"
+import { EntityType } from "./EntityType.js"
+import type * as Envelope from "./Envelope.js"
+import type * as Reply from "./Reply.js"
+import type { RunnerAddress } from "./RunnerAddress.js"
+import type { Sharding } from "./Sharding.js"
+
+/**
+ * @since 1.0.0
+ * @category type ids
+ */
+export const TypeId: unique symbol = Symbol.for("@effect/cluster/Entity")
+
+/**
+ * @since 1.0.0
+ * @category type ids
+ */
+export type TypeId = typeof TypeId
+
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export interface Entity<in out Rpcs extends Rpc.Any> extends Equal.Equal {
+  readonly [TypeId]: TypeId
+  /**
+   * The name of the entity type.
+   */
+  readonly type: EntityType
+
+  /**
+   * A RpcGroup definition for messages which represents the messaging protocol
+   * that the entity is capable of processing.
+   */
+  readonly protocol: RpcGroup.RpcGroup<Rpcs>
+
+  /**
+   * Annotate the entity with a value.
+   */
+  annotate<I, S>(tag: Context.Tag<I, S>, value: S): Entity<Rpcs>
+
+  /**
+   * Annotate the Rpc's above this point with a value.
+   */
+  annotateRpcs<I, S>(tag: Context.Tag<I, S>, value: S): Entity<Rpcs>
+
+  /**
+   * Annotate the entity with a context object.
+   */
+  annotateContext<S>(context: Context.Context<S>): Entity<Rpcs>
+
+  /**
+   * Annotate the Rpc's above this point with a context object.
+   */
+  annotateRpcsContext<S>(context: Context.Context<S>): Entity<Rpcs>
+
+  /**
+   * Create a client for this entity.
+   */
+  readonly client: Effect.Effect<
+    (entityId: string) => RpcClient.RpcClient<Rpcs, MailboxFull | AlreadyProcessingMessage | PersistenceError>,
+    never,
+    Sharding
+  >
+
+  /**
+   * Create a Layer from an Entity.
+   *
+   * It will register the entity with the Sharding service.
+   */
+  toLayer<
+    Handlers extends HandlersFrom<Rpcs>,
+    RX = never
+  >(
+    build: Handlers | Effect.Effect<Handlers, never, RX>,
+    options?: {
+      readonly maxIdleTime?: DurationInput | undefined
+      readonly concurrency?: number | "unbounded" | undefined
+      readonly mailboxCapacity?: number | "unbounded" | undefined
+    }
+  ): Layer.Layer<
+    never,
+    never,
+    | Exclude<RX, Scope | CurrentAddress | CurrentRunnerAddress>
+    | RpcGroup.HandlersContext<Rpcs, Handlers>
+    | Rpc.Context<Rpcs>
+    | Rpc.Middleware<Rpcs>
+    | Sharding
+  >
+
+  /**
+   * Create a Layer from an Entity.
+   *
+   * It will register the entity with the Sharding service.
+   */
+  toLayerMailbox<
+    R,
+    RX = never
+  >(
+    build:
+      | ((
+        mailbox: Mailbox.ReadonlyMailbox<Envelope.Request<Rpcs>>,
+        replier: Replier<Rpcs>
+      ) => Effect.Effect<never, never, R>)
+      | Effect.Effect<
+        (
+          mailbox: Mailbox.ReadonlyMailbox<Envelope.Request<Rpcs>>,
+          replier: Replier<Rpcs>
+        ) => Effect.Effect<never, never, R>,
+        never,
+        RX
+      >,
+    options?: {
+      readonly maxIdleTime?: DurationInput | undefined
+      readonly mailboxCapacity?: number | "unbounded" | undefined
+    }
+  ): Layer.Layer<
+    never,
+    never,
+    | Exclude<RX, Scope | CurrentAddress>
+    | R
+    | Rpc.Context<Rpcs>
+    | Rpc.Middleware<Rpcs>
+    | Sharding
+  >
+}
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export type Any = Entity<Rpc.Any>
+
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export type HandlersFrom<Rpc extends Rpc.Any> = {
+  readonly [Current in Rpc as Current["_tag"]]: (
+    envelope: Request<Current>
+  ) => RpcGroup.ResultFrom<Current> | Rpc.Fork<RpcGroup.ResultFrom<Current>>
+}
+
+/**
+ * @since 1.0.0
+ * @category refinements
+ */
+export const isEntity = (u: unknown): u is Any => Predicate.hasProperty(u, TypeId)
+
+const Proto = {
+  [TypeId]: TypeId,
+  [Hash.symbol](this: Entity<any>): number {
+    return Hash.structure({ type: this.type })
+  },
+  [Equal.symbol](this: Entity<any>, that: Equal.Equal): boolean {
+    return isEntity(that) && this.type === that.type
+  },
+  annotate<I, S>(this: Entity<any>, tag: Context.Tag<I, S>, value: S) {
+    return fromRpcGroup(this.type, this.protocol.annotate(tag, value))
+  },
+  annotateRpcs<I, S>(this: Entity<any>, tag: Context.Tag<I, S>, value: S) {
+    return fromRpcGroup(this.type, this.protocol.annotateRpcs(tag, value))
+  },
+  annotateContext<S>(this: Entity<any>, context: Context.Context<S>) {
+    return fromRpcGroup(this.type, this.protocol.annotateContext(context))
+  },
+  annotateRpcsContext<S>(this: Entity<any>, context: Context.Context<S>) {
+    return fromRpcGroup(this.type, this.protocol.annotateRpcsContext(context))
+  },
+  get client() {
+    return shardingTag.pipe(
+      Effect.flatMap((sharding) => sharding.makeClient(this as any))
+    )
+  },
+  toLayer<
+    Rpcs extends Rpc.Any,
+    Handlers extends HandlersFrom<Rpcs>,
+    RX = never
+  >(
+    this: Entity<Rpcs>,
+    build: Handlers | Effect.Effect<Handlers, never, RX>,
+    options?: {
+      readonly maxIdleTime?: DurationInput | undefined
+      readonly concurrency?: number | "unbounded" | undefined
+    }
+  ): Layer.Layer<
+    never,
+    never,
+    | Exclude<RX, Scope | CurrentAddress>
+    | RpcGroup.HandlersContext<Rpcs, Handlers>
+    | Rpc.Context<Rpcs>
+    | Rpc.Middleware<Rpcs>
+    | Sharding
+  > {
+    return shardingTag.pipe(
+      Effect.flatMap((sharding) =>
+        sharding.registerEntity(
+          this,
+          Effect.isEffect(build) ? build : Effect.succeed(build),
+          options
+        )
+      ),
+      Layer.effectDiscard
+    )
+  },
+  toLayerMailbox<
+    Rpcs extends Rpc.Any,
+    R,
+    RX = never
+  >(
+    this: Entity<Rpcs>,
+    build:
+      | ((
+        mailbox: Mailbox.ReadonlyMailbox<Envelope.Request<Rpcs>>,
+        replier: Replier<Rpcs>
+      ) => Effect.Effect<never, never, R>)
+      | Effect.Effect<
+        (
+          mailbox: Mailbox.ReadonlyMailbox<Envelope.Request<Rpcs>>,
+          replier: Replier<Rpcs>
+        ) => Effect.Effect<never, never, R>,
+        never,
+        RX
+      >,
+    options?: {
+      readonly maxIdleTime?: DurationInput | undefined
+    }
+  ) {
+    const buildHandlers = Effect.gen(this, function*() {
+      const behaviour = Effect.isEffect(build) ? yield* build : build
+      const mailbox = yield* Mailbox.make<Envelope.Request<Rpcs>>()
+
+      // create the rpc handlers for the entity
+      const handler = (envelope: any) => {
+        return Effect.async<any, any>((resume) => {
+          mailbox.unsafeOffer(envelope)
+          resumes.set(envelope, resume)
+        })
+      }
+      const handlers: Record<string, any> = {}
+      for (const rpc of this.protocol.requests.keys()) {
+        handlers[rpc] = handler
+      }
+
+      // make the Replier for the behaviour
+      const resumes = new Map<Envelope.Request<any>, (exit: Exit.Exit<any, any>) => void>()
+      const complete = (request: Envelope.Request<any>, exit: Exit.Exit<any, any>) =>
+        Effect.sync(() => {
+          const resume = resumes.get(request)
+          if (resume) {
+            resumes.delete(request)
+            resume(exit)
+          }
+        })
+      const replier: Replier<Rpcs> = {
+        succeed: (request, value) => complete(request, Exit.succeed(value)),
+        fail: (request, error) => complete(request, Exit.fail(error)),
+        failCause: (request, cause) => complete(request, Exit.failCause(cause)),
+        complete
+      }
+
+      // fork the behaviour into the layer scope
+      yield* behaviour(mailbox, replier).pipe(
+        Effect.catchAllCause((cause) => {
+          const exit = Exit.failCause(cause)
+          for (const resume of resumes.values()) {
+            resume(exit)
+          }
+          return Effect.void
+        }),
+        Effect.interruptible,
+        Effect.forkScoped
+      )
+
+      return handlers as any
+    })
+
+    return this.toLayer(buildHandlers, {
+      ...options,
+      concurrency: "unbounded"
+    })
+  }
+}
+
+/**
+ * Creates a new `Entity` of the specified `type` which will accept messages
+ * that adhere to the provided `RpcGroup`.
+ *
+ * @since 1.0.0
+ * @category constructors
+ */
+export const fromRpcGroup = <Rpcs extends Rpc.Any>(
+  /**
+   * The entity type name.
+   */
+  type: string,
+  /**
+   * The schema definition for messages that the entity is capable of
+   * processing.
+   */
+  protocol: RpcGroup.RpcGroup<Rpcs>
+): Entity<Rpcs> => {
+  const self = Object.create(Proto)
+  self.type = EntityType.make(type)
+  self.protocol = protocol
+  return self
+}
+
+/**
+ * Creates a new `Entity` of the specified `type` which will accept messages
+ * that adhere to the provided schemas.
+ *
+ * @since 1.0.0
+ * @category constructors
+ */
+export const make = <Rpcs extends ReadonlyArray<Rpc.Any>>(
+  /**
+   * The entity type name.
+   */
+  type: string,
+  /**
+   * The schema definition for messages that the entity is capable of
+   * processing.
+   */
+  protocol: Rpcs
+): Entity<Rpcs[number]> => fromRpcGroup(type, RpcGroup.make(...protocol))
+
+/**
+ * A Context.Tag to access the current entity address.
+ *
+ * @since 1.0.0
+ * @category context
+ */
+export class CurrentAddress extends Context.Tag("@effect/cluster/Entity/EntityAddress")<
+  CurrentAddress,
+  EntityAddress
+>() {}
+
+/**
+ * A Context.Tag to access the current Runner address.
+ *
+ * @since 1.0.0
+ * @category context
+ */
+export class CurrentRunnerAddress extends Context.Tag("@effect/cluster/Entity/RunnerAddress")<
+  CurrentRunnerAddress,
+  RunnerAddress
+>() {}
+
+/**
+ * @since 1.0.0
+ * @category Replier
+ */
+export interface Replier<Rpcs extends Rpc.Any> {
+  readonly succeed: <R extends Rpcs>(
+    request: Envelope.Request<R>,
+    value: Replier.Success<R>
+  ) => Effect.Effect<void>
+
+  readonly fail: <R extends Rpcs>(
+    request: Envelope.Request<R>,
+    error: Rpc.Error<R>
+  ) => Effect.Effect<void>
+
+  readonly failCause: <R extends Rpcs>(
+    request: Envelope.Request<R>,
+    cause: Cause.Cause<Rpc.Error<R>>
+  ) => Effect.Effect<void>
+
+  readonly complete: <R extends Rpcs>(
+    request: Envelope.Request<R>,
+    exit: Exit.Exit<Replier.Success<R>, Rpc.Error<R>>
+  ) => Effect.Effect<void>
+}
+
+/**
+ * @since 1.0.0
+ * @category Replier
+ */
+export declare namespace Replier {
+  /**
+   * @since 1.0.0
+   * @category Replier
+   */
+  export type Success<R extends Rpc.Any> = Rpc.Success<R> extends Stream.Stream<infer _A, infer _E, infer _R> ?
+    Stream.Stream<_A, _E | Rpc.Error<R>, _R> | Mailbox.ReadonlyMailbox<_A, _E | Rpc.Error<R>>
+    : Rpc.Success<R>
+}
+
+/**
+ * @since 1.0.0
+ * @category Request
+ */
+export class Request<Rpc extends Rpc.Any> extends Data.Class<
+  Envelope.Request<Rpc> & {
+    readonly lastSentChunk: Option.Option<Reply.Chunk<Rpc>>
+  }
+> {
+  /**
+   * @since 1.0.0
+   */
+  get lastSentChunkValue(): Option.Option<Rpc.SuccessChunk<Rpc>> {
+    return this.lastSentChunk.pipe(Option.map((chunk) => Arr.lastNonEmpty(chunk.values)))
+  }
+
+  /**
+   * @since 1.0.0
+   */
+  get nextSequence(): number {
+    if (Option.isNone(this.lastSentChunk)) {
+      return 0
+    }
+    return this.lastSentChunk.value.sequence + 1
+  }
+}
+
+const shardingTag = Context.GenericTag<Sharding, Sharding["Type"]>("@effect/cluster/Sharding")
diff --git a/src/EntityAddress.ts b/src/EntityAddress.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6b3a01cbc190c07a259c5be48605a3e1788c62be
--- /dev/null
+++ b/src/EntityAddress.ts
@@ -0,0 +1,55 @@
+/**
+ * @since 1.0.0
+ */
+import * as Hash from "effect/Hash"
+import * as Schema from "effect/Schema"
+import { EntityId } from "./EntityId.js"
+import { EntityType } from "./EntityType.js"
+import { ShardId } from "./ShardId.js"
+
+const SymbolKey = "@effect/cluster/EntityAddress"
+
+/**
+ * @since 1.0.0
+ * @category type ids
+ */
+export const TypeId: unique symbol = Symbol.for(SymbolKey)
+
+/**
+ * @since 1.0.0
+ * @category type ids
+ */
+export type TypeId = typeof TypeId
+
+/**
+ * Represents the unique address of an entity within the cluster.
+ *
+ * @since 1.0.0
+ * @category models
+ */
+export class EntityAddress extends Schema.Class<EntityAddress>(SymbolKey)({
+  shardId: ShardId,
+  entityType: EntityType,
+  entityId: EntityId
+}) {
+  /**
+   * @since 1.0.0
+   */
+  readonly [TypeId] = TypeId;
+  /**
+   * @since 1.0.0
+   */
+  [Hash.symbol]() {
+    return Hash.cached(this)(Hash.string(`${this.shardId}:${this.entityType}:${this.entityId}`))
+  }
+}
+
+/**
+ * Represents the unique address of an entity within the cluster.
+ *
+ * @since 1.0.0
+ * @category schemas
+ */
+export const EntityAddressFromSelf: Schema.Schema<EntityAddress> = Schema.typeSchema(
+  EntityAddress
+)
diff --git a/src/EntityId.ts b/src/EntityId.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b36e4d45770da85f4518444f5b047a4a6e11c77e
--- /dev/null
+++ b/src/EntityId.ts
@@ -0,0 +1,16 @@
+/**
+ * @since 1.0.0
+ */
+import * as Schema from "effect/Schema"
+
+/**
+ * @since 1.0.0
+ * @category constructors
+ */
+export const EntityId = Schema.NonEmptyTrimmedString.pipe(Schema.brand("EntityId"))
+
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export type EntityId = typeof EntityId.Type
diff --git a/src/EntityType.ts b/src/EntityType.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9f97d29397d3b832059ab45e0b7815998c94ee29
--- /dev/null
+++ b/src/EntityType.ts
@@ -0,0 +1,16 @@
+/**
+ * @since 1.0.0
+ */
+import * as Schema from "effect/Schema"
+
+/**
+ * @since 1.0.0
+ * @category constructors
+ */
+export const EntityType = Schema.NonEmptyTrimmedString.pipe(Schema.brand("EntityType"))
+
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export type EntityType = typeof EntityType.Type
diff --git a/src/Envelope.ts b/src/Envelope.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7e23c784f9468571a75d3225b679112980fef365
--- /dev/null
+++ b/src/Envelope.ts
@@ -0,0 +1,352 @@
+/**
+ * @since 1.0.0
+ */
+import * as Headers from "@effect/platform/Headers"
+import type * as Rpc from "@effect/rpc/Rpc"
+import * as Predicate from "effect/Predicate"
+import * as PrimaryKey from "effect/PrimaryKey"
+import type { ReadonlyRecord } from "effect/Record"
+import * as Schema from "effect/Schema"
+import { EntityAddress, EntityAddressFromSelf } from "./EntityAddress.js"
+import { type Snowflake, SnowflakeFromString } from "./Snowflake.js"
+
+/**
+ * @since 1.0.0
+ * @category type ids
+ */
+export const TypeId: unique symbol = Symbol.for("@effect/cluster/Envelope")
+
+/**
+ * @since 1.0.0
+ * @category type ids
+ */
+export type TypeId = typeof TypeId
+
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export type Envelope<R extends Rpc.Any> = Request<R> | AckChunk | Interrupt
+
+/**
+ * @since 1.0.0
+ */
+export declare namespace Envelope {
+  /**
+   * @since 1.0.0
+   * @category models
+   */
+  export type Any = Envelope<any>
+
+  /**
+   * @since 1.0.0
+   * @category models
+   */
+  export type Encoded = Request.Encoded | typeof AckChunk.Encoded | typeof Interrupt.Encoded
+
+  /**
+   * @since 1.0.0
+   * @category models
+   */
+  export type PartialEncoded = Request.PartialEncoded | AckChunk | Interrupt
+}
+
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export interface Request<in out Rpc extends Rpc.Any> {
+  readonly [TypeId]: TypeId
+  readonly _tag: "Request"
+  readonly requestId: Snowflake
+  readonly address: EntityAddress
+  readonly tag: Rpc.Tag<Rpc>
+  readonly payload: Rpc.Payload<Rpc>
+  readonly headers: Headers.Headers
+  readonly traceId: string
+  readonly spanId: string
+  readonly sampled: boolean
+}
+
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export class AckChunk extends Schema.TaggedClass<AckChunk>("@effect/cluster/Envelope/AckChunk")("AckChunk", {
+  id: SnowflakeFromString,
+  address: EntityAddress,
+  requestId: SnowflakeFromString,
+  replyId: SnowflakeFromString
+}) {
+  /**
+   * @since 1.0.0
+   */
+  readonly [TypeId]: TypeId = TypeId
+
+  /**
+   * @since 1.0.0
+   */
+  withRequestId(requestId: Snowflake): AckChunk {
+    return new AckChunk({
+      ...this,
+      requestId
+    })
+  }
+}
+
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export class Interrupt extends Schema.TaggedClass<Interrupt>("@effect/cluster/Envelope/Interrupt")("Interrupt", {
+  id: SnowflakeFromString,
+  address: EntityAddress,
+  requestId: SnowflakeFromString
+}) {
+  /**
+   * @since 1.0.0
+   */
+  readonly [TypeId]: TypeId = TypeId
+
+  /**
+   * @since 1.0.0
+   */
+  withRequestId(requestId: Snowflake): Interrupt {
+    return new Interrupt({
+      ...this,
+      requestId
+    })
+  }
+}
+
+/**
+ * @since 1.0.0
+ */
+export declare namespace Request {
+  /**
+   * @since 1.0.0
+   * @category models
+   */
+  export type Any = Request<any>
+
+  /**
+   * @since 1.0.0
+   * @category models
+   */
+  export interface Encoded {
+    readonly _tag: "Request"
+    readonly requestId: string
+    readonly address: typeof EntityAddress.Encoded
+    readonly tag: string
+    readonly payload: unknown
+    readonly headers: ReadonlyRecord<string, string>
+    readonly traceId: string
+    readonly spanId: string
+    readonly sampled: boolean
+  }
+
+  /**
+   * @since 1.0.0
+   * @category models
+   */
+  export interface PartialEncoded {
+    readonly _tag: "Request"
+    readonly requestId: Snowflake
+    readonly address: EntityAddress
+    readonly tag: string
+    readonly payload: unknown
+    readonly headers: Headers.Headers
+    readonly traceId: string
+    readonly spanId: string
+    readonly sampled: boolean
+  }
+}
+
+/**
+ * @since 1.0.0
+ * @category refinements
+ */
+export const isEnvelope = (u: unknown): u is Envelope<any> => Predicate.hasProperty(u, TypeId)
+
+/**
+ * @since 1.0.0
+ * @category constructors
+ */
+export const makeRequest = <Rpc extends Rpc.Any>(
+  options: {
+    readonly requestId: Snowflake
+    readonly address: EntityAddress
+    readonly tag: Rpc.Tag<Rpc>
+    readonly payload: Rpc.Payload<Rpc>
+    readonly headers: Headers.Headers
+    readonly traceId: string
+    readonly spanId: string
+    readonly sampled: boolean
+  }
+): Request<Rpc> => ({
+  [TypeId]: TypeId,
+  _tag: "Request",
+  requestId: options.requestId,
+  tag: options.tag,
+  address: options.address,
+  payload: options.payload,
+  headers: options.headers,
+  traceId: options.traceId,
+  spanId: options.spanId,
+  sampled: options.sampled
+})
+
+/**
+ * @since 1.0.0
+ * @category serialization / deserialization
+ */
+export const EnvelopeFromSelf: Schema.Schema<
+  Envelope.Any,
+  Envelope.Any
+> = Schema.declare(isEnvelope, {
+  identifier: "Envelope"
+})
+
+/**
+ * @since 1.0.0
+ * @category serialization / deserialization
+ */
+export const RequestFromSelf: Schema.Schema<
+  Request.Any,
+  Request.Any
+> = Schema.declare((u): u is Request.Any => isEnvelope(u) && u._tag === "Request", {
+  identifier: "Envelope"
+})
+
+/**
+ * @since 1.0.0
+ * @category serialization / deserialization
+ */
+export const PartialEncodedRequest: Schema.Struct<
+  {
+    _tag: Schema.Literal<["Request"]>
+    requestId: Schema.Schema<Snowflake, string>
+    address: typeof EntityAddress
+    tag: typeof Schema.String
+    payload: typeof Schema.Unknown
+    headers: Schema.Schema<Headers.Headers, ReadonlyRecord<string, string>>
+    traceId: typeof Schema.String
+    spanId: typeof Schema.String
+    sampled: typeof Schema.Boolean
+  }
+> = Schema.Struct({
+  _tag: Schema.Literal("Request"),
+  requestId: SnowflakeFromString,
+  address: EntityAddress,
+  tag: Schema.String,
+  payload: Schema.Unknown,
+  headers: Headers.schema,
+  traceId: Schema.String,
+  spanId: Schema.String,
+  sampled: Schema.Boolean
+}) satisfies Schema.Schema<Request.PartialEncoded, Request.Encoded>
+
+/**
+ * @since 1.0.0
+ * @category serialization / deserialization
+ */
+export const PartialEncoded: Schema.Union<
+  [
+    Schema.Struct<
+      {
+        _tag: Schema.Literal<["Request"]>
+        requestId: Schema.Schema<Snowflake, string>
+        address: typeof EntityAddress
+        tag: typeof Schema.String
+        payload: typeof Schema.Unknown
+        headers: Schema.Schema<Headers.Headers, ReadonlyRecord<string, string>>
+        traceId: typeof Schema.String
+        spanId: typeof Schema.String
+        sampled: typeof Schema.Boolean
+      }
+    >,
+    typeof AckChunk,
+    typeof Interrupt
+  ]
+> = Schema.Union(PartialEncodedRequest, AckChunk, Interrupt) satisfies Schema.Schema<
+  Envelope.PartialEncoded,
+  Envelope.Encoded
+>
+
+/**
+ * @since 1.0.0
+ * @category serialization / deserialization
+ */
+export const PartialEncodedArray: Schema.Schema<
+  Array<Envelope.PartialEncoded>,
+  Array<Envelope.Encoded>
+> = Schema.mutable(Schema.Array(PartialEncoded))
+
+/**
+ * @since 1.0.0
+ * @category serialization / deserialization
+ */
+export const PartialEncodedRequestFromSelf: Schema.Struct<
+  {
+    _tag: Schema.Literal<["Request"]>
+    requestId: Schema.Schema<Snowflake>
+    address: Schema.Schema<EntityAddress>
+    tag: typeof Schema.String
+    payload: typeof Schema.Unknown
+    headers: Schema.Schema<Headers.Headers>
+    traceId: typeof Schema.String
+    spanId: typeof Schema.String
+    sampled: typeof Schema.Boolean
+  }
+> = Schema.Struct({
+  _tag: Schema.Literal("Request"),
+  requestId: Schema.typeSchema(SnowflakeFromString),
+  address: EntityAddressFromSelf,
+  tag: Schema.String,
+  payload: Schema.Unknown,
+  headers: Headers.schemaFromSelf,
+  traceId: Schema.String,
+  spanId: Schema.String,
+  sampled: Schema.Boolean
+}) satisfies Schema.Schema<Request.PartialEncoded>
+
+/**
+ * @since 1.0.0
+ * @category serialization / deserialization
+ */
+export const PartialEncodedFromSelf: Schema.Union<
+  [
+    Schema.Struct<
+      {
+        _tag: Schema.Literal<["Request"]>
+        requestId: Schema.Schema<Snowflake>
+        address: Schema.Schema<EntityAddress>
+        tag: typeof Schema.String
+        payload: typeof Schema.Unknown
+        headers: Schema.Schema<Headers.Headers>
+        traceId: typeof Schema.String
+        spanId: typeof Schema.String
+        sampled: typeof Schema.Boolean
+      }
+    >,
+    Schema.Schema<AckChunk>,
+    Schema.Schema<Interrupt>
+  ]
+> = Schema.Union(
+  PartialEncodedRequestFromSelf,
+  Schema.typeSchema(AckChunk),
+  Schema.typeSchema(Interrupt)
+) satisfies Schema.Schema<Envelope.PartialEncoded>
+
+/**
+ * @since 1.0.0
+ * @category primary key
+ */
+export const primaryKey = <R extends Rpc.Any>(envelope: Envelope<R>): string | null => {
+  if (envelope._tag !== "Request" || !(Predicate.hasProperty(envelope.payload, PrimaryKey.symbol))) {
+    return null
+  }
+  const value = PrimaryKey.value(envelope.payload)
+  // hash the entity address to save space?
+  return `${envelope.address.entityType}/${envelope.address.entityId}/${envelope.tag}/${value}`
+}
diff --git a/src/HttpCommon.ts b/src/HttpCommon.ts
new file mode 100644
index 0000000000000000000000000000000000000000..df8dad182d784423998b3e75689fdc9beb7a2c02
--- /dev/null
+++ b/src/HttpCommon.ts
@@ -0,0 +1,73 @@
+/**
+ * @since 1.0.0
+ */
+import * as HttpClient from "@effect/platform/HttpClient"
+import * as HttpClientRequest from "@effect/platform/HttpClientRequest"
+import * as Socket from "@effect/platform/Socket"
+import * as RpcClient from "@effect/rpc/RpcClient"
+import * as RpcSerialization from "@effect/rpc/RpcSerialization"
+import * as Effect from "effect/Effect"
+import * as Layer from "effect/Layer"
+import { RpcClientProtocol } from "./Runners.js"
+
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layerClientProtocolHttp = (options: {
+  readonly path: string
+  readonly https?: boolean | undefined
+}): Layer.Layer<
+  RpcClientProtocol,
+  never,
+  RpcSerialization.RpcSerialization | HttpClient.HttpClient
+> =>
+  Layer.effect(
+    RpcClientProtocol,
+    Effect.gen(function*() {
+      const serialization = yield* RpcSerialization.RpcSerialization
+      const client = yield* HttpClient.HttpClient
+      const https = options.https ?? false
+      return (address) => {
+        const clientWithUrl = HttpClient.mapRequest(
+          client,
+          HttpClientRequest.prependUrl(`http${https ? "s" : ""}://${address.host}:${address.port}/${options.path}`)
+        )
+        return RpcClient.makeProtocolHttp(clientWithUrl).pipe(
+          Effect.provideService(RpcSerialization.RpcSerialization, serialization)
+        )
+      }
+    })
+  )
+
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layerClientProtocolWebsocket = (options: {
+  readonly path: string
+  readonly https?: boolean | undefined
+}): Layer.Layer<
+  RpcClientProtocol,
+  never,
+  RpcSerialization.RpcSerialization | Socket.WebSocketConstructor
+> =>
+  Layer.effect(
+    RpcClientProtocol,
+    Effect.gen(function*() {
+      const serialization = yield* RpcSerialization.RpcSerialization
+      const https = options.https ?? false
+      const constructor = yield* Socket.WebSocketConstructor
+      return Effect.fnUntraced(function*(address) {
+        const socket = yield* Socket.makeWebSocket(
+          `ws${https ? "s" : ""}://${address.host}:${address.port}/${options.path}`
+        ).pipe(
+          Effect.provideService(Socket.WebSocketConstructor, constructor)
+        )
+        return yield* RpcClient.makeProtocolSocket.pipe(
+          Effect.provideService(Socket.Socket, socket),
+          Effect.provideService(RpcSerialization.RpcSerialization, serialization)
+        )
+      })
+    })
+  )
diff --git a/src/HttpRunner.ts b/src/HttpRunner.ts
new file mode 100644
index 0000000000000000000000000000000000000000..321c76989718367509764b622ab1ad00ace321d4
--- /dev/null
+++ b/src/HttpRunner.ts
@@ -0,0 +1,196 @@
+/**
+ * @since 1.0.0
+ */
+import type * as HttpApp from "@effect/platform/HttpApp"
+import type * as HttpClient from "@effect/platform/HttpClient"
+import * as HttpRouter from "@effect/platform/HttpRouter"
+import * as HttpServer from "@effect/platform/HttpServer"
+import type * as Socket from "@effect/platform/Socket"
+import type * as RpcSerialization from "@effect/rpc/RpcSerialization"
+import * as RpcServer from "@effect/rpc/RpcServer"
+import * as Effect from "effect/Effect"
+import * as Layer from "effect/Layer"
+import type { Scope } from "effect/Scope"
+import { layerClientProtocolHttp, layerClientProtocolWebsocket } from "./HttpCommon.js"
+import type { MessageStorage } from "./MessageStorage.js"
+import * as Runners from "./Runners.js"
+import * as RunnerServer from "./RunnerServer.js"
+import * as Sharding from "./Sharding.js"
+import type * as ShardingConfig from "./ShardingConfig.js"
+import * as ShardManager from "./ShardManager.js"
+import type { ShardStorage } from "./ShardStorage.js"
+import * as SynchronizedClock from "./SynchronizedClock.js"
+
+/**
+ * @since 1.0.0
+ * @category Http App
+ */
+export const toHttpApp: Effect.Effect<
+  HttpApp.Default<never, Scope>,
+  never,
+  Scope | Sharding.Sharding | RpcSerialization.RpcSerialization | MessageStorage
+> = Effect.gen(function*() {
+  const handlers = yield* Layer.build(RunnerServer.layerHandlers)
+  return yield* RpcServer.toHttpApp(Runners.Rpcs, {
+    spanPrefix: "RunnerServer",
+    disableTracing: true
+  }).pipe(Effect.provide(handlers))
+})
+
+/**
+ * @since 1.0.0
+ * @category Http App
+ */
+export const toHttpAppWebsocket: Effect.Effect<
+  HttpApp.Default<never, Scope>,
+  never,
+  Scope | Sharding.Sharding | RpcSerialization.RpcSerialization | MessageStorage
+> = Effect.gen(function*() {
+  const handlers = yield* Layer.build(RunnerServer.layerHandlers)
+  return yield* RpcServer.toHttpAppWebsocket(Runners.Rpcs, {
+    spanPrefix: "RunnerServer",
+    disableTracing: true
+  }).pipe(
+    Effect.provide(handlers)
+  )
+})
+
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layerClient: Layer.Layer<
+  Sharding.Sharding | Runners.Runners,
+  never,
+  ShardingConfig.ShardingConfig | Runners.RpcClientProtocol | MessageStorage | ShardStorage
+> = Sharding.layer.pipe(
+  Layer.provideMerge(Runners.layerRpc),
+  Layer.provideMerge(SynchronizedClock.layer),
+  Layer.provide(ShardManager.layerClientRpc)
+)
+
+/**
+ * A HTTP layer for the `Runners` services, that adds a route to the provided
+ * `HttpRouter.Tag`.
+ *
+ * By default, it uses the `HttpRouter.Default` tag.
+ *
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layer = <I = HttpRouter.Default>(options: {
+  readonly path: HttpRouter.PathInput
+  readonly routerTag?: HttpRouter.HttpRouter.TagClass<I, string, any, any>
+  readonly logAddress?: boolean | undefined
+}): Layer.Layer<
+  Sharding.Sharding | Runners.Runners,
+  never,
+  | RpcSerialization.RpcSerialization
+  | ShardingConfig.ShardingConfig
+  | Runners.RpcClientProtocol
+  | HttpServer.HttpServer
+  | MessageStorage
+  | ShardStorage
+> => {
+  const layer = RunnerServer.layerWithClients.pipe(
+    Layer.provide(RpcServer.layerProtocolHttp(options))
+  )
+  return options.logAddress ? withLogAddress(layer) : layer
+}
+
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layerWebsocketOptions = <I = HttpRouter.Default>(options: {
+  readonly path: HttpRouter.PathInput
+  readonly routerTag?: HttpRouter.HttpRouter.TagClass<I, string, any, any>
+  readonly logAddress?: boolean | undefined
+}): Layer.Layer<
+  Sharding.Sharding | Runners.Runners,
+  never,
+  | RpcSerialization.RpcSerialization
+  | ShardingConfig.ShardingConfig
+  | Runners.RpcClientProtocol
+  | HttpServer.HttpServer
+  | MessageStorage
+  | ShardStorage
+> => {
+  const layer = RunnerServer.layerWithClients.pipe(
+    Layer.provide(RpcServer.layerProtocolWebsocket(options))
+  )
+  return options.logAddress ? withLogAddress(layer) : layer
+}
+
+const withLogAddress = <A, E, R>(layer: Layer.Layer<A, E, R>): Layer.Layer<A, E, R | HttpServer.HttpServer> =>
+  Layer.effectDiscard(
+    HttpServer.addressFormattedWith((address) =>
+      Effect.annotateLogs(Effect.logInfo(`Listening on: ${address}`), {
+        package: "@effect/cluster",
+        service: "Runner"
+      })
+    )
+  ).pipe(Layer.provideMerge(layer))
+
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layerHttp: Layer.Layer<
+  Sharding.Sharding | Runners.Runners,
+  never,
+  | RpcSerialization.RpcSerialization
+  | ShardingConfig.ShardingConfig
+  | HttpClient.HttpClient
+  | HttpServer.HttpServer
+  | MessageStorage
+  | ShardStorage
+> = HttpRouter.Default.serve().pipe(
+  Layer.provideMerge(layer({ path: "/", logAddress: true })),
+  Layer.provide(layerClientProtocolHttp({ path: "/" }))
+)
+
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layerHttpClientOnly: Layer.Layer<
+  Sharding.Sharding | Runners.Runners,
+  never,
+  | RpcSerialization.RpcSerialization
+  | ShardingConfig.ShardingConfig
+  | HttpClient.HttpClient
+  | MessageStorage
+> = RunnerServer.layerClientOnly.pipe(
+  Layer.provide(layerClientProtocolHttp({ path: "/" }))
+)
+
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layerWebsocket: Layer.Layer<
+  Sharding.Sharding | Runners.Runners,
+  never,
+  | RpcSerialization.RpcSerialization
+  | ShardingConfig.ShardingConfig
+  | Socket.WebSocketConstructor
+  | HttpServer.HttpServer
+  | MessageStorage
+  | ShardStorage
+> = HttpRouter.Default.serve().pipe(
+  Layer.provideMerge(layerWebsocketOptions({ path: "/", logAddress: true })),
+  Layer.provide(layerClientProtocolWebsocket({ path: "/" }))
+)
+
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layerWebsocketClientOnly: Layer.Layer<
+  Sharding.Sharding | Runners.Runners,
+  never,
+  ShardingConfig.ShardingConfig | MessageStorage | RpcSerialization.RpcSerialization | Socket.WebSocketConstructor
+> = RunnerServer.layerClientOnly.pipe(
+  Layer.provide(layerClientProtocolWebsocket({ path: "/" }))
+)
diff --git a/src/HttpShardManager.ts b/src/HttpShardManager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e60b3af7f94e0939f4928a4b9d3f419295c18c8a
--- /dev/null
+++ b/src/HttpShardManager.ts
@@ -0,0 +1,273 @@
+/**
+ * @since 1.0.0
+ */
+import type * as HttpApp from "@effect/platform/HttpApp"
+import type * as HttpClient from "@effect/platform/HttpClient"
+import * as HttpRouter from "@effect/platform/HttpRouter"
+import * as HttpServer from "@effect/platform/HttpServer"
+import type * as Socket from "@effect/platform/Socket"
+import type * as RpcSerialization from "@effect/rpc/RpcSerialization"
+import * as RpcServer from "@effect/rpc/RpcServer"
+import * as Effect from "effect/Effect"
+import { identity } from "effect/Function"
+import * as Layer from "effect/Layer"
+import type { Scope } from "effect/Scope"
+import { layerClientProtocolHttp, layerClientProtocolWebsocket } from "./HttpCommon.js"
+import * as MessageStorage from "./MessageStorage.js"
+import * as RunnerHealth from "./RunnerHealth.js"
+import * as Runners from "./Runners.js"
+import type { ShardingConfig } from "./ShardingConfig.js"
+import * as ShardManager from "./ShardManager.js"
+import type { ShardStorage } from "./ShardStorage.js"
+
+/**
+ * @since 1.0.0
+ * @category Http App
+ */
+export const toHttpApp: Effect.Effect<
+  HttpApp.Default<never, Scope>,
+  never,
+  Scope | RpcSerialization.RpcSerialization | ShardManager.ShardManager
+> = Effect.gen(function*() {
+  const handlers = yield* Layer.build(ShardManager.layerServerHandlers)
+  return yield* RpcServer.toHttpApp(ShardManager.Rpcs).pipe(
+    Effect.provide(handlers)
+  )
+})
+
+/**
+ * @since 1.0.0
+ * @category Http App
+ */
+export const toHttpAppWebsocket: Effect.Effect<
+  HttpApp.Default<never, Scope>,
+  never,
+  Scope | RpcSerialization.RpcSerialization | ShardManager.ShardManager
+> = Effect.gen(function*() {
+  const handlers = yield* Layer.build(ShardManager.layerServerHandlers)
+  return yield* RpcServer.toHttpAppWebsocket(ShardManager.Rpcs).pipe(
+    Effect.provide(handlers)
+  )
+})
+
+/**
+ * A layer for the `ShardManager` service, that does not run a server.
+ *
+ * It only provides the `Runners` rpc client.
+ *
+ * You can use this with the `toHttpApp` and `toHttpAppWebsocket` apis
+ * to run a complete `ShardManager` server.
+ *
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layerNoServerHttp = (
+  options: {
+    readonly runnerPath: string
+    readonly runnerHttps?: boolean | undefined
+  }
+): Layer.Layer<
+  ShardManager.ShardManager,
+  never,
+  | RpcSerialization.RpcSerialization
+  | ShardStorage
+  | RunnerHealth.RunnerHealth
+  | HttpClient.HttpClient
+  | ShardManager.Config
+  | ShardingConfig
+> =>
+  ShardManager.layer.pipe(
+    Layer.provide(Runners.layerRpc.pipe(
+      Layer.provide([
+        layerClientProtocolHttp({
+          path: options.runnerPath,
+          https: options.runnerHttps
+        }),
+        MessageStorage.layerNoop
+      ])
+    ))
+  )
+
+/**
+ * A layer for the `ShardManager` service, that does not run a server.
+ *
+ * It only provides the `Runners` rpc client.
+ *
+ * You can use this with the `toHttpApp` and `toHttpAppWebsocket` apis
+ * to run a complete `ShardManager` server.
+ *
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layerNoServerWebsocket = (
+  options: {
+    readonly runnerPath: string
+    readonly runnerHttps?: boolean | undefined
+  }
+): Layer.Layer<
+  ShardManager.ShardManager,
+  never,
+  | RpcSerialization.RpcSerialization
+  | ShardStorage
+  | RunnerHealth.RunnerHealth
+  | Socket.WebSocketConstructor
+  | ShardManager.Config
+  | ShardingConfig
+> =>
+  ShardManager.layer.pipe(
+    Layer.provide(Runners.layerRpc.pipe(
+      Layer.provide([
+        layerClientProtocolWebsocket({
+          path: options.runnerPath,
+          https: options.runnerHttps
+        }),
+        MessageStorage.layerNoop
+      ])
+    ))
+  )
+
+/**
+ * A HTTP layer for the `ShardManager` server, that adds a route to the provided
+ * `HttpRouter.Tag`.
+ *
+ * By default, it uses the `HttpRouter.Default` tag.
+ *
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layerHttpOptions = <I = HttpRouter.Default>(
+  options: {
+    readonly path: HttpRouter.PathInput
+    readonly routerTag?: HttpRouter.HttpRouter.TagClass<I, string, any, any>
+    readonly runnerPath: string
+    readonly runnerHttps?: boolean | undefined
+    readonly logAddress?: boolean | undefined
+  }
+): Layer.Layer<
+  ShardManager.ShardManager,
+  never,
+  | RpcSerialization.RpcSerialization
+  | ShardStorage
+  | RunnerHealth.RunnerHealth
+  | HttpClient.HttpClient
+  | HttpServer.HttpServer
+  | ShardManager.Config
+  | ShardingConfig
+> => {
+  const routerTag = options.routerTag ?? HttpRouter.Default
+  return routerTag.serve().pipe(
+    options.logAddress ? withLogAddress : identity,
+    Layer.merge(ShardManager.layerServer),
+    Layer.provide(RpcServer.layerProtocolHttp(options)),
+    Layer.provideMerge(layerNoServerHttp(options))
+  )
+}
+
+/**
+ * A WebSocket layer for the `ShardManager` server, that adds a route to the provided
+ * `HttpRouter.Tag`.
+ *
+ * By default, it uses the `HttpRouter.Default` tag.
+ *
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layerWebsocketOptions = <I = HttpRouter.Default>(
+  options: {
+    readonly path: HttpRouter.PathInput
+    readonly routerTag?: HttpRouter.HttpRouter.TagClass<I, string, any, any>
+    readonly runnerPath: string
+    readonly runnerHttps?: boolean | undefined
+    readonly logAddress?: boolean | undefined
+  }
+): Layer.Layer<
+  ShardManager.ShardManager,
+  never,
+  | RpcSerialization.RpcSerialization
+  | ShardStorage
+  | RunnerHealth.RunnerHealth
+  | HttpServer.HttpServer
+  | Socket.WebSocketConstructor
+  | ShardManager.Config
+  | ShardingConfig
+> => {
+  const routerTag = options.routerTag ?? HttpRouter.Default
+  return routerTag.serve().pipe(
+    options.logAddress ? withLogAddress : identity,
+    Layer.merge(ShardManager.layerServer),
+    Layer.provide(RpcServer.layerProtocolWebsocket(options)),
+    Layer.provideMerge(layerNoServerWebsocket(options))
+  )
+}
+
+const withLogAddress = <A, E, R>(layer: Layer.Layer<A, E, R>): Layer.Layer<A, E, R | HttpServer.HttpServer> =>
+  Layer.effectDiscard(
+    HttpServer.addressFormattedWith((address) =>
+      Effect.annotateLogs(Effect.logInfo(`Listening on: ${address}`), {
+        package: "@effect/cluster",
+        service: "ShardManager"
+      })
+    )
+  ).pipe(Layer.provideMerge(layer))
+
+/**
+ * A HTTP layer for the `ShardManager` server, that adds a route to the provided
+ * `HttpRouter.Tag`.
+ *
+ * By default, it uses the `HttpRouter.Default` tag.
+ *
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layerHttp: Layer.Layer<
+  ShardManager.ShardManager,
+  never,
+  | RpcSerialization.RpcSerialization
+  | ShardStorage
+  | RunnerHealth.RunnerHealth
+  | HttpClient.HttpClient
+  | HttpServer.HttpServer
+  | ShardManager.Config
+  | ShardingConfig
+> = layerHttpOptions({ path: "/", runnerPath: "/" })
+
+/**
+ * A Websocket layer for the `ShardManager` server, that adds a route to the provided
+ * `HttpRouter.Tag`.
+ *
+ * By default, it uses the `HttpRouter.Default` tag.
+ *
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layerWebsocket: Layer.Layer<
+  ShardManager.ShardManager,
+  never,
+  | RpcSerialization.RpcSerialization
+  | ShardStorage
+  | RunnerHealth.RunnerHealth
+  | Socket.WebSocketConstructor
+  | HttpServer.HttpServer
+  | ShardManager.Config
+  | ShardingConfig
+> = layerWebsocketOptions({ path: "/", runnerPath: "/" })
+
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layerRunnerHealthHttp: Layer.Layer<
+  RunnerHealth.RunnerHealth,
+  never,
+  RpcSerialization.RpcSerialization | HttpClient.HttpClient | ShardingConfig
+> = Layer.provide(RunnerHealth.layerRpc, layerClientProtocolHttp({ path: "/" }))
+
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layerRunnerHealthWebsocket: Layer.Layer<
+  RunnerHealth.RunnerHealth,
+  never,
+  RpcSerialization.RpcSerialization | Socket.WebSocketConstructor | ShardingConfig
+> = Layer.provide(RunnerHealth.layerRpc, layerClientProtocolWebsocket({ path: "/" }))
diff --git a/src/MachineId.ts b/src/MachineId.ts
new file mode 100644
index 0000000000000000000000000000000000000000..92056e25dc55e254e84b30f33fe5d015176ac351
--- /dev/null
+++ b/src/MachineId.ts
@@ -0,0 +1,27 @@
+/**
+ * @since 1.0.0
+ */
+import * as Schema from "effect/Schema"
+
+/**
+ * @since 1.0.0
+ * @category constructors
+ */
+export const MachineId = Schema.Int.pipe(
+  Schema.brand("MachineId"),
+  Schema.annotations({
+    pretty: () => (machineId) => `MachineId(${machineId})`
+  })
+)
+
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export type MachineId = typeof MachineId.Type
+
+/**
+ * @since 1.0.0
+ * @category Constructors
+ */
+export const make = (shardId: number): MachineId => MachineId.make(shardId)
diff --git a/src/Message.ts b/src/Message.ts
index 8767e9d53905c019336b1f19b623b48d2f2e7ba4..1ebd847e9a25721a7fbe09049d252c8ac7cffca7 100644
--- a/src/Message.ts
+++ b/src/Message.ts
@@ -1,133 +1,184 @@
 /**
  * @since 1.0.0
  */
-import type * as Exit_ from "effect/Exit"
-import type * as PrimaryKey from "effect/PrimaryKey"
-import type * as Schema from "effect/Schema"
-import type * as Types from "effect/Types"
-import * as internal from "./internal/message.js"
+import type * as Rpc from "@effect/rpc/Rpc"
+import { FiberRef } from "effect"
+import type { Context } from "effect/Context"
+import * as Data from "effect/Data"
+import * as Effect from "effect/Effect"
+import * as Option from "effect/Option"
+import * as Schema from "effect/Schema"
+import type { PersistenceError } from "./ClusterError.js"
+import { MalformedMessage } from "./ClusterError.js"
+import * as Envelope from "./Envelope.js"
+import type * as Reply from "./Reply.js"
 
 /**
- * A Message is a request for an entity that will process it.
- * A Message also has a PrimaryKey so that the receiver is eventually able to detect duplicated messages.
- *
  * @since 1.0.0
- * @category models
+ * @category incoming
  */
-export interface Message<A, AI, E, EI>
-  extends Schema.SerializableWithResult<any, any, never, A, AI, E, EI, never>, PrimaryKey.PrimaryKey
-{}
+export type Incoming<R extends Rpc.Any> = IncomingRequest<R> | IncomingEnvelope
 
 /**
  * @since 1.0.0
- * @category models
+ * @category incoming
  */
-export namespace Message {
-  /**
-   * @since 1.0.0
-   * @category models
-   */
-  export type Any =
-    | Message<any, any, any, any>
-    | Message<any, any, never, never>
+export type IncomingLocal<R extends Rpc.Any> = IncomingRequestLocal<R> | IncomingEnvelope
 
-  /**
-   * Extracts the success type from a `Message`.
-   *
-   * @since 1.0.0
-   * @category utils
-   */
-  export type Success<S> = S extends Message<infer A, infer _AI, infer _E, infer _EI> ? A : never
+/**
+ * @since 1.0.0
+ * @category incoming
+ */
+export const incomingLocalFromOutgoing = <R extends Rpc.Any>(self: Outgoing<R>): IncomingLocal<R> => {
+  if (self._tag === "OutgoingEnvelope") {
+    return new IncomingEnvelope({ envelope: self.envelope })
+  }
+  return new IncomingRequestLocal({
+    envelope: self.envelope,
+    respond: self.respond,
+    lastSentReply: Option.none()
+  })
+}
 
-  /**
-   * Extracts the success type from a `Message`.
-   *
-   * @since 1.0.0
-   * @category utils
-   */
-  export type SuccessEncoded<S> = S extends Message<infer _A, infer _AI, infer _E, infer _EI> ? _AI : never
+/**
+ * @since 1.0.0
+ * @category incoming
+ */
+export class IncomingRequest<R extends Rpc.Any> extends Data.TaggedClass("IncomingRequest")<{
+  readonly envelope: Envelope.Request.PartialEncoded
+  readonly lastSentReply: Option.Option<Reply.ReplyEncoded<R>>
+  readonly respond: (reply: Reply.ReplyWithContext<R>) => Effect.Effect<void, MalformedMessage | PersistenceError>
+}> {}
 
-  /**
-   * Extracts the error type from a `Message`.
-   *
-   * @since 1.0.0
-   * @category utils
-   */
-  export type Error<S> = S extends Message<infer _A, infer _AI, infer E, infer _EI> ? E : never
+/**
+ * @since 1.0.0
+ * @category outgoing
+ */
+export class IncomingRequestLocal<R extends Rpc.Any> extends Data.TaggedClass("IncomingRequestLocal")<{
+  readonly envelope: Envelope.Request<R>
+  readonly lastSentReply: Option.Option<Reply.Reply<R>>
+  readonly respond: (reply: Reply.Reply<R>) => Effect.Effect<void, MalformedMessage | PersistenceError>
+}> {}
 
-  /**
-   * Extracts the error type from a `Message`.
-   *
-   * @since 1.0.0
-   * @category utils
-   */
-  export type ErrorEncoded<S> = S extends Message<infer _A, infer _AI, infer _E, infer _EI> ? _EI : never
+/**
+ * @since 1.0.0
+ * @category incoming
+ */
+export class IncomingEnvelope extends Data.TaggedClass("IncomingEnvelope")<{
+  readonly _tag: "IncomingEnvelope"
+  readonly envelope: Envelope.AckChunk | Envelope.Interrupt
+}> {}
 
-  /**
-   * Extracts the exit type from a `Message`.
-   *
-   * @since 1.0.0
-   * @category utils
-   */
-  export type Exit<S> = S extends Schema.WithResult<infer A, infer _AI, infer E, infer _EI, infer _R> ? Exit_.Exit<A, E>
-    : never
-}
+/**
+ * @since 1.0.0
+ * @category outgoing
+ */
+export type Outgoing<R extends Rpc.Any> = OutgoingRequest<R> | OutgoingEnvelope
 
 /**
  * @since 1.0.0
- * @category schemas
+ * @category outgoing
  */
-export interface TaggedMessageConstructor<Tag extends string, Self, R, IS, S, IE, E, IA, A>
-  extends Schema.Schema<Self, Types.Simplify<IS & { readonly _tag: Tag }>, R>
-{
-  new(
-    props: Types.Equals<S, {}> extends true ? void : S,
-    disableValidation?: boolean
-  ):
-    & Schema.TaggedRequest<Tag, S, IS & { readonly _tag: Tag }, never, A, IA, E, IE, never>
-    & S
-    & PrimaryKey.PrimaryKey
+export class OutgoingRequest<R extends Rpc.Any> extends Data.TaggedClass("OutgoingRequest")<{
+  readonly envelope: Envelope.Request<R>
+  readonly context: Context<Rpc.Context<R>>
+  readonly lastReceivedReply: Option.Option<Reply.Reply<R>>
+  readonly rpc: R
+  readonly respond: (reply: Reply.Reply<R>) => Effect.Effect<void, PersistenceError>
+}> {
+  /**
+   * @since 1.0.0
+   */
+  public encodedCache?: Envelope.Request.PartialEncoded
 }
 
 /**
  * @since 1.0.0
- * @category schemas
+ * @category outgoing
  */
-export const TaggedMessage = internal.TaggedMessage_
+export class OutgoingEnvelope extends Data.TaggedClass("OutgoingEnvelope")<{
+  readonly envelope: Envelope.AckChunk | Envelope.Interrupt
+  readonly rpc: Rpc.AnyWithProps
+}> {}
 
 /**
  * @since 1.0.0
- * @category utils
+ * @category serialization / deserialization
  */
-export const isMessageWithResult: (value: unknown) => value is Message<unknown, unknown, unknown, unknown> =
-  internal.isMessageWithResult
+export const serialize = <Rpc extends Rpc.Any>(
+  message: Outgoing<Rpc>
+): Effect.Effect<Envelope.Envelope.PartialEncoded, MalformedMessage> => {
+  if (message._tag !== "OutgoingRequest") {
+    return Effect.succeed(message.envelope)
+  }
+  return Effect.suspend(() =>
+    message.encodedCache
+      ? Effect.succeed(message.encodedCache)
+      : serializeRequest(message)
+  )
+}
 
 /**
- * Extracts the exit schema from a Message. This schema will be used to encode the remote exit of the Message processor.
- *
  * @since 1.0.0
- * @category utils
+ * @category serialization / deserialization
  */
-export const exitSchema: <A extends Message.Any>(
-  message: A
-) => Schema.Schema<Message.Exit<A>, unknown> = internal.exitSchema
+export const serializeEnvelope = <Rpc extends Rpc.Any>(
+  message: Outgoing<Rpc>
+): Effect.Effect<Envelope.Envelope.Encoded, MalformedMessage> =>
+  Effect.flatMap(
+    serialize(message),
+    (envelope) => MalformedMessage.refail(Schema.encode(Envelope.PartialEncoded)(envelope))
+  )
 
 /**
- * Extracts the failure schema from a Message. This schema will be used to encode remote failures of the Message processor.
- *
  * @since 1.0.0
- * @category utils
+ * @category serialization / deserialization
  */
-export const failureSchema: <A extends Message.Any>(
-  message: A
-) => Schema.Schema<Message.Error<A>, unknown> = internal.failureSchema
+export const serializeRequest = <Rpc extends Rpc.Any>(
+  self: OutgoingRequest<Rpc>
+): Effect.Effect<Envelope.Request.PartialEncoded, MalformedMessage> => {
+  const rpc = self.rpc as any as Rpc.AnyWithProps
+  return Schema.encode(rpc.payloadSchema)(self.envelope.payload).pipe(
+    Effect.locally(FiberRef.currentContext, self.context),
+    MalformedMessage.refail,
+    Effect.map((payload) => ({
+      ...self.envelope,
+      payload
+    }))
+  ) as any as Effect.Effect<Envelope.Request.PartialEncoded, MalformedMessage>
+}
 
 /**
- * Extracts the success schema from a Message. This schema will be used to encode the remote success of the Message processor.
- *
  * @since 1.0.0
- * @category utils
+ * @category serialization / deserialization
  */
-export const successSchema: <A extends Message.Any>(
-  message: A
-) => Schema.Schema<Message.Success<A>, unknown> = internal.successSchema
+export const deserializeLocal = <Rpc extends Rpc.Any>(
+  self: Outgoing<Rpc>,
+  encoded: Envelope.Envelope.PartialEncoded
+): Effect.Effect<
+  IncomingLocal<Rpc>,
+  MalformedMessage
+> => {
+  if (encoded._tag !== "Request") {
+    return Effect.succeed(new IncomingEnvelope({ envelope: encoded }))
+  } else if (self._tag !== "OutgoingRequest") {
+    return Effect.fail(
+      new MalformedMessage({ cause: new Error("Can only deserialize a Request with an OutgoingRequest message") })
+    )
+  }
+  const rpc = self.rpc as any as Rpc.AnyWithProps
+  return Schema.decode(rpc.payloadSchema)(encoded.payload).pipe(
+    Effect.locally(FiberRef.currentContext, self.context),
+    MalformedMessage.refail,
+    Effect.map((payload) =>
+      new IncomingRequestLocal({
+        envelope: Envelope.makeRequest({
+          ...encoded,
+          payload
+        } as any),
+        lastSentReply: Option.none(),
+        respond: self.respond
+      })
+    )
+  ) as Effect.Effect<IncomingRequestLocal<Rpc>, MalformedMessage>
+}
diff --git a/src/MessageStorage.ts b/src/MessageStorage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d22a135392a468df2a50258f548cbd71202a9d68
--- /dev/null
+++ b/src/MessageStorage.ts
@@ -0,0 +1,697 @@
+/**
+ * @since 1.0.0
+ */
+import type * as Rpc from "@effect/rpc/Rpc"
+import * as Arr from "effect/Array"
+import * as Context from "effect/Context"
+import * as Data from "effect/Data"
+import * as Effect from "effect/Effect"
+import * as Exit from "effect/Exit"
+import * as FiberRef from "effect/FiberRef"
+import { globalValue } from "effect/GlobalValue"
+import * as Iterable from "effect/Iterable"
+import * as Layer from "effect/Layer"
+import * as Option from "effect/Option"
+import type { ParseError } from "effect/ParseResult"
+import type { Predicate } from "effect/Predicate"
+import * as Schema from "effect/Schema"
+import type { PersistenceError } from "./ClusterError.js"
+import { MalformedMessage } from "./ClusterError.js"
+import * as DeliverAt from "./DeliverAt.js"
+import type { EntityAddress } from "./EntityAddress.js"
+import * as Envelope from "./Envelope.js"
+import * as Message from "./Message.js"
+import * as Reply from "./Reply.js"
+import type { ShardId } from "./ShardId.js"
+import type { ShardingConfig } from "./ShardingConfig.js"
+import * as Snowflake from "./Snowflake.js"
+
+/**
+ * @since 1.0.0
+ * @category context
+ */
+export class MessageStorage extends Context.Tag("@effect/cluster/MessageStorage")<MessageStorage, {
+  /**
+   * Save the provided message and its associated metadata.
+   */
+  readonly saveRequest: <R extends Rpc.Any>(
+    envelope: Message.OutgoingRequest<R>
+  ) => Effect.Effect<SaveResult<R>, PersistenceError | MalformedMessage>
+
+  /**
+   * Save the provided message and its associated metadata.
+   */
+  readonly saveEnvelope: (
+    envelope: Message.OutgoingEnvelope
+  ) => Effect.Effect<void, PersistenceError | MalformedMessage>
+
+  /**
+   * Save the provided `Reply` and its associated metadata.
+   */
+  readonly saveReply: <R extends Rpc.Any>(
+    reply: Reply.ReplyWithContext<R>
+  ) => Effect.Effect<void, PersistenceError | MalformedMessage>
+
+  /**
+   * Retrieves the replies for the specified requests.
+   *
+   * - Un-acknowledged chunk replies
+   * - WithExit replies
+   */
+  readonly repliesFor: <R extends Rpc.Any>(
+    requests: Iterable<Message.OutgoingRequest<R>>
+  ) => Effect.Effect<Array<Reply.Reply<R>>, PersistenceError | MalformedMessage>
+
+  /**
+   * For locally sent messages, register a handler to process the replies.
+   */
+  readonly registerReplyHandler: <R extends Rpc.Any>(message: Message.OutgoingRequest<R>) => Effect.Effect<void>
+
+  /**
+   * Retrieves the unprocessed messages for the specified shards.
+   *
+   * A message is unprocessed when:
+   *
+   * - Requests that have no WithExit replies
+   *   - Or they have no unacknowledged chunk replies
+   * - The latest AckChunk envelope
+   * - All Interrupt's for unprocessed requests
+   */
+  readonly unprocessedMessages: (
+    shardIds: Iterable<ShardId>
+  ) => Effect.Effect<Array<Message.Incoming<any>>, PersistenceError>
+
+  /**
+   * Retrieves the unprocessed messages by id.
+   */
+  readonly unprocessedMessagesById: <R extends Rpc.Any>(
+    messageIds: Iterable<Snowflake.Snowflake>
+  ) => Effect.Effect<Array<Message.Incoming<R>>, PersistenceError>
+
+  /**
+   * Reset the mailbox state for the provided address.
+   */
+  readonly resetAddress: (
+    address: EntityAddress
+  ) => Effect.Effect<void, PersistenceError>
+}>() {}
+
+/**
+ * @since 1.0.0
+ * @category SaveResult
+ */
+export type SaveResult<R extends Rpc.Any> = SaveResult.Success | SaveResult.Duplicate<R>
+
+/**
+ * @since 1.0.0
+ * @category SaveResult
+ */
+export const SaveResult = Data.taggedEnum<SaveResult.Constructor>()
+
+/**
+ * @since 1.0.0
+ * @category SaveResult
+ */
+export const SaveResultEncoded = Data.taggedEnum<SaveResult.Encoded>()
+
+/**
+ * @since 1.0.0
+ * @category SaveResult
+ */
+export declare namespace SaveResult {
+  /**
+   * @since 1.0.0
+   * @category SaveResult
+   */
+  export type Encoded = SaveResult.Success | SaveResult.DuplicateEncoded
+
+  /**
+   * @since 1.0.0
+   * @category SaveResult
+   */
+  export interface Success {
+    readonly _tag: "Success"
+  }
+
+  /**
+   * @since 1.0.0
+   * @category SaveResult
+   */
+  export interface Duplicate<R extends Rpc.Any> {
+    readonly _tag: "Duplicate"
+    readonly originalId: Snowflake.Snowflake
+    readonly lastReceivedReply: Option.Option<Reply.Reply<R>>
+  }
+
+  /**
+   * @since 1.0.0
+   * @category SaveResult
+   */
+  export interface DuplicateEncoded {
+    readonly _tag: "Duplicate"
+    readonly originalId: Snowflake.Snowflake
+    readonly lastReceivedReply: Option.Option<Reply.ReplyEncoded<any>>
+  }
+
+  /**
+   * @since 1.0.0
+   * @category SaveResult
+   */
+  export interface Constructor extends Data.TaggedEnum.WithGenerics<1> {
+    readonly taggedEnum: SaveResult<this["A"]>
+  }
+}
+
+/**
+ * @since 1.0.0
+ * @category Encoded
+ */
+export type Encoded = {
+  /**
+   * Save the provided message and its associated metadata.
+   */
+  readonly saveEnvelope: (
+    options: {
+      readonly envelope: Envelope.Envelope.Encoded
+      readonly primaryKey: string | null
+      readonly deliverAt: number | null
+    }
+  ) => Effect.Effect<SaveResult.Encoded, PersistenceError>
+
+  /**
+   * Save the provided `Reply` and its associated metadata.
+   */
+  readonly saveReply: (
+    reply: Reply.ReplyEncoded<any>
+  ) => Effect.Effect<void, PersistenceError>
+
+  /**
+   * Retrieves the replies for the specified requests.
+   *
+   * - Un-acknowledged chunk replies
+   * - WithExit replies
+   */
+  readonly repliesFor: (requestIds: Array<string>) => Effect.Effect<
+    Array<Reply.ReplyEncoded<any>>,
+    PersistenceError
+  >
+
+  /**
+   * Retrieves the unprocessed messages for the given shards.
+   *
+   * A message is unprocessed when:
+   *
+   * - Requests that have no WithExit replies
+   *   - Or they have no unacknowledged chunk replies
+   * - The latest AckChunk envelope
+   * - All Interrupt's for unprocessed requests
+   */
+  readonly unprocessedMessages: (
+    shardIds: ReadonlyArray<number>,
+    now: number
+  ) => Effect.Effect<
+    Array<{
+      readonly envelope: Envelope.Envelope.Encoded
+      readonly lastSentReply: Option.Option<Reply.ReplyEncoded<any>>
+    }>,
+    PersistenceError
+  >
+
+  /**
+   * Retrieves the unprocessed messages by id.
+   */
+  readonly unprocessedMessagesById: (
+    messageIds: ReadonlyArray<Snowflake.Snowflake>,
+    now: number
+  ) => Effect.Effect<
+    Array<{
+      readonly envelope: Envelope.Envelope.Encoded
+      readonly lastSentReply: Option.Option<Reply.ReplyEncoded<any>>
+    }>,
+    PersistenceError
+  >
+
+  /**
+   * Reset the mailbox state for the provided address.
+   */
+  readonly resetAddress: (
+    address: EntityAddress
+  ) => Effect.Effect<void, PersistenceError>
+}
+
+/**
+ * @since 1.0.0
+ * @category Encoded
+ */
+export type EncodedUnprocessedOptions<A> = {
+  readonly existingShards: Array<number>
+  readonly newShards: Array<number>
+  readonly cursor: Option.Option<A>
+}
+
+/**
+ * @since 1.0.0
+ * @category Encoded
+ */
+export type EncodedRepliesOptions<A> = {
+  readonly existingRequests: Array<string>
+  readonly newRequests: Array<string>
+  readonly cursor: Option.Option<A>
+}
+
+/**
+ * @since 1.0.0
+ * @category constructors
+ */
+export const make = (
+  storage: Omit<MessageStorage["Type"], "registerReplyHandler">
+): Effect.Effect<MessageStorage["Type"]> =>
+  Effect.sync(() => {
+    const replyHandlers = new Map<
+      Snowflake.Snowflake,
+      (reply: Reply.Reply<any>) => Effect.Effect<void, PersistenceError>
+    >()
+    return MessageStorage.of({
+      ...storage,
+      registerReplyHandler: (message) =>
+        Effect.sync(() => {
+          replyHandlers.set(message.envelope.requestId, message.respond)
+        }),
+      saveReply(reply) {
+        return Effect.flatMap(storage.saveReply(reply), () => {
+          const handler = replyHandlers.get(reply.reply.requestId)
+          if (!handler) {
+            return Effect.void
+          } else if (reply.reply._tag === "WithExit") {
+            replyHandlers.delete(reply.reply.requestId)
+          }
+          return handler(reply.reply)
+        })
+      }
+    })
+  })
+
+/**
+ * @since 1.0.0
+ * @category constructors
+ */
+export const makeEncoded: (encoded: Encoded) => Effect.Effect<
+  MessageStorage["Type"],
+  never,
+  Snowflake.Generator
+> = Effect.fnUntraced(function*(encoded: Encoded) {
+  const snowflakeGen = yield* Snowflake.Generator
+  const clock = yield* Effect.clock
+
+  const storage: MessageStorage["Type"] = yield* make({
+    saveRequest: (message) =>
+      Message.serializeEnvelope(message).pipe(
+        Effect.flatMap((envelope) =>
+          encoded.saveEnvelope({
+            envelope,
+            primaryKey: Envelope.primaryKey(message.envelope),
+            deliverAt: DeliverAt.toMillis(message.envelope.payload)
+          })
+        ),
+        Effect.flatMap((result) => {
+          if (result._tag === "Success" || result.lastReceivedReply._tag === "None") {
+            return Effect.succeed(result as SaveResult<any>)
+          }
+          const duplicate = result
+          const schema = Reply.Reply(message.rpc)
+          return Schema.decode(schema)(result.lastReceivedReply.value).pipe(
+            Effect.locally(FiberRef.currentContext, message.context),
+            MalformedMessage.refail,
+            Effect.map((reply) =>
+              SaveResult.Duplicate({
+                originalId: duplicate.originalId,
+                lastReceivedReply: Option.some(reply)
+              })
+            )
+          )
+        })
+      ),
+    saveEnvelope: (message) =>
+      Message.serializeEnvelope(message).pipe(
+        Effect.flatMap((envelope) =>
+          encoded.saveEnvelope({
+            envelope,
+            primaryKey: null,
+            deliverAt: null
+          })
+        ),
+        Effect.asVoid
+      ),
+    saveReply: (reply) => Effect.flatMap(Reply.serialize(reply), encoded.saveReply),
+    repliesFor: Effect.fnUntraced(function*(messages) {
+      const requestIds = Arr.empty<string>()
+      const map = new Map<string, Message.OutgoingRequest<any>>()
+      for (const message of messages) {
+        const id = String(message.envelope.requestId)
+        requestIds.push(id)
+        map.set(id, message)
+      }
+      if (requestIds.length === 0) return []
+      const encodedReplies = yield* encoded.repliesFor(requestIds)
+      return yield* decodeReplies(map, encodedReplies)
+    }),
+    unprocessedMessages: (shardIds) => {
+      const shards = Array.from(shardIds)
+      if (shards.length === 0) return Effect.succeed([])
+      return Effect.flatMap(
+        Effect.suspend(() => encoded.unprocessedMessages(shards, clock.unsafeCurrentTimeMillis())),
+        decodeMessages
+      )
+    },
+    unprocessedMessagesById(messageIds) {
+      const ids = Array.from(messageIds)
+      if (ids.length === 0) return Effect.succeed([])
+      return Effect.flatMap(
+        Effect.suspend(() => encoded.unprocessedMessagesById(ids, clock.unsafeCurrentTimeMillis())),
+        decodeMessages
+      )
+    },
+    resetAddress: (address) => encoded.resetAddress(address)
+  })
+
+  const decodeMessages = (
+    envelopes: Array<{
+      readonly envelope: Envelope.Envelope.Encoded
+      readonly lastSentReply: Option.Option<Reply.ReplyEncoded<any>>
+    }>
+  ) => {
+    const messages: Array<Message.Incoming<any>> = []
+    let index = 0
+
+    // if we have a malformed message, we should not return it and update
+    // the storage with a defect
+    const decodeMessage = Effect.catchAll(
+      Effect.suspend(() => {
+        const envelope = envelopes[index]
+        if (!envelope) return Effect.succeed(undefined)
+        return decodeEnvelopeWithReply(envelope)
+      }),
+      (error) => {
+        const envelope = envelopes[index]
+        return storage.saveReply(Reply.ReplyWithContext.fromDefect({
+          id: snowflakeGen.unsafeNext(),
+          requestId: Snowflake.Snowflake(envelope.envelope.requestId),
+          defect: error.toString()
+        })).pipe(
+          Effect.forkDaemon,
+          Effect.asVoid
+        )
+      }
+    )
+    return Effect.as(
+      Effect.whileLoop({
+        while: () => index < envelopes.length,
+        body: () => decodeMessage,
+        step: (message) => {
+          const envelope = envelopes[index++]
+          if (!message) return
+          messages.push(
+            message.envelope._tag === "Request"
+              ? new Message.IncomingRequest({
+                envelope: message.envelope,
+                lastSentReply: envelope.lastSentReply,
+                respond: storage.saveReply
+              })
+              : new Message.IncomingEnvelope({
+                envelope: message.envelope
+              })
+          )
+        }
+      }),
+      messages
+    )
+  }
+
+  const decodeReplies = (
+    messages: Map<string, Message.OutgoingRequest<any>>,
+    encodedReplies: Array<Reply.ReplyEncoded<any>>
+  ) => {
+    const replies: Array<Reply.Reply<any>> = []
+    const ignoredRequests = new Set<string>()
+    let index = 0
+
+    const decodeReply: Effect.Effect<void | Reply.Reply<any>> = Effect.catchAll(
+      Effect.suspend(() => {
+        const reply = encodedReplies[index]
+        if (ignoredRequests.has(reply.requestId)) return Effect.void
+        const message = messages.get(reply.requestId)
+        if (!message) return Effect.void
+        const schema = Reply.Reply(message.rpc)
+        return Schema.decode(schema)(reply).pipe(
+          Effect.locally(FiberRef.currentContext, message.context)
+        ) as Effect.Effect<Reply.Reply<any>, ParseError>
+      }),
+      (error) => {
+        const reply = encodedReplies[index]
+        ignoredRequests.add(reply.requestId)
+        return Effect.succeed(
+          new Reply.WithExit({
+            id: snowflakeGen.unsafeNext(),
+            requestId: Snowflake.Snowflake(reply.requestId),
+            exit: Exit.die(error)
+          })
+        )
+      }
+    )
+
+    return Effect.as(
+      Effect.whileLoop({
+        while: () => index < encodedReplies.length,
+        body: () => decodeReply,
+        step: (reply) => {
+          index++
+          if (reply) replies.push(reply)
+        }
+      }),
+      replies
+    )
+  }
+
+  return storage
+})
+
+/**
+ * @since 1.0.0
+ * @category Constructors
+ */
+export const noop: MessageStorage["Type"] = globalValue(
+  "@effect/cluster/MessageStorage/noop",
+  () =>
+    Effect.runSync(make({
+      saveRequest: () => Effect.succeed(SaveResult.Success()),
+      saveEnvelope: () => Effect.void,
+      saveReply: () => Effect.void,
+      repliesFor: () => Effect.succeed([]),
+      unprocessedMessages: () => Effect.succeed([]),
+      unprocessedMessagesById: () => Effect.succeed([]),
+      resetAddress: () => Effect.void
+    }))
+)
+
+/**
+ * @since 1.0.0
+ * @category Memory
+ */
+export type MemoryEntry = {
+  readonly envelope: Envelope.Request.Encoded
+  lastReceivedChunk: Option.Option<Reply.ChunkEncoded<any>>
+  replies: Array<Reply.ReplyEncoded<any>>
+}
+
+/**
+ * @since 1.0.0
+ * @category Memory
+ */
+export class MemoryDriver extends Effect.Service<MemoryDriver>()("@effect/cluster/MessageStorage/MemoryDriver", {
+  dependencies: [Snowflake.layerGenerator],
+  effect: Effect.gen(function*() {
+    const requests = new Map<string, MemoryEntry>()
+    const requestsByPrimaryKey = new Map<string, MemoryEntry>()
+    const unprocessed = new Set<Envelope.Request.Encoded>()
+    const replyIds = new Set<string>()
+
+    const journal: Array<Envelope.Envelope.Encoded> = []
+
+    const cursors = new WeakMap<{}, number>()
+
+    const unprocessedWith = (predicate: Predicate<Envelope.Envelope.Encoded>) => {
+      const messages: Array<{
+        readonly envelope: Envelope.Envelope.Encoded
+        readonly lastSentReply: Option.Option<Reply.ReplyEncoded<any>>
+      }> = []
+      for (const envelope of unprocessed) {
+        if (!predicate(envelope)) {
+          continue
+        }
+        if (envelope._tag === "Request") {
+          const entry = requests.get(envelope.requestId)
+          messages.push({
+            envelope,
+            lastSentReply: Option.fromNullable(entry?.replies[entry.replies.length - 1])
+          })
+        } else {
+          messages.push({
+            envelope,
+            lastSentReply: Option.none()
+          })
+        }
+      }
+      return messages
+    }
+
+    const replyLatch = yield* Effect.makeLatch()
+
+    const encoded: Encoded = {
+      saveEnvelope: ({ envelope, primaryKey }) =>
+        Effect.sync(() => {
+          const existing = primaryKey
+            ? requestsByPrimaryKey.get(primaryKey)
+            : envelope._tag === "Request" && requests.get(envelope.requestId)
+          if (existing) {
+            return SaveResultEncoded.Duplicate({
+              originalId: Snowflake.Snowflake(existing.envelope.requestId),
+              lastReceivedReply: existing.lastReceivedChunk
+            })
+          }
+          if (envelope._tag === "Request") {
+            const entry: MemoryEntry = { envelope, replies: [], lastReceivedChunk: Option.none() }
+            requests.set(envelope.requestId, entry)
+            if (primaryKey) {
+              requestsByPrimaryKey.set(primaryKey, entry)
+            }
+            unprocessed.add(envelope)
+          } else if (envelope._tag === "AckChunk") {
+            const entry = requests.get(envelope.requestId)
+            if (entry) {
+              entry.lastReceivedChunk = Arr.findFirst(
+                entry.replies,
+                (r): r is Reply.ChunkEncoded<any> => r._tag === "Chunk" && r.id === envelope.replyId
+              ).pipe(Option.orElse(() => entry.lastReceivedChunk))
+            }
+          }
+          journal.push(envelope)
+          return SaveResultEncoded.Success()
+        }),
+      saveReply: (reply) =>
+        Effect.sync(() => {
+          const entry = requests.get(reply.requestId)
+          if (!entry || replyIds.has(reply.id)) return
+          if (reply._tag === "WithExit") {
+            unprocessed.delete(entry.envelope)
+          }
+          entry.replies.push(reply)
+          replyIds.add(reply.id)
+          replyLatch.unsafeOpen()
+        }),
+      repliesFor: (requestIds) =>
+        Effect.sync(() => {
+          const replies = Arr.empty<Reply.ReplyEncoded<any>>()
+          for (const requestId of requestIds) {
+            const request = requests.get(requestId)
+            if (!request) continue
+            else if (Option.isNone(request.lastReceivedChunk)) {
+              // eslint-disable-next-line no-restricted-syntax
+              replies.push(...request.replies)
+              continue
+            }
+            const sequence = request.lastReceivedChunk.value.sequence
+            for (const reply of request.replies) {
+              if (reply._tag === "Chunk" && reply.sequence <= sequence) {
+                continue
+              }
+              replies.push(reply)
+            }
+          }
+          return replies
+        }),
+      unprocessedMessages: (shardIds) =>
+        Effect.sync(() => {
+          if (unprocessed.size === 0) return []
+          const messages = Arr.empty<{
+            envelope: Envelope.Envelope.Encoded
+            lastSentReply: Option.Option<Reply.ReplyEncoded<any>>
+          }>()
+          let index = journal.indexOf(Iterable.unsafeHead(unprocessed))
+          for (; index < journal.length; index++) {
+            const envelope = journal[index]
+            if (!shardIds.includes(envelope.address.shardId)) {
+              continue
+            }
+            if (envelope._tag === "Request") {
+              const entry = requests.get(envelope.requestId)!
+              messages.push({
+                envelope,
+                lastSentReply: Arr.last(entry.replies)
+              })
+            } else {
+              messages.push({
+                envelope,
+                lastSentReply: Option.none()
+              })
+            }
+          }
+          return messages
+        }),
+      unprocessedMessagesById: (ids) =>
+        Effect.sync(() => {
+          const envelopeIds = new Set<string>()
+          for (const id of ids) {
+            envelopeIds.add(String(id))
+          }
+          return unprocessedWith((envelope) => envelopeIds.has(envelope.requestId))
+        }),
+      resetAddress: () => Effect.void
+    }
+
+    const storage = yield* makeEncoded(encoded)
+
+    return {
+      storage,
+      encoded,
+      requests,
+      requestsByPrimaryKey,
+      unprocessed,
+      replyIds,
+      journal,
+      cursors
+    } as const
+  })
+}) {}
+
+/**
+ * @since 1.0.0
+ * @category layers
+ */
+export const layerNoop: Layer.Layer<MessageStorage> = Layer.succeed(MessageStorage, noop)
+
+/**
+ * @since 1.0.0
+ * @category layers
+ */
+export const layerMemory: Layer.Layer<
+  MessageStorage | MemoryDriver,
+  never,
+  ShardingConfig
+> = Layer.effect(MessageStorage, Effect.map(MemoryDriver, (_) => _.storage)).pipe(
+  Layer.provideMerge(MemoryDriver.Default)
+)
+
+// --- internal ---
+
+const EnvelopeWithReply: Schema.Schema<{
+  readonly envelope: Envelope.Envelope.PartialEncoded
+  readonly lastSentReply: Option.Option<Reply.ReplyEncoded<any>>
+}, {
+  readonly envelope: Envelope.Envelope.Encoded
+  readonly lastSentReply: Schema.OptionEncoded<Reply.ReplyEncoded<any>>
+}> = Schema.Struct({
+  envelope: Envelope.PartialEncoded,
+  lastSentReply: Schema.OptionFromSelf(Reply.Encoded)
+}) as any
+
+const decodeEnvelopeWithReply = Schema.decode(EnvelopeWithReply)
diff --git a/src/Reply.ts b/src/Reply.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6cc04d838b6d8b7fbbaf7564b23739a7771a82e9
--- /dev/null
+++ b/src/Reply.ts
@@ -0,0 +1,295 @@
+/**
+ * @since 1.0.0
+ */
+import * as Rpc from "@effect/rpc/Rpc"
+import type * as RpcSchema from "@effect/rpc/RpcSchema"
+import type { NonEmptyReadonlyArray } from "effect/Array"
+import * as Context from "effect/Context"
+import * as Data from "effect/Data"
+import * as Effect from "effect/Effect"
+import * as Exit from "effect/Exit"
+import * as FiberRef from "effect/FiberRef"
+import { identity } from "effect/Function"
+import type * as Option from "effect/Option"
+import { hasProperty } from "effect/Predicate"
+import * as Schema from "effect/Schema"
+import { MalformedMessage } from "./ClusterError.js"
+import type { OutgoingRequest } from "./Message.js"
+import { Snowflake, SnowflakeFromString } from "./Snowflake.js"
+
+/**
+ * @since 1.0.0
+ * @category type ids
+ */
+export const TypeId: unique symbol = Symbol.for("@effect/cluster/Reply")
+
+/**
+ * @since 1.0.0
+ * @category type ids
+ */
+export type TypeId = typeof TypeId
+
+/**
+ * @since 1.0.0
+ * @category guards
+ */
+export const isReply = (u: unknown): u is Reply<Rpc.Any> => hasProperty(u, TypeId)
+
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export type Reply<R extends Rpc.Any> = WithExit<R> | Chunk<R>
+
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export class ReplyWithContext<R extends Rpc.Any> extends Data.TaggedClass("ReplyWithContext")<{
+  readonly reply: Reply<R>
+  readonly context: Context.Context<Rpc.Context<R>>
+  readonly rpc: R
+}> {
+  /**
+   * @since 1.0.0
+   */
+  static fromDefect(options: {
+    readonly id: Snowflake
+    readonly requestId: Snowflake
+    readonly defect: unknown
+  }): ReplyWithContext<any> {
+    return new ReplyWithContext({
+      reply: new WithExit({
+        requestId: options.requestId,
+        id: options.id,
+        exit: Exit.die(Schema.encodeSync(Schema.Defect)(options.defect))
+      }),
+      context: Context.empty() as any,
+      rpc: neverRpc
+    })
+  }
+}
+
+const neverRpc = Rpc.make("Never", {
+  success: Schema.Never as any,
+  error: Schema.Never,
+  payload: {}
+})
+
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export type ReplyEncoded<R extends Rpc.Any> = WithExitEncoded<R> | ChunkEncoded<R>
+
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export interface WithExitEncoded<R extends Rpc.Any> {
+  readonly _tag: "WithExit"
+  readonly requestId: string
+  readonly id: string
+  readonly exit: Rpc.ExitEncoded<R>
+}
+
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export interface ChunkEncoded<R extends Rpc.Any> {
+  readonly _tag: "Chunk"
+  readonly requestId: string
+  readonly id: string
+  readonly sequence: number
+  readonly values: NonEmptyReadonlyArray<Rpc.SuccessChunkEncoded<R>>
+}
+
+const schemaCache = new WeakMap<Rpc.Any, Schema.Schema<Reply<Rpc.Any>, ReplyEncoded<Rpc.Any>, Rpc.Context<Rpc.Any>>>()
+
+/**
+ * @since 1.0.0
+ * @category schemas
+ */
+export const Reply = <R extends Rpc.Any>(rpc: R): Schema.Schema<
+  Reply<R>,
+  ReplyEncoded<R>,
+  Rpc.Context<R>
+> => {
+  if (schemaCache.has(rpc)) {
+    return schemaCache.get(rpc) as any
+  }
+  const schema = Schema.Union(WithExit.schema(rpc), Chunk.schema(rpc))
+  schemaCache.set(rpc, schema)
+  return schema
+}
+
+/**
+ * @since 1.0.0
+ * @category schemas
+ */
+export const Encoded = Schema.Union(
+  Schema.Struct({
+    _tag: Schema.Literal("WithExit"),
+    requestId: Schema.String,
+    id: Schema.String,
+    exit: Schema.Unknown
+  }),
+  Schema.Struct({
+    _tag: Schema.Literal("Chunk"),
+    requestId: Schema.String,
+    id: Schema.String,
+    sequence: Schema.Number,
+    values: Schema.Array(Schema.Unknown)
+  })
+)
+
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export class Chunk<R extends Rpc.Any> extends Data.TaggedClass("Chunk")<{
+  readonly requestId: Snowflake
+  readonly id: Snowflake
+  readonly sequence: number
+  readonly values: NonEmptyReadonlyArray<Rpc.SuccessChunk<R>>
+}> {
+  /**
+   * @since 1.0.0
+   */
+  readonly [TypeId] = TypeId
+
+  /**
+   * @since 1.0.0
+   */
+  static emptyFrom(requestId: Snowflake) {
+    return new Chunk({
+      requestId,
+      id: Snowflake(BigInt(0)),
+      sequence: 0,
+      values: [undefined]
+    })
+  }
+
+  /**
+   * @since 1.0.0
+   */
+  static readonly schemaFromSelf: Schema.Schema<Chunk<never>> = Schema.declare((u): u is Chunk<never> =>
+    isReply(u) && u._tag === "Chunk"
+  )
+
+  /**
+   * @since 1.0.0
+   */
+  static schema<R extends Rpc.Any>(rpc: R): Schema.Schema<
+    Chunk<R>,
+    ChunkEncoded<R>,
+    Rpc.Context<R>
+  > {
+    const successSchema = ((rpc as any as Rpc.AnyWithProps).successSchema as RpcSchema.Stream<any, any>).success
+    if (!successSchema) {
+      return Schema.Never as any
+    }
+    return Schema.transform(
+      Schema.Struct({
+        _tag: Schema.Literal("Chunk"),
+        requestId: SnowflakeFromString,
+        id: SnowflakeFromString,
+        sequence: Schema.Number,
+        values: Schema.NonEmptyArray(successSchema)
+      }),
+      Chunk.schemaFromSelf,
+      {
+        decode: (encoded) => new Chunk(encoded as any),
+        encode: identity
+      }
+    ) as any
+  }
+
+  /**
+   * @since 1.0.0
+   */
+  withRequestId(requestId: Snowflake): Chunk<R> {
+    return new Chunk({
+      ...this,
+      requestId
+    })
+  }
+}
+
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export class WithExit<R extends Rpc.Any> extends Data.TaggedClass("WithExit")<{
+  readonly requestId: Snowflake
+  readonly id: Snowflake
+  readonly exit: Rpc.Exit<R>
+}> {
+  /**
+   * @since 1.0.0
+   */
+  readonly [TypeId] = TypeId
+
+  /**
+   * @since 1.0.0
+   */
+  static schema<R extends Rpc.Any>(rpc: R): Schema.Schema<
+    WithExit<R>,
+    WithExitEncoded<R>,
+    Rpc.Context<R>
+  > {
+    return Schema.transform(
+      Schema.Struct({
+        _tag: Schema.Literal("WithExit"),
+        requestId: SnowflakeFromString,
+        id: SnowflakeFromString,
+        exit: Rpc.exitSchema(rpc)
+      }),
+      Schema.declare((u): u is WithExit<R> => isReply(u) && u._tag === "WithExit"),
+      {
+        decode: (encoded) => new WithExit(encoded),
+        encode: identity
+      }
+    ) as any
+  }
+
+  /**
+   * @since 1.0.0
+   */
+  withRequestId(requestId: Snowflake): WithExit<R> {
+    return new WithExit({
+      ...this,
+      requestId
+    })
+  }
+}
+
+/**
+ * @since 1.0.0
+ * @category serialization / deserialization
+ */
+export const serialize = <R extends Rpc.Any>(
+  self: ReplyWithContext<R>
+): Effect.Effect<ReplyEncoded<R>, MalformedMessage> => {
+  const schema = Reply(self.rpc)
+  return MalformedMessage.refail(
+    Effect.locally(Schema.encode(schema)(self.reply), FiberRef.currentContext, self.context)
+  )
+}
+
+/**
+ * @since 1.0.0
+ * @category serialization / deserialization
+ */
+export const serializeLastReceived = <R extends Rpc.Any>(
+  self: OutgoingRequest<R>
+): Effect.Effect<Option.Option<ReplyEncoded<R>>, MalformedMessage> => {
+  if (self.lastReceivedReply._tag === "None") {
+    return Effect.succeedNone
+  }
+  const schema = Reply(self.rpc)
+  return Effect.asSome(MalformedMessage.refail(
+    Effect.locally(Schema.encode(schema)(self.lastReceivedReply.value), FiberRef.currentContext, self.context)
+  ))
+}
diff --git a/src/Runner.ts b/src/Runner.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cef8e283475b648ac0b4a6016a69c001f966f509
--- /dev/null
+++ b/src/Runner.ts
@@ -0,0 +1,84 @@
+/**
+ * @since 1.0.0
+ */
+import { NodeInspectSymbol } from "effect/Inspectable"
+import * as Pretty from "effect/Pretty"
+import * as Schema from "effect/Schema"
+import { RunnerAddress } from "./RunnerAddress.js"
+
+const SymbolKey = "@effect/cluster/Runner"
+
+/**
+ * @since 1.0.0
+ * @category type ids
+ */
+export const TypeId: unique symbol = Symbol.for(SymbolKey)
+
+/**
+ * @since 1.0.0
+ * @category type ids
+ */
+export type TypeId = typeof TypeId
+
+/**
+ * A `Runner` represents a physical application server that is capable of running
+ * entities.
+ *
+ * Because a Runner represents a physical application server, a Runner must have a
+ * unique `address` which can be used to communicate with the server.
+ *
+ * The version of a Runner is used during rebalancing to give priority to newer
+ * application servers and slowly decommission older ones.
+ *
+ * @since 1.0.0
+ * @category models
+ */
+export class Runner extends Schema.Class<Runner>(SymbolKey)({
+  address: RunnerAddress,
+  version: Schema.Int
+}) {
+  /**
+   * @since 1.0.0
+   */
+  static pretty = Pretty.make(this)
+
+  /**
+   * @since 1.0.0
+   */
+  readonly [TypeId] = TypeId
+
+  /**
+   * @since 1.0.0
+   */
+  static readonly decodeSync = Schema.decodeSync(Schema.parseJson(Runner))
+
+  /**
+   * @since 1.0.0
+   */
+  static readonly encodeSync = Schema.encodeSync(Schema.parseJson(Runner));
+
+  /**
+   * @since 1.0.0
+   */
+  [NodeInspectSymbol](): string {
+    return this.toString()
+  }
+}
+
+/**
+ * A `Runner` represents a physical application server that is capable of running
+ * entities.
+ *
+ * Because a Runner represents a physical application server, a Runner must have a
+ * unique `address` which can be used to communicate with the server.
+ *
+ * The version of a Runner is used during rebalancing to give priority to newer
+ * application servers and slowly decommission older ones.
+ *
+ * @since 1.0.0
+ * @category Constructors
+ */
+export const make = (props: {
+  readonly address: RunnerAddress
+  readonly version: number
+}): Runner => new Runner(props)
diff --git a/src/RunnerAddress.ts b/src/RunnerAddress.ts
new file mode 100644
index 0000000000000000000000000000000000000000..bec013a671e889a704e6fda143e484cf04f75072
--- /dev/null
+++ b/src/RunnerAddress.ts
@@ -0,0 +1,61 @@
+/**
+ * @since 1.0.0
+ */
+import * as Hash from "effect/Hash"
+import { NodeInspectSymbol } from "effect/Inspectable"
+import * as Schema from "effect/Schema"
+
+const SymbolKey = "@effect/cluster/RunnerAddress"
+
+/**
+ * @since 1.0.0
+ * @category type ids
+ */
+export const TypeId: unique symbol = Symbol.for(SymbolKey)
+
+/**
+ * @since 1.0.0
+ * @category type ids
+ */
+export type TypeId = typeof TypeId
+
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export class RunnerAddress extends Schema.Class<RunnerAddress>(SymbolKey)({
+  host: Schema.NonEmptyString,
+  port: Schema.Int
+}) {
+  /**
+   * @since 1.0.0
+   */
+  readonly [TypeId] = TypeId;
+
+  /**
+   * @since 1.0.0
+   */
+  [Hash.symbol]() {
+    return Hash.cached(this)(Hash.string(this.toString()))
+  }
+
+  /**
+   * @since 1.0.0
+   */
+  toString(): string {
+    return `RunnerAddress(${this.host}:${this.port})`
+  }
+
+  /**
+   * @since 1.0.0
+   */
+  [NodeInspectSymbol](): string {
+    return this.toString()
+  }
+}
+
+/**
+ * @since 1.0.0
+ * @category constructors
+ */
+export const make = (host: string, port: number): RunnerAddress => new RunnerAddress({ host, port })
diff --git a/src/RunnerHealth.ts b/src/RunnerHealth.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0a8e508accf7ca392e6ebcade74c81af2377933e
--- /dev/null
+++ b/src/RunnerHealth.ts
@@ -0,0 +1,87 @@
+/**
+ * @since 1.0.0
+ */
+import * as Context from "effect/Context"
+import * as Effect from "effect/Effect"
+import * as Layer from "effect/Layer"
+import * as MessageStorage from "./MessageStorage.js"
+import type { RunnerAddress } from "./RunnerAddress.js"
+import * as Runners from "./Runners.js"
+import type { ShardingConfig } from "./ShardingConfig.js"
+
+/**
+ * Represents the service used to check if a Runner is healthy.
+ *
+ * If a Runner is responsive, shards will not be re-assigned because the Runner may
+ * still be processing messages. If a Runner is not responsive, then its
+ * associated shards can and will be re-assigned to a different Runner.
+ *
+ * @since 1.0.0
+ * @category models
+ */
+export class RunnerHealth extends Context.Tag("@effect/cluster/RunnerHealth")<
+  RunnerHealth,
+  {
+    readonly isAlive: (address: RunnerAddress) => Effect.Effect<boolean>
+  }
+>() {}
+
+/**
+ * A layer which will **always** consider a Runner healthy.
+ *
+ * This is useful for testing.
+ *
+ * @since 1.0.0
+ * @category layers
+ */
+export const layerNoop = Layer.succeed(
+  RunnerHealth,
+  RunnerHealth.of({
+    isAlive: () => Effect.succeed(true)
+  })
+)
+
+/**
+ * @since 1.0.0
+ * @category Constructors
+ */
+export const make: Effect.Effect<
+  RunnerHealth["Type"],
+  never,
+  Runners.Runners
+> = Effect.gen(function*() {
+  const runners = yield* Runners.Runners
+
+  function isAlive(address: RunnerAddress): Effect.Effect<boolean> {
+    return Effect.isSuccess(Effect.timeout(runners.ping(address), 3000))
+  }
+
+  return RunnerHealth.of({ isAlive })
+})
+
+/**
+ * A layer which will ping a Runner directly to check if it is healthy.
+ *
+ * @since 1.0.0
+ * @category layers
+ */
+export const layer: Layer.Layer<
+  RunnerHealth,
+  never,
+  Runners.Runners
+> = Layer.effect(RunnerHealth, make)
+
+/**
+ * A layer which will ping a Runner directly to check if it is healthy.
+ *
+ * @since 1.0.0
+ * @category layers
+ */
+export const layerRpc: Layer.Layer<
+  RunnerHealth,
+  never,
+  Runners.RpcClientProtocol | ShardingConfig
+> = layer.pipe(
+  Layer.provide(Runners.layerRpc),
+  Layer.provide(MessageStorage.layerNoop)
+)
diff --git a/src/RunnerServer.ts b/src/RunnerServer.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e49cfde026c437c13262a2e2005fb4b940c04922
--- /dev/null
+++ b/src/RunnerServer.ts
@@ -0,0 +1,156 @@
+/**
+ * @since 1.0.0
+ */
+import * as RpcServer from "@effect/rpc/RpcServer"
+import * as Effect from "effect/Effect"
+import { constant } from "effect/Function"
+import * as Layer from "effect/Layer"
+import * as Mailbox from "effect/Mailbox"
+import * as Option from "effect/Option"
+import * as Message from "./Message.js"
+import type * as MessageStorage from "./MessageStorage.js"
+import * as Reply from "./Reply.js"
+import * as Runners from "./Runners.js"
+import * as Sharding from "./Sharding.js"
+import { ShardingConfig } from "./ShardingConfig.js"
+import * as ShardManager from "./ShardManager.js"
+import * as ShardStorage from "./ShardStorage.js"
+import * as SynchronizedClock from "./SynchronizedClock.js"
+
+const constVoid = constant(Effect.void)
+
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layerHandlers = Runners.Rpcs.toLayer(Effect.gen(function*() {
+  const sharding = yield* Sharding.Sharding
+
+  return {
+    Ping: () => Effect.void,
+    Notify: ({ envelope }) =>
+      sharding.notify(
+        envelope._tag === "Request"
+          ? new Message.IncomingRequest({
+            envelope,
+            respond: constVoid,
+            lastSentReply: Option.none()
+          })
+          : new Message.IncomingEnvelope({ envelope })
+      ),
+    Effect: ({ request }) => {
+      let resume: (reply: Effect.Effect<Reply.ReplyEncoded<any>>) => void
+      let replyEncoded: Reply.ReplyEncoded<any> | undefined
+      const message = new Message.IncomingRequest({
+        envelope: request,
+        lastSentReply: Option.none(),
+        respond(reply) {
+          return Effect.flatMap(Reply.serialize(reply), (reply) => {
+            if (resume) {
+              resume(Effect.succeed(reply))
+            } else {
+              replyEncoded = reply
+            }
+            return Effect.void
+          })
+        }
+      })
+      return Effect.zipRight(
+        sharding.send(message),
+        Effect.async<Reply.ReplyEncoded<any>>((resume_) => {
+          if (replyEncoded) {
+            resume_(Effect.succeed(replyEncoded))
+          } else {
+            resume = resume_
+          }
+        })
+      )
+    },
+    Stream: ({ request }) =>
+      Effect.flatMap(
+        Mailbox.make<Reply.ReplyEncoded<any>>(),
+        (mailbox) =>
+          Effect.as(
+            sharding.send(
+              new Message.IncomingRequest({
+                envelope: request,
+                lastSentReply: Option.none(),
+                respond(reply) {
+                  return Effect.flatMap(Reply.serialize(reply), (reply) => {
+                    mailbox.unsafeOffer(reply)
+                    return Effect.void
+                  })
+                }
+              })
+            ),
+            mailbox
+          )
+      ),
+    Envelope: ({ envelope }) => sharding.send(new Message.IncomingEnvelope({ envelope }))
+  }
+}))
+
+/**
+ * The `RunnerServer` recieves messages from other Runners and forwards them to the
+ * `Sharding` layer.
+ *
+ * It also responds to `Ping` requests.
+ *
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layer: Layer.Layer<
+  never,
+  never,
+  RpcServer.Protocol | Sharding.Sharding | MessageStorage.MessageStorage
+> = RpcServer.layer(Runners.Rpcs, {
+  spanPrefix: "RunnerServer",
+  disableTracing: true
+}).pipe(Layer.provide(layerHandlers))
+
+/**
+ * A `RunnerServer` layer that includes the `Runners` & `Sharding` clients.
+ *
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layerWithClients: Layer.Layer<
+  Sharding.Sharding | Runners.Runners,
+  never,
+  | RpcServer.Protocol
+  | ShardingConfig
+  | Runners.RpcClientProtocol
+  | MessageStorage.MessageStorage
+  | ShardStorage.ShardStorage
+> = layer.pipe(
+  Layer.provideMerge(Sharding.layer),
+  Layer.provideMerge(Runners.layerRpc),
+  Layer.provideMerge(SynchronizedClock.layer),
+  Layer.provide(ShardManager.layerClientRpc)
+)
+
+/**
+ * A `Runners` layer that is client only.
+ *
+ * It will not register with the ShardManager and recieve shard assignments,
+ * so this layer can be used to embed a cluster client inside another effect
+ * application.
+ *
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layerClientOnly: Layer.Layer<
+  Sharding.Sharding | Runners.Runners,
+  never,
+  | ShardingConfig
+  | Runners.RpcClientProtocol
+  | MessageStorage.MessageStorage
+> = Sharding.layer.pipe(
+  Layer.provideMerge(Runners.layerRpc),
+  Layer.provide(ShardManager.layerClientRpc),
+  Layer.provide(ShardStorage.layerNoop),
+  Layer.updateService(ShardingConfig, (config) => ({
+    ...config,
+    runnerAddress: Option.none()
+  }))
+)
diff --git a/src/Runners.ts b/src/Runners.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ec496f0bd017c40fcee9d25b428555d0a3946908
--- /dev/null
+++ b/src/Runners.ts
@@ -0,0 +1,529 @@
+/**
+ * @since 1.0.0
+ */
+import * as Rpc from "@effect/rpc/Rpc"
+import * as RpcClient_ from "@effect/rpc/RpcClient"
+import * as RpcGroup from "@effect/rpc/RpcGroup"
+import * as RpcSchema from "@effect/rpc/RpcSchema"
+import * as Cause from "effect/Cause"
+import * as Context from "effect/Context"
+import * as Effect from "effect/Effect"
+import * as Exit from "effect/Exit"
+import * as FiberRef from "effect/FiberRef"
+import * as Layer from "effect/Layer"
+import * as RcMap from "effect/RcMap"
+import * as Schema from "effect/Schema"
+import type { Scope } from "effect/Scope"
+import {
+  AlreadyProcessingMessage,
+  EntityNotManagedByRunner,
+  MailboxFull,
+  PersistenceError,
+  RunnerUnavailable
+} from "./ClusterError.js"
+import { Persisted } from "./ClusterSchema.js"
+import * as Envelope from "./Envelope.js"
+import * as Message from "./Message.js"
+import * as MessageStorage from "./MessageStorage.js"
+import * as Reply from "./Reply.js"
+import type { RunnerAddress } from "./RunnerAddress.js"
+import { ShardingConfig } from "./ShardingConfig.js"
+import * as Snowflake from "./Snowflake.js"
+
+/**
+ * @since 1.0.0
+ * @category context
+ */
+export class Runners extends Context.Tag("@effect/cluster/Runners")<Runners, {
+  /**
+   * Checks if a Runner is responsive.
+   */
+  readonly ping: (address: RunnerAddress) => Effect.Effect<void, RunnerUnavailable>
+
+  /**
+   * Send a message locally.
+   *
+   * This ensures that the message hits storage before being sent to the local
+   * entity.
+   */
+  readonly sendLocal: <R extends Rpc.Any>(
+    options: {
+      readonly message: Message.Outgoing<R>
+      readonly send: <Rpc extends Rpc.Any>(
+        message: Message.IncomingLocal<Rpc>
+      ) => Effect.Effect<void, EntityNotManagedByRunner | MailboxFull | AlreadyProcessingMessage>
+      readonly simulateRemoteSerialization: boolean
+    }
+  ) => Effect.Effect<void, EntityNotManagedByRunner | MailboxFull | AlreadyProcessingMessage>
+
+  /**
+   * Send a message to a Runner.
+   */
+  readonly send: <R extends Rpc.Any>(
+    options: {
+      readonly address: RunnerAddress
+      readonly message: Message.Outgoing<R>
+    }
+  ) => Effect.Effect<
+    void,
+    EntityNotManagedByRunner | RunnerUnavailable | MailboxFull | AlreadyProcessingMessage | PersistenceError
+  >
+
+  /**
+   * Notify a Runner that a message is available, then read replies from storage.
+   */
+  readonly notify: <R extends Rpc.Any>(
+    options: {
+      readonly address: RunnerAddress
+      readonly message: Message.Outgoing<R>
+      readonly discard: boolean
+    }
+  ) => Effect.Effect<void>
+
+  /**
+   * Notify the current Runner that a message is available, then read replies from
+   * storage.
+   *
+   * This ensures that the message hits storage before being sent to the local
+   * entity.
+   */
+  readonly notifyLocal: <R extends Rpc.Any>(
+    options: {
+      readonly message: Message.Outgoing<R>
+      readonly notify: (options: Message.IncomingLocal<any>) => Effect.Effect<void, EntityNotManagedByRunner>
+      readonly discard: boolean
+    }
+  ) => Effect.Effect<void>
+}>() {}
+
+/**
+ * @since 1.0.0
+ * @category Constructors
+ */
+export const make: (options: Omit<Runners["Type"], "sendLocal" | "notifyLocal">) => Effect.Effect<
+  Runners["Type"],
+  never,
+  MessageStorage.MessageStorage | Snowflake.Generator | ShardingConfig | Scope
+> = Effect.fnUntraced(function*(options: Omit<Runners["Type"], "sendLocal" | "notifyLocal">) {
+  const storage = yield* MessageStorage.MessageStorage
+  const snowflakeGen = yield* Snowflake.Generator
+  const config = yield* ShardingConfig
+
+  const requestIdRewrites = new Map<Snowflake.Snowflake, Snowflake.Snowflake>()
+
+  function notifyWith<E>(
+    message: Message.Outgoing<any>,
+    afterPersist: (message: Message.Outgoing<any>, isDuplicate: boolean) => Effect.Effect<void, E>
+  ): Effect.Effect<void, E> {
+    const rpc = message.rpc as any as Rpc.AnyWithProps
+    const persisted = Context.get(rpc.annotations, Persisted)
+    if (!persisted) {
+      return Effect.dieMessage("Runners.notify only supports persisted messages")
+    }
+
+    if (message._tag === "OutgoingEnvelope") {
+      const rewriteId = requestIdRewrites.get(message.envelope.requestId)
+      const requestId = rewriteId ?? message.envelope.requestId
+      const entry = storageRequests.get(requestId)
+      if (rewriteId) {
+        message = new Message.OutgoingEnvelope({
+          ...message,
+          envelope: message.envelope.withRequestId(rewriteId)
+        })
+      }
+      return storage.saveEnvelope(message).pipe(
+        Effect.orDie,
+        Effect.zipRight(
+          entry ? Effect.zipRight(entry.latch.open, afterPersist(message, false)) : afterPersist(message, false)
+        )
+      )
+    }
+
+    // For requests, after persisting the request, we need to check if the
+    // request is a duplicate. If it is, we need to resume from the last
+    // received reply.
+    //
+    // Otherwise, we notify the remote entity and then reply from storage.
+    return Effect.flatMap(
+      Effect.orDie(storage.saveRequest(message)),
+      MessageStorage.SaveResult.$match({
+        Success: () => afterPersist(message, false),
+        Duplicate: ({ lastReceivedReply, originalId }) => {
+          requestIdRewrites.set(message.envelope.requestId, originalId)
+          return afterPersist(
+            new Message.OutgoingRequest({
+              ...message,
+              lastReceivedReply,
+              envelope: Envelope.makeRequest({
+                ...message.envelope,
+                requestId: originalId
+              }),
+              respond(reply) {
+                if (reply._tag === "WithExit") {
+                  requestIdRewrites.delete(message.envelope.requestId)
+                }
+                return message.respond(reply.withRequestId(message.envelope.requestId))
+              }
+            }),
+            true
+          )
+        }
+      })
+    )
+  }
+
+  type StorageRequestEntry = {
+    readonly latch: Effect.Latch
+    replies: Array<Reply.Reply<any>>
+  }
+  const storageRequests = new Map<Snowflake.Snowflake, StorageRequestEntry>()
+  const waitingStorageRequests = new Map<Snowflake.Snowflake, Message.OutgoingRequest<any>>()
+  const replyFromStorage = Effect.fnUntraced(
+    function*(message: Message.OutgoingRequest<any>) {
+      const entry: StorageRequestEntry = {
+        latch: Effect.unsafeMakeLatch(false),
+        replies: []
+      }
+      storageRequests.set(message.envelope.requestId, entry)
+
+      while (true) {
+        // wait for the storage loop to notify us
+        entry.latch.unsafeClose()
+        waitingStorageRequests.set(message.envelope.requestId, message)
+        yield* storageLatch.open
+        yield* entry.latch.await
+
+        // send the replies back
+        for (const reply of entry.replies) {
+          // we have reached the end
+          if (reply._tag === "WithExit") {
+            return yield* message.respond(reply)
+          }
+
+          entry.latch.unsafeClose()
+          yield* message.respond(reply)
+          yield* entry.latch.await
+        }
+        entry.replies = []
+      }
+    },
+    (effect, message) =>
+      Effect.ensuring(
+        effect,
+        Effect.sync(() => {
+          storageRequests.delete(message.envelope.requestId)
+          waitingStorageRequests.delete(message.envelope.requestId)
+        })
+      )
+  )
+
+  const storageLatch = Effect.unsafeMakeLatch(false)
+  if (storage !== MessageStorage.noop) {
+    yield* Effect.gen(function*() {
+      while (true) {
+        yield* storageLatch.await
+        storageLatch.unsafeClose()
+
+        const replies = yield* storage.repliesFor(waitingStorageRequests.values()).pipe(
+          Effect.catchAllCause((cause) =>
+            Effect.as(
+              Effect.annotateLogs(Effect.logDebug(cause), {
+                package: "@effect/cluster",
+                module: "Runners",
+                fiber: "Read replies loop"
+              }),
+              []
+            )
+          )
+        )
+
+        const foundRequests = new Set<StorageRequestEntry>()
+
+        // put the replies into the storage requests and then open the latches
+        for (const reply of replies) {
+          const entry = storageRequests.get(reply.requestId)
+          if (!entry) continue
+          entry.replies.push(reply)
+          waitingStorageRequests.delete(reply.requestId)
+          foundRequests.add(entry)
+        }
+
+        for (const entry of foundRequests) {
+          entry.latch.unsafeOpen()
+        }
+      }
+    }).pipe(
+      Effect.interruptible,
+      Effect.forkScoped
+    )
+
+    yield* Effect.suspend(() => {
+      if (waitingStorageRequests.size === 0) {
+        return storageLatch.await
+      }
+      return storageLatch.open
+    }).pipe(
+      Effect.delay(config.entityReplyPollInterval),
+      Effect.forever,
+      Effect.interruptible,
+      Effect.forkScoped
+    )
+  }
+
+  return Runners.of({
+    ...options,
+    sendLocal(options) {
+      const message = options.message
+      if (!options.simulateRemoteSerialization) {
+        return options.send(Message.incomingLocalFromOutgoing(message))
+      }
+      return Message.serialize(message).pipe(
+        Effect.flatMap((encoded) => Message.deserializeLocal(message, encoded)),
+        Effect.flatMap(options.send),
+        Effect.catchTag("MalformedMessage", (error) => {
+          if (message._tag === "OutgoingEnvelope") {
+            return Effect.die(error)
+          }
+          return Effect.orDie(message.respond(
+            new Reply.WithExit({
+              id: snowflakeGen.unsafeNext(),
+              requestId: message.envelope.requestId,
+              exit: Exit.die(error)
+            })
+          ))
+        })
+      )
+    },
+    notify(options_) {
+      const { discard, message } = options_
+      return notifyWith(message, (message) => {
+        if (message._tag === "OutgoingEnvelope") {
+          return options.notify(options_)
+        }
+        return discard ? options.notify(options_) : options.notify(options_).pipe(
+          Effect.fork,
+          Effect.andThen(Effect.orDie(replyFromStorage(message)))
+        )
+      })
+    },
+    notifyLocal(options) {
+      return notifyWith(options.message, (message, duplicate) => {
+        if (options.discard || message._tag === "OutgoingEnvelope") {
+          return Effect.orDie(options.notify(Message.incomingLocalFromOutgoing(message)))
+        } else if (!duplicate) {
+          return storage.registerReplyHandler(message).pipe(
+            Effect.andThen(Effect.orDie(options.notify(Message.incomingLocalFromOutgoing(message))))
+          )
+        }
+        return Effect.orDie(options.notify(Message.incomingLocalFromOutgoing(message))).pipe(
+          Effect.fork,
+          Effect.andThen(Effect.orDie(replyFromStorage(message)))
+        )
+      })
+    }
+  })
+})
+
+/**
+ * @since 1.0.0
+ * @category No-op
+ */
+export const makeNoop: Effect.Effect<
+  Runners["Type"],
+  never,
+  MessageStorage.MessageStorage | Snowflake.Generator | ShardingConfig | Scope
+> = make({
+  send: ({ message }) => Effect.fail(new EntityNotManagedByRunner({ address: message.envelope.address })),
+  notify: () => Effect.void,
+  ping: () => Effect.void
+})
+
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layerNoop: Layer.Layer<
+  Runners,
+  never,
+  ShardingConfig | MessageStorage.MessageStorage
+> = Layer.scoped(Runners, makeNoop).pipe(Layer.provide([Snowflake.layerGenerator]))
+
+const rpcErrors: Schema.Union<[
+  typeof EntityNotManagedByRunner,
+  typeof MailboxFull,
+  typeof AlreadyProcessingMessage,
+  typeof PersistenceError
+]> = Schema.Union(EntityNotManagedByRunner, MailboxFull, AlreadyProcessingMessage, PersistenceError)
+
+/**
+ * @since 1.0.0
+ * @category Rpcs
+ */
+export class Rpcs extends RpcGroup.make(
+  Rpc.make("Ping"),
+  Rpc.make("Notify", {
+    payload: {
+      envelope: Envelope.PartialEncoded
+    },
+    success: Schema.Void,
+    error: EntityNotManagedByRunner
+  }),
+  Rpc.make("Effect", {
+    payload: {
+      request: Envelope.PartialEncodedRequest
+    },
+    success: Schema.Object as Schema.Schema<Reply.ReplyEncoded<any>>,
+    error: rpcErrors
+  }),
+  Rpc.make("Stream", {
+    payload: {
+      request: Envelope.PartialEncodedRequest
+    },
+    error: rpcErrors,
+    success: Schema.Object as Schema.Schema<Reply.ReplyEncoded<any>>,
+    stream: true
+  }),
+  Rpc.make("Envelope", {
+    payload: { envelope: Schema.Union(Envelope.AckChunk, Envelope.Interrupt) },
+    error: rpcErrors
+  })
+) {}
+
+/**
+ * @since 1.0.0
+ * @category Rpcs
+ */
+export interface RpcClient extends RpcClient_.FromGroup<typeof Rpcs> {}
+
+/**
+ * @since 1.0.0
+ * @category Rpcs
+ */
+export const makeRpcClient: Effect.Effect<
+  RpcClient,
+  never,
+  RpcClient_.Protocol | Scope
+> = RpcClient_.make(Rpcs, { spanPrefix: "Runners", disableTracing: true })
+
+/**
+ * @since 1.0.0
+ * @category constructors
+ */
+export const makeRpc: Effect.Effect<
+  Runners["Type"],
+  never,
+  Scope | RpcClientProtocol | MessageStorage.MessageStorage | Snowflake.Generator | ShardingConfig
+> = Effect.gen(function*() {
+  const makeClientProtocol = yield* RpcClientProtocol
+  const snowflakeGen = yield* Snowflake.Generator
+
+  const clients = yield* RcMap.make({
+    lookup: (address: RunnerAddress) =>
+      Effect.flatMap(
+        makeClientProtocol(address),
+        (protocol) => Effect.provideService(makeRpcClient, RpcClient_.Protocol, protocol)
+      ),
+    idleTimeToLive: "1 minute"
+  })
+
+  return yield* make({
+    ping(address) {
+      return RcMap.get(clients, address).pipe(
+        Effect.flatMap((client) => client.Ping()),
+        Effect.catchAllCause(() => Effect.fail(new RunnerUnavailable({ address }))),
+        Effect.scoped
+      )
+    },
+    send({ address, message }) {
+      if (message._tag === "OutgoingEnvelope") {
+        return RcMap.get(clients, address).pipe(
+          Effect.flatMap((client) => client.Envelope({ envelope: message.envelope })),
+          Effect.scoped,
+          Effect.catchAllDefect(() => Effect.fail(new RunnerUnavailable({ address })))
+        )
+      }
+      const rpc = message.rpc as any as Rpc.AnyWithProps
+      const isStream = RpcSchema.isStreamSchema(rpc.successSchema)
+      if (!isStream) {
+        return Effect.matchEffect(Message.serializeRequest(message), {
+          onSuccess: (request) =>
+            RcMap.get(clients, address).pipe(
+              Effect.flatMap((client) => client.Effect({ request })),
+              Effect.flatMap((reply) =>
+                Schema.decode(Reply.Reply(message.rpc))(reply).pipe(
+                  Effect.locally(FiberRef.currentContext, message.context),
+                  Effect.orDie
+                )
+              ),
+              Effect.flatMap(message.respond),
+              Effect.scoped,
+              Effect.catchAllDefect(() => Effect.fail(new RunnerUnavailable({ address })))
+            ),
+          onFailure: (error) =>
+            message.respond(
+              new Reply.WithExit({
+                id: snowflakeGen.unsafeNext(),
+                requestId: message.envelope.requestId,
+                exit: Exit.die(error)
+              })
+            )
+        })
+      }
+      return Effect.matchEffect(Message.serializeRequest(message), {
+        onSuccess: (request) =>
+          RcMap.get(clients, address).pipe(
+            Effect.flatMap((client) => client.Stream({ request }, { asMailbox: true })),
+            Effect.flatMap((mailbox) => {
+              const decode = Schema.decode(Reply.Reply(message.rpc))
+              return mailbox.take.pipe(
+                Effect.flatMap((reply) => Effect.orDie(decode(reply))),
+                Effect.flatMap(message.respond),
+                Effect.forever,
+                Effect.locally(FiberRef.currentContext, message.context),
+                Effect.catchIf(Cause.isNoSuchElementException, () => Effect.void),
+                Effect.catchAllDefect(() => Effect.fail(new RunnerUnavailable({ address })))
+              )
+            }),
+            Effect.scoped
+          ),
+        onFailure: (error) =>
+          message.respond(
+            new Reply.WithExit({
+              id: snowflakeGen.unsafeNext(),
+              requestId: message.envelope.requestId,
+              exit: Exit.die(error)
+            })
+          )
+      })
+    },
+    notify({ address, message }) {
+      const envelope = message.envelope
+      return RcMap.get(clients, address).pipe(
+        Effect.flatMap((client) => client.Notify({ envelope })),
+        Effect.scoped,
+        Effect.ignore
+      )
+    }
+  })
+})
+
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layerRpc: Layer.Layer<
+  Runners,
+  never,
+  MessageStorage.MessageStorage | RpcClientProtocol | ShardingConfig
+> = Layer.scoped(Runners, makeRpc).pipe(
+  Layer.provide(Snowflake.layerGenerator)
+)
+
+/**
+ * @since 1.0.0
+ * @category Client
+ */
+export class RpcClientProtocol extends Context.Tag("@effect/cluster/Runners/RpcClientProtocol")<
+  RpcClientProtocol,
+  (address: RunnerAddress) => Effect.Effect<RpcClient_.Protocol["Type"], never, Scope>
+>() {}
diff --git a/src/ShardId.ts b/src/ShardId.ts
index 25902a286673f78e9121d3e35495b384ef9645cd..edfb386c843fac8f759a79f661f3374f8bd07802 100644
--- a/src/ShardId.ts
+++ b/src/ShardId.ts
@@ -2,78 +2,26 @@
  * @since 1.0.0
  */
 import * as Schema from "effect/Schema"
-import { TypeIdSchema } from "./internal/utils.js"
-
-/** @internal */
-const ShardIdSymbolKey = "@effect/cluster/ShardId"
-
-/**
- * @since 1.0.0
- * @category symbols
- */
-export const ShardIdTypeId: unique symbol = Symbol.for(ShardIdSymbolKey)
 
 /**
  * @since 1.0.0
- * @category symbols
- */
-export type ShardIdTypeId = typeof ShardIdTypeId
-
-/** @internal */
-const ShardIdTypeIdSchema = TypeIdSchema(ShardIdSymbolKey, ShardIdTypeId)
-
-/**
- * A shard is a logical grouping of multiple entities. There could be thousands of entities in your system,
- * so instead of managing every single entity id, the shard manager group them by shard id, and when they are assigned
- * or moved around, we always move all the entities with the same shard id.
- *
- * @since 1.0.0
- * @category models
+ * @category constructors
  */
-export class ShardId extends Schema.Class<ShardId>(ShardIdSymbolKey)({
-  [ShardIdTypeId]: Schema.propertySignature(ShardIdTypeIdSchema).pipe(Schema.fromKey(ShardIdSymbolKey)),
-  value: Schema.Number
-}) {
-  /**
-   * @since 1.0.0
-   */
-  toString() {
-    return `ShardId(${this.value})`
-  }
-}
+export const ShardId = Schema.Int.pipe(
+  Schema.brand("ShardId"),
+  Schema.annotations({
+    pretty: () => (shardId) => `ShardId(${shardId})`
+  })
+)
 
 /**
  * @since 1.0.0
  * @category models
  */
-export namespace ShardId {
-  /**
-   * This is the shape that a shard id has over the wire.
-   *
-   * @since 1.0.0
-   * @category models
-   */
-  export interface Encoded extends Schema.Schema.Encoded<typeof ShardId> {}
-}
-
-/**
- * Constructs a shard id from its numerical value.
- * The shard id is currently built up by making the hash of the entity id, and then modulo the max amount of shards configured in ManagerConfig.
- *
- * @since 1.0.0
- * @category constructors
- */
-export function make(value: number): ShardId {
-  return new ShardId({ [ShardIdTypeId]: ShardIdTypeId, value })
-}
+export type ShardId = typeof ShardId.Type
 
 /**
- * This is the schema for a ShardId.
- *
  * @since 1.0.0
- * @category schema
+ * @category Constructors
  */
-export const schema: Schema.Schema<
-  ShardId,
-  ShardId.Encoded
-> = Schema.asSchema(ShardId)
+export const make = (shardId: number): ShardId => ShardId.make(shardId)
diff --git a/src/ShardManager.ts b/src/ShardManager.ts
index 84b4c03b45addd39f5c7a51a8fe882ede0580661..c67224e636ceb67cc4f8cc525154710c626e8163 100644
--- a/src/ShardManager.ts
+++ b/src/ShardManager.ts
@@ -1,53 +1,804 @@
 /**
  * @since 1.0.0
  */
-import type * as Effect from "effect/Effect"
-import type * as HashMap from "effect/HashMap"
-import type * as Option from "effect/Option"
-import type * as Stream from "effect/Stream"
-import * as internal from "./internal/shardManager.js"
-import type * as Pod from "./Pod.js"
-import type * as PodAddress from "./PodAddress.js"
-import type * as ShardId from "./ShardId.js"
-import type * as ShardingEvent from "./ShardingEvent.js"
+import * as Rpc from "@effect/rpc/Rpc"
+import * as RpcClient from "@effect/rpc/RpcClient"
+import * as RpcGroup from "@effect/rpc/RpcGroup"
+import * as RpcServer from "@effect/rpc/RpcServer"
+import * as Arr from "effect/Array"
+import * as Clock from "effect/Clock"
+import * as Config_ from "effect/Config"
+import type { ConfigError } from "effect/ConfigError"
+import * as ConfigProvider from "effect/ConfigProvider"
+import * as Context from "effect/Context"
+import * as Data from "effect/Data"
+import * as Deferred from "effect/Deferred"
+import * as Duration from "effect/Duration"
+import * as Effect from "effect/Effect"
+import * as Equal from "effect/Equal"
+import * as FiberSet from "effect/FiberSet"
+import { identity } from "effect/Function"
+import * as Iterable from "effect/Iterable"
+import * as Layer from "effect/Layer"
+import * as Mailbox from "effect/Mailbox"
+import * as Metric from "effect/Metric"
+import * as MutableHashMap from "effect/MutableHashMap"
+import * as MutableHashSet from "effect/MutableHashSet"
+import * as Option from "effect/Option"
+import * as PubSub from "effect/PubSub"
+import * as Queue from "effect/Queue"
+import * as Schedule from "effect/Schedule"
+import * as Schema from "effect/Schema"
+import type { Scope } from "effect/Scope"
+import { RunnerNotRegistered } from "./ClusterError.js"
+import * as ClusterMetrics from "./ClusterMetrics.js"
+import {
+  decideAssignmentsForUnassignedShards,
+  decideAssignmentsForUnbalancedShards,
+  RunnerWithMetadata,
+  State
+} from "./internal/shardManager.js"
+import * as MachineId from "./MachineId.js"
+import { Runner } from "./Runner.js"
+import { RunnerAddress } from "./RunnerAddress.js"
+import { RunnerHealth } from "./RunnerHealth.js"
+import { RpcClientProtocol, Runners } from "./Runners.js"
+import { ShardId } from "./ShardId.js"
+import { ShardingConfig } from "./ShardingConfig.js"
+import { ShardStorage } from "./ShardStorage.js"
 
 /**
  * @since 1.0.0
- * @category symbols
+ * @category models
+ */
+export class ShardManager extends Context.Tag("@effect/cluster/ShardManager")<ShardManager, {
+  /**
+   * Get all shard assignments.
+   */
+  readonly getAssignments: Effect.Effect<
+    ReadonlyMap<ShardId, Option.Option<RunnerAddress>>
+  >
+  /**
+   * Get a stream of sharding events emit by the shard manager.
+   */
+  readonly shardingEvents: Effect.Effect<Queue.Dequeue<ShardingEvent>, never, Scope>
+  /**
+   * Register a new runner with the cluster.
+   */
+  readonly register: (runner: Runner) => Effect.Effect<MachineId.MachineId>
+  /**
+   * Unregister a runner from the cluster.
+   */
+  readonly unregister: (address: RunnerAddress) => Effect.Effect<void>
+  /**
+   * Rebalance shards assigned to runners within the cluster.
+   */
+  readonly rebalance: (immediate: boolean) => Effect.Effect<void>
+  /**
+   * Notify the cluster of an unhealthy runner.
+   */
+  readonly notifyUnhealthyRunner: (address: RunnerAddress) => Effect.Effect<void>
+  /**
+   * Check and repot on the health of all runners in the cluster.
+   */
+  readonly checkRunnerHealth: Effect.Effect<void>
+}>() {}
+
+/**
+ * @since 1.0.0
+ * @category Config
+ */
+export class Config extends Context.Tag("@effect/cluster/ShardManager/Config")<Config, {
+  /**
+   * The duration to wait before rebalancing shards after a change.
+   */
+  readonly rebalanceDebounce: Duration.DurationInput
+  /**
+   * The interval on which regular rebalancing of shards will occur.
+   */
+  readonly rebalanceInterval: Duration.DurationInput
+  /**
+   * The interval on which rebalancing of shards which failed to be
+   * rebalanced will be retried.
+   */
+  readonly rebalanceRetryInterval: Duration.DurationInput
+  /**
+   * The maximum ratio of shards to rebalance at once.
+   *
+   * **Note**: this value should be a number between `0` and `1`.
+   */
+  readonly rebalanceRate: number
+  /**
+   * The interval on which persistence of Runners will be retried if it fails.
+   */
+  readonly persistRetryInterval: Duration.DurationInput
+  /**
+   * The number of times persistence of Runners will be retried if it fails.
+   */
+  readonly persistRetryCount: number
+  /**
+   * The interval on which Runner health will be checked.
+   */
+  readonly runnerHealthCheckInterval: Duration.DurationInput
+  /**
+   * The length of time to wait for a Runner to respond to a ping.
+   */
+  readonly runnerPingTimeout: Duration.DurationInput
+}>() {
+  /**
+   * @since 1.0.0
+   */
+  static readonly defaults: Config["Type"] = {
+    rebalanceDebounce: Duration.millis(500),
+    rebalanceInterval: Duration.seconds(20),
+    rebalanceRetryInterval: Duration.seconds(10),
+    rebalanceRate: 2 / 100,
+    persistRetryCount: 100,
+    persistRetryInterval: Duration.seconds(3),
+    runnerHealthCheckInterval: Duration.minutes(1),
+    runnerPingTimeout: Duration.seconds(3)
+  }
+}
+
+/**
+ * @since 1.0.0
+ * @category Config
+ */
+export const configConfig: Config_.Config<Config["Type"]> = Config_.all({
+  rebalanceDebounce: Config_.duration("rebalanceDebounce").pipe(
+    Config_.withDefault(Config.defaults.rebalanceDebounce),
+    Config_.withDescription("The duration to wait before rebalancing shards after a change.")
+  ),
+  rebalanceInterval: Config_.duration("rebalanceInterval").pipe(
+    Config_.withDefault(Config.defaults.rebalanceInterval),
+    Config_.withDescription("The interval on which regular rebalancing of shards will occur.")
+  ),
+  rebalanceRetryInterval: Config_.duration("rebalanceRetryInterval").pipe(
+    Config_.withDefault(Config.defaults.rebalanceRetryInterval),
+    Config_.withDescription(
+      "The interval on which rebalancing of shards which failed to be rebalanced will be retried."
+    )
+  ),
+  rebalanceRate: Config_.number("rebalanceRate").pipe(
+    Config_.withDefault(Config.defaults.rebalanceRate),
+    Config_.withDescription("The maximum ratio of shards to rebalance at once.")
+  ),
+  persistRetryCount: Config_.integer("persistRetryCount").pipe(
+    Config_.withDefault(Config.defaults.persistRetryCount),
+    Config_.withDescription("The number of times persistence of runners will be retried if it fails.")
+  ),
+  persistRetryInterval: Config_.duration("persistRetryInterval").pipe(
+    Config_.withDefault(Config.defaults.persistRetryInterval),
+    Config_.withDescription("The interval on which persistence of runners will be retried if it fails.")
+  ),
+  runnerHealthCheckInterval: Config_.duration("runnerHealthCheckInterval").pipe(
+    Config_.withDefault(Config.defaults.runnerHealthCheckInterval),
+    Config_.withDescription("The interval on which runner health will be checked.")
+  ),
+  runnerPingTimeout: Config_.duration("runnerPingTimeout").pipe(
+    Config_.withDefault(Config.defaults.runnerPingTimeout),
+    Config_.withDescription("The length of time to wait for a runner to respond to a ping.")
+  )
+})
+
+/**
+ * @since 1.0.0
+ * @category Config
  */
-export const ShardManagerTypeId: unique symbol = internal.ShardManagerTypeId
+export const configFromEnv: Effect.Effect<Config["Type"], ConfigError> = configConfig.pipe(
+  Effect.withConfigProvider(
+    ConfigProvider.fromEnv().pipe(
+      ConfigProvider.constantCase
+    )
+  )
+)
 
 /**
  * @since 1.0.0
- * @category symbols
+ * @category Config
  */
-export type ShardManagerTypeId = typeof ShardManagerTypeId
+export const layerConfig = (config?: Partial<Config["Type"]>): Layer.Layer<Config> =>
+  Layer.succeed(Config, {
+    ...Config.defaults,
+    ...config
+  })
 
 /**
  * @since 1.0.0
- * @category context
+ * @category Config
  */
-export const ShardManager = internal.shardManagerTag
+export const layerConfigFromEnv: Layer.Layer<Config, ConfigError> = Layer.effect(Config, configFromEnv)
+
+/**
+ * Represents a client which can be used to communicate with the
+ * `ShardManager`.
+ *
+ * @since 1.0.0
+ * @category Client
+ */
+export class ShardManagerClient
+  extends Context.Tag("@effect/cluster/ShardManager/ShardManagerClient")<ShardManagerClient, {
+    /**
+     * Register a new runner with the cluster.
+     */
+    readonly register: (address: RunnerAddress) => Effect.Effect<MachineId.MachineId>
+    /**
+     * Unregister a runner from the cluster.
+     */
+    readonly unregister: (address: RunnerAddress) => Effect.Effect<void>
+    /**
+     * Notify the cluster of an unhealthy runner.
+     */
+    readonly notifyUnhealthyRunner: (address: RunnerAddress) => Effect.Effect<void>
+    /**
+     * Get all shard assignments.
+     */
+    readonly getAssignments: Effect.Effect<
+      ReadonlyMap<ShardId, Option.Option<RunnerAddress>>
+    >
+    /**
+     * Get a stream of sharding events emit by the shard manager.
+     */
+    readonly shardingEvents: Effect.Effect<Mailbox.ReadonlyMailbox<ShardingEvent>, never, Scope>
+    /**
+     * Get the current time on the shard manager.
+     */
+    readonly getTime: Effect.Effect<number>
+  }>()
+{}
 
 /**
  * @since 1.0.0
  * @category models
  */
-export interface ShardManager {
-  readonly getShardingEvents: Stream.Stream<ShardingEvent.ShardingEvent>
-  readonly register: (pod: Pod.Pod) => Effect.Effect<void>
-  readonly unregister: (podAddress: PodAddress.PodAddress) => Effect.Effect<void>
-  readonly notifyUnhealthyPod: (podAddress: PodAddress.PodAddress) => Effect.Effect<void>
-  readonly checkAllPodsHealth: Effect.Effect<void>
-  readonly getAssignments: Effect.Effect<HashMap.HashMap<ShardId.ShardId, Option.Option<PodAddress.PodAddress>>>
-  /* @internal */
-  readonly rebalance: (rebalanceImmediately: boolean) => Effect.Effect<void>
-  /* @internal */
-  readonly persistPods: Effect.Effect<void>
-}
+export const ShardingEventSchema = Schema.Union(
+  Schema.TaggedStruct("StreamStarted", {}),
+  Schema.TaggedStruct("ShardsAssigned", {
+    address: RunnerAddress,
+    shards: Schema.Array(ShardId)
+  }),
+  Schema.TaggedStruct("ShardsUnassigned", {
+    address: RunnerAddress,
+    shards: Schema.Array(ShardId)
+  }),
+  Schema.TaggedStruct("RunnerRegistered", {
+    address: RunnerAddress
+  }),
+  Schema.TaggedStruct("RunnerUnregistered", {
+    address: RunnerAddress
+  })
+) satisfies Schema.Schema<ShardingEvent, any>
+
+/**
+ * The messaging protocol for the `ShardManager`.
+ *
+ * @since 1.0.0
+ * @category Rpcs
+ */
+export class Rpcs extends RpcGroup.make(
+  Rpc.make("Register", {
+    payload: { runner: Runner },
+    success: MachineId.MachineId
+  }),
+  Rpc.make("Unregister", {
+    payload: { address: RunnerAddress }
+  }),
+  Rpc.make("NotifyUnhealthyRunner", {
+    payload: { address: RunnerAddress }
+  }),
+  Rpc.make("GetAssignments", {
+    success: Schema.ReadonlyMap({ key: ShardId, value: Schema.Option(RunnerAddress) })
+  }),
+  Rpc.make("ShardingEvents", {
+    success: ShardingEventSchema,
+    stream: true
+  }),
+  Rpc.make("GetTime", {
+    success: Schema.Number
+  })
+) {}
+
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export type ShardingEvent = Data.TaggedEnum<{
+  StreamStarted: {}
+  ShardsAssigned: {
+    address: RunnerAddress
+    shards: ReadonlyArray<ShardId>
+  }
+  ShardsUnassigned: {
+    address: RunnerAddress
+    shards: ReadonlyArray<ShardId>
+  }
+  RunnerRegistered: { address: RunnerAddress }
+  RunnerUnregistered: { address: RunnerAddress }
+}>
+
+/**
+ * @since 1.0.0
+ * @category models
+ */
+export const ShardingEvent = Data.taggedEnum<ShardingEvent>()
+
+/**
+ * @since 1.0.0
+ * @category Client
+ */
+export const makeClientLocal = Effect.gen(function*() {
+  const runnerAddress = yield* ShardingConfig
+  const clock = yield* Effect.clock
+
+  const shards = new Map<ShardId, Option.Option<RunnerAddress>>()
+  for (let n = 1; n <= runnerAddress.numberOfShards; n++) {
+    shards.set(ShardId.make(n), runnerAddress.runnerAddress)
+  }
+
+  let machineId = 0
+
+  return ShardManagerClient.of({
+    register: () => Effect.sync(() => MachineId.make(++machineId)),
+    unregister: () => Effect.void,
+    notifyUnhealthyRunner: () => Effect.void,
+    getAssignments: Effect.succeed(shards),
+    shardingEvents: Effect.gen(function*() {
+      const mailbox = yield* Mailbox.make<ShardingEvent>()
+      yield* mailbox.offer(ShardingEvent.StreamStarted())
+      return mailbox
+    }),
+    getTime: clock.currentTimeMillis
+  })
+})
+
+/**
+ * @since 1.0.0
+ * @category Client
+ */
+export const makeClientRpc: Effect.Effect<
+  ShardManagerClient["Type"],
+  never,
+  ShardingConfig | RpcClient.Protocol | Scope
+> = Effect.gen(function*() {
+  const config = yield* ShardingConfig
+  const client = yield* RpcClient.make(Rpcs, {
+    spanPrefix: "ShardManagerClient",
+    disableTracing: true
+  })
+
+  return ShardManagerClient.of({
+    register: (address) => client.Register({ runner: Runner.make({ address, version: config.serverVersion }) }),
+    unregister: (address) => client.Unregister({ address }),
+    notifyUnhealthyRunner: (address) => client.NotifyUnhealthyRunner({ address }),
+    getAssignments: client.GetAssignments(),
+    shardingEvents: client.ShardingEvents({}, { asMailbox: true }),
+    getTime: client.GetTime()
+  })
+})
+
+/**
+ * @since 1.0.0
+ * @category Client
+ */
+export const layerClientLocal: Layer.Layer<
+  ShardManagerClient,
+  never,
+  ShardingConfig
+> = Layer.effect(ShardManagerClient, makeClientLocal)
+
+/**
+ * @since 1.0.0
+ * @category Client
+ */
+export const layerClientRpc: Layer.Layer<
+  ShardManagerClient,
+  never,
+  ShardingConfig | RpcClientProtocol
+> = Layer.scoped(ShardManagerClient, makeClientRpc).pipe(
+  Layer.provide(Layer.scoped(
+    RpcClient.Protocol,
+    Effect.gen(function*() {
+      const config = yield* ShardingConfig
+      const clientProtocol = yield* RpcClientProtocol
+      return yield* clientProtocol(config.shardManagerAddress)
+    })
+  ))
+)
+
+/**
+ * @since 1.0.0
+ * @category Constructors
+ */
+export const make = Effect.gen(function*() {
+  const storage = yield* ShardStorage
+  const runnersApi = yield* Runners
+  const runnerHealthApi = yield* RunnerHealth
+  const clock = yield* Effect.clock
+  const config = yield* Config
+  const shardingConfig = yield* ShardingConfig
+
+  const state = yield* Effect.orDie(State.fromStorage(shardingConfig.numberOfShards))
+  const scope = yield* Effect.scope
+  const events = yield* PubSub.unbounded<ShardingEvent>()
+
+  yield* Metric.incrementBy(ClusterMetrics.runners, MutableHashMap.size(state.runners))
+
+  for (const address of state.shards.values()) {
+    const metric = Option.isSome(address) ?
+      Metric.tagged(ClusterMetrics.assignedShards, "address", address.toString()) :
+      ClusterMetrics.unassignedShards
+    yield* Metric.increment(metric)
+  }
+
+  function withRetry<A, E, R>(effect: Effect.Effect<A, E, R>): Effect.Effect<void, never, R> {
+    return effect.pipe(
+      Effect.retry({
+        schedule: Schedule.spaced(config.persistRetryCount),
+        times: config.persistRetryCount
+      }),
+      Effect.ignore
+    )
+  }
+
+  const persistRunners = Effect.unsafeMakeSemaphore(1).withPermits(1)(withRetry(
+    Effect.suspend(() =>
+      storage.saveRunners(
+        Iterable.map(state.runners, ([address, runner]) => [address, runner.runner])
+      )
+    )
+  ))
+
+  const persistAssignments = Effect.unsafeMakeSemaphore(1).withPermits(1)(withRetry(
+    Effect.suspend(() => storage.saveAssignments(state.shards))
+  ))
+
+  const notifyUnhealthyRunner = Effect.fnUntraced(function*(address: RunnerAddress) {
+    if (!MutableHashMap.has(state.runners, address)) return
+
+    yield* Metric.increment(
+      Metric.tagged(ClusterMetrics.runnerHealthChecked, "runner_address", address.toString())
+    )
+
+    if (!(yield* runnerHealthApi.isAlive(address))) {
+      yield* Effect.logWarning(`Runner at address '${address.toString()}' is not alive`)
+      yield* unregister(address)
+    }
+  })
+
+  function updateShardsState(
+    shards: Iterable<ShardId>,
+    address: Option.Option<RunnerAddress>
+  ): Effect.Effect<void, RunnerNotRegistered> {
+    return Effect.suspend(() => {
+      if (Option.isSome(address) && !MutableHashMap.has(state.runners, address.value)) {
+        return Effect.fail(new RunnerNotRegistered({ address: address.value }))
+      }
+      for (const shardId of shards) {
+        if (!state.shards.has(shardId)) continue
+        state.shards.set(shardId, address)
+      }
+      return Effect.void
+    })
+  }
+
+  const getAssignments = Effect.sync(() => state.shards)
+
+  let machineId = 0
+  const register = Effect.fnUntraced(function*(runner: Runner) {
+    yield* Effect.logInfo(`Registering runner ${Runner.pretty(runner)}`)
+    const now = clock.unsafeCurrentTimeMillis()
+    MutableHashMap.set(state.runners, runner.address, RunnerWithMetadata({ runner, registeredAt: now }))
+
+    yield* Metric.increment(ClusterMetrics.runners)
+    yield* PubSub.publish(events, ShardingEvent.RunnerRegistered({ address: runner.address }))
+    if (state.unassignedShards.length > 0) {
+      yield* rebalance(false)
+    }
+    yield* Effect.forkIn(persistRunners, scope)
+    return MachineId.make(++machineId)
+  })
+
+  const unregister = Effect.fnUntraced(function*(address: RunnerAddress) {
+    if (!MutableHashMap.has(state.runners, address)) return
+
+    yield* Effect.logInfo("Unregistering runner at address:", address)
+    const unassignments = Arr.empty<ShardId>()
+    for (const [shard, runner] of state.shards) {
+      if (Option.isSome(runner) && Equal.equals(runner.value, address)) {
+        unassignments.push(shard)
+        state.shards.set(shard, Option.none())
+      }
+    }
+
+    MutableHashMap.remove(state.runners, address)
+    yield* Metric.incrementBy(ClusterMetrics.runners, -1)
+
+    if (unassignments.length > 0) {
+      yield* Metric.incrementBy(
+        Metric.tagged(ClusterMetrics.unassignedShards, "runner_address", address.toString()),
+        unassignments.length
+      )
+      yield* PubSub.publish(events, ShardingEvent.RunnerUnregistered({ address }))
+    }
+
+    yield* Effect.forkIn(persistRunners, scope)
+    yield* Effect.forkIn(rebalance(true), scope)
+  })
+
+  let rebalancing = false
+  let nextRebalanceImmediate = false
+  let rebalanceDeferred: Deferred.Deferred<void> | undefined
+  const rebalanceFibers = yield* FiberSet.make()
+
+  const rebalance = (immmediate: boolean): Effect.Effect<void> =>
+    Effect.withFiberRuntime<void>((fiber) => {
+      if (!rebalancing) {
+        rebalancing = true
+        return rebalanceLoop(immmediate)
+      }
+      if (immmediate) {
+        nextRebalanceImmediate = true
+      }
+      if (!rebalanceDeferred) {
+        rebalanceDeferred = Deferred.unsafeMake(fiber.id())
+      }
+      return Deferred.await(rebalanceDeferred)
+    })
+
+  const rebalanceLoop = (immediate?: boolean): Effect.Effect<void> =>
+    Effect.suspend(() => {
+      const deferred = rebalanceDeferred
+      rebalanceDeferred = undefined
+      if (!immediate) {
+        immediate = nextRebalanceImmediate
+        nextRebalanceImmediate = false
+      }
+      return runRebalance(immediate).pipe(
+        deferred ? Effect.intoDeferred(deferred) : identity,
+        Effect.onExit(() => {
+          if (!rebalanceDeferred) {
+            rebalancing = false
+            return Effect.void
+          }
+          return Effect.forkIn(rebalanceLoop(), scope)
+        })
+      )
+    })
+
+  const runRebalance = Effect.fn("ShardManager.rebalance")(function*(immediate: boolean) {
+    yield* Effect.annotateCurrentSpan("immmediate", immediate)
+
+    yield* Effect.sleep(config.rebalanceDebounce)
+
+    // Determine which shards to assign and unassign
+    const [assignments, unassignments, changes] = immediate || (state.unassignedShards.length > 0)
+      ? decideAssignmentsForUnassignedShards(state)
+      : decideAssignmentsForUnbalancedShards(state, config.rebalanceRate)
+
+    yield* Effect.logDebug(`Rebalancing shards (immediate = ${immediate})`)
+
+    if (MutableHashSet.size(changes) === 0) return
+
+    yield* Metric.increment(ClusterMetrics.rebalances)
+
+    // Ping runners first and remove unhealthy ones
+    const failedRunners = MutableHashSet.empty<RunnerAddress>()
+    for (const address of changes) {
+      yield* FiberSet.run(
+        rebalanceFibers,
+        runnersApi.ping(address).pipe(
+          Effect.timeout(config.runnerPingTimeout),
+          Effect.catchAll(() => {
+            MutableHashSet.add(failedRunners, address)
+            MutableHashMap.remove(assignments, address)
+            MutableHashMap.remove(unassignments, address)
+            return Effect.void
+          })
+        )
+      )
+    }
+    yield* FiberSet.awaitEmpty(rebalanceFibers)
+
+    const failedUnassignments = new Set<ShardId>()
+    for (const [address, shards] of unassignments) {
+      yield* FiberSet.run(
+        rebalanceFibers,
+        updateShardsState(shards, Option.none()).pipe(
+          Effect.matchEffect({
+            onFailure: () => {
+              MutableHashSet.add(failedRunners, address)
+              for (const shard of shards) {
+                failedUnassignments.add(shard)
+              }
+              // Remove failed runners from the assignments
+              MutableHashMap.remove(assignments, address)
+              return Effect.void
+            },
+            onSuccess: () => {
+              const shardCount = shards.size
+              return Metric.incrementBy(
+                Metric.tagged(ClusterMetrics.assignedShards, "runner_address", address.toString()),
+                -shardCount
+              ).pipe(
+                Effect.zipRight(Metric.incrementBy(ClusterMetrics.unassignedShards, shardCount)),
+                Effect.zipRight(
+                  PubSub.publish(events, ShardingEvent.ShardsUnassigned({ address, shards: Array.from(shards) }))
+                )
+              )
+            }
+          })
+        )
+      )
+    }
+    yield* FiberSet.awaitEmpty(rebalanceFibers)
+
+    // Remove failed shard unassignments from the assignments
+    MutableHashMap.forEach(assignments, (shards, address) => {
+      for (const shard of failedUnassignments) {
+        shards.delete(shard)
+      }
+      if (shards.size === 0) {
+        MutableHashMap.remove(assignments, address)
+      }
+    })
+
+    // Perform the assignments
+    for (const [address, shards] of assignments) {
+      yield* FiberSet.run(
+        rebalanceFibers,
+        updateShardsState(shards, Option.some(address)).pipe(
+          Effect.matchEffect({
+            onFailure: () => {
+              MutableHashSet.add(failedRunners, address)
+              return Effect.void
+            },
+            onSuccess: () => {
+              const shardCount = shards.size
+              return Metric.incrementBy(
+                Metric.tagged(ClusterMetrics.assignedShards, "runner_address", address.toString()),
+                -shardCount
+              ).pipe(
+                Effect.zipRight(Metric.incrementBy(ClusterMetrics.unassignedShards, -shardCount)),
+                Effect.zipRight(
+                  PubSub.publish(events, ShardingEvent.ShardsAssigned({ address, shards: Array.from(shards) }))
+                )
+              )
+            }
+          })
+        )
+      )
+    }
+    yield* FiberSet.awaitEmpty(rebalanceFibers)
+
+    const wereFailures = MutableHashSet.size(failedRunners) > 0
+    if (wereFailures) {
+      // Check if the failing runners are still reachable
+      yield* Effect.forEach(failedRunners, notifyUnhealthyRunner, { discard: true }).pipe(
+        Effect.forkIn(scope)
+      )
+      yield* Effect.logWarning("Failed to rebalance runners: ", failedRunners)
+    }
+
+    if (wereFailures && immediate) {
+      // Try rebalancing again later if there were any failures
+      yield* Clock.sleep(config.rebalanceRetryInterval).pipe(
+        Effect.zipRight(rebalance(immediate)),
+        Effect.forkIn(scope)
+      )
+    }
+
+    yield* persistAssignments
+  })
+
+  const checkRunnerHealth: Effect.Effect<void> = Effect.suspend(() =>
+    Effect.forEach(MutableHashMap.keys(state.runners), notifyUnhealthyRunner, {
+      concurrency: "inherit",
+      discard: true
+    })
+  ).pipe(
+    Effect.withConcurrency(4),
+    Effect.asVoid
+  )
+
+  yield* Effect.addFinalizer(() =>
+    persistAssignments.pipe(
+      Effect.catchAllCause((cause) => Effect.logWarning("Failed to persist assignments on shutdown", cause)),
+      Effect.zipRight(persistRunners.pipe(
+        Effect.catchAllCause((cause) => Effect.logWarning("Failed to persist runners on shutdown", cause))
+      ))
+    )
+  )
+
+  yield* Effect.forkIn(persistRunners, scope)
+
+  // Rebalance immediately if there are unassigned shards
+  yield* Effect.forkIn(
+    rebalance(state.unassignedShards.length > 0),
+    scope
+  )
+
+  // Start a regular cluster rebalance at the configured interval
+  yield* rebalance(false).pipe(
+    Effect.andThen(Effect.sleep(config.rebalanceInterval)),
+    Effect.forever,
+    Effect.forkIn(scope)
+  )
+
+  yield* checkRunnerHealth.pipe(
+    Effect.andThen(Effect.sleep(config.runnerHealthCheckInterval)),
+    Effect.forever,
+    Effect.forkIn(scope)
+  )
+
+  yield* Effect.gen(function*() {
+    const queue = yield* PubSub.subscribe(events)
+    while (true) {
+      yield* Effect.logInfo("Shard manager event:", yield* Queue.take(queue))
+    }
+  }).pipe(Effect.forkIn(scope))
+
+  yield* Effect.logInfo("Shard manager initialized")
+
+  return ShardManager.of({
+    getAssignments,
+    shardingEvents: PubSub.subscribe(events),
+    register,
+    unregister,
+    rebalance,
+    notifyUnhealthyRunner,
+    checkRunnerHealth
+  })
+})
+
+/**
+ * @since 1.0.0
+ * @category layer
+ */
+export const layer: Layer.Layer<
+  ShardManager,
+  never,
+  ShardStorage | RunnerHealth | Runners | Config | ShardingConfig
+> = Layer.scoped(ShardManager, make)
+
+/**
+ * @since 1.0.0
+ * @category Server
+ */
+export const layerServerHandlers = Rpcs.toLayer(Effect.gen(function*() {
+  const shardManager = yield* ShardManager
+  const clock = yield* Effect.clock
+  return {
+    Register: ({ runner }) => shardManager.register(runner),
+    Unregister: ({ address }) => shardManager.unregister(address),
+    NotifyUnhealthyRunner: ({ address }) => shardManager.notifyUnhealthyRunner(address),
+    GetAssignments: () => shardManager.getAssignments,
+    ShardingEvents: Effect.fnUntraced(function*() {
+      const queue = yield* shardManager.shardingEvents
+      const mailbox = yield* Mailbox.make<ShardingEvent>()
+
+      yield* mailbox.offer(ShardingEvent.StreamStarted())
+
+      yield* Queue.takeBetween(queue, 1, Number.MAX_SAFE_INTEGER).pipe(
+        Effect.flatMap((events) => mailbox.offerAll(events)),
+        Effect.forever,
+        Effect.forkScoped
+      )
+
+      return mailbox
+    }),
+    GetTime: () => clock.currentTimeMillis
+  }
+}))
 
 /**
  * @since 1.0.0
- * @category layers
+ * @category Server
  */
-export const live = internal.live
+export const layerServer: Layer.Layer<
+  never,
+  never,
+  ShardManager | RpcServer.Protocol
+> = RpcServer.layer(Rpcs, {
+  spanPrefix: "ShardManager",
+  disableTracing: true
+}).pipe(Layer.provide(layerServerHandlers))
diff --git a/src/ShardStorage.ts b/src/ShardStorage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f7f1b4438ec4c16f8cd202c730b23e72d53ae75c
--- /dev/null
+++ b/src/ShardStorage.ts
@@ -0,0 +1,289 @@
+/**
+ * @since 1.0.0
+ */
+import * as Context from "effect/Context"
+import * as Effect from "effect/Effect"
+import * as Layer from "effect/Layer"
+import * as MutableHashMap from "effect/MutableHashMap"
+import * as Option from "effect/Option"
+import type { PersistenceError } from "./ClusterError.js"
+import { Runner } from "./Runner.js"
+import { RunnerAddress } from "./RunnerAddress.js"
+import { ShardId } from "./ShardId.js"
+
+/**
+ * Represents a generic interface to the persistent storage required by the
+ * cluster.
+ *
+ * @since 1.0.0
+ * @category models
+ */
+export class ShardStorage extends Context.Tag("@effect/cluster/ShardStorage")<ShardStorage, {
+  /**
+   * Get the current assignments of shards to runners.
+   */
+  readonly getAssignments: Effect.Effect<ReadonlyMap<ShardId, Option.Option<RunnerAddress>>, PersistenceError>
+
+  /**
+   * Save the current state of shards assignments to runners.
+   */
+  readonly saveAssignments: (
+    assignments: Iterable<readonly [ShardId, Option.Option<RunnerAddress>]>
+  ) => Effect.Effect<void, PersistenceError>
+
+  /**
+   * Get all runners registered with the cluster.
+   */
+  readonly getRunners: Effect.Effect<Array<[RunnerAddress, Runner]>, PersistenceError>
+
+  /**
+   * Save the current runners registered with the cluster.
+   */
+  readonly saveRunners: (runners: Iterable<readonly [RunnerAddress, Runner]>) => Effect.Effect<void, PersistenceError>
+
+  /**
+   * Try to acquire the given shard ids for processing.
+   *
+   * It returns an array of shards it was able to acquire.
+   */
+  readonly acquire: (
+    address: RunnerAddress,
+    shardIds: Iterable<ShardId>
+  ) => Effect.Effect<Array<ShardId>, PersistenceError>
+
+  /**
+   * Refresh the locks owned by the given runner.
+   *
+   * Locks expire after 90 seconds, so this method should be called every 60
+   * seconds to keep the locks alive.
+   */
+  readonly refresh: (
+    address: RunnerAddress,
+    shardIds: Iterable<ShardId>
+  ) => Effect.Effect<Array<ShardId>, PersistenceError>
+
+  /**
+   * Release the given shard ids.
+   */
+  readonly release: (
+    address: RunnerAddress,
+    shardId: ShardId
+  ) => Effect.Effect<void, PersistenceError>
+
+  /**
+   * Release all the shards assigned to the given runner.
+   */
+  readonly releaseAll: (address: RunnerAddress) => Effect.Effect<void, PersistenceError>
+}>() {}
+
+/**
+ * @since 1.0.0
+ * @category Encoded
+ */
+export interface Encoded {
+  /**
+   * Get the current assignments of shards to runners.
+   */
+  readonly getAssignments: Effect.Effect<
+    Array<
+      readonly [
+        shardId: number,
+        runnerAddress: string | null
+      ]
+    >,
+    PersistenceError
+  >
+
+  /**
+   * Save the current state of shards assignments to runners.
+   */
+  readonly saveAssignments: (
+    assignments: Array<readonly [shardId: number, RunnerAddress: string | null]>
+  ) => Effect.Effect<void, PersistenceError>
+
+  /**
+   * Get all runners registered with the cluster.
+   */
+  readonly getRunners: Effect.Effect<Array<readonly [address: string, runner: string]>, PersistenceError>
+
+  /**
+   * Save the current runners registered with the cluster.
+   */
+  readonly saveRunners: (
+    runners: Array<readonly [address: string, runner: string]>
+  ) => Effect.Effect<void, PersistenceError>
+
+  /**
+   * Acquire the lock on the given shards, returning the shards that were
+   * successfully locked.
+   */
+  readonly acquire: (
+    address: string,
+    shardIds: ReadonlyArray<number>
+  ) => Effect.Effect<Array<number>, PersistenceError>
+
+  /**
+   * Refresh the lock on the given shards, returning the shards that were
+   * successfully locked.
+   */
+  readonly refresh: (
+    address: string,
+    shardIds: ReadonlyArray<number>
+  ) => Effect.Effect<Array<number>, PersistenceError>
+
+  /**
+   * Release the lock on the given shards.
+   */
+  readonly release: (
+    address: string,
+    shardIds: number
+  ) => Effect.Effect<void, PersistenceError>
+
+  /**
+   * Release the lock on all shards for the given runner.
+   */
+  readonly releaseAll: (address: string) => Effect.Effect<void, PersistenceError>
+}
+
+/**
+ * @since 1.0.0
+ * @category layers
+ */
+export const makeEncoded = Effect.fnUntraced(function*(encoded: Encoded) {
+  const activeShards = new Set<ShardId>()
+
+  return ShardStorage.of({
+    getAssignments: Effect.map(encoded.getAssignments, (assignments) => {
+      const map = new Map<ShardId, Option.Option<RunnerAddress>>()
+      for (const [shardId, runnerAddress] of assignments) {
+        map.set(
+          ShardId.make(shardId),
+          runnerAddress === null ? Option.none() : Option.some(decodeRunnerAddress(runnerAddress))
+        )
+      }
+      return map
+    }),
+    saveAssignments: (assignments) =>
+      encoded.saveAssignments(
+        Array.from(
+          assignments,
+          (
+            [shardId, runnerAddress]
+          ) => [shardId, Option.isNone(runnerAddress) ? null : encodeRunnerAddress(runnerAddress.value)]
+        )
+      ),
+    getRunners: Effect.gen(function*() {
+      const runners = yield* encoded.getRunners
+      const results = new Array<[RunnerAddress, Runner]>(runners.length)
+      for (let i = 0; i < runners.length; i++) {
+        const [address, runner] = runners[i]
+        results[i] = [decodeRunnerAddress(address), Runner.decodeSync(runner)]
+      }
+      return results
+    }),
+    saveRunners: (runners) =>
+      Effect.suspend(() =>
+        encoded.saveRunners(
+          Array.from(runners, ([address, runner]) => [encodeRunnerAddress(address), Runner.encodeSync(runner)])
+        )
+      ),
+    acquire: (address, shardIds) =>
+      encoded.acquire(encodeRunnerAddress(address), Array.from(shardIds)) as Effect.Effect<
+        Array<ShardId>,
+        PersistenceError
+      >,
+    refresh: (address, shardIds) => encoded.refresh(encodeRunnerAddress(address), Array.from(shardIds)) as any,
+    release: Effect.fnUntraced(function*(address, shardId) {
+      activeShards.delete(shardId)
+      yield* encoded.release(encodeRunnerAddress(address), shardId).pipe(
+        Effect.onError(() => Effect.sync(() => activeShards.add(shardId)))
+      )
+    }),
+    releaseAll: Effect.fnUntraced(function*(address) {
+      activeShards.clear()
+      yield* encoded.releaseAll(encodeRunnerAddress(address))
+    })
+  })
+})
+
+/**
+ * @since 1.0.0
+ * @category layers
+ */
+export const layerNoop: Layer.Layer<ShardStorage> = Layer.sync(
+  ShardStorage,
+  () => {
+    let acquired: Array<ShardId> = []
+    return ShardStorage.of({
+      getAssignments: Effect.succeed(new Map()),
+      saveAssignments: () => Effect.void,
+      getRunners: Effect.sync(() => []),
+      saveRunners: () => Effect.void,
+      acquire: (_address, shards) => {
+        acquired = Array.from(shards)
+        return Effect.succeed(Array.from(shards))
+      },
+      refresh: () => Effect.sync(() => acquired),
+      release: () => Effect.void,
+      releaseAll: () => Effect.void
+    })
+  }
+)
+
+/**
+ * @since 1.0.0
+ * @category constructors
+ */
+export const makeMemory = Effect.gen(function*() {
+  const assignments = new Map<ShardId, Option.Option<RunnerAddress>>()
+  const runners = MutableHashMap.empty<RunnerAddress, Runner>()
+
+  function saveAssignments(value: Iterable<readonly [ShardId, Option.Option<RunnerAddress>]>) {
+    return Effect.sync(() => {
+      for (const [shardId, runnerAddress] of value) {
+        assignments.set(shardId, runnerAddress)
+      }
+    })
+  }
+
+  function saveRunners(value: Iterable<readonly [RunnerAddress, Runner]>) {
+    return Effect.sync(() => {
+      for (const [address, runner] of value) {
+        MutableHashMap.set(runners, address, runner)
+      }
+    })
+  }
+
+  let acquired: Array<ShardId> = []
+
+  return ShardStorage.of({
+    getAssignments: Effect.sync(() => new Map(assignments)),
+    saveAssignments,
+    getRunners: Effect.sync(() => Array.from(runners)),
+    saveRunners,
+    acquire: (_address, shardIds) => {
+      acquired = Array.from(shardIds)
+      return Effect.succeed(Array.from(shardIds))
+    },
+    refresh: () => Effect.sync(() => acquired),
+    release: () => Effect.void,
+    releaseAll: () => Effect.void
+  })
+})
+
+/**
+ * @since 1.0.0
+ * @category layers
+ */
+export const layerMemory: Layer.Layer<ShardStorage> = Layer.effect(ShardStorage, makeMemory)
+
+// -------------------------------------------------------------------------------------
+// internal
+// -------------------------------------------------------------------------------------
+
+const encodeRunnerAddress = (runnerAddress: RunnerAddress) => `${runnerAddress.host}:${runnerAddress.port}`
+
+const decodeRunnerAddress = (runnerAddress: string): RunnerAddress => {
+  const [host, port] = runnerAddress.split(":")
+  return new RunnerAddress({ host, port: Number(port) })
+}
diff --git a/src/Sharding.ts b/src/Sharding.ts
index e53aa2ac965ebd52042dbfce65c86efa8be7b74b..d7b63c58c06de67c2e283c1013d741d86cd3233e 100644
--- a/src/Sharding.ts
+++ b/src/Sharding.ts
@@ -1,214 +1,1092 @@
 /**
  * @since 1.0.0
  */
-import type * as Effect from "effect/Effect"
-import type * as HashSet from "effect/HashSet"
-import type * as Scope from "effect/Scope"
-import type * as Stream from "effect/Stream"
-import type { Broadcaster } from "./Broadcaster.js"
-import * as internal from "./internal/sharding.js"
-import type * as Message from "./Message.js"
-import type * as MessageState from "./MessageState.js"
-import type { Messenger } from "./Messenger.js"
-import type * as PodAddress from "./PodAddress.js"
-import type * as RecipientAddress from "./RecipientAddress.js"
-import type * as RecipientBehaviour from "./RecipientBehaviour.js"
-import type * as RecipientBehaviourContext from "./RecipientBehaviourContext.js"
-import type * as RecipentType from "./RecipientType.js"
-import type * as SerializedEnvelope from "./SerializedEnvelope.js"
-import type * as SerializedMessage from "./SerializedMessage.js"
-import type * as ShardId from "./ShardId.js"
-import type * as ShardingException from "./ShardingException.js"
-import type * as ShardingRegistrationEvent from "./ShardingRegistrationEvent.js"
+import type * as Rpc from "@effect/rpc/Rpc"
+import * as RpcClient from "@effect/rpc/RpcClient"
+import { type FromServer, RequestId } from "@effect/rpc/RpcMessage"
+import * as Arr from "effect/Array"
+import * as Cause from "effect/Cause"
+import * as Context from "effect/Context"
+import type { DurationInput } from "effect/Duration"
+import * as Effect from "effect/Effect"
+import * as Equal from "effect/Equal"
+import * as Fiber from "effect/Fiber"
+import * as FiberHandle from "effect/FiberHandle"
+import * as FiberMap from "effect/FiberMap"
+import * as FiberRef from "effect/FiberRef"
+import { constant } from "effect/Function"
+import * as HashMap from "effect/HashMap"
+import * as Iterable from "effect/Iterable"
+import * as Layer from "effect/Layer"
+import * as MutableHashMap from "effect/MutableHashMap"
+import * as MutableRef from "effect/MutableRef"
+import * as Option from "effect/Option"
+import * as Predicate from "effect/Predicate"
+import * as PubSub from "effect/PubSub"
+import * as Schedule from "effect/Schedule"
+import * as Scope from "effect/Scope"
+import * as Stream from "effect/Stream"
+import type { AlreadyProcessingMessage, MailboxFull, PersistenceError } from "./ClusterError.js"
+import { EntityNotManagedByRunner, RunnerUnavailable } from "./ClusterError.js"
+import { Persisted } from "./ClusterSchema.js"
+import type { CurrentAddress, Entity, HandlersFrom } from "./Entity.js"
+import { EntityAddress } from "./EntityAddress.js"
+import { EntityId } from "./EntityId.js"
+import type { EntityType } from "./EntityType.js"
+import * as Envelope from "./Envelope.js"
+import * as EntityManager from "./internal/entityManager.js"
+import { EntityReaper } from "./internal/entityReaper.js"
+import { hashString } from "./internal/hash.js"
+import { internalInterruptors } from "./internal/interruptors.js"
+import { ResourceMap } from "./internal/resourceMap.js"
+import * as Message from "./Message.js"
+import * as MessageStorage from "./MessageStorage.js"
+import * as Reply from "./Reply.js"
+import type { RunnerAddress } from "./RunnerAddress.js"
+import { Runners } from "./Runners.js"
+import { ShardId } from "./ShardId.js"
+import { ShardingConfig } from "./ShardingConfig.js"
+import { EntityRegistered, type ShardingRegistrationEvent, SingletonRegistered } from "./ShardingRegistrationEvent.js"
+import { ShardManagerClient } from "./ShardManager.js"
+import { ShardStorage } from "./ShardStorage.js"
+import { SingletonAddress } from "./SingletonAddress.js"
+import * as Snowflake from "./Snowflake.js"
 
 /**
  * @since 1.0.0
- * @category symbols
+ * @category models
  */
-export const ShardingTypeId: unique symbol = internal.ShardingTypeId
+export class Sharding extends Context.Tag("@effect/cluster/Sharding")<Sharding, {
+  /**
+   * Returns a stream of events that occur when the runner registers entities or
+   * singletons.
+   */
+  readonly getRegistrationEvents: Stream.Stream<ShardingRegistrationEvent>
 
-/**
- * @since 1.0.0
- * @category symbols
- */
-export type ShardingTypeId = typeof ShardingTypeId
+  /**
+   * Returns the `ShardId` of the shard to which the entity at the specified
+   * `address` is assigned.
+   */
+  readonly getShardId: (entityId: EntityId) => ShardId
 
-/**
- * @since 1.0.0
- * @category models
- */
-export interface Sharding {
-  readonly [ShardingTypeId]: ShardingTypeId
-  readonly register: Effect.Effect<void>
-  readonly unregister: Effect.Effect<void>
-  readonly messenger: <Msg extends Message.Message.Any>(
-    entityType: RecipentType.EntityType<Msg>
-  ) => Messenger<Msg>
-  readonly broadcaster: <Msg extends Message.Message.Any>(
-    topicType: RecipentType.TopicType<Msg>
-  ) => Broadcaster<Msg>
-  readonly isEntityOnLocalShards: (
-    recipientAddress: RecipientAddress.RecipientAddress
-  ) => Effect.Effect<boolean>
-  readonly isShuttingDown: Effect.Effect<boolean>
-
-  readonly registerScoped: Effect.Effect<void, never, Scope.Scope>
-  readonly registerEntity: <Msg extends Message.Message.Any>(
-    entityType: RecipentType.EntityType<Msg>
-  ) => <R>(
-    behaviour: RecipientBehaviour.RecipientBehaviour<Msg, R>,
-    options?: RecipientBehaviour.EntityBehaviourOptions
-  ) => Effect.Effect<void, never, Exclude<R, RecipientBehaviourContext.RecipientBehaviourContext>>
-  readonly registerTopic: <Msg extends Message.Message.Any>(
-    topicType: RecipentType.TopicType<Msg>
-  ) => <R>(
-    behaviour: RecipientBehaviour.RecipientBehaviour<Msg, R>,
-    options?: RecipientBehaviour.EntityBehaviourOptions
-  ) => Effect.Effect<void, never, Exclude<R, RecipientBehaviourContext.RecipientBehaviourContext>>
-  readonly getShardingRegistrationEvents: Stream.Stream<ShardingRegistrationEvent.ShardingRegistrationEvent>
-  readonly registerSingleton: <R>(name: string, run: Effect.Effect<void, never, R>) => Effect.Effect<void, never, R>
-  readonly assign: (shards: HashSet.HashSet<ShardId.ShardId>) => Effect.Effect<void>
-  readonly unassign: (shards: HashSet.HashSet<ShardId.ShardId>) => Effect.Effect<void>
-  readonly sendMessageToLocalEntityManagerWithoutRetries: (
-    message: SerializedEnvelope.SerializedEnvelope
+  /**
+   * Returns `true` if sharding is shutting down, `false` otherwise.
+   */
+  readonly isShutdown: Effect.Effect<boolean>
+
+  /**
+   * Constructs a `RpcClient` which can be used to send messages to the
+   * specified `Entity`.
+   */
+  readonly makeClient: <Rpcs extends Rpc.Any>(
+    entity: Entity<Rpcs>
   ) => Effect.Effect<
-    MessageState.MessageState<SerializedMessage.SerializedMessage>,
-    ShardingException.ShardingException
+    (entityId: string) => RpcClient.RpcClient<Rpcs, MailboxFull | AlreadyProcessingMessage | PersistenceError>
   >
-  readonly getPods: Effect.Effect<HashSet.HashSet<PodAddress.PodAddress>>
-  readonly getAssignedShardIds: Effect.Effect<HashSet.HashSet<ShardId.ShardId>>
-  /** @internal */
-  readonly refreshAssignments: Effect.Effect<void, never, Scope.Scope>
-  /** @internal */
-  readonly getShardId: (recipientAddress: RecipientAddress.RecipientAddress) => ShardId.ShardId
+
+  /**
+   * Registers a new entity with the runner.
+   */
+  readonly registerEntity: <Rpcs extends Rpc.Any, Handlers extends HandlersFrom<Rpcs>, RX>(
+    entity: Entity<Rpcs>,
+    handlers: Effect.Effect<Handlers, never, RX>,
+    options?: {
+      readonly maxIdleTime?: DurationInput | undefined
+      readonly concurrency?: number | "unbounded" | undefined
+      readonly mailboxCapacity?: number | "unbounded" | undefined
+    }
+  ) => Effect.Effect<void, never, Rpc.Context<Rpcs> | Rpc.Middleware<Rpcs> | Exclude<RX, Scope.Scope | CurrentAddress>>
+
+  /**
+   * Registers a new singleton with the runner.
+   */
+  readonly registerSingleton: <E, R>(
+    name: string,
+    run: Effect.Effect<void, E, R>
+  ) => Effect.Effect<void, never, Exclude<R, Scope.Scope>>
+
+  /**
+   * Sends a message to the specified entity.
+   */
+  readonly send: (message: Message.Incoming<any>) => Effect.Effect<
+    void,
+    EntityNotManagedByRunner | MailboxFull | AlreadyProcessingMessage
+  >
+
+  /**
+   * Notify sharding that a message has been persisted to storage.
+   */
+  readonly notify: (message: Message.Incoming<any>) => Effect.Effect<
+    void,
+    EntityNotManagedByRunner
+  >
+}>() {}
+
+// -----------------------------------------------------------------------------
+// Implementation
+// -----------------------------------------------------------------------------
+
+interface EntityManagerState {
+  readonly entity: Entity<any>
+  readonly scope: Scope.CloseableScope
+  readonly manager: EntityManager.EntityManager
 }
 
 /**
  * @since 1.0.0
- * @category context
+ * @category constructors
  */
-export const Tag = internal.shardingTag
+export const make = Effect.gen(function*() {
+  const config = yield* ShardingConfig
 
-/**
- * @since 1.0.0
- * @category layers
- */
-export const live = internal.live
+  const runners = yield* Runners
+  const shardManager = yield* ShardManagerClient
+  const snowflakeGen = yield* Snowflake.Generator
+  const shardingScope = yield* Effect.scope
+  const isShutdown = MutableRef.make(false)
 
-/**
- * Notify the shard manager that shards can now be assigned to this pod.
- *
- * @since 1.0.0
- * @category utils
- */
-export const register: Effect.Effect<void, never, Sharding> = internal.register
+  const storage = yield* MessageStorage.MessageStorage
+  const storageEnabled = storage !== MessageStorage.noop
+  const shardStorage = yield* ShardStorage
 
-/**
- * Notify the shard manager that shards must be unassigned from this pod.
- *
- * @since 1.0.0
- * @category utils
- */
-export const unregister: Effect.Effect<void, never, Sharding> = internal.unregister
+  const entityManagers = new Map<EntityType, EntityManagerState>()
 
-/**
- * Same as `register`, but will automatically call `unregister` when the `Scope` is terminated.
- *
- * @since 1.0.0
- * @category utils
- */
-export const registerScoped: Effect.Effect<void, never, Scope.Scope | Sharding> = internal.registerScoped
+  const shardAssignments = MutableHashMap.empty<ShardId, RunnerAddress>()
+  const selfShards = new Set<ShardId>()
 
-/**
- * Start a computation that is guaranteed to run only on a single pod.
- * Each pod should call `registerSingleton` but only a single pod will actually run it at any given time.
- *
- * @since 1.0.0
- * @category utils
- */
-export const registerSingleton: <R>(
-  name: string,
-  run: Effect.Effect<void, never, R>
-) => Effect.Effect<void, never, Sharding | R> = internal.registerSingleton
+  // the active shards are the ones that we have acquired the lock for
+  const acquiredShards = new Set<ShardId>()
+  const activeShardsLatch = yield* Effect.makeLatch(false)
 
-/**
- * Register a new entity type, allowing pods to send messages to entities of this type.
- *
- * @since 1.0.0
- * @category utils
- */
-export const registerEntity: <Msg extends Message.Message.Any>(
-  entityType: RecipentType.EntityType<Msg>
-) => <R>(
-  behavior: RecipientBehaviour.RecipientBehaviour<Msg, R>,
-  options?: RecipientBehaviour.EntityBehaviourOptions | undefined
-) => Effect.Effect<void, never, Sharding | Exclude<R, RecipientBehaviourContext.RecipientBehaviourContext>> =
-  internal.registerEntity
+  const events = yield* PubSub.unbounded<ShardingRegistrationEvent>()
+  const getRegistrationEvents: Stream.Stream<ShardingRegistrationEvent> = Stream.fromPubSub(events)
 
-/**
- * Register a new topic type, allowing pods to broadcast messages to subscribers.
- *
- * @since 1.0.0
- * @category utils
- */
-export const registerTopic: <Msg extends Message.Message.Any>(
-  topicType: RecipentType.TopicType<Msg>
-) => <R>(
-  behavior: RecipientBehaviour.RecipientBehaviour<Msg, R>,
-  options?: RecipientBehaviour.EntityBehaviourOptions | undefined
-) => Effect.Effect<void, never, Sharding | Exclude<R, RecipientBehaviourContext.RecipientBehaviourContext>> =
-  internal.registerTopic
+  const isLocalRunner = (address: RunnerAddress) =>
+    Option.isSome(config.runnerAddress) && Equal.equals(address, config.runnerAddress.value)
 
-/**
- * Get an object that allows sending messages to a given entity type.
- * You can provide a custom send timeout to override the one globally defined.
- *
- * @since 1.0.0
- * @category utils
- */
-export const messenger: <Msg extends Message.Message.Any>(
-  entityType: RecipentType.EntityType<Msg>
-) => Effect.Effect<Messenger<Msg>, never, Sharding> = internal.messenger
+  function getShardId(entityId: EntityId): ShardId {
+    return ShardId.make((Math.abs(hashString(entityId) % config.numberOfShards)) + 1)
+  }
 
-/**
- * Get an object that allows broadcasting messages to a given topic type.
- * You can provide a custom send timeout to override the one globally defined.
- *
- * @since 1.0.0
- * @category utils
- */
-export const broadcaster: <Msg extends Message.Message.Any>(
-  topicType: RecipentType.TopicType<Msg>
-) => Effect.Effect<Broadcaster<Msg>, never, Sharding> = internal.broadcaster
+  function isEntityOnLocalShards(address: EntityAddress): boolean {
+    return acquiredShards.has(address.shardId)
+  }
 
-/**
- * Get the list of pods currently registered to the Shard Manager
- *
- * @since 1.0.0
- * @category utils
- */
-export const getPods: Effect.Effect<HashSet.HashSet<PodAddress.PodAddress>, never, Sharding> = internal.getPods
+  // --- Shard acquisition ---
 
-/**
- * Sends a raw message to the local entity manager without performing reties.
- * Those are up to the caller.
- *
- * @since 1.0.0
- * @category utils
- */
-export const sendMessageToLocalEntityManagerWithoutRetries: (
-  message: SerializedEnvelope.SerializedEnvelope
-) => Effect.Effect<
-  MessageState.MessageState<SerializedMessage.SerializedMessage>,
-  ShardingException.ShardingException,
-  Sharding
-> = internal.sendMessageToLocalEntityManagerWithoutRetries
+  if (Option.isSome(config.runnerAddress)) {
+    const selfAddress = config.runnerAddress.value
+    yield* Scope.addFinalizerExit(shardingScope, () => {
+      // the locks expire over time, so if this fails we ignore it
+      return Effect.ignore(shardStorage.releaseAll(selfAddress))
+    })
+
+    const releasingShards = new Set<ShardId>()
+    yield* Effect.gen(function*() {
+      while (true) {
+        yield* activeShardsLatch.await
+
+        // if a shard is no longer assigned to this runner, we release it
+        for (const shardId of acquiredShards) {
+          if (selfShards.has(shardId)) continue
+          acquiredShards.delete(shardId)
+          releasingShards.add(shardId)
+        }
+        // if a shard has been assigned to this runner, we acquire it
+        const unacquiredShards = new Set<ShardId>()
+        for (const shardId of selfShards) {
+          if (acquiredShards.has(shardId) || releasingShards.has(shardId)) continue
+          unacquiredShards.add(shardId)
+        }
+
+        if (releasingShards.size > 0) {
+          yield* Effect.forkIn(syncSingletons, shardingScope)
+          yield* releaseShards
+        }
+
+        if (unacquiredShards.size === 0) {
+          yield* activeShardsLatch.close
+          continue
+        }
+
+        const acquired = yield* shardStorage.acquire(selfAddress, unacquiredShards)
+        for (const shardId of acquired) {
+          acquiredShards.add(shardId)
+        }
+        if (acquired.length > 0) {
+          yield* storageReadLatch.open
+          yield* Effect.forkIn(syncSingletons, shardingScope)
+        }
+        yield* Effect.sleep(1000)
+      }
+    }).pipe(
+      Effect.catchAllCause((cause) => Effect.logWarning("Could not acquire/release shards", cause)),
+      Effect.repeat(Schedule.spaced(config.entityMessagePollInterval)),
+      Effect.annotateLogs({
+        package: "@effect/cluster",
+        module: "Sharding",
+        fiber: "Shard acquisition loop",
+        runner: selfAddress
+      }),
+      Effect.interruptible,
+      Effect.forkIn(shardingScope)
+    )
+
+    // refresh the shard locks every minute
+    yield* Effect.suspend(() =>
+      shardStorage.refresh(selfAddress, [
+        ...acquiredShards,
+        ...releasingShards
+      ])
+    ).pipe(
+      Effect.flatMap((acquired) => {
+        for (const shardId of acquiredShards) {
+          if (!acquired.includes(shardId)) {
+            acquiredShards.delete(shardId)
+            releasingShards.add(shardId)
+          }
+        }
+        return releasingShards.size > 0 ?
+          Effect.andThen(
+            Effect.forkIn(syncSingletons, shardingScope),
+            releaseShards
+          ) :
+          Effect.void
+      }),
+      Effect.retry({
+        times: 5,
+        schedule: Schedule.spaced(250)
+      }),
+      Effect.catchAllCause((cause) =>
+        Effect.logError("Could not refresh shard locks", cause).pipe(
+          Effect.andThen(clearSelfShards)
+        )
+      ),
+      Effect.delay("1 minute"),
+      Effect.forever,
+      Effect.interruptible,
+      Effect.forkIn(shardingScope)
+    )
+
+    const releaseShardsLock = Effect.unsafeMakeSemaphore(1).withPermits(1)
+    const releaseShards = releaseShardsLock(
+      Effect.suspend(() =>
+        Effect.forEach(
+          releasingShards,
+          (shardId) =>
+            Effect.forEach(
+              entityManagers.values(),
+              (state) => state.manager.interruptShard(shardId),
+              { concurrency: "unbounded", discard: true }
+            ).pipe(
+              Effect.andThen(shardStorage.release(selfAddress, shardId)),
+              Effect.annotateLogs({
+                runner: selfAddress
+              }),
+              Effect.andThen(() => {
+                releasingShards.delete(shardId)
+              })
+            ),
+          { concurrency: "unbounded", discard: true }
+        )
+      )
+    )
+  }
+
+  const clearSelfShards = Effect.suspend(() => {
+    selfShards.clear()
+    return activeShardsLatch.open
+  })
+
+  // --- Singletons ---
+
+  const singletons = new Map<ShardId, MutableHashMap.MutableHashMap<SingletonAddress, Effect.Effect<void>>>()
+  const singletonFibers = yield* FiberMap.make<SingletonAddress>()
+  const withSingletonLock = Effect.unsafeMakeSemaphore(1).withPermits(1)
+
+  const registerSingleton: Sharding["Type"]["registerSingleton"] = Effect.fnUntraced(
+    function*(name, run) {
+      const address = new SingletonAddress({
+        shardId: getShardId(EntityId.make(name)),
+        name
+      })
+
+      let map = singletons.get(address.shardId)
+      if (!map) {
+        map = MutableHashMap.empty()
+        singletons.set(address.shardId, map)
+      }
+      if (MutableHashMap.has(map, address)) {
+        return yield* Effect.dieMessage(`Singleton '${name}' is already registered`)
+      }
+
+      const context = yield* Effect.context<never>()
+      const wrappedRun = run.pipe(
+        Effect.locally(FiberRef.currentLogAnnotations, HashMap.empty()),
+        Effect.andThen(Effect.never),
+        Effect.scoped,
+        Effect.provide(context),
+        Effect.orDie,
+        Effect.interruptible
+      ) as Effect.Effect<never>
+      MutableHashMap.set(map, address, wrappedRun)
+
+      yield* PubSub.publish(events, SingletonRegistered({ address }))
+
+      // start if we are on the right shard
+      if (acquiredShards.has(address.shardId)) {
+        yield* Effect.logDebug("Starting singleton", address)
+        yield* FiberMap.run(singletonFibers, address, wrappedRun)
+      }
+    },
+    withSingletonLock
+  )
+
+  const syncSingletons = withSingletonLock(Effect.gen(function*() {
+    for (const [shardId, map] of singletons) {
+      for (const [address, run] of map) {
+        const running = FiberMap.unsafeHas(singletonFibers, address)
+        const shouldBeRunning = acquiredShards.has(shardId)
+        if (running && !shouldBeRunning) {
+          yield* Effect.logDebug("Stopping singleton", address)
+          internalInterruptors.add(yield* Effect.fiberId)
+          yield* FiberMap.remove(singletonFibers, address)
+        } else if (!running && shouldBeRunning) {
+          yield* Effect.logDebug("Starting singleton", address)
+          yield* FiberMap.run(singletonFibers, address, run)
+        }
+      }
+    }
+  }))
+
+  // --- Storage inbox ---
+
+  const storageReadLatch = yield* Effect.makeLatch(true)
+  const openStorageReadLatch = constant(storageReadLatch.open)
+
+  const storageReadLock = Effect.unsafeMakeSemaphore(1)
+  const withStorageReadLock = storageReadLock.withPermits(1)
+
+  if (storageEnabled && Option.isSome(config.runnerAddress)) {
+    const selfAddress = config.runnerAddress.value
+
+    yield* Effect.gen(function*() {
+      yield* Effect.logDebug("Starting")
+      yield* Effect.addFinalizer(() => Effect.logDebug("Shutting down"))
+
+      // keep track of the last sent request ids to avoid duplicates
+      // we only keep the last 30 sets to avoid memory leaks
+      const sentRequestIds = new Set<Snowflake.Snowflake>()
+      const sentRequestIdSets = new Set<Set<Snowflake.Snowflake>>()
+
+      while (true) {
+        // wait for the next poll interval, or if we get notified of a change
+        yield* storageReadLatch.await
+
+        // if we get notified of a change, ensure we start a read immediately
+        // next iteration
+        storageReadLatch.unsafeClose()
+
+        // the lock is used to ensure resuming entities have a garantee that no
+        // more items are added to the unprocessed set while the semaphore is
+        // acquired.
+        yield* storageReadLock.take(1)
+
+        const messages = yield* storage.unprocessedMessages(acquiredShards)
+        const currentSentRequestIds = new Set<Snowflake.Snowflake>()
+        sentRequestIdSets.add(currentSentRequestIds)
+
+        const send = Effect.catchAllCause(
+          Effect.suspend(() => {
+            const message = messages[index]
+            if (message._tag === "IncomingRequest") {
+              if (sentRequestIds.has(message.envelope.requestId)) {
+                return Effect.void
+              }
+              sentRequestIds.add(message.envelope.requestId)
+              currentSentRequestIds.add(message.envelope.requestId)
+            }
+            const address = message.envelope.address
+            const state = entityManagers.get(address.entityType)
+            if (!state || !acquiredShards.has(address.shardId)) {
+              return Effect.void
+            }
+
+            const isProcessing = state.manager.isProcessingFor(message)
+
+            // If the message might affect a currently processing request, we
+            // send it to the entity manager to be processed.
+            if (message._tag === "IncomingEnvelope" && isProcessing) {
+              return state.manager.send(message)
+            } else if (isProcessing) {
+              return Effect.void
+            }
+
+            // If the entity was resuming in another fiber, we add the message
+            // id to the unprocessed set.
+            const resumptionState = MutableHashMap.get(entityResumptionState, address)
+            if (Option.isSome(resumptionState)) {
+              resumptionState.value.unprocessed.add(message.envelope.requestId)
+              if (message.envelope._tag === "Interrupt") {
+                resumptionState.value.interrupts.set(message.envelope.requestId, message as Message.IncomingEnvelope)
+              }
+              return Effect.void
+            }
+            return state.manager.send(message)
+          }),
+          (cause) => {
+            const message = messages[index]
+            const error = Cause.failureOption(cause)
+            // if we get a defect, then update storage
+            if (Option.isNone(error)) {
+              return storage.saveReply(Reply.ReplyWithContext.fromDefect({
+                id: snowflakeGen.unsafeNext(),
+                requestId: message.envelope.requestId,
+                defect: Cause.squash(cause)
+              }))
+            }
+            if (error.value._tag === "MailboxFull") {
+              // MailboxFull can only happen for requests, so this cast is safe
+              return resumeEntityFromStorage(message as Message.IncomingRequest<any>)
+            }
+            return Effect.void
+          }
+        )
+
+        let index = 0
+        yield* Effect.whileLoop({
+          while: () => index < messages.length,
+          step: () => index++,
+          body: constant(send)
+        })
+
+        // let the resuming entities check if they are done
+        yield* storageReadLock.release(1)
+
+        while (sentRequestIdSets.size > 30) {
+          const oldest = Iterable.unsafeHead(sentRequestIdSets)
+          sentRequestIdSets.delete(oldest)
+          for (const id of oldest) {
+            sentRequestIds.delete(id)
+          }
+        }
+      }
+    }).pipe(
+      Effect.scoped,
+      Effect.ensuring(storageReadLock.releaseAll),
+      Effect.catchAllCause((cause) => Effect.logWarning("Could not read messages from storage", cause)),
+      Effect.repeat(Schedule.spaced(config.entityMessagePollInterval)),
+      Effect.annotateLogs({
+        package: "@effect/cluster",
+        module: "Sharding",
+        fiber: "Storage read loop",
+        runner: selfAddress
+      }),
+      Effect.interruptible,
+      Effect.forkIn(shardingScope)
+    )
+
+    // open the storage latch every poll interval
+    yield* storageReadLatch.open.pipe(
+      Effect.delay(config.entityMessagePollInterval),
+      Effect.forever,
+      Effect.interruptible,
+      Effect.forkIn(shardingScope)
+    )
+
+    // Resume unprocessed messages for entities that reached a full mailbox.
+    const entityResumptionState = MutableHashMap.empty<EntityAddress, {
+      unprocessed: Set<Snowflake.Snowflake>
+      interrupts: Map<Snowflake.Snowflake, Message.IncomingEnvelope>
+    }>()
+    const resumeEntityFromStorage = (lastReceivedMessage: Message.IncomingRequest<any>) => {
+      const address = lastReceivedMessage.envelope.address
+      const resumptionState = MutableHashMap.get(entityResumptionState, address)
+      if (Option.isSome(resumptionState)) {
+        resumptionState.value.unprocessed.add(lastReceivedMessage.envelope.requestId)
+        return Effect.void
+      }
+      MutableHashMap.set(entityResumptionState, address, {
+        unprocessed: new Set([lastReceivedMessage.envelope.requestId]),
+        interrupts: new Map()
+      })
+      return resumeEntityFromStorageImpl(address)
+    }
+    const resumeEntityFromStorageImpl = Effect.fnUntraced(
+      function*(address: EntityAddress) {
+        const state = entityManagers.get(address.entityType)
+        if (!state) {
+          MutableHashMap.remove(entityResumptionState, address)
+          return
+        }
+
+        const resumptionState = Option.getOrThrow(MutableHashMap.get(entityResumptionState, address))
+        let done = false
+
+        while (!done) {
+          // if the shard is no longer assigned to this runner, we stop
+          if (!acquiredShards.has(address.shardId)) {
+            return
+          }
+
+          // take a batch of unprocessed messages ids
+          const messageIds = Arr.empty<Snowflake.Snowflake>()
+          for (const id of resumptionState.unprocessed) {
+            if (messageIds.length === 1024) break
+            messageIds.push(id)
+          }
+
+          const messages = yield* storage.unprocessedMessagesById(messageIds)
+
+          // this should not happen, but we handle it just in case
+          if (messages.length === 0) {
+            yield* Effect.sleep(config.entityMessagePollInterval)
+            continue
+          }
+
+          let index = 0
+
+          const sendWithRetry: Effect.Effect<
+            void,
+            EntityNotManagedByRunner
+          > = Effect.catchTags(
+            Effect.suspend(() => {
+              if (!acquiredShards.has(address.shardId)) {
+                return Effect.fail(new EntityNotManagedByRunner({ address }))
+              }
+
+              const message = messages[index]
+              // check if this is a request that was interrupted
+              const interrupt = message._tag === "IncomingRequest" &&
+                resumptionState.interrupts.get(message.envelope.requestId)
+              return interrupt ?
+                Effect.flatMap(state.manager.send(message), () => {
+                  resumptionState.interrupts.delete(message.envelope.requestId)
+                  return state.manager.send(interrupt)
+                }) :
+                state.manager.send(message)
+            }),
+            {
+              MailboxFull: () => Effect.delay(sendWithRetry, config.sendRetryInterval),
+              AlreadyProcessingMessage: () => Effect.void
+            }
+          )
+
+          yield* Effect.whileLoop({
+            while: () => index < messages.length,
+            body: constant(sendWithRetry),
+            step: () => index++
+          })
+
+          for (const id of messageIds) {
+            resumptionState.unprocessed.delete(id)
+          }
+          if (resumptionState.unprocessed.size > 0) continue
+
+          // if we have caught up to the main storage loop, we let it take over
+          yield* withStorageReadLock(Effect.sync(() => {
+            if (resumptionState.unprocessed.size === 0) {
+              MutableHashMap.remove(entityResumptionState, address)
+              done = true
+            }
+          }))
+        }
+      },
+      Effect.retry({
+        while: (e) => e._tag === "PersistenceError",
+        schedule: Schedule.spaced(config.entityMessagePollInterval)
+      }),
+      Effect.catchAllCause((cause) => Effect.logError("Could not resume unprocessed messages", cause)),
+      (effect, address) =>
+        Effect.annotateLogs(effect, {
+          package: "@effect/cluster",
+          module: "Sharding",
+          fiber: "Resuming unprocessed messages",
+          runner: selfAddress,
+          entity: address
+        }),
+      (effect, address) =>
+        Effect.ensuring(
+          effect,
+          Effect.sync(() => MutableHashMap.remove(entityResumptionState, address))
+        ),
+      Effect.interruptible,
+      Effect.forkIn(shardingScope)
+    )
+  }
+
+  // --- Sending messages ---
+
+  const sendLocal = (
+    message: Message.Outgoing<any> | Message.Incoming<any>
+  ): Effect.Effect<
+    void,
+    EntityNotManagedByRunner | MailboxFull | AlreadyProcessingMessage
+  > =>
+    Effect.suspend(() => {
+      const address = message.envelope.address
+      if (!isEntityOnLocalShards(address)) {
+        return Effect.fail(new EntityNotManagedByRunner({ address }))
+      }
+      const state = entityManagers.get(address.entityType)
+      if (!state) {
+        return Effect.fail(new EntityNotManagedByRunner({ address }))
+      }
+
+      return message._tag === "IncomingRequest" || message._tag === "IncomingEnvelope" ?
+        state.manager.send(message) :
+        runners.sendLocal({
+          message,
+          send: state.manager.sendLocal,
+          simulateRemoteSerialization: config.simulateRemoteSerialization
+        })
+    })
+
+  const notifyLocal = (message: Message.Outgoing<any> | Message.Incoming<any>, discard: boolean) =>
+    Effect.suspend(() => {
+      const address = message.envelope.address
+      if (!isEntityOnLocalShards(address)) {
+        return Effect.fail(new EntityNotManagedByRunner({ address }))
+      }
+
+      const notify = storageEnabled
+        ? openStorageReadLatch
+        : () => Effect.dieMessage("Sharding.notifyLocal: storage is disabled")
+
+      return message._tag === "IncomingRequest" || message._tag === "IncomingEnvelope"
+        ? notify()
+        : runners.notifyLocal({ message, notify, discard })
+    })
+
+  const isTransientError = Predicate.or(RunnerUnavailable.is, EntityNotManagedByRunner.is)
+  function sendOutgoing(
+    message: Message.Outgoing<any>,
+    discard: boolean,
+    retries?: number
+  ): Effect.Effect<void, MailboxFull | AlreadyProcessingMessage | PersistenceError> {
+    return Effect.catchIf(
+      Effect.suspend(() => {
+        const address = message.envelope.address
+        const maybeRunner = MutableHashMap.get(shardAssignments, address.shardId)
+        if (Option.isNone(maybeRunner)) {
+          return Effect.fail(new EntityNotManagedByRunner({ address }))
+        }
+        const runner = maybeRunner.value
+        const rpc = message.rpc as any as Rpc.AnyWithProps
+        if (storageEnabled && Context.get(rpc.annotations, Persisted)) {
+          return isLocalRunner(runner)
+            ? notifyLocal(message, discard)
+            : runners.notify({ address: runner, message, discard })
+        }
+        return isLocalRunner(runner)
+          ? sendLocal(message)
+          : runners.send({ address: runner, message })
+      }),
+      isTransientError,
+      (error) => {
+        if (retries === 0) {
+          return Effect.die(error)
+        }
+        return Effect.delay(sendOutgoing(message, discard, retries && retries - 1), config.sendRetryInterval)
+      }
+    )
+  }
+
+  // --- Shard Manager sync ---
+
+  const shardManagerTimeoutFiber = yield* FiberHandle.make().pipe(
+    Scope.extend(shardingScope)
+  )
+  const startShardManagerTimeout = FiberHandle.run(
+    shardManagerTimeoutFiber,
+    Effect.flatMap(Effect.sleep(config.shardManagerUnavailableTimeout), () => {
+      MutableHashMap.clear(shardAssignments)
+      return clearSelfShards
+    }),
+    { onlyIfMissing: true }
+  )
+  const stopShardManagerTimeout = FiberHandle.clear(shardManagerTimeoutFiber)
+
+  // Every time the link to the shard manager is lost, we re-register the runner
+  // and re-subscribe to sharding events
+  yield* Effect.gen(function*() {
+    yield* Effect.logDebug("Registering with shard manager")
+    if (Option.isSome(config.runnerAddress)) {
+      const machineId = yield* shardManager.register(config.runnerAddress.value)
+      yield* snowflakeGen.setMachineId(machineId)
+    }
+
+    yield* stopShardManagerTimeout
+
+    yield* Effect.logDebug("Subscribing to sharding events")
+    const mailbox = yield* shardManager.shardingEvents
+    const startedLatch = yield* Effect.makeLatch(false)
+
+    const eventsFiber = yield* Effect.gen(function*() {
+      while (true) {
+        const [events] = yield* mailbox.takeAll
+        for (const event of events) {
+          yield* Effect.logDebug("Received sharding event", event)
+
+          switch (event._tag) {
+            case "StreamStarted": {
+              yield* startedLatch.open
+              break
+            }
+            case "ShardsAssigned": {
+              for (const shard of event.shards) {
+                MutableHashMap.set(shardAssignments, shard, event.address)
+              }
+              if (!MutableRef.get(isShutdown) && isLocalRunner(event.address)) {
+                for (const shardId of event.shards) {
+                  if (selfShards.has(shardId)) continue
+                  selfShards.add(shardId)
+                }
+                yield* activeShardsLatch.open
+              }
+              break
+            }
+            case "ShardsUnassigned": {
+              for (const shard of event.shards) {
+                MutableHashMap.remove(shardAssignments, shard)
+              }
+              if (isLocalRunner(event.address)) {
+                for (const shard of event.shards) {
+                  selfShards.delete(shard)
+                }
+                yield* activeShardsLatch.open
+              }
+              break
+            }
+          }
+        }
+      }
+    }).pipe(Effect.forkScoped)
+
+    // Wait for the stream to be established
+    yield* startedLatch.await
+
+    // perform a full sync every config.refreshAssignmentsInterval
+    const syncFiber = yield* syncAssignments.pipe(
+      Effect.andThen(Effect.sleep(config.refreshAssignmentsInterval)),
+      Effect.forever,
+      Effect.forkScoped
+    )
+
+    yield* Fiber.joinAll([eventsFiber, syncFiber])
+  }).pipe(
+    Effect.scoped,
+    Effect.catchAllCause((cause) => Effect.logDebug(cause)),
+    Effect.zipRight(startShardManagerTimeout),
+    Effect.repeat(
+      Schedule.exponential(1000).pipe(
+        Schedule.union(Schedule.spaced(10_000))
+      )
+    ),
+    Effect.annotateLogs({
+      package: "@effect/cluster",
+      module: "Sharding",
+      fiber: "ShardManager sync",
+      runner: config.runnerAddress
+    }),
+    Effect.interruptible,
+    Effect.forkIn(shardingScope)
+  )
+
+  const syncAssignments = Effect.gen(function*() {
+    const assignments = yield* shardManager.getAssignments
+    yield* Effect.logDebug("Received shard assignments", assignments)
+
+    for (const [shardId, runner] of assignments) {
+      if (Option.isNone(runner)) {
+        MutableHashMap.remove(shardAssignments, shardId)
+        selfShards.delete(shardId)
+        continue
+      }
+
+      MutableHashMap.set(shardAssignments, shardId, runner.value)
+
+      if (!isLocalRunner(runner.value)) {
+        selfShards.delete(shardId)
+        continue
+      }
+      if (MutableRef.get(isShutdown) || selfShards.has(shardId)) {
+        continue
+      }
+      selfShards.add(shardId)
+    }
+
+    yield* activeShardsLatch.open
+  })
+
+  // --- Clients ---
+
+  type ClientRequestEntry = {
+    readonly rpc: Rpc.AnyWithProps
+    readonly context: Context.Context<never>
+    lastChunkId?: Snowflake.Snowflake
+  }
+  const clientRequests = new Map<Snowflake.Snowflake, ClientRequestEntry>()
+
+  const clients: ResourceMap<
+    Entity<any>,
+    (entityId: string) => RpcClient.RpcClient<any, MailboxFull | AlreadyProcessingMessage>,
+    never
+  > = yield* ResourceMap.make(Effect.fnUntraced(function*(entity: Entity<any>) {
+    const client = yield* RpcClient.makeNoSerialization(entity.protocol, {
+      supportsAck: true,
+      generateRequestId: () => RequestId(snowflakeGen.unsafeNext()),
+      onFromClient(options): Effect.Effect<void, MailboxFull | AlreadyProcessingMessage | PersistenceError> {
+        const address = Context.unsafeGet(options.context, ClientAddressTag)
+        switch (options.message._tag) {
+          case "Request": {
+            const fiber = Option.getOrThrow(Fiber.getCurrentFiber())
+            const id = Snowflake.Snowflake(options.message.id)
+            const rpc = entity.protocol.requests.get(options.message.tag)!
+            let respond: (reply: Reply.Reply<any>) => Effect.Effect<void>
+            if (!options.discard) {
+              const entry: ClientRequestEntry = {
+                rpc: rpc as any,
+                context: fiber.currentContext
+              }
+              clientRequests.set(id, entry)
+              respond = makeClientRespond(entry, client.write)
+            } else {
+              respond = clientRespondDiscard
+            }
+            return sendOutgoing(
+              new Message.OutgoingRequest({
+                envelope: Envelope.makeRequest({
+                  requestId: id,
+                  address,
+                  tag: options.message.tag,
+                  payload: options.message.payload,
+                  headers: options.message.headers,
+                  traceId: options.message.traceId,
+                  spanId: options.message.spanId,
+                  sampled: options.message.sampled
+                }),
+                lastReceivedReply: Option.none(),
+                rpc,
+                context: fiber.currentContext as Context.Context<any>,
+                respond
+              }),
+              options.discard
+            )
+          }
+          case "Ack": {
+            const requestId = Snowflake.Snowflake(options.message.requestId)
+            const entry = clientRequests.get(requestId)
+            if (!entry) return Effect.void
+            return sendOutgoing(
+              new Message.OutgoingEnvelope({
+                envelope: new Envelope.AckChunk({
+                  id: snowflakeGen.unsafeNext(),
+                  address,
+                  requestId,
+                  replyId: entry.lastChunkId!
+                }),
+                rpc: entry.rpc
+              }),
+              false
+            )
+          }
+          case "Interrupt": {
+            const requestId = Snowflake.Snowflake(options.message.requestId)
+            const entry = clientRequests.get(requestId)!
+            if (!entry) return Effect.void
+            clientRequests.delete(requestId)
+            // for durable messages, we ignore interrupts on shutdown or as a
+            // result of a shard being resassigned
+            const isTransientInterrupt = MutableRef.get(isShutdown) ||
+              options.message.interruptors.some((id) => internalInterruptors.has(id))
+            if (isTransientInterrupt && storageEnabled && Context.get(entry.rpc.annotations, Persisted)) {
+              return Effect.void
+            }
+            return Effect.ignore(sendOutgoing(
+              new Message.OutgoingEnvelope({
+                envelope: new Envelope.Interrupt({
+                  id: snowflakeGen.unsafeNext(),
+                  address,
+                  requestId
+                }),
+                rpc: entry.rpc
+              }),
+              false,
+              3
+            ))
+          }
+        }
+        return Effect.void
+      }
+    })
+
+    const wrappedClient: any = {}
+    for (const method of Object.keys(client.client)) {
+      wrappedClient[method] = function(this: any, payload: any, options?: {
+        readonly context?: Context.Context<never>
+      }) {
+        return (client as any).client[method](payload, {
+          ...options,
+          context: options?.context
+            ? Context.merge(options.context, this[currentClientAddress])
+            : this[currentClientAddress]
+        })
+      }
+    }
+
+    yield* Scope.addFinalizer(
+      yield* Effect.scope,
+      Effect.withFiberRuntime((fiber) => {
+        internalInterruptors.add(fiber.id())
+        return Effect.void
+      })
+    )
+
+    return (entityId: string) => {
+      const id = EntityId.make(entityId)
+      return {
+        ...wrappedClient,
+        [currentClientAddress]: ClientAddressTag.context(EntityAddress.make({
+          shardId: getShardId(id),
+          entityId: id,
+          entityType: entity.type
+        }))
+      }
+    }
+  }))
+
+  const makeClient = <Rpcs extends Rpc.Any>(entity: Entity<Rpcs>): Effect.Effect<
+    (entityId: string) => RpcClient.RpcClient<Rpcs, MailboxFull | AlreadyProcessingMessage>
+  > => clients.get(entity)
+
+  const clientRespondDiscard = (_reply: Reply.Reply<any>) => Effect.void
+
+  const makeClientRespond = (
+    entry: ClientRequestEntry,
+    write: (reply: FromServer<any>) => Effect.Effect<void>
+  ) =>
+  (reply: Reply.Reply<any>) => {
+    switch (reply._tag) {
+      case "Chunk": {
+        entry.lastChunkId = reply.id
+        return write({
+          _tag: "Chunk",
+          clientId: 0,
+          requestId: RequestId(reply.requestId),
+          values: reply.values
+        })
+      }
+      case "WithExit": {
+        clientRequests.delete(reply.requestId)
+        return write({
+          _tag: "Exit",
+          clientId: 0,
+          requestId: RequestId(reply.requestId),
+          exit: reply.exit
+        })
+      }
+    }
+  }
+
+  // --- Entities ---
+
+  const context = yield* Effect.context<ShardingConfig>()
+  const reaper = yield* EntityReaper
+  const registerEntity: Sharding["Type"]["registerEntity"] = Effect.fnUntraced(
+    function*(entity, build, options) {
+      if (entityManagers.has(entity.type)) return
+      const scope = yield* Scope.make()
+      const manager = yield* EntityManager.make(entity, build, {
+        ...options,
+        storage,
+        runnerAddress: Option.getOrThrow(config.runnerAddress),
+        sharding
+      }).pipe(
+        Effect.provide(context.pipe(
+          Context.add(EntityReaper, reaper),
+          Context.add(Scope.Scope, scope),
+          Context.add(Snowflake.Generator, snowflakeGen)
+        ))
+      ) as Effect.Effect<EntityManager.EntityManager>
+      entityManagers.set(entity.type, {
+        entity,
+        scope,
+        manager
+      })
+
+      yield* Scope.addFinalizer(scope, Effect.sync(() => entityManagers.delete(entity.type)))
+      yield* PubSub.publish(events, EntityRegistered({ entity }))
+    }
+  )
+
+  yield* Scope.addFinalizerExit(
+    shardingScope,
+    (exit) =>
+      Effect.forEach(
+        entityManagers.values(),
+        (state) =>
+          Effect.catchAllCause(Scope.close(state.scope, exit), (cause) =>
+            Effect.annotateLogs(Effect.logError("Error closing entity manager", cause), {
+              entity: state.entity.type
+            })),
+        { concurrency: "unbounded", discard: true }
+      )
+  )
+
+  // --- Finalization ---
+
+  if (Option.isSome(config.runnerAddress)) {
+    const selfAddress = config.runnerAddress.value
+    // Unregister runner from shard manager when scope is closed
+    yield* Scope.addFinalizer(
+      shardingScope,
+      Effect.gen(function*() {
+        yield* Effect.logDebug("Unregistering runner from shard manager", selfAddress)
+        yield* shardManager.unregister(selfAddress).pipe(
+          Effect.catchAllCause((cause) => Effect.logError("Error calling unregister with shard manager", cause))
+        )
+        yield* clearSelfShards
+      })
+    )
+  }
+
+  yield* Scope.addFinalizer(
+    shardingScope,
+    Effect.withFiberRuntime((fiber) => {
+      MutableRef.set(isShutdown, true)
+      internalInterruptors.add(fiber.id())
+      return Effect.void
+    })
+  )
+
+  const sharding = Sharding.of({
+    getRegistrationEvents,
+    getShardId,
+    isShutdown: Effect.sync(() => MutableRef.get(isShutdown)),
+    registerEntity,
+    registerSingleton,
+    makeClient,
+    send: sendLocal,
+    notify: (message) => notifyLocal(message, false)
+  })
+
+  return sharding
+})
 
 /**
- * Gets the list of shardIds assigned to the current Pod
- *
  * @since 1.0.0
- * @category utils
+ * @category layers
  */
-export const getAssignedShardIds: Effect.Effect<HashSet.HashSet<ShardId.ShardId>, never, Sharding> =
-  internal.getAssignedShardIds
+export const layer: Layer.Layer<
+  Sharding,
+  never,
+  ShardingConfig | Runners | ShardManagerClient | MessageStorage.MessageStorage | ShardStorage
+> = Layer.scoped(Sharding, make).pipe(
+  Layer.provide([Snowflake.layerGenerator, EntityReaper.Default])
+)
+
+// Utilities
+
+const ClientAddressTag = Context.GenericTag<EntityAddress>("@effect/cluster/Sharding/ClientAddress")
+const currentClientAddress = Symbol.for(ClientAddressTag.key)
diff --git a/src/ShardingConfig.ts b/src/ShardingConfig.ts
index 1c0f83aea7604ac84ceb43340a1d95904d1e876b..74ab6d8cc12fd976bcbfab29dd3d1ce14430559c 100644
--- a/src/ShardingConfig.ts
+++ b/src/ShardingConfig.ts
@@ -1,76 +1,217 @@
 /**
  * @since 1.0.0
  */
-import type * as ConfigError from "effect/ConfigError"
-import type * as Context from "effect/Context"
-import type * as Duration from "effect/Duration"
-import type * as Layer from "effect/Layer"
-import * as internal from "./internal/shardingConfig.js"
+import * as Config from "effect/Config"
+import type { ConfigError } from "effect/ConfigError"
+import * as ConfigProvider from "effect/ConfigProvider"
+import * as Context from "effect/Context"
+import type { DurationInput } from "effect/Duration"
+import * as Duration from "effect/Duration"
+import * as Effect from "effect/Effect"
+import * as Layer from "effect/Layer"
+import * as Option from "effect/Option"
+import { RunnerAddress } from "./RunnerAddress.js"
 
 /**
+ * Represents the configuration for the `Sharding` service on a given runner.
+ *
  * @since 1.0.0
- * @category symbols
+ * @category models
  */
-export const ShardingConfigTypeId: unique symbol = internal.ShardingConfigTypeId
+export class ShardingConfig extends Context.Tag("@effect/cluster/ShardingConfig")<ShardingConfig, {
+  /**
+   * The address for the current runner.
+   *
+   * If `None`, the runner is not part of the cluster and will be in a client-only
+   * mode.
+   */
+  readonly runnerAddress: Option.Option<RunnerAddress>
+  /**
+   * The version of the current runner.
+   */
+  readonly serverVersion: number
+  /**
+   * The number of shards to allocate to a runner.
+   *
+   * **Note**: this value should be consistent across all runners.
+   */
+  readonly numberOfShards: number
+  /**
+   * The address of the shard manager.
+   */
+  readonly shardManagerAddress: RunnerAddress
+  /**
+   * If the shard manager is unavailable for this duration, all the shard
+   * assignments will be reset.
+   */
+  readonly shardManagerUnavailableTimeout: DurationInput
+  /**
+   * The default capacity of the mailbox for entities.
+   */
+  readonly entityMailboxCapacity: number | "unbounded"
+  /**
+   * The maximum duration of inactivity (i.e. without receiving a message)
+   * after which an entity will be interrupted.
+   */
+  readonly entityMaxIdleTime: DurationInput
+  /**
+   * The maximum duration of time to wait for an entity to terminate.
+   *
+   * By default this is set to 15 seconds to stay within kubernetes defaults.
+   */
+  readonly entityTerminationTimeout: DurationInput
+  /**
+   * The interval at which to poll for unprocessed messages from storage.
+   */
+  readonly entityMessagePollInterval: DurationInput
+  /**
+   * The interval at which to poll for client replies from storage.
+   */
+  readonly entityReplyPollInterval: DurationInput
+  readonly refreshAssignmentsInterval: DurationInput
+  /**
+   * The interval to retry a send if EntityNotManagedByRunner is returned.
+   */
+  readonly sendRetryInterval: DurationInput
+  // readonly unhealthyRunnerReportInterval: Duration.Duration
+  /**
+   * Simulate serialization and deserialization to remote runners for local
+   * entities.
+   */
+  readonly simulateRemoteSerialization: boolean
+}>() {}
+
+const defaultRunnerAddress = RunnerAddress.make({ host: "localhost", port: 34431 })
 
 /**
  * @since 1.0.0
- * @category symbols
+ * @category defaults
  */
-export type ShardingConfigTypeId = typeof ShardingConfigTypeId
+export const defaults: ShardingConfig["Type"] = {
+  runnerAddress: Option.some(defaultRunnerAddress),
+  serverVersion: 1,
+  numberOfShards: 300,
+  shardManagerAddress: RunnerAddress.make({ host: "localhost", port: 8080 }),
+  shardManagerUnavailableTimeout: Duration.minutes(10),
+  entityMailboxCapacity: 4096,
+  entityMaxIdleTime: Duration.minutes(1),
+  entityTerminationTimeout: Duration.seconds(15),
+  entityMessagePollInterval: Duration.seconds(10),
+  entityReplyPollInterval: Duration.millis(200),
+  sendRetryInterval: Duration.millis(100),
+  refreshAssignmentsInterval: Duration.minutes(5),
+  simulateRemoteSerialization: true
+}
 
 /**
- * Sharding configuration
- * @param numberOfShards number of shards (see documentation on how to choose this), should be same on all nodes
- * @param selfHost hostname or IP address of the current pod
- * @param shardingPort port used for pods to communicate together
- * @param shardManagerUri url of the Shard Manager API
- * @param serverVersion version of the current pod
- * @param entityMaxIdleTime time of inactivity (without receiving any message) after which an entity will be interrupted
- * @param entityTerminationTimeout time we give to an entity to handle the termination message before interrupting it
- * @param refreshAssignmentsRetryInterval retry interval in case of failure getting shard assignments from storage
- * @param unhealthyPodReportInterval interval to report unhealthy pods to the Shard Manager (this exists to prevent calling the Shard Manager for each failed message)
  * @since 1.0.0
- * @category models
+ * @category Layers
  */
-export interface ShardingConfig {
-  readonly numberOfShards: number
-  readonly selfHost: string
-  readonly shardingPort: number
-  readonly shardManagerUri: string
-  readonly serverVersion: string
-  readonly entityMaxIdleTime: Duration.Duration
-  readonly entityTerminationTimeout: Duration.Duration
-  readonly refreshAssignmentsRetryInterval: Duration.Duration
-  readonly unhealthyPodReportInterval: Duration.Duration
-}
+export const layer = (options?: Partial<ShardingConfig["Type"]>): Layer.Layer<ShardingConfig> =>
+  Layer.succeed(ShardingConfig, { ...defaults, ...options })
 
 /**
  * @since 1.0.0
- * @category context
+ * @category defaults
  */
-export const ShardingConfig: Context.Tag<ShardingConfig, ShardingConfig> = internal.shardingConfigTag
+export const layerDefaults: Layer.Layer<ShardingConfig> = layer()
 
 /**
- * Provides the default values for the ShardingConfig.
- *
  * @since 1.0.0
- * @category layers
+ * @category Config
  */
-export const defaults: Layer.Layer<ShardingConfig> = internal.defaults
+export const config: Config.Config<ShardingConfig["Type"]> = Config.all({
+  runnerAddress: Config.all({
+    host: Config.string("host").pipe(
+      Config.withDefault(defaultRunnerAddress.host),
+      Config.withDescription("The hostname or IP address of the runner.")
+    ),
+    port: Config.integer("port").pipe(
+      Config.withDefault(defaultRunnerAddress.port),
+      Config.withDescription("The port used for inter-runner communication.")
+    )
+  }).pipe(Config.map((options) => RunnerAddress.make(options)), Config.option),
+  serverVersion: Config.integer("serverVersion").pipe(
+    Config.withDefault(defaults.serverVersion),
+    Config.withDescription("The version of the current runner.")
+  ),
+  numberOfShards: Config.integer("numberOfShards").pipe(
+    Config.withDefault(defaults.numberOfShards),
+    Config.withDescription("The number of shards to allocate to a runner.")
+  ),
+  shardManagerAddress: Config.all({
+    host: Config.string("shardManagerHost").pipe(
+      Config.withDefault(defaults.shardManagerAddress.host),
+      Config.withDescription("The host of the shard manager.")
+    ),
+    port: Config.integer("shardManagerPort").pipe(
+      Config.withDefault(defaults.shardManagerAddress.port),
+      Config.withDescription("The port of the shard manager.")
+    )
+  }).pipe(Config.map((options) => RunnerAddress.make(options))),
+  shardManagerUnavailableTimeout: Config.duration("shardManagerUnavailableTimeout").pipe(
+    Config.withDefault(defaults.shardManagerUnavailableTimeout),
+    Config.withDescription(
+      "If the shard is unavilable for this duration, all the shard assignments will be reset."
+    )
+  ),
+  entityMailboxCapacity: Config.integer("entityMailboxCapacity").pipe(
+    Config.withDefault(defaults.entityMailboxCapacity),
+    Config.withDescription("The default capacity of the mailbox for entities.")
+  ),
+  entityMaxIdleTime: Config.duration("entityMaxIdleTime").pipe(
+    Config.withDefault(defaults.entityMaxIdleTime),
+    Config.withDescription(
+      "The maximum duration of inactivity (i.e. without receiving a message) after which an entity will be interrupted."
+    )
+  ),
+  entityTerminationTimeout: Config.duration("entityTerminationTimeout").pipe(
+    Config.withDefault(defaults.entityTerminationTimeout),
+    Config.withDescription("The maximum duration of time to wait for an entity to terminate.")
+  ),
+  entityMessagePollInterval: Config.duration("entityMessagePollInterval").pipe(
+    Config.withDefault(defaults.entityMessagePollInterval),
+    Config.withDescription("The interval at which to poll for unprocessed messages from storage.")
+  ),
+  entityReplyPollInterval: Config.duration("entityReplyPollInterval").pipe(
+    Config.withDefault(defaults.entityReplyPollInterval),
+    Config.withDescription("The interval at which to poll for client replies from storage.")
+  ),
+  sendRetryInterval: Config.duration("sendRetryInterval").pipe(
+    Config.withDefault(defaults.sendRetryInterval),
+    Config.withDescription("The interval to retry a send if EntityNotManagedByRunner is returned.")
+  ),
+  refreshAssignmentsInterval: Config.duration("refreshAssignmentsInterval").pipe(
+    Config.withDefault(defaults.refreshAssignmentsInterval),
+    Config.withDescription("The interval at which to refresh shard assignments.")
+  ),
+  simulateRemoteSerialization: Config.boolean("simulateRemoteSerialization").pipe(
+    Config.withDefault(defaults.simulateRemoteSerialization),
+    Config.withDescription("Simulate serialization and deserialization to remote runners for local entities.")
+  )
+})
 
 /**
- * Provides the ShardingConfig, values that are omitted will be read from the defaults
- *
  * @since 1.0.0
- * @category layers
+ * @category Config
  */
-export const withDefaults: (customs: Partial<ShardingConfig>) => Layer.Layer<ShardingConfig> = internal.withDefaults
+export const configFromEnv = config.pipe(
+  Effect.withConfigProvider(
+    ConfigProvider.fromEnv().pipe(
+      ConfigProvider.constantCase
+    )
+  )
+)
 
 /**
- * Reads the ShardingConfig from the effect/ConfigProvider
- *
  * @since 1.0.0
- * @category layers
+ * @category Layers
  */
-export const fromConfig: Layer.Layer<ShardingConfig, ConfigError.ConfigError> = internal.fromConfig
+export const layerFromEnv = (options?: Partial<ShardingConfig["Type"]> | undefined): Layer.Layer<
+  ShardingConfig,
+  ConfigError
+> =>
+  Layer.effect(
+    ShardingConfig,
+    options ? Effect.map(configFromEnv, (config) => ({ ...config, ...options })) : configFromEnv
+  )
diff --git a/src/ShardingRegistrationEvent.ts b/src/ShardingRegistrationEvent.ts
index 49a0d50a15c4d0a906b7524e21e8d0cb5b093a5a..fa37f2c2d84dbcf52a00b3c9ee99a756f17d690d 100644
--- a/src/ShardingRegistrationEvent.ts
+++ b/src/ShardingRegistrationEvent.ts
@@ -1,62 +1,61 @@
 /**
  * @since 1.0.0
  */
-import type * as Message from "./Message.js"
-import type * as RecipientType from "./RecipientType.js"
-
-interface EntityRegistered<Msg extends Message.Message.Any> {
-  _tag: "EntityRegistered"
-  entityType: RecipientType.EntityType<Msg>
-}
+import * as Data from "effect/Data"
+import type { Entity } from "./Entity.js"
+import type { SingletonAddress } from "./SingletonAddress.js"
 
 /**
- * Constructs and event that occurs when a new EntityType gets registered.
+ * Represents events that can occur when a runner registers entities or singletons.
  *
  * @since 1.0.0
- * @category constructors
+ * @category models
  */
-export function EntityRegistered<Msg extends Message.Message.Any>(
-  entityType: RecipientType.EntityType<Msg>
-): ShardingRegistrationEvent {
-  return ({ _tag: "EntityRegistered", entityType })
-}
-
-interface SingletonRegistered {
-  _tag: "SingletonRegistered"
-  name: string
-}
+export type ShardingRegistrationEvent =
+  | EntityRegistered
+  | SingletonRegistered
 
 /**
- * Constructs a new event that occurs when a new Singleton is registered.
+ * Represents an event that occurs when a new entity is registered with a runner.
  *
  * @since 1.0.0
- * @category constructors
+ * @category models
  */
-export function SingletonRegistered(name: string): ShardingRegistrationEvent {
-  return ({ _tag: "SingletonRegistered", name })
-}
-
-interface TopicRegistered<Msg extends Message.Message.Any> {
-  _tag: "TopicRegistered"
-  topicType: RecipientType.TopicType<Msg>
+export interface EntityRegistered {
+  readonly _tag: "EntityRegistered"
+  readonly entity: Entity<any>
 }
 
 /**
- * Constructs a new event that occurs when a topic is Registered.
+ * Represents an event that occurs when a new singleton is registered with a
+ * runner.
+ *
  * @since 1.0.0
- * @category constructors
+ * @category models
  */
-export function TopicRegistered<Msg extends Message.Message.Any>(
-  topicType: RecipientType.TopicType<Msg>
-): ShardingRegistrationEvent {
-  return ({ _tag: "TopicRegistered", topicType })
+export interface SingletonRegistered {
+  readonly _tag: "SingletonRegistered"
+  readonly address: SingletonAddress
 }
 
 /**
  * @since 1.0.0
- * @category models
+ * @category pattern matching
  */
-export type ShardingRegistrationEvent =
-  | EntityRegistered<any>
-  | SingletonRegistered
-  | TopicRegistered<any>
+export const {
+  /**
+   * @since 1.0.0
+   * @category pattern matching
+   */
+  $match: match,
+  /**
+   * @since 1.0.0
+   * @category constructors
+   */
+  EntityRegistered,
+  /**
+   * @since 1.0.0
+   * @category constructors
+   */
+  SingletonRegistered
+} = Data.taggedEnum<ShardingRegistrationEvent>()
diff --git a/src/Singleton.ts b/src/Singleton.ts
new file mode 100644
index 0000000000000000000000000000000000000000..213b75a669170a55d9c0ae11e1b8df5a1a16d578
--- /dev/null
+++ b/src/Singleton.ts
@@ -0,0 +1,20 @@
+/**
+ * @since 1.0.0
+ */
+import * as Effect from "effect/Effect"
+import * as Layer from "effect/Layer"
+import type { Scope } from "effect/Scope"
+import { Sharding } from "./Sharding.js"
+
+/**
+ * @since 1.0.0
+ * @category constructors
+ */
+export const make = <E, R>(
+  name: string,
+  run: Effect.Effect<void, E, R>
+): Layer.Layer<never, never, Sharding | Exclude<R, Scope>> =>
+  Layer.effectDiscard(Effect.gen(function*() {
+    const sharding = yield* Sharding
+    yield* sharding.registerSingleton(name, run)
+  }))
diff --git a/src/SingletonAddress.ts b/src/SingletonAddress.ts
new file mode 100644
index 0000000000000000000000000000000000000000..72313a348afff1c40a9254239e4f574fb75c4030
--- /dev/null
+++ b/src/SingletonAddress.ts
@@ -0,0 +1,47 @@
+/**
+ * @since 1.0.0
+ */
+import * as Equal from "effect/Equal"
+import * as Hash from "effect/Hash"
+import * as Schema from "effect/Schema"
+import { ShardId } from "./ShardId.js"
+
+/**
+ * @since 1.0.0
+ * @category Address
+ */
+export const TypeId: unique symbol = Symbol.for("@effect/cluster/SingletonAddress")
+
+/**
+ * @since 1.0.0
+ * @category Address
+ */
+export type TypeId = typeof TypeId
+
+/**
+ * Represents the unique address of an singleton within the cluster.
+ *
+ * @since 1.0.0
+ * @category Address
+ */
+export class SingletonAddress extends Schema.Class<SingletonAddress>("@effect/cluster/SingletonAddress")({
+  shardId: ShardId,
+  name: Schema.NonEmptyTrimmedString
+}) {
+  /**
+   * @since 1.0.0
+   */
+  readonly [TypeId] = TypeId;
+  /**
+   * @since 1.0.0
+   */
+  [Hash.symbol]() {
+    return Hash.cached(this)(Hash.string(`${this.shardId}:${this.name}`))
+  }
+  /**
+   * @since 1.0.0
+   */
+  [Equal.symbol](that: SingletonAddress): boolean {
+    return this.shardId === that.shardId && this.name === that.name
+  }
+}
diff --git a/src/Snowflake.ts b/src/Snowflake.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3da190f12b7713fa32d333f37367d91a1caeceea
--- /dev/null
+++ b/src/Snowflake.ts
@@ -0,0 +1,194 @@
+/**
+ * @since 1.0.0
+ */
+import type * as Brand from "effect/Brand"
+import * as Context from "effect/Context"
+import * as DateTime from "effect/DateTime"
+import * as Effect from "effect/Effect"
+import { identity } from "effect/Function"
+import * as Layer from "effect/Layer"
+import * as Schema from "effect/Schema"
+import type { MachineId } from "./MachineId.js"
+
+/**
+ * @since 1.0.0
+ * @category Symbols
+ */
+export const TypeId: unique symbol = Symbol.for("@effect/cluster/Snowflake")
+
+/**
+ * @since 1.0.0
+ * @category Symbols
+ */
+export type TypeId = typeof TypeId
+
+/**
+ * @since 1.0.0
+ * @category Models
+ */
+export type Snowflake = Brand.Branded<bigint, TypeId>
+
+/**
+ * @since 1.0.0
+ * @category Models
+ */
+export const Snowflake = (input: string | bigint): Snowflake =>
+  typeof input === "string" ? BigInt(input) as Snowflake : input as Snowflake
+
+/**
+ * @since 1.0.0
+ * @category Models
+ */
+export declare namespace Snowflake {
+  /**
+   * @since 1.0.0
+   * @category Models
+   */
+  export interface Parts {
+    readonly timestamp: number
+    readonly machineId: MachineId
+    readonly sequence: number
+  }
+
+  /**
+   * @since 1.0.0
+   * @category Models
+   */
+  export interface Generator {
+    readonly unsafeNext: () => Snowflake
+    readonly setMachineId: (machineId: MachineId) => Effect.Effect<void>
+  }
+}
+
+/**
+ * @since 1.0.0
+ * @category Schemas
+ */
+export const SnowflakeFromBigInt: Schema.Schema<Snowflake, bigint> = Schema.BigIntFromSelf.pipe(
+  Schema.brand(TypeId)
+)
+
+/**
+ * @since 1.0.0
+ * @category Schemas
+ */
+export const SnowflakeFromString: Schema.Schema<Snowflake, string> = Schema.BigInt.pipe(
+  Schema.brand(TypeId)
+)
+
+/**
+ * @since 1.0.0
+ * @category Epoch
+ */
+export const constEpochMillis: number = Date.UTC(2025, 0, 1)
+
+const sinceUnixEpoch = constEpochMillis - Date.UTC(1970, 0, 1)
+const constBigInt12 = BigInt(12)
+const constBigInt22 = BigInt(22)
+const constBigInt1024 = BigInt(1024)
+const constBigInt4096 = BigInt(4096)
+
+/**
+ * @since 1.0.0
+ * @category constructors
+ */
+export const make = (options: {
+  readonly machineId: MachineId
+  readonly sequence: number
+  readonly timestamp: number
+}): Snowflake =>
+  (BigInt(options.timestamp - constEpochMillis) << constBigInt22
+    | (BigInt(options.machineId % 1024) << constBigInt12)
+    | BigInt(options.sequence % 4096)) as Snowflake
+
+/**
+ * @since 1.0.0
+ * @category Parts
+ */
+export const timestamp = (snowflake: Snowflake): number => Number(snowflake >> constBigInt22) + sinceUnixEpoch
+
+/**
+ * @since 1.0.0
+ * @category Parts
+ */
+export const dateTime = (snowflake: Snowflake): DateTime.Utc => DateTime.unsafeMake(timestamp(snowflake))
+
+/**
+ * @since 1.0.0
+ * @category Parts
+ */
+export const machineId = (snowflake: Snowflake): MachineId =>
+  Number((snowflake >> constBigInt12) % constBigInt1024) as MachineId
+
+/**
+ * @since 1.0.0
+ * @category Parts
+ */
+export const sequence = (snowflake: Snowflake): number => Number(snowflake % constBigInt4096)
+
+/**
+ * @since 1.0.0
+ * @category Parts
+ */
+export const toParts = (snowflake: Snowflake): Snowflake.Parts => ({
+  timestamp: timestamp(snowflake),
+  machineId: machineId(snowflake),
+  sequence: sequence(snowflake)
+})
+
+/**
+ * @since 1.0.0
+ * @category Generator
+ */
+export const makeGenerator: Effect.Effect<Snowflake.Generator> = Effect.gen(function*() {
+  let machineId = Math.floor(Math.random() * 1024) as MachineId
+  const clock = yield* Effect.clock
+
+  let sequence = 0
+  let sequenceAt = clock.unsafeCurrentTimeMillis()
+
+  return identity<Snowflake.Generator>({
+    setMachineId: (newMachineId) =>
+      Effect.sync(() => {
+        machineId = newMachineId
+      }),
+    unsafeNext() {
+      let now = clock.unsafeCurrentTimeMillis()
+
+      // account for clock drift, only allow time to move forward
+      if (now < sequenceAt) {
+        now = sequenceAt
+      } else if (now > sequenceAt) {
+        // reset sequence if we're in a new millisecond
+        sequence = 0
+        sequenceAt = now
+      } else if (sequence >= 1024) {
+        // if we've hit the max sequence for this millisecond, go to the next
+        // millisecond
+        sequenceAt++
+        sequence = 0
+      }
+
+      return make({
+        machineId,
+        sequence: sequence++,
+        timestamp: sequenceAt
+      })
+    }
+  })
+})
+
+/**
+ * @since 1.0.0
+ * @category Generator
+ */
+export class Generator extends Context.Tag("@effect/cluster/Snowflake/Generator")<
+  Generator,
+  Snowflake.Generator
+>() {}
+
+/**
+ * @since 1.0.0
+ * @category Generator
+ */
+export const layerGenerator: Layer.Layer<Generator> = Layer.effect(Generator, makeGenerator)
diff --git a/src/SocketRunner.ts b/src/SocketRunner.ts
new file mode 100644
index 0000000000000000000000000000000000000000..51dd0c68b5dcd82ae916586da26d2fd2a33c5053
--- /dev/null
+++ b/src/SocketRunner.ts
@@ -0,0 +1,59 @@
+/**
+ * @since 1.0.0
+ */
+import { SocketServer } from "@effect/platform/SocketServer"
+import type * as RpcSerialization from "@effect/rpc/RpcSerialization"
+import * as RpcServer from "@effect/rpc/RpcServer"
+import * as Effect from "effect/Effect"
+import * as Layer from "effect/Layer"
+import type { MessageStorage } from "./MessageStorage.js"
+import * as Runners from "./Runners.js"
+import * as RunnerServer from "./RunnerServer.js"
+import * as Sharding from "./Sharding.js"
+import type { ShardingConfig } from "./ShardingConfig.js"
+import * as ShardManager from "./ShardManager.js"
+import * as ShardStorage from "./ShardStorage.js"
+
+const withLogAddress = <A, E, R>(layer: Layer.Layer<A, E, R>): Layer.Layer<A, E, R | SocketServer> =>
+  Layer.effectDiscard(Effect.gen(function*() {
+    const server = yield* SocketServer
+    const address = server.address._tag === "UnixAddress"
+      ? server.address.path
+      : `${server.address.hostname}:${server.address.port}`
+    yield* Effect.annotateLogs(Effect.logInfo(`Listening on: ${address}`), {
+      package: "@effect/cluster",
+      service: "Runner"
+    })
+  })).pipe(Layer.provideMerge(layer))
+
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layer: Layer.Layer<
+  Sharding.Sharding | Runners.Runners,
+  never,
+  | Runners.RpcClientProtocol
+  | ShardingConfig
+  | RpcSerialization.RpcSerialization
+  | SocketServer
+  | MessageStorage
+  | ShardStorage.ShardStorage
+> = RunnerServer.layerWithClients.pipe(
+  withLogAddress,
+  Layer.provide(RpcServer.layerProtocolSocketServer)
+)
+
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layerClientOnly: Layer.Layer<
+  Sharding.Sharding | Runners.Runners,
+  never,
+  Runners.RpcClientProtocol | ShardingConfig | MessageStorage
+> = Sharding.layer.pipe(
+  Layer.provideMerge(Runners.layerRpc),
+  Layer.provide(ShardManager.layerClientRpc),
+  Layer.provide(ShardStorage.layerNoop)
+)
diff --git a/src/SocketShardManager.ts b/src/SocketShardManager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3db1fe4499404b3dc52821969656f89c2cbce564
--- /dev/null
+++ b/src/SocketShardManager.ts
@@ -0,0 +1,48 @@
+/**
+ * @since 1.0.0
+ */
+import { SocketServer } from "@effect/platform/SocketServer"
+import type { RpcSerialization } from "@effect/rpc/RpcSerialization"
+import * as RpcServer from "@effect/rpc/RpcServer"
+import * as Effect from "effect/Effect"
+import * as Layer from "effect/Layer"
+import * as MessageStorage from "./MessageStorage.js"
+import type { RunnerHealth } from "./RunnerHealth.js"
+import * as Runners from "./Runners.js"
+import type { ShardingConfig } from "./ShardingConfig.js"
+import * as ShardManager from "./ShardManager.js"
+import type { ShardStorage } from "./ShardStorage.js"
+
+const withLogAddress = <A, E, R>(layer: Layer.Layer<A, E, R>): Layer.Layer<A, E, R | SocketServer> =>
+  Layer.effectDiscard(Effect.gen(function*() {
+    const server = yield* SocketServer
+    const address = server.address._tag === "UnixAddress"
+      ? server.address.path
+      : `${server.address.hostname}:${server.address.port}`
+    yield* Effect.annotateLogs(Effect.logInfo(`Listening on: ${address}`), {
+      package: "@effect/cluster",
+      service: "ShardManager"
+    })
+  })).pipe(Layer.provideMerge(layer))
+
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layer: Layer.Layer<
+  ShardManager.ShardManager,
+  never,
+  | ShardStorage
+  | SocketServer
+  | Runners.RpcClientProtocol
+  | RpcSerialization
+  | RunnerHealth
+  | ShardManager.Config
+  | ShardingConfig
+> = ShardManager.layerServer.pipe(
+  withLogAddress,
+  Layer.provide(RpcServer.layerProtocolSocketServer),
+  Layer.provideMerge(ShardManager.layer),
+  Layer.provide(Runners.layerRpc),
+  Layer.provide(MessageStorage.layerNoop)
+)
diff --git a/src/SqlMessageStorage.ts b/src/SqlMessageStorage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8f988b6daa71014fff32594bccf3c0db2a0b2030
--- /dev/null
+++ b/src/SqlMessageStorage.ts
@@ -0,0 +1,833 @@
+/**
+ * @since 1.0.0
+ */
+import * as SqlClient from "@effect/sql/SqlClient"
+import type { Row } from "@effect/sql/SqlConnection"
+import type { SqlError } from "@effect/sql/SqlError"
+import * as Arr from "effect/Array"
+import type { DurationInput } from "effect/Duration"
+import * as Effect from "effect/Effect"
+import * as Layer from "effect/Layer"
+import * as Option from "effect/Option"
+import * as Schedule from "effect/Schedule"
+import { PersistenceError } from "./ClusterError.js"
+import type * as Envelope from "./Envelope.js"
+import * as MessageStorage from "./MessageStorage.js"
+import { SaveResultEncoded } from "./MessageStorage.js"
+import type * as Reply from "./Reply.js"
+import type { ShardingConfig } from "./ShardingConfig.js"
+import * as Snowflake from "./Snowflake.js"
+
+/**
+ * @since 1.0.0
+ * @category Constructors
+ */
+export const make = Effect.fnUntraced(function*(options?: {
+  readonly prefix?: string | undefined
+}) {
+  const sql = (yield* SqlClient.SqlClient).withoutTransforms()
+  const prefix = options?.prefix ?? "cluster"
+  const table = (name: string) => `${prefix}_${name}`
+
+  const messageKindAckChunk = sql.literal(String(messageKind.AckChunk))
+  const replyKindWithExit = sql.literal(String(replyKind.WithExit))
+
+  const messagesTable = table("messages")
+  const messagesTableSql = sql(messagesTable)
+
+  const repliesTable = table("replies")
+  const repliesTableSql = sql(repliesTable)
+
+  yield* sql.onDialectOrElse({
+    mssql: () =>
+      sql`
+        IF OBJECT_ID(N'${messagesTableSql}', N'U') IS NULL
+        CREATE TABLE ${messagesTableSql} (
+          id BIGINT PRIMARY KEY,
+          rowid BIGINT IDENTITY(1,1),
+          message_id VARCHAR(255),
+          shard_id INT NOT NULL,
+          entity_type VARCHAR(255) NOT NULL,
+          entity_id VARCHAR(255) NOT NULL,
+          kind INT NOT NULL,
+          tag VARCHAR(255),
+          payload TEXT,
+          headers TEXT,
+          trace_id VARCHAR(255),
+          span_id VARCHAR(255),
+          sampled BIT,
+          processed BIT NOT NULL DEFAULT 0,
+          request_id BIGINT NOT NULL,
+          reply_id BIGINT,
+          last_reply_id BIGINT,
+          last_read DATETIME,
+          deliver_at BIGINT,
+          UNIQUE (message_id),
+          FOREIGN KEY (request_id) REFERENCES ${messagesTableSql} (id) ON DELETE CASCADE
+        )
+      `,
+    mysql: () =>
+      sql`
+        CREATE TABLE IF NOT EXISTS ${messagesTableSql} (
+          id BIGINT NOT NULL,
+          rowid BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,
+          message_id VARCHAR(255),
+          shard_id INT NOT NULL,
+          entity_type VARCHAR(255) NOT NULL,
+          entity_id VARCHAR(255) NOT NULL,
+          kind INT NOT NULL,
+          tag VARCHAR(255),
+          payload TEXT,
+          headers TEXT,
+          trace_id VARCHAR(255),
+          span_id VARCHAR(255),
+          sampled BOOLEAN,
+          processed BOOLEAN NOT NULL DEFAULT FALSE,
+          request_id BIGINT NOT NULL,
+          reply_id BIGINT,
+          last_reply_id BIGINT,
+          last_read DATETIME,
+          deliver_at BIGINT,
+          UNIQUE (id),
+          UNIQUE (message_id),
+          FOREIGN KEY (request_id) REFERENCES ${messagesTableSql} (id) ON DELETE CASCADE
+        )
+      `,
+    pg: () =>
+      sql`
+        CREATE TABLE IF NOT EXISTS ${messagesTableSql} (
+          id BIGINT PRIMARY KEY,
+          rowid BIGSERIAL,
+          message_id VARCHAR(255),
+          shard_id INT NOT NULL,
+          entity_type VARCHAR(255) NOT NULL,
+          entity_id VARCHAR(255) NOT NULL,
+          kind INT NOT NULL,
+          tag VARCHAR(255),
+          payload TEXT,
+          headers TEXT,
+          trace_id VARCHAR(255),
+          span_id VARCHAR(255),
+          sampled BOOLEAN,
+          processed BOOLEAN NOT NULL DEFAULT FALSE,
+          request_id BIGINT NOT NULL,
+          reply_id BIGINT,
+          last_reply_id BIGINT,
+          last_read TIMESTAMP,
+          deliver_at BIGINT,
+          UNIQUE (message_id),
+          FOREIGN KEY (request_id) REFERENCES ${messagesTableSql} (id) ON DELETE CASCADE
+        )
+      `.pipe(Effect.ignore),
+    orElse: () =>
+      // sqlite
+      sql`
+        CREATE TABLE IF NOT EXISTS ${messagesTableSql} (
+          id INTEGER PRIMARY KEY,
+          message_id TEXT,
+          shard_id INTEGER NOT NULL,
+          entity_type TEXT NOT NULL,
+          entity_id TEXT NOT NULL,
+          kind INTEGER NOT NULL,
+          tag TEXT,
+          payload TEXT,
+          headers TEXT,
+          trace_id TEXT,
+          span_id TEXT,
+          sampled BOOLEAN,
+          processed BOOLEAN NOT NULL DEFAULT FALSE,
+          request_id INTEGER NOT NULL,
+          reply_id INTEGER,
+          last_reply_id INTEGER,
+          last_read TEXT,
+          deliver_at INTEGER,
+          UNIQUE (message_id),
+          FOREIGN KEY (request_id) REFERENCES ${messagesTableSql} (id) ON DELETE CASCADE
+        )
+      `
+  })
+
+  // Add message indexes optimized for the specific query patterns
+  const shardLookupIndex = `${messagesTable}_shard_idx`
+  const requestIdLookupIndex = `${messagesTable}_request_id_idx`
+  yield* sql.onDialectOrElse({
+    mssql: () =>
+      sql`
+        IF NOT EXISTS (SELECT * FROM sys.indexes WHERE name = ${shardLookupIndex})
+        CREATE INDEX ${sql(shardLookupIndex)} 
+        ON ${messagesTableSql} (shard_id, processed, last_read, deliver_at);
+
+        IF NOT EXISTS (SELECT * FROM sys.indexes WHERE name = ${requestIdLookupIndex})
+        CREATE INDEX ${sql(requestIdLookupIndex)}
+        ON ${messagesTableSql} (request_id);
+      `,
+    mysql: () =>
+      sql`
+        CREATE INDEX ${sql(shardLookupIndex)}
+        ON ${messagesTableSql} (shard_id, processed, last_read, deliver_at);
+
+        CREATE INDEX ${sql(requestIdLookupIndex)}
+        ON ${messagesTableSql} (request_id);
+      `.unprepared.pipe(Effect.ignore),
+    pg: () =>
+      sql`
+        CREATE INDEX IF NOT EXISTS ${sql(shardLookupIndex)}
+        ON ${messagesTableSql} (shard_id, processed, last_read, deliver_at);
+
+        CREATE INDEX IF NOT EXISTS ${sql(requestIdLookupIndex)}
+        ON ${messagesTableSql} (request_id);
+      `.pipe(
+        Effect.tapDefect((error) =>
+          Effect.annotateLogs(Effect.logDebug("Failed to create indexes", error), {
+            package: "@effect/cluster",
+            module: "SqlMessageStorage"
+          })
+        ),
+        Effect.retry({
+          schedule: Schedule.spaced(1000)
+        })
+      ),
+    orElse: () =>
+      // sqlite
+      Effect.all([
+        sql`
+          CREATE INDEX IF NOT EXISTS ${sql(shardLookupIndex)}
+          ON ${messagesTableSql} (shard_id, processed, last_read, deliver_at)
+        `,
+        sql`
+          CREATE INDEX IF NOT EXISTS ${sql(requestIdLookupIndex)}
+          ON ${messagesTableSql} (request_id)
+        `
+      ]).pipe(sql.withTransaction)
+  })
+
+  yield* sql.onDialectOrElse({
+    mssql: () =>
+      sql`
+        IF OBJECT_ID(N'${repliesTableSql}', N'U') IS NULL
+        CREATE TABLE ${repliesTableSql} (
+          id BIGINT PRIMARY KEY,
+          rowid BIGINT IDENTITY(1,1),
+          kind INT,
+          request_id BIGINT NOT NULL,
+          payload TEXT NOT NULL,
+          sequence INT,
+          acked BIT NOT NULL DEFAULT 0,
+          CONSTRAINT ${sql(repliesTable + "_one_exit")} UNIQUE (request_id, kind),
+          CONSTRAINT ${sql(repliesTable + "_sequence")} UNIQUE (request_id, sequence),
+          FOREIGN KEY (request_id) REFERENCES ${messagesTableSql} (id) ON DELETE CASCADE
+        )
+      `,
+    mysql: () =>
+      sql`
+        CREATE TABLE IF NOT EXISTS ${repliesTableSql} (
+          id BIGINT NOT NULL,
+          rowid BIGINT AUTO_INCREMENT PRIMARY KEY,
+          kind INT,
+          request_id BIGINT NOT NULL,
+          payload TEXT NOT NULL,
+          sequence INT,
+          acked BOOLEAN NOT NULL DEFAULT FALSE,
+          UNIQUE (id),
+          UNIQUE (request_id, kind),
+          UNIQUE (request_id, sequence),
+          FOREIGN KEY (request_id) REFERENCES ${messagesTableSql} (id) ON DELETE CASCADE
+        )
+      `,
+    pg: () =>
+      sql`
+        CREATE TABLE IF NOT EXISTS ${repliesTableSql} (
+          id BIGINT PRIMARY KEY,
+          rowid BIGSERIAL,
+          kind INT,
+          request_id BIGINT NOT NULL,
+          payload TEXT NOT NULL,
+          sequence INT,
+          acked BOOLEAN NOT NULL DEFAULT FALSE,
+          UNIQUE (request_id, kind),
+          UNIQUE (request_id, sequence),
+          FOREIGN KEY (request_id) REFERENCES ${messagesTableSql} (id) ON DELETE CASCADE
+        )
+      `,
+    orElse: () =>
+      // sqlite
+      sql`
+        CREATE TABLE IF NOT EXISTS ${repliesTableSql} (
+          id INTEGER PRIMARY KEY,
+          kind INTEGER,
+          request_id INTEGER NOT NULL,
+          payload TEXT NOT NULL,
+          sequence INTEGER,
+          acked BOOLEAN NOT NULL DEFAULT FALSE,
+          UNIQUE (request_id, kind),
+          UNIQUE (request_id, sequence),
+          FOREIGN KEY (request_id) REFERENCES ${messagesTableSql} (id) ON DELETE CASCADE
+        )
+      `
+  })
+
+  // Add reply indexes optimized for request_id lookups
+  const replyLookupIndex = `${repliesTable}_request_lookup_idx`
+  yield* sql.onDialectOrElse({
+    mssql: () =>
+      sql`
+        IF NOT EXISTS (SELECT * FROM sys.indexes WHERE name = ${replyLookupIndex})
+        CREATE INDEX ${sql(replyLookupIndex)}
+        ON ${repliesTableSql} (request_id, kind, acked);
+      `,
+    mysql: () =>
+      sql`
+        CREATE INDEX ${sql(replyLookupIndex)}
+        ON ${repliesTableSql} (request_id, kind, acked);
+      `.unprepared.pipe(Effect.ignore),
+    pg: () =>
+      sql`
+        CREATE INDEX IF NOT EXISTS ${sql(replyLookupIndex)}
+        ON ${repliesTableSql} (request_id, kind, acked);
+`.pipe(
+        Effect.tapDefect((error) =>
+          Effect.annotateLogs(Effect.logDebug("Failed to create indexes", error), {
+            package: "@effect/cluster",
+            module: "SqlMessageStorage"
+          })
+        ),
+        Effect.retry({
+          schedule: Schedule.spaced(1000)
+        })
+      ),
+    orElse: () =>
+      // sqlite
+      sql`
+        CREATE INDEX IF NOT EXISTS ${sql(replyLookupIndex)}
+        ON ${repliesTableSql} (request_id, kind, acked);
+      `
+  })
+
+  const envelopeToRow = (
+    envelope: Envelope.Envelope.Encoded,
+    message_id: string | null,
+    deliver_at: number | null
+  ): MessageRow => {
+    switch (envelope._tag) {
+      case "Request":
+        return {
+          id: envelope.requestId,
+          message_id,
+          shard_id: envelope.address.shardId,
+          entity_type: envelope.address.entityType,
+          entity_id: envelope.address.entityId,
+          kind: messageKind.Request,
+          tag: envelope.tag,
+          payload: JSON.stringify(envelope.payload),
+          headers: JSON.stringify(envelope.headers),
+          trace_id: envelope.traceId,
+          span_id: envelope.spanId,
+          sampled: supportsBooleans ? envelope.sampled : envelope.sampled ? 1 : 0,
+          request_id: envelope.requestId,
+          reply_id: null,
+          deliver_at
+        }
+      case "AckChunk":
+        return {
+          id: envelope.id,
+          message_id,
+          shard_id: envelope.address.shardId,
+          entity_type: envelope.address.entityType,
+          entity_id: envelope.address.entityId,
+          kind: messageKind.AckChunk,
+          tag: null,
+          payload: null,
+          headers: null,
+          trace_id: null,
+          span_id: null,
+          sampled: null,
+          request_id: envelope.requestId,
+          reply_id: envelope.replyId,
+          deliver_at
+        }
+      case "Interrupt":
+        return {
+          id: envelope.id,
+          message_id,
+          shard_id: envelope.address.shardId,
+          entity_type: envelope.address.entityType,
+          entity_id: envelope.address.entityId,
+          kind: messageKind.Interrupt,
+          payload: null,
+          tag: null,
+          headers: null,
+          trace_id: null,
+          span_id: null,
+          sampled: null,
+          request_id: envelope.requestId,
+          reply_id: null,
+          deliver_at
+        }
+    }
+  }
+
+  const replyToRow = (reply: Reply.ReplyEncoded<any>): ReplyRow => ({
+    id: reply.id,
+    kind: replyKind[reply._tag],
+    request_id: reply.requestId,
+    payload: reply._tag === "WithExit" ? JSON.stringify(reply.exit) : JSON.stringify(reply.values),
+    sequence: reply._tag === "Chunk" ? reply.sequence : null
+  })
+
+  const supportsBooleans = sql.onDialectOrElse({
+    mssql: () => false,
+    sqlite: () => false,
+    orElse: () => true
+  })
+
+  const messageFromRow = (row: MessageRow & ReplyJoinRow): {
+    readonly envelope: Envelope.Envelope.Encoded
+    readonly lastSentReply: Option.Option<Reply.ReplyEncoded<any>>
+  } => {
+    switch (Number(row.kind) as 0 | 1 | 2) {
+      case 0:
+        return {
+          envelope: {
+            _tag: "Request",
+            requestId: String(row.id),
+            address: {
+              shardId: Number(row.shard_id),
+              entityType: row.entity_type,
+              entityId: row.entity_id
+            },
+            tag: row.tag!,
+            payload: JSON.parse(row.payload!),
+            headers: JSON.parse(row.headers!),
+            traceId: row.trace_id!,
+            spanId: row.span_id!,
+            sampled: !!row.sampled
+          },
+          lastSentReply: row.reply_reply_id ?
+            Option.some({
+              _tag: "Chunk",
+              id: String(row.reply_reply_id),
+              requestId: String(row.request_id),
+              sequence: Number(row.reply_sequence!),
+              values: JSON.parse(row.reply_payload!)
+            } as any) :
+            Option.none()
+        }
+      case 1:
+        return {
+          envelope: {
+            _tag: "AckChunk",
+            id: String(row.id),
+            requestId: String(row.request_id!),
+            replyId: String(row.reply_id!),
+            address: {
+              shardId: Number(row.shard_id),
+              entityType: row.entity_type,
+              entityId: row.entity_id
+            }
+          },
+          lastSentReply: Option.none()
+        }
+      case 2:
+        return {
+          envelope: {
+            _tag: "Interrupt",
+            id: String(row.id),
+            requestId: String(row.request_id!),
+            address: {
+              shardId: Number(row.shard_id),
+              entityType: row.entity_type,
+              entityId: row.entity_id
+            }
+          },
+          lastSentReply: Option.none()
+        }
+    }
+  }
+
+  const sqlFalse = sql.literal(supportsBooleans ? "FALSE" : "0")
+  const sqlTrue = sql.literal(supportsBooleans ? "TRUE" : "1")
+
+  const insertEnvelope: (
+    row: MessageRow,
+    message_id: string
+  ) => Effect.Effect<ReadonlyArray<Row>, SqlError> = sql.onDialectOrElse({
+    pg: () => (row, message_id) =>
+      sql`
+        WITH inserted AS (
+          INSERT INTO ${messagesTableSql} ${sql.insert(row)}
+          ON CONFLICT (message_id) DO NOTHING
+          RETURNING id
+        ),
+        existing AS (
+          SELECT m.id, r.id as reply_id, r.kind as reply_kind, r.payload as reply_payload, r.sequence as reply_sequence
+          FROM ${messagesTableSql} m
+          LEFT JOIN ${repliesTableSql} r ON r.id = m.last_reply_id
+          WHERE m.message_id = ${message_id}
+          AND NOT EXISTS (SELECT 1 FROM inserted)
+        )
+        SELECT * FROM existing
+      `,
+    mysql: () => (row, message_id) =>
+      sql`
+        SELECT m.id, r.id as reply_id, r.kind as reply_kind, r.payload as reply_payload, r.sequence as reply_sequence
+        FROM ${messagesTableSql} m
+        LEFT JOIN ${repliesTableSql} r ON r.id = m.last_reply_id
+        WHERE m.message_id = ${message_id};
+        INSERT INTO ${messagesTableSql} ${sql.insert(row)}
+        ON DUPLICATE KEY UPDATE id = id;
+      `.unprepared.pipe(
+        // we need 2 queries for mysql, so we need to run them in a
+        // transaction with retries
+        sql.withTransaction,
+        Effect.retry({ times: 3 }),
+        Effect.map(([rows]) => rows as any as ReadonlyArray<Row>)
+      ),
+    mssql: () => (row, message_id) =>
+      sql`
+        MERGE ${messagesTableSql} WITH (HOLDLOCK) AS target
+        USING (SELECT ${message_id} as message_id) AS source
+        ON target.message_id = source.message_id
+        WHEN NOT MATCHED THEN
+          INSERT ${sql.insert(row)}
+        OUTPUT
+          inserted.id,
+          CASE
+            WHEN inserted.id IS NULL THEN (
+              SELECT r.id, r.kind, r.payload
+              FROM ${repliesTableSql} r
+              WHERE r.id = target.last_reply_id
+            )
+          END as reply_id,
+          CASE
+            WHEN inserted.id IS NULL THEN (
+              SELECT r.kind
+              FROM ${repliesTableSql} r
+              WHERE r.id = target.last_reply_id
+            )
+          END as reply_kind,
+          CASE
+            WHEN inserted.id IS NULL THEN (
+              SELECT r.payload
+              FROM ${repliesTableSql} r
+              WHERE r.id = target.last_reply_id
+            )
+          END as reply_payload,
+          CASE
+            WHEN inserted.id IS NULL THEN (
+              SELECT r.sequence
+              FROM ${repliesTableSql} r
+              WHERE r.id = target.last_reply_id
+            )
+          END as reply_sequence;
+      `,
+    orElse: () => (row, message_id) =>
+      sql`
+        SELECT m.id, r.id as reply_id, r.kind as reply_kind, r.payload as reply_payload, r.sequence as reply_sequence
+        FROM ${messagesTableSql} m
+        LEFT JOIN ${repliesTableSql} r ON r.id = m.last_reply_id
+        WHERE m.message_id = ${message_id}
+      `.pipe(
+        Effect.tap(sql`INSERT OR IGNORE INTO ${messagesTableSql} ${sql.insert(row)}`),
+        sql.withTransaction,
+        Effect.retry({ times: 3 })
+      )
+  })
+
+  const fiveMinutesAgo = sql.onDialectOrElse({
+    mssql: () => sql.literal(`DATEADD(MINUTE, -5, GETDATE())`),
+    mysql: () => sql.literal(`NOW() - INTERVAL 5 MINUTE`),
+    pg: () => sql.literal(`NOW() - INTERVAL '5 minutes'`),
+    orElse: () => sql.literal(`DATETIME('now', '-5 minute')`)
+  })
+  const sqlNowString = sql.onDialectOrElse({
+    pg: () => "NOW()",
+    mysql: () => "NOW()",
+    mssql: () => "GETDATE()",
+    orElse: () => "CURRENT_TIMESTAMP"
+  })
+  const sqlNow = sql.literal(sqlNowString)
+
+  const getUnprocessedMessages = sql.onDialectOrElse({
+    pg: () => (shardIds: ReadonlyArray<number>, now: number) =>
+      sql<MessageJoinRow>`
+        UPDATE ${messagesTableSql} m
+        SET last_read = ${sqlNow}
+        FROM (
+          SELECT m.*
+          FROM ${messagesTableSql} m
+          WHERE m.shard_id IN (${sql.literal(shardIds.map(String).join(","))})
+          AND NOT EXISTS (
+            SELECT 1 FROM ${repliesTableSql}
+            WHERE request_id = m.request_id
+            AND (kind = ${replyKindWithExit} OR acked = ${sqlFalse})
+          )
+          AND m.processed = ${sqlFalse}
+          AND (m.last_read IS NULL OR m.last_read < ${fiveMinutesAgo})
+          AND (m.deliver_at IS NULL OR m.deliver_at <= ${sql.literal(String(now))})
+          ORDER BY m.rowid ASC
+          FOR UPDATE
+        ) AS ids
+        LEFT JOIN ${repliesTableSql} r ON r.id = ids.last_reply_id
+        WHERE m.id = ids.id
+        RETURNING ids.*, r.id as reply_reply_id, r.kind as reply_kind, r.payload as reply_payload, r.sequence as reply_sequence
+      `,
+    orElse: () => (shardIds: ReadonlyArray<number>, now: number) =>
+      sql<MessageJoinRow>`
+        SELECT m.*, r.id as reply_reply_id, r.kind as reply_kind, r.payload as reply_payload, r.sequence as reply_sequence
+        FROM ${messagesTableSql} m
+        LEFT JOIN ${repliesTableSql} r ON r.id = m.last_reply_id
+        WHERE m.shard_id IN (${sql.literal(shardIds.map(String).join(","))})
+        AND NOT EXISTS (
+          SELECT 1 FROM ${repliesTableSql}
+          WHERE request_id = m.request_id
+          AND (kind = ${replyKindWithExit} OR acked = ${sqlFalse})
+        )
+        AND processed = ${sqlFalse}
+        AND (m.last_read IS NULL OR m.last_read < ${fiveMinutesAgo})
+        AND (m.deliver_at IS NULL OR m.deliver_at <= ${sql.literal(String(now))})
+        ORDER BY m.rowid ASC
+      `.unprepared.pipe(
+        Effect.tap((rows) => {
+          if (rows.length === 0) {
+            return Effect.void
+          }
+          return sql`
+            UPDATE ${messagesTableSql}
+            SET last_read = ${sqlNow}
+            WHERE id IN (${sql.literal(rows.map((row) => row.id).join(","))})
+          `.unprepared
+        }),
+        sql.withTransaction
+      )
+  })
+
+  return yield* MessageStorage.makeEncoded({
+    saveEnvelope: ({ deliverAt, envelope, primaryKey }) =>
+      Effect.suspend(() => {
+        const row = envelopeToRow(envelope, primaryKey, deliverAt)
+        let insert = primaryKey
+          ? insertEnvelope(row, primaryKey)
+          : Effect.as(sql`INSERT INTO ${messagesTableSql} ${sql.insert(row)}`.unprepared, [])
+        if (envelope._tag === "AckChunk") {
+          insert = sql`UPDATE ${repliesTableSql} SET acked = ${sqlTrue} WHERE id = ${envelope.replyId}`.pipe(
+            Effect.andThen(
+              sql`UPDATE ${messagesTableSql} SET processed = ${sqlTrue} WHERE processed = ${sqlFalse} AND request_id = ${envelope.requestId} AND kind = ${messageKindAckChunk}`
+            ),
+            Effect.andThen(insert),
+            sql.withTransaction
+          )
+        }
+        return insert.pipe(
+          Effect.map((rows) => {
+            if (rows.length === 0) {
+              return SaveResultEncoded.Success()
+            }
+            const row = rows[0]
+            return SaveResultEncoded.Duplicate({
+              originalId: Snowflake.Snowflake(row.id as any),
+              lastReceivedReply: row.reply_id ?
+                Option.some({
+                  id: String(row.reply_id),
+                  requestId: String(row.id),
+                  _tag: row.reply_kind === replyKind.WithExit ? "WithExit" : "Chunk",
+                  ...(row.reply_kind === replyKind.WithExit
+                    ? { exit: JSON.parse(row.reply_payload as string) }
+                    : {
+                      sequence: Number(row.reply_sequence),
+                      values: JSON.parse(row.reply_payload as string)
+                    })
+                } as any) :
+                Option.none()
+            })
+          })
+        )
+      }).pipe(
+        Effect.provideService(SqlClient.SafeIntegers, true),
+        PersistenceError.refail
+      ),
+
+    saveReply: (reply) =>
+      Effect.suspend(() => {
+        const row = replyToRow(reply)
+        const update = reply._tag === "Chunk" ?
+          sql`UPDATE ${messagesTableSql} SET last_reply_id = ${reply.id} WHERE id = ${reply.requestId}` :
+          sql`UPDATE ${messagesTableSql} SET processed = ${sqlTrue}, last_reply_id = NULL WHERE request_id = ${reply.requestId}`
+        return update.unprepared.pipe(
+          Effect.andThen(sql`INSERT INTO ${repliesTableSql} ${sql.insert(row)}`),
+          sql.withTransaction
+        )
+      }).pipe(
+        Effect.asVoid,
+        PersistenceError.refail
+      ),
+
+    repliesFor: (requestIds) =>
+      // replies where:
+      // - the request is in the list
+      // - the kind is WithExit
+      // - or the kind is Chunk and has not been acked yet
+      sql<ReplyRow>`
+        SELECT id, kind, request_id, payload, sequence
+        FROM ${repliesTableSql}
+        WHERE request_id IN (${sql.literal(requestIds.join(","))})
+        AND (
+          kind = ${replyKindWithExit}
+          OR (
+            kind IS NULL
+            AND acked = ${sqlFalse}
+          )
+        )
+        ORDER BY rowid ASC
+      `.unprepared.pipe(
+        Effect.provideService(SqlClient.SafeIntegers, true),
+        Effect.map(Arr.map((row): Reply.ReplyEncoded<any> =>
+          row.kind === replyKind.WithExit ?
+            ({
+              _tag: "WithExit",
+              id: String(row.id),
+              requestId: String(row.request_id),
+              exit: JSON.parse(row.payload)
+            }) :
+            {
+              _tag: "Chunk",
+              id: String(row.id),
+              requestId: String(row.request_id),
+              values: JSON.parse(row.payload),
+              sequence: Number(row.sequence!)
+            }
+        )),
+        PersistenceError.refail
+      ),
+
+    unprocessedMessages: Effect.fnUntraced(
+      function*(shardIds, now) {
+        const rows = yield* getUnprocessedMessages(shardIds, now)
+        if (rows.length === 0) {
+          return []
+        }
+        const messages: Array<{
+          readonly envelope: Envelope.Envelope.Encoded
+          readonly lastSentReply: Option.Option<Reply.ReplyEncoded<any>>
+        }> = new Array(rows.length)
+        const ids = new Array<string>(rows.length)
+        for (let i = 0; i < rows.length; i++) {
+          messages[i] = messageFromRow(rows[i])
+          ids[i] = String(rows[i].id)
+        }
+        return messages
+      },
+      Effect.provideService(SqlClient.SafeIntegers, true),
+      PersistenceError.refail
+    ),
+
+    unprocessedMessagesById(ids, now) {
+      const idArr = Array.from(ids, (id) => String(id))
+      return sql<MessageRow & ReplyJoinRow>`
+        SELECT m.*, r.id as reply_id, r.kind as reply_kind, r.payload as reply_payload, r.sequence as reply_sequence
+        FROM ${messagesTableSql} m
+        LEFT JOIN ${repliesTableSql} r ON r.id = m.last_reply_id
+        WHERE m.id IN (${sql.literal(idArr.join(","))})
+        AND NOT EXISTS (
+          SELECT 1 FROM ${repliesTableSql}
+          WHERE request_id = m.request_id
+          AND (kind = ${replyKindWithExit} OR acked = ${sqlFalse})
+        )
+        AND m.processed = ${sqlFalse}
+        AND (m.deliver_at IS NULL OR m.deliver_at <= ${sql.literal(String(now))})
+        ORDER BY m.rowid ASC
+      `.unprepared.pipe(
+        Effect.map(Arr.map(messageFromRow)),
+        Effect.provideService(SqlClient.SafeIntegers, true),
+        PersistenceError.refail
+      )
+    },
+
+    resetAddress: (address) =>
+      sql`
+        UPDATE ${messagesTableSql}
+        SET last_read = NULL
+        WHERE processed = ${sqlFalse}
+        AND shard_id = ${address.shardId}
+        AND entity_type = ${address.entityType}
+        AND entity_id = ${address.entityId}
+`.pipe(
+        Effect.asVoid,
+        PersistenceError.refail
+      )
+  })
+})
+
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layer: Layer.Layer<
+  MessageStorage.MessageStorage,
+  SqlError,
+  SqlClient.SqlClient | ShardingConfig
+> = Layer.scoped(MessageStorage.MessageStorage, make()).pipe(
+  Layer.provide(Snowflake.layerGenerator)
+)
+
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layerWith = (options: {
+  readonly prefix?: string | undefined
+  readonly replyPollInterval?: DurationInput | undefined
+}): Layer.Layer<MessageStorage.MessageStorage, SqlError, SqlClient.SqlClient | ShardingConfig> =>
+  Layer.scoped(MessageStorage.MessageStorage, make(options)).pipe(
+    Layer.provide(Snowflake.layerGenerator)
+  )
+
+// -------------------------------------------------------------------------------------------------
+// internal
+// -------------------------------------------------------------------------------------------------
+
+const messageKind = {
+  "Request": 0,
+  "AckChunk": 1,
+  "Interrupt": 2
+} as const satisfies Record<Envelope.Envelope.Any["_tag"], number>
+
+const replyKind = {
+  "WithExit": 0,
+  "Chunk": null
+} as const satisfies Record<Reply.Reply<any>["_tag"], number | null>
+
+type MessageRow = {
+  readonly id: string | bigint
+  readonly message_id: string | null
+  readonly shard_id: number | bigint
+  readonly entity_type: string
+  readonly entity_id: string
+  readonly kind: 0 | 1 | 2 | 0n | 1n | 2n
+  readonly tag: string | null
+  readonly payload: string | null
+  readonly headers: string | null
+  readonly trace_id: string | null
+  readonly span_id: string | null
+  readonly sampled: boolean | number | bigint | null
+  readonly request_id: string | bigint | null
+  readonly reply_id: string | bigint | null
+  readonly deliver_at: number | bigint | null
+}
+
+type ReplyRow = {
+  readonly id: string | bigint
+  readonly kind: 0 | null | 0n
+  readonly request_id: string | bigint
+  readonly payload: string
+  readonly sequence: number | bigint | null
+}
+
+type ReplyJoinRow = {
+  readonly reply_reply_id: string | bigint | null
+  readonly reply_payload: string | null
+  readonly reply_sequence: number | bigint | null
+}
+
+type MessageJoinRow = MessageRow & ReplyJoinRow & {
+  readonly sequence: number | bigint
+}
diff --git a/src/SqlShardStorage.ts b/src/SqlShardStorage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2478cd2716be378531a67d133ca36dcf4aafec43
--- /dev/null
+++ b/src/SqlShardStorage.ts
@@ -0,0 +1,292 @@
+/**
+ * @since 1.0.0
+ */
+import * as SqlClient from "@effect/sql/SqlClient"
+import type { SqlError } from "@effect/sql/SqlError"
+import * as Arr from "effect/Array"
+import * as Effect from "effect/Effect"
+import * as Layer from "effect/Layer"
+import { PersistenceError } from "./ClusterError.js"
+import * as ShardStorage from "./ShardStorage.js"
+
+/**
+ * @since 1.0.0
+ * @category Constructors
+ */
+export const make = Effect.fnUntraced(function*(options?: {
+  readonly prefix?: string | undefined
+}) {
+  const sql = (yield* SqlClient.SqlClient).withoutTransforms()
+  const prefix = options?.prefix ?? "cluster"
+  const table = (name: string) => `${prefix}_${name}`
+
+  const runnersTable = table("runners")
+  const runnersTableSql = sql(runnersTable)
+
+  yield* sql.onDialectOrElse({
+    mssql: () =>
+      sql`
+        IF OBJECT_ID(N'${runnersTableSql}', N'U') IS NULL
+        CREATE TABLE ${runnersTableSql} (
+          address VARCHAR(255) PRIMARY KEY,
+          runner TEXT NOT NULL
+        )
+      `,
+    mysql: () =>
+      sql`
+        CREATE TABLE IF NOT EXISTS ${runnersTableSql} (
+          address VARCHAR(255) PRIMARY KEY,
+          runner TEXT NOT NULL
+        )
+      `,
+    pg: () =>
+      sql`
+        CREATE TABLE IF NOT EXISTS ${runnersTableSql} (
+          address VARCHAR(255) PRIMARY KEY,
+          runner TEXT NOT NULL
+        )
+      `,
+    orElse: () =>
+      // sqlite
+      sql`
+        CREATE TABLE IF NOT EXISTS ${runnersTableSql} (
+          address TEXT PRIMARY KEY,
+          runner TEXT NOT NULL
+        )
+      `
+  })
+
+  const shardsTable = table("shards")
+  const shardsTableSql = sql(shardsTable)
+
+  yield* sql.onDialectOrElse({
+    mssql: () =>
+      sql`
+        IF OBJECT_ID(N'${shardsTableSql}', N'U') IS NULL
+        CREATE TABLE ${shardsTableSql} (
+          shard_id INT PRIMARY KEY,
+          address VARCHAR(255)
+        )
+      `,
+    mysql: () =>
+      sql`
+        CREATE TABLE IF NOT EXISTS ${shardsTableSql} (
+          shard_id INT PRIMARY KEY,
+          address VARCHAR(255)
+        )
+      `,
+    pg: () =>
+      sql`
+        CREATE TABLE IF NOT EXISTS ${shardsTableSql} (
+          shard_id INT PRIMARY KEY,
+          address VARCHAR(255)
+        )
+      `,
+    orElse: () =>
+      // sqlite
+      sql`
+        CREATE TABLE IF NOT EXISTS ${shardsTableSql} (
+          shard_id INTEGER PRIMARY KEY,
+          address TEXT
+        )
+      `
+  })
+
+  const locksTable = table("locks")
+  const locksTableSql = sql(locksTable)
+
+  yield* sql.onDialectOrElse({
+    mssql: () =>
+      sql`
+        IF OBJECT_ID(N'${locksTableSql}', N'U') IS NULL
+        CREATE TABLE ${locksTableSql} (
+          shard_id INT PRIMARY KEY,
+          address VARCHAR(255) NOT NULL,
+          acquired_at DATETIME NOT NULL
+        )
+      `,
+    mysql: () =>
+      sql`
+        CREATE TABLE IF NOT EXISTS ${locksTableSql} (
+          shard_id INT PRIMARY KEY,
+          address VARCHAR(255) NOT NULL,
+          acquired_at DATETIME NOT NULL
+        )
+      `,
+    pg: () =>
+      sql`
+        CREATE TABLE IF NOT EXISTS ${locksTableSql} (
+          shard_id INT PRIMARY KEY,
+          address VARCHAR(255) NOT NULL,
+          acquired_at TIMESTAMP NOT NULL
+        )
+      `,
+    orElse: () =>
+      // sqlite
+      sql`
+        CREATE TABLE IF NOT EXISTS ${locksTableSql} (
+          shard_id INTEGER PRIMARY KEY,
+          address TEXT NOT NULL,
+          acquired_at DATETIME NOT NULL
+        )
+      `
+  })
+
+  const sqlNowString = sql.onDialectOrElse({
+    pg: () => "NOW()",
+    mysql: () => "NOW()",
+    mssql: () => "GETDATE()",
+    orElse: () => "CURRENT_TIMESTAMP"
+  })
+  const sqlNow = sql.literal(sqlNowString)
+
+  const lockExpiresAt = sql.onDialectOrElse({
+    pg: () => sql`${sqlNow} - INTERVAL '120 seconds'`,
+    mysql: () => sql`DATE_SUB(${sqlNow}, INTERVAL 120 SECOND)`,
+    mssql: () => sql`DATEADD(SECOND, -120, ${sqlNow})`,
+    orElse: () => sql`datetime(${sqlNow}, '-120 seconds')`
+  })
+
+  const acquireLock = sql.onDialectOrElse({
+    pg: () => (address: string, values: Array<any>) =>
+      sql`
+        INSERT INTO ${locksTableSql} (shard_id, address, acquired_at) VALUES ${sql.csv(values)}
+        ON CONFLICT (shard_id) DO UPDATE
+        SET address = ${address}, acquired_at = ${sqlNow}
+        WHERE ${locksTableSql}.address = ${address}
+          OR ${locksTableSql}.acquired_at < ${lockExpiresAt}
+      `,
+    mysql: () => (_address: string, values: Array<any>) =>
+      sql`
+        INSERT INTO ${locksTableSql} (shard_id, address, acquired_at) VALUES ${sql.csv(values)}
+        ON DUPLICATE KEY UPDATE
+        address = IF(address = VALUES(address) OR acquired_at < ${lockExpiresAt}, VALUES(address), address),
+        acquired_at = IF(address = VALUES(address) OR acquired_at < ${lockExpiresAt}, VALUES(acquired_at), acquired_at)
+      `.unprepared,
+    mssql: () => (_address: string, values: Array<any>) =>
+      sql`
+        MERGE ${locksTableSql} WITH (HOLDLOCK) AS target
+        USING (SELECT * FROM (VALUES ${sql.csv(values)})) AS source (shard_id, address, acquired_at)
+        ON target.shard_id = source.shard_id
+        WHEN MATCHED AND (target.address = source.address OR DATEDIFF(SECOND, target.acquired_at, ${sqlNow}) > 120) THEN
+          UPDATE SET address = source.address, acquired_at = source.acquired_at
+        WHEN NOT MATCHED THEN
+          INSERT (shard_id, address, acquired_at)
+          VALUES (source.shard_id, source.address, source.acquired_at);
+      `,
+    orElse: () => (address: string, values: Array<any>) =>
+      // sqlite
+      sql`
+        WITH source(shard_id, address, acquired_at) AS (VALUES ${sql.csv(values)})
+        INSERT INTO ${locksTableSql} (shard_id, address, acquired_at)
+        SELECT source.shard_id, source.address, source.acquired_at
+        FROM source
+        WHERE NOT EXISTS (
+          SELECT 1 FROM ${locksTableSql}
+          WHERE shard_id = source.shard_id
+          AND address != ${address}
+          AND (strftime('%s', ${sqlNow}) - strftime('%s', acquired_at)) <= 120
+        )
+        ON CONFLICT(shard_id) DO UPDATE
+        SET address = ${address}, acquired_at = ${sqlNow}
+      `
+  })
+
+  const forUpdate = sql.onDialectOrElse({
+    sqlite: () => sql.literal(""),
+    orElse: () => sql.literal("FOR UPDATE")
+  })
+
+  return yield* ShardStorage.makeEncoded({
+    getAssignments: sql`SELECT shard_id, address FROM ${shardsTableSql} ORDER BY shard_id`.values.pipe(
+      PersistenceError.refail
+    ) as any,
+
+    saveAssignments: (assignments) => {
+      const remove = sql`DELETE FROM ${shardsTableSql}`
+      if (assignments.length === 0) {
+        return PersistenceError.refail(remove)
+      }
+      const values = assignments.map(([shardId, address]) => sql`(${shardId}, ${address})`)
+      return remove.pipe(
+        Effect.andThen(sql`INSERT INTO ${shardsTableSql} (shard_id, address) VALUES ${sql.csv(values)}`.unprepared),
+        sql.withTransaction,
+        PersistenceError.refail
+      )
+    },
+
+    getRunners: sql`SELECT address, runner FROM ${runnersTableSql}`.values.pipe(
+      PersistenceError.refail,
+      Effect.map(Arr.map(([address, runner]) => [String(address), String(runner)] as const))
+    ),
+
+    saveRunners: (runners) => {
+      const remove = sql`DELETE FROM ${runnersTableSql}`
+      if (runners.length === 0) {
+        return PersistenceError.refail(remove)
+      }
+      const values = runners.map(([address, runner]) => sql`(${address}, ${runner})`)
+      const insert = sql`INSERT INTO ${runnersTableSql} (address, runner) VALUES ${sql.csv(values)}`.unprepared
+      return remove.pipe(
+        Effect.andThen(insert),
+        sql.withTransaction,
+        PersistenceError.refail
+      )
+    },
+
+    acquire: Effect.fnUntraced(
+      function*(address, shardIds) {
+        const values = shardIds.map((shardId) => sql`(${shardId}, ${address}, ${sqlNow})`)
+        yield* acquireLock(address, values)
+        const currentLocks = yield* sql<{ shard_id: number }>`
+          SELECT shard_id FROM ${sql(locksTable)}
+          WHERE address = ${address} AND ${sql.in("shard_id", shardIds)}
+          ${forUpdate}
+        `
+        return currentLocks.map((row) => row.shard_id)
+      },
+      sql.withTransaction,
+      PersistenceError.refail
+    ),
+
+    refresh: (address, shardIds) =>
+      sql`UPDATE ${locksTableSql} SET acquired_at = ${sqlNow} WHERE address = ${address} AND ${
+        sql.in("shard_id", shardIds)
+      }`.pipe(
+        Effect.andThen(
+          sql`SELECT shard_id FROM ${locksTableSql} WHERE address = ${address} AND acquired_at >= ${lockExpiresAt} ${forUpdate}`
+            .values
+        ),
+        Effect.map((rows) => rows.map((row) => Number(row[0]))),
+        PersistenceError.refail
+      ),
+
+    release: (address, shardId) =>
+      sql`DELETE FROM ${locksTableSql} WHERE address = ${address} AND shard_id = ${shardId}`
+        .pipe(PersistenceError.refail),
+
+    releaseAll: (address) =>
+      sql`DELETE FROM ${locksTableSql} WHERE address = ${address}`.pipe(
+        PersistenceError.refail
+      )
+  })
+})
+
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layer: Layer.Layer<
+  ShardStorage.ShardStorage,
+  SqlError,
+  SqlClient.SqlClient
+> = Layer.effect(ShardStorage.ShardStorage, make())
+
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layerWith = (options: {
+  readonly prefix?: string | undefined
+}): Layer.Layer<ShardStorage.ShardStorage, SqlError, SqlClient.SqlClient> =>
+  Layer.scoped(ShardStorage.ShardStorage, make(options))
diff --git a/src/SynchronizedClock.ts b/src/SynchronizedClock.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6385093e245dcc56a66010cf567d7e945eb83d8a
--- /dev/null
+++ b/src/SynchronizedClock.ts
@@ -0,0 +1,82 @@
+/**
+ * @since 1.0.0
+ */
+import * as Clock from "effect/Clock"
+import * as Duration from "effect/Duration"
+import * as Effect from "effect/Effect"
+import * as Layer from "effect/Layer"
+import * as Schedule from "effect/Schedule"
+import type { Scope } from "effect/Scope"
+import { ShardManagerClient } from "./ShardManager.js"
+
+/**
+ * @since 1.0.0
+ * @category Constructors
+ */
+export const make: (getRemoteTime: Effect.Effect<number, never, never>) => Effect.Effect<
+  Clock.Clock,
+  never,
+  Scope
+> = Effect.fnUntraced(function*(getRemoteTime) {
+  const clock = yield* Effect.clock
+
+  let driftMillis = 0
+  let driftNanos = BigInt(0)
+
+  yield* getRemoteTime.pipe(
+    Effect.timed,
+    Effect.map(([duration, shardManagerTime]) => {
+      const halfTrip = Duration.unsafeDivide(duration, 2)
+      shardManagerTime = shardManagerTime + Duration.toMillis(halfTrip) + 1
+      const selfTime = clock.unsafeCurrentTimeMillis()
+      return shardManagerTime - selfTime
+    }),
+    Effect.replicateEffect(5),
+    Effect.flatMap((drifts) => {
+      drifts.sort()
+      const drift = (driftMillis + drifts[2]) / 2
+      driftMillis = Math.round(drift)
+      driftNanos = BigInt(Math.round(drift * 1_000_000))
+      return Effect.logDebug("Current drift", driftMillis)
+    }),
+    Effect.andThen(Effect.sleep(Duration.minutes(5))),
+    Effect.forever,
+    Effect.sandbox,
+    Effect.retry(Schedule.spaced(Duration.minutes(1))),
+    Effect.annotateLogs({
+      package: "@effect/cluster",
+      service: "SynchronizedClock"
+    }),
+    Effect.forkScoped
+  )
+
+  function unsafeCurrentTimeMillis() {
+    return clock.unsafeCurrentTimeMillis() + driftMillis
+  }
+  function unsafeCurrentTimeNanos() {
+    return clock.unsafeCurrentTimeNanos() + driftNanos
+  }
+
+  return Clock.Clock.of({
+    [Clock.ClockTypeId]: Clock.ClockTypeId,
+    sleep: clock.sleep,
+    unsafeCurrentTimeMillis,
+    unsafeCurrentTimeNanos,
+    currentTimeMillis: Effect.sync(unsafeCurrentTimeMillis),
+    currentTimeNanos: Effect.sync(unsafeCurrentTimeNanos)
+  })
+})
+
+/**
+ * @since 1.0.0
+ * @category Layers
+ */
+export const layer: Layer.Layer<
+  never,
+  never,
+  ShardManagerClient
+> = Layer.unwrapScoped(Effect.gen(function*() {
+  const shardManager = yield* ShardManagerClient
+  const clock = yield* make(shardManager.getTime)
+  return Layer.setClock(clock)
+}))
diff --git a/src/index.ts b/src/index.ts
index eb221f9b5b56bf3ec4ab2ab811c58b5ea456cf3a..900e68acb8a8d1f6bd66a6ca3084937af52160aa 100644
--- a/src/index.ts
+++ b/src/index.ts
@@ -1,97 +1,102 @@
 /**
  * @since 1.0.0
  */
-export * as AtLeastOnce from "./AtLeastOnce.js"
+export * as ClusterError from "./ClusterError.js"
 
 /**
  * @since 1.0.0
  */
-export * as AtLeastOnceStorage from "./AtLeastOnceStorage.js"
+export * as ClusterMetrics from "./ClusterMetrics.js"
 
 /**
  * @since 1.0.0
  */
-export * as Broadcaster from "./Broadcaster.js"
+export * as ClusterSchema from "./ClusterSchema.js"
 
 /**
  * @since 1.0.0
  */
-export * as ManagerConfig from "./ManagerConfig.js"
+export * as DeliverAt from "./DeliverAt.js"
 
 /**
  * @since 1.0.0
  */
-export * as Message from "./Message.js"
+export * as Entity from "./Entity.js"
 
 /**
  * @since 1.0.0
  */
-export * as MessageState from "./MessageState.js"
+export * as EntityAddress from "./EntityAddress.js"
 
 /**
  * @since 1.0.0
  */
-export * as Messenger from "./Messenger.js"
+export * as EntityId from "./EntityId.js"
 
 /**
  * @since 1.0.0
  */
-export * as Pod from "./Pod.js"
+export * as EntityType from "./EntityType.js"
 
 /**
  * @since 1.0.0
  */
-export * as PodAddress from "./PodAddress.js"
+export * as Envelope from "./Envelope.js"
 
 /**
  * @since 1.0.0
  */
-export * as Pods from "./Pods.js"
+export * as HttpCommon from "./HttpCommon.js"
 
 /**
  * @since 1.0.0
  */
-export * as PodsHealth from "./PodsHealth.js"
+export * as HttpRunner from "./HttpRunner.js"
 
 /**
  * @since 1.0.0
  */
-export * as PoisonPill from "./PoisonPill.js"
+export * as HttpShardManager from "./HttpShardManager.js"
 
 /**
  * @since 1.0.0
  */
-export * as RecipientAddress from "./RecipientAddress.js"
+export * as Message from "./Message.js"
 
 /**
  * @since 1.0.0
  */
-export * as RecipientBehaviour from "./RecipientBehaviour.js"
+export * as MessageStorage from "./MessageStorage.js"
 
 /**
  * @since 1.0.0
  */
-export * as RecipientBehaviourContext from "./RecipientBehaviourContext.js"
+export * as Reply from "./Reply.js"
 
 /**
  * @since 1.0.0
  */
-export * as RecipientType from "./RecipientType.js"
+export * as Runner from "./Runner.js"
 
 /**
  * @since 1.0.0
  */
-export * as Serialization from "./Serialization.js"
+export * as RunnerAddress from "./RunnerAddress.js"
 
 /**
  * @since 1.0.0
  */
-export * as SerializedEnvelope from "./SerializedEnvelope.js"
+export * as RunnerHealth from "./RunnerHealth.js"
 
 /**
  * @since 1.0.0
  */
-export * as SerializedMessage from "./SerializedMessage.js"
+export * as RunnerServer from "./RunnerServer.js"
+
+/**
+ * @since 1.0.0
+ */
+export * as Runners from "./Runners.js"
 
 /**
  * @since 1.0.0
@@ -106,7 +111,7 @@ export * as ShardManager from "./ShardManager.js"
 /**
  * @since 1.0.0
  */
-export * as ShardManagerClient from "./ShardManagerClient.js"
+export * as ShardStorage from "./ShardStorage.js"
 
 /**
  * @since 1.0.0
@@ -121,19 +126,44 @@ export * as ShardingConfig from "./ShardingConfig.js"
 /**
  * @since 1.0.0
  */
-export * as ShardingEvent from "./ShardingEvent.js"
+export * as ShardingRegistrationEvent from "./ShardingRegistrationEvent.js"
+
+/**
+ * @since 1.0.0
+ */
+export * as Singleton from "./Singleton.js"
 
 /**
  * @since 1.0.0
  */
-export * as ShardingException from "./ShardingException.js"
+export * as SingletonAddress from "./SingletonAddress.js"
 
 /**
  * @since 1.0.0
  */
-export * as ShardingRegistrationEvent from "./ShardingRegistrationEvent.js"
+export * as Snowflake from "./Snowflake.js"
+
+/**
+ * @since 1.0.0
+ */
+export * as SocketRunner from "./SocketRunner.js"
+
+/**
+ * @since 1.0.0
+ */
+export * as SocketShardManager from "./SocketShardManager.js"
+
+/**
+ * @since 1.0.0
+ */
+export * as SqlMessageStorage from "./SqlMessageStorage.js"
+
+/**
+ * @since 1.0.0
+ */
+export * as SqlShardStorage from "./SqlShardStorage.js"
 
 /**
  * @since 1.0.0
  */
-export * as Storage from "./Storage.js"
+export * as SynchronizedClock from "./SynchronizedClock.js"
diff --git a/src/internal/entityManager.ts b/src/internal/entityManager.ts
index e54bdb2f8b50075637e37c52c86eaf2a9e71d7e9..c126a7544fd89b929ca98791656eed40a84bd677 100644
--- a/src/internal/entityManager.ts
+++ b/src/internal/entityManager.ts
@@ -1,402 +1,505 @@
-import * as Clock from "effect/Clock"
+import type * as Rpc from "@effect/rpc/Rpc"
+import { RequestId } from "@effect/rpc/RpcMessage"
+import * as RpcServer from "@effect/rpc/RpcServer"
+import * as Arr from "effect/Array"
+import * as Cause from "effect/Cause"
+import * as Context from "effect/Context"
 import * as Duration from "effect/Duration"
+import type { DurationInput } from "effect/Duration"
 import * as Effect from "effect/Effect"
 import * as Exit from "effect/Exit"
-import * as Fiber from "effect/Fiber"
-import { pipe } from "effect/Function"
+import * as FiberRef from "effect/FiberRef"
+import { identity } from "effect/Function"
 import * as HashMap from "effect/HashMap"
-import * as HashSet from "effect/HashSet"
+import * as Metric from "effect/Metric"
 import * as Option from "effect/Option"
+import * as Schedule from "effect/Schedule"
+import * as Schema from "effect/Schema"
 import * as Scope from "effect/Scope"
-import * as RefSynchronized from "effect/SynchronizedRef"
+import { AlreadyProcessingMessage, EntityNotManagedByRunner, MailboxFull, MalformedMessage } from "../ClusterError.js"
+import * as ClusterMetrics from "../ClusterMetrics.js"
+import { Persisted } from "../ClusterSchema.js"
+import type { Entity, HandlersFrom } from "../Entity.js"
+import { CurrentAddress, CurrentRunnerAddress, Request } from "../Entity.js"
+import type { EntityAddress } from "../EntityAddress.js"
+import type { EntityId } from "../EntityId.js"
+import * as Envelope from "../Envelope.js"
 import * as Message from "../Message.js"
-import * as MessageState from "../MessageState.js"
-import type * as RecipientAddress from "../RecipientAddress.js"
-import type * as RecipientBehaviour from "../RecipientBehaviour.js"
-import * as RecipientBehaviourContext from "../RecipientBehaviourContext.js"
-import type * as RecipientType from "../RecipientType.js"
-import type * as Serialization from "../Serialization.js"
-import type * as SerializedEnvelope from "../SerializedEnvelope.js"
-import type * as SerializedMessage from "../SerializedMessage.js"
-import type * as ShardId from "../ShardId.js"
-import type * as Sharding from "../Sharding.js"
-import type * as ShardingConfig from "../ShardingConfig.js"
-import * as ShardingException from "../ShardingException.js"
-import * as EntityState from "./entityState.js"
+import * as MessageStorage from "../MessageStorage.js"
+import * as Reply from "../Reply.js"
+import type { RunnerAddress } from "../RunnerAddress.js"
+import type { ShardId } from "../ShardId.js"
+import type { Sharding } from "../Sharding.js"
+import { ShardingConfig } from "../ShardingConfig.js"
+import * as Snowflake from "../Snowflake.js"
+import { EntityReaper } from "./entityReaper.js"
+import { internalInterruptors } from "./interruptors.js"
+import { ResourceMap } from "./resourceMap.js"
+import { ResourceRef } from "./resourceRef.js"
 
 /** @internal */
-const EntityManagerSymbolKey = "@effect/cluster/EntityManager"
+export interface EntityManager {
+  readonly sendLocal: <R extends Rpc.Any>(
+    message: Message.IncomingLocal<R>
+  ) => Effect.Effect<void, EntityNotManagedByRunner | MailboxFull | AlreadyProcessingMessage>
 
-/** @internal */
-export const EntityManagerTypeId = Symbol.for(
-  EntityManagerSymbolKey
-)
+  readonly send: (
+    message: Message.Incoming<any>
+  ) => Effect.Effect<void, EntityNotManagedByRunner | MailboxFull | AlreadyProcessingMessage>
 
-/** @internal */
-export type EntityManagerTypeId = typeof EntityManagerTypeId
+  readonly isProcessingFor: (message: Message.Incoming<any>) => boolean
 
+  readonly interruptShard: (shardId: ShardId) => Effect.Effect<void>
+}
+
+// Represents the entities managed by this entity manager
 /** @internal */
-export interface EntityManager {
-  readonly [EntityManagerTypeId]: EntityManagerTypeId
-
-  /** @internal */
-  readonly sendAndGetState: (
-    envelope: SerializedEnvelope.SerializedEnvelope
-  ) => Effect.Effect<
-    MessageState.MessageState<SerializedMessage.SerializedMessage>,
-    | ShardingException.EntityNotManagedByThisPodException
-    | ShardingException.PodUnavailableException
-    | ShardingException.ExceptionWhileOfferingMessageException
-    | ShardingException.SerializationException
-  >
-
-  /** @internal */
-  readonly terminateEntitiesOnShards: (
-    shards: HashSet.HashSet<ShardId.ShardId>
-  ) => Effect.Effect<void>
-
-  /** @internal */
-  readonly terminateAllEntities: Effect.Effect<void>
+export type EntityState = {
+  readonly address: EntityAddress
+  readonly mailboxGauge: Metric.Metric.Gauge<bigint>
+  readonly activeRequests: Map<bigint, {
+    readonly rpc: Rpc.AnyWithProps
+    readonly message: Message.IncomingRequestLocal<any>
+    lastSentChunk: Option.Option<Reply.Chunk<Rpc.Any>>
+    sequence: number
+  }>
+  lastActiveCheck: number
+  write: RpcServer.RpcServer<any>["write"]
 }
 
 /** @internal */
-export function make<Msg extends Message.Message.Any, R>(
-  recipientType: RecipientType.RecipientType<Msg>,
-  recipientBehaviour: RecipientBehaviour.RecipientBehaviour<Msg, R>,
-  sharding: Sharding.Sharding,
-  config: ShardingConfig.ShardingConfig,
-  serialization: Serialization.Serialization,
-  options: RecipientBehaviour.EntityBehaviourOptions = {}
+export const make = Effect.fnUntraced(function*<
+  Rpcs extends Rpc.Any,
+  Handlers extends HandlersFrom<Rpcs>,
+  RX
+>(
+  entity: Entity<Rpcs>,
+  buildHandlers: Effect.Effect<Handlers, never, RX>,
+  options: {
+    readonly sharding: Sharding["Type"]
+    readonly storage: MessageStorage.MessageStorage["Type"]
+    readonly runnerAddress: RunnerAddress
+    readonly maxIdleTime?: DurationInput | undefined
+    readonly concurrency?: number | "unbounded" | undefined
+    readonly mailboxCapacity?: number | "unbounded" | undefined
+  }
 ) {
-  return Effect.gen(function*() {
-    const entityMaxIdle = options.entityMaxIdleTime || Option.none()
-    const env = yield* Effect.context<Exclude<R, RecipientBehaviourContext.RecipientBehaviourContext>>()
-    const entityStates = yield* RefSynchronized.make<
-      HashMap.HashMap<
-        RecipientAddress.RecipientAddress,
-        EntityState.EntityState
-      >
-    >(HashMap.empty())
-
-    function startExpirationFiber(recipientAddress: RecipientAddress.RecipientAddress) {
-      const maxIdleMillis = pipe(
-        entityMaxIdle,
-        Option.getOrElse(() => config.entityMaxIdleTime),
-        Duration.toMillis
-      )
+  const config = yield* ShardingConfig
+  const snowflakeGen = yield* Snowflake.Generator
+  const managerScope = yield* Effect.scope
+  const storageEnabled = options.storage !== MessageStorage.noop
+  const mailboxCapacity = options.mailboxCapacity ?? config.entityMailboxCapacity
+  const clock = yield* Effect.clock
+  const context = yield* Effect.context<Rpc.Context<Rpcs> | Rpc.Middleware<Rpcs> | RX>()
 
-      function sleep(duration: number): Effect.Effect<void> {
-        return pipe(
-          Effect.Do,
-          Effect.zipLeft(Clock.sleep(Duration.millis(duration))),
-          Effect.bind("cdt", () => Clock.currentTimeMillis),
-          Effect.bind("map", () => RefSynchronized.get(entityStates)),
-          Effect.let("lastReceivedAt", ({ map }) =>
-            pipe(
-              HashMap.get(map, recipientAddress),
-              Option.map((_) => _.lastReceivedAt),
-              Option.getOrElse(() => 0)
-            )),
-          Effect.let("remaining", ({ cdt, lastReceivedAt }) => (maxIdleMillis - cdt + lastReceivedAt)),
-          Effect.tap((_) => _.remaining > 0 ? sleep(_.remaining) : Effect.void)
-        )
-      }
+  const activeServers = new Map<EntityId, EntityState>()
 
-      return pipe(
-        sleep(maxIdleMillis),
-        Effect.zipRight(forkEntityTermination(recipientAddress)),
-        Effect.asVoid,
-        Effect.interruptible,
-        Effect.annotateLogs("entityId", recipientAddress),
-        Effect.annotateLogs("recipientType", recipientType.name),
-        Effect.forkDaemon
-      )
+  const entities: ResourceMap<
+    EntityAddress,
+    EntityState,
+    EntityNotManagedByRunner
+  > = yield* ResourceMap.make(Effect.fnUntraced(function*(address) {
+    if (yield* options.sharding.isShutdown) {
+      return yield* new EntityNotManagedByRunner({ address })
     }
 
-    /**
-     * Performs proper termination of the entity, interrupting the expiration timer, closing the scope and failing pending replies
-     */
-    function terminateEntity(recipientAddress: RecipientAddress.RecipientAddress) {
-      return pipe(
-        // get the things to cleanup
-        RefSynchronized.get(
-          entityStates
-        ),
-        Effect.map(HashMap.get(recipientAddress)),
-        Effect.flatMap(Option.match({
-          // there is no entity state to cleanup
-          onNone: () => Effect.void,
-          // found it!
-          onSome: (entityState) =>
-            pipe(
-              // interrupt the expiration timer
-              Fiber.interrupt(entityState.expirationFiber),
-              // close the scope of the entity,
-              Effect.ensuring(Scope.close(entityState.executionScope, Exit.void)),
-              // remove the entry from the map
-              Effect.ensuring(RefSynchronized.update(entityStates, HashMap.remove(recipientAddress))),
-              // log error if happens
-              Effect.catchAllCause(Effect.logError),
-              Effect.asVoid,
-              Effect.annotateLogs("entityId", recipientAddress.entityId),
-              Effect.annotateLogs("recipientType", recipientAddress.recipientTypeName)
-            )
-        }))
-      )
-    }
+    const scope = yield* Effect.scope
+    const endLatch = yield* Effect.makeLatch()
 
-    /**
-     * Begins entity termination (if needed) and return the fiber to wait for completed termination (if any)
-     */
-    function forkEntityTermination(
-      recipientAddress: RecipientAddress.RecipientAddress
-    ): Effect.Effect<Option.Option<Fiber.RuntimeFiber<void, never>>> {
-      return RefSynchronized.modifyEffect(entityStates, (entityStatesMap) =>
-        pipe(
-          HashMap.get(entityStatesMap, recipientAddress),
-          Option.match({
-            // if no entry is found, the entity has succefully shut down
-            onNone: () => Effect.succeed([Option.none(), entityStatesMap] as const),
-            // there is an entry, so we should begin termination
-            onSome: (entityState) =>
-              pipe(
-                entityState.terminationFiber,
-                Option.match({
-                  // termination has already begun, keep everything as-is
-                  onSome: () => Effect.succeed([entityState.terminationFiber, entityStatesMap] as const),
-                  // begin to terminate the queue
-                  onNone: () =>
-                    pipe(
-                      terminateEntity(recipientAddress),
-                      Effect.forkDaemon,
-                      Effect.map((terminationFiber) =>
-                        [
-                          Option.some(terminationFiber),
-                          HashMap.modify(
-                            entityStatesMap,
-                            recipientAddress,
-                            EntityState.withTerminationFiber(terminationFiber)
-                          )
-                        ] as const
-                      )
-                    )
-                })
-              )
-          })
-        ))
-    }
+    // on shutdown, reset the storage for the entity
+    yield* Scope.addFinalizer(
+      scope,
+      Effect.ignore(options.storage.resetAddress(address))
+    )
 
-    function getOrCreateEntityState(
-      recipientAddress: RecipientAddress.RecipientAddress
-    ): Effect.Effect<
-      Option.Option<EntityState.EntityState>,
-      ShardingException.EntityNotManagedByThisPodException
-    > {
-      return RefSynchronized.modifyEffect(entityStates, (map) =>
-        pipe(
-          HashMap.get(map, recipientAddress),
-          Option.match({
-            onSome: (entityState) =>
-              pipe(
-                entityState.terminationFiber,
-                Option.match({
-                  // offer exists, delay the interruption fiber and return the offer
-                  onNone: () =>
-                    pipe(
-                      Clock.currentTimeMillis,
-                      Effect.map(
-                        (cdt) =>
-                          [
-                            Option.some(entityState),
-                            HashMap.modify(map, recipientAddress, EntityState.withLastReceivedAd(cdt))
-                          ] as const
-                      )
-                    ),
-                  // the queue is shutting down, stash and retry
-                  onSome: () => Effect.succeed([Option.none(), map] as const)
-                })
-              ),
-            onNone: () =>
-              Effect.flatMap(sharding.isShuttingDown, (isGoingDown) => {
-                if (isGoingDown) {
-                  // don't start any fiber while sharding is shutting down
-                  return Effect.fail(new ShardingException.EntityNotManagedByThisPodException({ recipientAddress }))
-                } else {
-                  // offer doesn't exist, create a new one
-                  return Effect.gen(function*() {
-                    const executionScope = yield* Scope.make()
-                    const expirationFiber = yield* startExpirationFiber(recipientAddress)
-                    const cdt = yield* Clock.currentTimeMillis
-                    const forkShutdown = pipe(forkEntityTermination(recipientAddress), Effect.asVoid)
-                    const shardId = sharding.getShardId(recipientAddress)
-
-                    const sendAndGetState = yield* pipe(
-                      recipientBehaviour,
-                      Effect.map((offer) => (envelope: SerializedEnvelope.SerializedEnvelope) =>
-                        pipe(
-                          serialization.decode(recipientType.schema, envelope.body),
-                          Effect.flatMap((message) =>
-                            pipe(
-                              offer(message),
-                              Effect.flatMap((_) =>
-                                MessageState.mapEffect(
-                                  _,
-                                  (value) => serialization.encode(Message.exitSchema(message), value)
-                                )
-                              )
-                            )
-                          )
-                        )
-                      ),
-                      Scope.extend(executionScope),
-                      Effect.provideService(
-                        RecipientBehaviourContext.RecipientBehaviourContext,
-                        RecipientBehaviourContext.make({
-                          recipientAddress,
-                          shardId,
-                          recipientType: recipientType as any,
-                          forkShutdown
-                        })
-                      ),
-                      Effect.provide(env)
+    const activeRequests: EntityState["activeRequests"] = new Map()
+    let defectRequestIds: Array<bigint> = []
+
+    // the server is stored in a ref, so if there is a defect, we can
+    // swap the server without losing the active requests
+    const writeRef = yield* ResourceRef.from(
+      scope,
+      Effect.fnUntraced(function*(scope) {
+        let isShuttingDown = false
+
+        // Initiate the behavior for the entity
+        const handlers = yield* (entity.protocol.toHandlersContext(buildHandlers).pipe(
+          Effect.provide(context.pipe(
+            Context.add(CurrentAddress, address),
+            Context.add(CurrentRunnerAddress, options.runnerAddress),
+            Context.add(Scope.Scope, scope)
+          )),
+          Effect.locally(FiberRef.currentLogAnnotations, HashMap.empty())
+        ) as Effect.Effect<Context.Context<Rpc.ToHandler<Rpcs>>>)
+
+        const server = yield* RpcServer.makeNoSerialization(entity.protocol, {
+          spanPrefix: `${entity.type}(${address.entityId})`,
+          concurrency: options.concurrency ?? 1,
+          onFromServer(response): Effect.Effect<void> {
+            switch (response._tag) {
+              case "Exit": {
+                const request = activeRequests.get(response.requestId)
+                if (!request) return Effect.void
+
+                // For durable messages, ignore interrupts during shutdown.
+                // They will be retried when the entity is restarted.
+                if (
+                  storageEnabled &&
+                  isShuttingDown &&
+                  Context.get(request.rpc.annotations, Persisted) &&
+                  Exit.isInterrupted(response.exit)
+                ) {
+                  return Effect.void
+                }
+                return retryRespond(
+                  4,
+                  Effect.suspend(() =>
+                    request.message.respond(
+                      new Reply.WithExit({
+                        requestId: Snowflake.Snowflake(response.requestId),
+                        id: snowflakeGen.unsafeNext(),
+                        exit: response.exit
+                      })
                     )
+                  )
+                ).pipe(
+                  Effect.flatMap(() => {
+                    activeRequests.delete(response.requestId)
 
-                    const entityState = EntityState.make({
-                      sendAndGetState,
-                      expirationFiber,
-                      executionScope,
-                      terminationFiber: Option.none(),
-                      lastReceivedAt: cdt
-                    })
+                    // ensure that the reaper does not remove the entity as we haven't
+                    // been "idle" yet
+                    if (activeRequests.size === 0) {
+                      state.lastActiveCheck = clock.unsafeCurrentTimeMillis()
+                    }
 
-                    return [
-                      Option.some(entityState),
-                      HashMap.set(
-                        map,
-                        recipientAddress,
-                        entityState
-                      )
-                    ] as const
+                    return Effect.void
+                  }),
+                  Effect.orDie
+                )
+              }
+              case "Chunk": {
+                const request = activeRequests.get(response.requestId)
+                if (!request) return Effect.void
+                const sequence = request.sequence
+                request.sequence++
+                return Effect.orDie(retryRespond(
+                  4,
+                  Effect.suspend(() => {
+                    const reply = new Reply.Chunk({
+                      requestId: Snowflake.Snowflake(response.requestId),
+                      id: snowflakeGen.unsafeNext(),
+                      sequence,
+                      values: response.values
+                    })
+                    request.lastSentChunk = Option.some(reply)
+                    return request.message.respond(reply)
                   })
-                }
-              })
+                ))
+              }
+              case "Defect": {
+                const effect = writeRef.unsafeRebuild()
+                defectRequestIds = Array.from(activeRequests.keys())
+                return Effect.logError("Defect in entity, restarting", Cause.die(response.defect)).pipe(
+                  Effect.andThen(effect.pipe(
+                    Effect.tapErrorCause(Effect.logError),
+                    Effect.retry(Schedule.spaced(500))
+                  )),
+                  Effect.annotateLogs({
+                    module: "EntityManager",
+                    address,
+                    runner: options.runnerAddress
+                  })
+                )
+              }
+              case "ClientEnd": {
+                return endLatch.open
+              }
+            }
+          }
+        }).pipe(
+          Scope.extend(scope),
+          Effect.provide(handlers)
+        )
+
+        yield* Scope.addFinalizer(
+          scope,
+          Effect.sync(() => {
+            isShuttingDown = true
+          })
+        )
+
+        for (const id of defectRequestIds) {
+          const { lastSentChunk, message } = activeRequests.get(id)!
+          yield* server.write(0, {
+            ...message.envelope,
+            id: RequestId(message.envelope.requestId),
+            tag: message.envelope.tag as any,
+            payload: new Request({
+              ...message.envelope,
+              lastSentChunk
+            } as any) as any
           })
-        ))
+        }
+        defectRequestIds = []
+
+        return server.write
+      })
+    )
+
+    const state: EntityState = {
+      address,
+      mailboxGauge: ClusterMetrics.mailboxSize.pipe(
+        Metric.tagged("type", entity.type),
+        Metric.tagged("entityId", address.entityId)
+      ),
+      write(clientId, message) {
+        if (writeRef.state.current._tag !== "Acquired") {
+          return Effect.flatMap(writeRef.await, (write) => write(clientId, message))
+        }
+        return writeRef.state.current.value(clientId, message)
+      },
+      activeRequests,
+      lastActiveCheck: clock.unsafeCurrentTimeMillis()
     }
 
-    function sendAndGetState(
-      envelope: SerializedEnvelope.SerializedEnvelope
-    ): Effect.Effect<
-      MessageState.MessageState<SerializedMessage.SerializedMessage>,
-      | ShardingException.EntityNotManagedByThisPodException
-      | ShardingException.PodUnavailableException
-      | ShardingException.ExceptionWhileOfferingMessageException
-      | ShardingException.SerializationException
-    > {
-      return pipe(
-        Effect.Do,
-        Effect.tap(() => {
-          // first, verify that this entity should be handled by this pod
-          if (recipientType._tag === "EntityType") {
-            return Effect.asVoid(Effect.unlessEffect(
-              Effect.fail(
-                new ShardingException.EntityNotManagedByThisPodException({
-                  recipientAddress: envelope.recipientAddress
-                })
-              ),
-              sharding.isEntityOnLocalShards(envelope.recipientAddress)
-            ))
-          } else if (recipientType._tag === "TopicType") {
-            return Effect.void
-          }
-          return Effect.die("Unhandled recipientType")
-        }),
-        Effect.bind("maybeEntityState", () => getOrCreateEntityState(envelope.recipientAddress)),
-        Effect.flatMap((_) =>
-          pipe(
-            _.maybeEntityState,
-            Option.match({
-              onNone: () =>
-                pipe(
-                  Effect.sleep(Duration.millis(100)),
-                  Effect.flatMap(() => sendAndGetState(envelope))
-                ),
-              onSome: (entityState) => {
-                return entityState.sendAndGetState(envelope)
-              }
-            })
-          )
+    // During shutdown, signal that no more messages will be processed
+    // and wait for the fiber to complete.
+    //
+    // If the termination timeout is reached, let the server clean itself up
+    yield* Scope.addFinalizer(
+      scope,
+      Effect.withFiberRuntime((fiber) => {
+        activeServers.delete(address.entityId)
+        internalInterruptors.add(fiber.id())
+        return state.write(0, { _tag: "Eof" }).pipe(
+          Effect.andThen(Effect.interruptible(endLatch.await)),
+          Effect.timeoutOption(config.entityTerminationTimeout)
         )
-      )
+      })
+    )
+    activeServers.set(address.entityId, state)
+
+    return state
+  }, Effect.locally(FiberRef.currentLogAnnotations, HashMap.empty())))
+
+  const reaper = yield* EntityReaper
+  const maxIdleTime = Duration.toMillis(options.maxIdleTime ?? config.entityMaxIdleTime)
+  if (Number.isFinite(maxIdleTime)) {
+    yield* reaper.register({
+      maxIdleTime,
+      servers: activeServers,
+      entities
+    })
+  }
+
+  // update metrics for active servers
+  const gauge = ClusterMetrics.entities.pipe(Metric.tagged("type", entity.type))
+  yield* Effect.sync(() => {
+    gauge.unsafeUpdate(BigInt(activeServers.size), [])
+    for (const state of activeServers.values()) {
+      state.mailboxGauge.unsafeUpdate(BigInt(state.activeRequests.size), [])
     }
+  }).pipe(
+    Effect.andThen(Effect.sleep(1000)),
+    Effect.forever,
+    Effect.forkIn(managerScope)
+  )
 
-    const terminateAllEntities = pipe(
-      RefSynchronized.get(entityStates),
-      Effect.map(HashMap.keySet),
-      Effect.flatMap(terminateEntities)
-    )
+  function sendLocal<R extends Rpc.Any>(
+    message: Message.IncomingLocal<R>
+  ): Effect.Effect<void, EntityNotManagedByRunner | MailboxFull | AlreadyProcessingMessage> {
+    return Effect.locally(
+      Effect.flatMap(
+        entities.get(message.envelope.address),
+        (server): Effect.Effect<void, EntityNotManagedByRunner | MailboxFull | AlreadyProcessingMessage> => {
+          switch (message._tag) {
+            case "IncomingRequestLocal": {
+              // If the request is already running, then we might have more than
+              // one sender for the same request. In this case, the other senders
+              // should resume from storage only.
+              let entry = server.activeRequests.get(message.envelope.requestId)
+              if (entry) {
+                return Effect.fail(
+                  new AlreadyProcessingMessage({
+                    envelopeId: message.envelope.requestId,
+                    address: message.envelope.address
+                  })
+                )
+              }
 
-    function terminateEntities(
-      entitiesToTerminate: HashSet.HashSet<
-        RecipientAddress.RecipientAddress
-      >
-    ) {
-      return pipe(
-        entitiesToTerminate,
-        Effect.forEach(
-          (recipientAddress) =>
-            pipe(
-              forkEntityTermination(recipientAddress),
-              Effect.flatMap((_) =>
-                Option.match(_, {
-                  onNone: () => Effect.void,
-                  onSome: (terminationFiber) =>
-                    pipe(
-                      Fiber.await(terminationFiber),
-                      Effect.timeout(config.entityTerminationTimeout),
-                      Effect.match({
-                        onFailure: () =>
-                          Effect.logError(
-                            `Entity ${recipientAddress} termination is taking more than expected entityTerminationTimeout (${
-                              Duration.toMillis(config.entityTerminationTimeout)
-                            }ms).`
-                          ),
-                        onSuccess: () =>
-                          Effect.logDebug(
-                            `Entity ${recipientAddress} cleaned up.`
-                          )
-                      }),
-                      Effect.asVoid
-                    )
+              if (mailboxCapacity !== "unbounded" && server.activeRequests.size >= mailboxCapacity) {
+                return Effect.fail(new MailboxFull({ address: message.envelope.address }))
+              }
+
+              entry = {
+                rpc: entity.protocol.requests.get(message.envelope.tag)! as any as Rpc.AnyWithProps,
+                message,
+                lastSentChunk: message.lastSentReply as any,
+                sequence: Option.match(message.lastSentReply, {
+                  onNone: () => 0,
+                  onSome: (reply) => reply._tag === "Chunk" ? reply.sequence + 1 : 0
+                })
+              }
+              server.activeRequests.set(message.envelope.requestId, entry)
+              return server.write(0, {
+                ...message.envelope,
+                id: RequestId(message.envelope.requestId),
+                payload: new Request({
+                  ...message.envelope,
+                  lastSentChunk: message.lastSentReply as any
                 })
+              })
+            }
+            case "IncomingEnvelope": {
+              const entry = server.activeRequests.get(message.envelope.requestId)
+              if (!entry) {
+                return Effect.fail(new EntityNotManagedByRunner({ address: message.envelope.address }))
+              } else if (
+                message.envelope._tag === "AckChunk" &&
+                Option.isSome(entry.lastSentChunk) &&
+                message.envelope.replyId !== entry.lastSentChunk.value.id
+              ) {
+                return Effect.void
+              }
+              return server.write(
+                0,
+                message.envelope._tag === "AckChunk"
+                  ? { _tag: "Ack", requestId: RequestId(message.envelope.requestId) }
+                  : { _tag: "Interrupt", requestId: RequestId(message.envelope.requestId), interruptors: [] }
               )
-            ),
-          { concurrency: "inherit" }
-        ),
-        Effect.asVoid
-      )
-    }
+            }
+          }
+        }
+      ),
+      FiberRef.currentLogAnnotations,
+      HashMap.empty()
+    )
+  }
 
-    function terminateEntitiesOnShards(shards: HashSet.HashSet<ShardId.ShardId>) {
-      return pipe(
-        RefSynchronized.modify(entityStates, (entities) => [
-          HashMap.filter(
-            entities,
-            (_, recipientAddress) => HashSet.has(shards, sharding.getShardId(recipientAddress))
-          ),
-          entities
-        ]),
-        Effect.map(HashMap.keySet),
-        Effect.flatMap(terminateEntities)
+  const interruptShard = (shardId: ShardId) =>
+    Effect.suspend(function loop(): Effect.Effect<void> {
+      const toInterrupt = new Set<EntityState>()
+      for (const state of activeServers.values()) {
+        if (shardId === state.address.shardId) {
+          toInterrupt.add(state)
+        }
+      }
+      if (toInterrupt.size === 0) {
+        return Effect.void
+      }
+      return Effect.flatMap(
+        Effect.forEach(toInterrupt, (state) => entities.removeIgnore(state.address), {
+          concurrency: "unbounded",
+          discard: true
+        }),
+        loop
       )
-    }
+    })
 
-    const self: EntityManager = {
-      [EntityManagerTypeId]: EntityManagerTypeId,
-      sendAndGetState,
-      terminateAllEntities,
-      terminateEntitiesOnShards
-    }
-    return self
+  const decodeMessage = Schema.decode(makeMessageSchema(entity))
+
+  return identity<EntityManager>({
+    interruptShard,
+    isProcessingFor(message) {
+      const state = activeServers.get(message.envelope.address.entityId)
+      if (!state) return false
+      return state.activeRequests.has(message.envelope.requestId)
+    },
+    sendLocal,
+    send: (message) =>
+      decodeMessage(message).pipe(
+        Effect.matchEffect({
+          onFailure: (cause) => {
+            if (message._tag === "IncomingEnvelope") {
+              return Effect.die(new MalformedMessage({ cause }))
+            }
+            return Effect.orDie(message.respond(
+              new Reply.ReplyWithContext({
+                reply: new Reply.WithExit({
+                  id: snowflakeGen.unsafeNext(),
+                  requestId: message.envelope.requestId,
+                  exit: Exit.die(new MalformedMessage({ cause }))
+                }),
+                rpc: entity.protocol.requests.get(message.envelope.tag)!,
+                context
+              })
+            ))
+          },
+          onSuccess: (decoded) => {
+            if (decoded._tag === "IncomingEnvelope") {
+              return sendLocal(
+                new Message.IncomingEnvelope(decoded)
+              )
+            }
+            const request = message as Message.IncomingRequest<any>
+            const rpc = entity.protocol.requests.get(decoded.envelope.tag)!
+            return sendLocal(
+              new Message.IncomingRequestLocal({
+                envelope: decoded.envelope,
+                lastSentReply: decoded.lastSentReply,
+                respond: (reply) =>
+                  request.respond(
+                    new Reply.ReplyWithContext({
+                      reply,
+                      rpc,
+                      context
+                    })
+                  )
+              })
+            )
+          }
+        }),
+        Effect.provide(context as Context.Context<unknown>)
+      )
   })
+})
+
+const makeMessageSchema = <Rpcs extends Rpc.Any>(entity: Entity<Rpcs>): Schema.Schema<
+  {
+    readonly _tag: "IncomingRequest"
+    readonly envelope: Envelope.Request.Any
+    readonly lastSentReply: Option.Option<Reply.Reply<Rpcs>>
+  } | {
+    readonly _tag: "IncomingEnvelope"
+    readonly envelope: Envelope.AckChunk | Envelope.Interrupt
+  },
+  Message.Incoming<Rpcs>,
+  Rpc.Context<Rpcs>
+> => {
+  const requests = Arr.empty<Schema.Schema.Any>()
+
+  for (const rpc of entity.protocol.requests.values()) {
+    requests.push(
+      Schema.TaggedStruct("IncomingRequest", {
+        envelope: Schema.transform(
+          Schema.Struct({
+            ...Envelope.PartialEncodedRequestFromSelf.fields,
+            tag: Schema.Literal(rpc._tag),
+            payload: (rpc as any as Rpc.AnyWithProps).payloadSchema
+          }),
+          Envelope.RequestFromSelf,
+          {
+            decode: (encoded) => Envelope.makeRequest(encoded),
+            encode: identity
+          }
+        ),
+        lastSentReply: Schema.OptionFromSelf(Reply.Reply(rpc))
+      })
+    )
+  }
+
+  return Schema.Union(
+    ...requests,
+    Schema.TaggedStruct("IncomingEnvelope", {
+      envelope: Schema.Union(
+        Schema.typeSchema(Envelope.AckChunk),
+        Schema.typeSchema(Envelope.Interrupt)
+      )
+    })
+  ) as any
 }
+
+const retryRespond = <A, E, R>(times: number, effect: Effect.Effect<A, E, R>): Effect.Effect<A, E, R> =>
+  times === 0 ?
+    effect :
+    Effect.catchAll(effect, () => Effect.delay(retryRespond(times - 1, effect), 200))
diff --git a/src/internal/entityReaper.ts b/src/internal/entityReaper.ts
new file mode 100644
index 0000000000000000000000000000000000000000..94f7615350b0d7fefb3b9e19fc33182771657d58
--- /dev/null
+++ b/src/internal/entityReaper.ts
@@ -0,0 +1,53 @@
+import * as Effect from "effect/Effect"
+import type { EntityNotManagedByRunner } from "../ClusterError.js"
+import type { EntityAddress } from "../EntityAddress.js"
+import type { EntityId } from "../EntityId.js"
+import type { EntityState } from "./entityManager.js"
+import type { ResourceMap } from "./resourceMap.js"
+
+/** @internal */
+export class EntityReaper extends Effect.Service<EntityReaper>()("@effect/cluster/EntityReaper", {
+  scoped: Effect.gen(function*() {
+    let currentResolution = 30_000
+    const registered: Array<{
+      readonly maxIdleTime: number
+      readonly servers: Map<EntityId, EntityState>
+      readonly entities: ResourceMap<EntityAddress, EntityState, EntityNotManagedByRunner>
+    }> = []
+    const latch = yield* Effect.makeLatch()
+
+    const register = (options: {
+      readonly maxIdleTime: number
+      readonly servers: Map<EntityId, EntityState>
+      readonly entities: ResourceMap<EntityAddress, EntityState, EntityNotManagedByRunner>
+    }) =>
+      Effect.suspend(() => {
+        currentResolution = Math.max(Math.min(currentResolution, options.maxIdleTime), 5000)
+        registered.push(options)
+        return latch.open
+      })
+
+    const clock = yield* Effect.clock
+    yield* Effect.gen(function*() {
+      while (true) {
+        yield* Effect.sleep(currentResolution)
+        const now = clock.unsafeCurrentTimeMillis()
+        for (const { entities, maxIdleTime, servers } of registered) {
+          for (const state of servers.values()) {
+            const duration = now - state.lastActiveCheck
+            if (state.activeRequests.size > 0 || duration < maxIdleTime) {
+              continue
+            }
+            yield* Effect.fork(entities.removeIgnore(state.address))
+          }
+        }
+      }
+    }).pipe(
+      latch.whenOpen,
+      Effect.interruptible,
+      Effect.forkScoped
+    )
+
+    return { register } as const
+  })
+}) {}
diff --git a/src/internal/hash.ts b/src/internal/hash.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cd3045931eacc3895c0606d7ce884fde407a3ed6
--- /dev/null
+++ b/src/internal/hash.ts
@@ -0,0 +1,11 @@
+/** @internal */
+export const hashOptimize = (n: number): number => (n & 0xbfffffff) | ((n >>> 1) & 0x40000000)
+
+/** @internal */
+export const hashString = (str: string) => {
+  let h = 5381, i = str.length
+  while (i) {
+    h = (h * 33) ^ str.charCodeAt(--i)
+  }
+  return hashOptimize(h)
+}
diff --git a/src/internal/interruptors.ts b/src/internal/interruptors.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3ef2be81c4c7bec98bf65dee39f7554c8291cb8b
--- /dev/null
+++ b/src/internal/interruptors.ts
@@ -0,0 +1,4 @@
+import type { FiberId } from "effect/FiberId"
+
+/** @internal */
+export const internalInterruptors = new WeakSet<FiberId>()
diff --git a/src/internal/resourceMap.ts b/src/internal/resourceMap.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f5bac550f7bc4956801c73800595ee9f0dff65d8
--- /dev/null
+++ b/src/internal/resourceMap.ts
@@ -0,0 +1,89 @@
+import * as Context from "effect/Context"
+import * as Deferred from "effect/Deferred"
+import * as Effect from "effect/Effect"
+import * as Exit from "effect/Exit"
+import * as MutableHashMap from "effect/MutableHashMap"
+import * as MutableRef from "effect/MutableRef"
+import * as Option from "effect/Option"
+import * as Scope from "effect/Scope"
+
+export class ResourceMap<K, A, E> {
+  constructor(
+    readonly lookup: (key: K, scope: Scope.Scope) => Effect.Effect<A, E>,
+    readonly entries: MutableHashMap.MutableHashMap<K, {
+      readonly scope: Scope.CloseableScope
+      readonly deferred: Deferred.Deferred<A, E>
+    }>,
+    readonly isClosed: MutableRef.MutableRef<boolean>
+  ) {}
+
+  static make = Effect.fnUntraced(function*<K, A, E, R>(lookup: (key: K) => Effect.Effect<A, E, R>) {
+    const scope = yield* Effect.scope
+    const context = yield* Effect.context<R>()
+    const isClosed = MutableRef.make(false)
+
+    const entries = MutableHashMap.empty<K, {
+      scope: Scope.CloseableScope
+      deferred: Deferred.Deferred<A, E>
+    }>()
+
+    yield* Scope.addFinalizerExit(
+      scope,
+      (exit) => {
+        MutableRef.set(isClosed, true)
+        return Effect.forEach(entries, ([key, { scope }]) => {
+          MutableHashMap.remove(entries, key)
+          return Effect.exit(Scope.close(scope, exit))
+        }, { concurrency: "unbounded", discard: true })
+      }
+    )
+
+    return new ResourceMap(
+      (key, scope) => Effect.provide(lookup(key), Context.add(context, Scope.Scope, scope)),
+      entries,
+      isClosed
+    )
+  })
+
+  get(key: K): Effect.Effect<A, E> {
+    return Effect.withFiberRuntime((fiber) => {
+      if (MutableRef.get(this.isClosed)) {
+        return Effect.interrupt
+      }
+      const existing = MutableHashMap.get(this.entries, key)
+      if (Option.isSome(existing)) {
+        return Deferred.await(existing.value.deferred)
+      }
+      const scope = Effect.runSync(Scope.make())
+      const deferred = Deferred.unsafeMake<A, E>(fiber.id())
+      MutableHashMap.set(this.entries, key, { scope, deferred })
+      return Effect.onExit(this.lookup(key, scope), (exit) => {
+        if (exit._tag === "Success") {
+          return Deferred.done(deferred, exit)
+        }
+        MutableHashMap.remove(this.entries, key)
+        return Deferred.done(deferred, exit)
+      })
+    })
+  }
+
+  remove(key: K): Effect.Effect<void> {
+    return Effect.suspend(() => {
+      const entry = MutableHashMap.get(this.entries, key)
+      if (Option.isNone(entry)) {
+        return Effect.void
+      }
+      MutableHashMap.remove(this.entries, key)
+      return Scope.close(entry.value.scope, Exit.void)
+    })
+  }
+
+  removeIgnore(key: K): Effect.Effect<void> {
+    return Effect.catchAllCause(this.remove(key), (cause) =>
+      Effect.annotateLogs(Effect.logDebug(cause), {
+        module: "ResourceMap",
+        method: "removeIgnore",
+        key
+      }))
+  }
+}
diff --git a/src/internal/resourceRef.ts b/src/internal/resourceRef.ts
new file mode 100644
index 0000000000000000000000000000000000000000..caff201c339a7b69105d60eb88051b677e23e153
--- /dev/null
+++ b/src/internal/resourceRef.ts
@@ -0,0 +1,88 @@
+import * as Effect from "effect/Effect"
+import * as Exit from "effect/Exit"
+import * as MutableRef from "effect/MutableRef"
+import * as Option from "effect/Option"
+import * as Scope from "effect/Scope"
+import { internalInterruptors } from "./interruptors.js"
+
+export type State<A> = {
+  readonly _tag: "Closed"
+} | {
+  readonly _tag: "Acquiring"
+  readonly scope: Scope.CloseableScope
+} | {
+  readonly _tag: "Acquired"
+  readonly scope: Scope.CloseableScope
+  readonly value: A
+}
+
+export class ResourceRef<A, E = never> {
+  static from = Effect.fnUntraced(function*<A, E>(
+    parentScope: Scope.Scope,
+    acquire: (scope: Scope.Scope) => Effect.Effect<A, E>
+  ) {
+    const state = MutableRef.make<State<A>>({ _tag: "Closed" })
+
+    yield* Scope.addFinalizerExit(parentScope, (exit) => {
+      const s = MutableRef.get(state)
+      if (s._tag === "Closed") {
+        return Effect.void
+      }
+      const scope = s.scope
+      MutableRef.set(state, { _tag: "Closed" })
+      return Scope.close(scope, exit)
+    })
+
+    const scope = yield* Scope.make()
+    MutableRef.set(state, { _tag: "Acquiring", scope })
+    const value = yield* acquire(scope)
+    MutableRef.set(state, { _tag: "Acquired", scope, value })
+
+    return new ResourceRef(state, acquire)
+  })
+
+  constructor(
+    readonly state: MutableRef.MutableRef<State<A>>,
+    readonly acquire: (scope: Scope.Scope) => Effect.Effect<A, E>
+  ) {}
+
+  latch = Effect.unsafeMakeLatch(true)
+
+  unsafeGet(): Option.Option<A> {
+    if (this.state.current._tag === "Acquired") {
+      return Option.some(this.state.current.value)
+    }
+    return Option.none()
+  }
+
+  unsafeRebuild(): Effect.Effect<void, E> {
+    const s = this.state.current
+    if (s._tag === "Closed") {
+      return Effect.interrupt
+    }
+    const prevScope = s.scope
+    const scope = Effect.runSync(Scope.make())
+    this.latch.unsafeClose()
+    MutableRef.set(this.state, { _tag: "Acquiring", scope })
+    return Effect.fiberIdWith((fiberId) => {
+      internalInterruptors.add(fiberId)
+      return Scope.close(prevScope, Exit.void)
+    }).pipe(
+      Effect.andThen(this.acquire(scope)),
+      Effect.flatMap((value) => {
+        MutableRef.set(this.state, { _tag: "Acquired", scope, value })
+        return this.latch.open
+      })
+    )
+  }
+
+  await: Effect.Effect<A> = Effect.suspend(() => {
+    const s = this.state.current
+    if (s._tag === "Closed") {
+      return Effect.interrupt
+    } else if (s._tag === "Acquired") {
+      return Effect.succeed(s.value)
+    }
+    return Effect.zipRight(this.latch.await, this.await)
+  })
+}
diff --git a/src/internal/shardManager.ts b/src/internal/shardManager.ts
index c18d28906e062d80f9525a06f444ade6f2ca0b57..e9b1c50f8ba960feffc86b607a2c4178c91d4fe4 100644
--- a/src/internal/shardManager.ts
+++ b/src/internal/shardManager.ts
@@ -1,591 +1,318 @@
-/**
- * @since 1.0.0
- */
-import * as Chunk from "effect/Chunk"
+import * as Arr from "effect/Array"
 import * as Clock from "effect/Clock"
-import { GenericTag } from "effect/Context"
 import * as Effect from "effect/Effect"
-import { equals } from "effect/Equal"
-import { pipe } from "effect/Function"
-import * as HashMap from "effect/HashMap"
-import * as HashSet from "effect/HashSet"
-import * as Layer from "effect/Layer"
-import * as List from "effect/List"
+import { constFalse } from "effect/Function"
+import * as MutableHashMap from "effect/MutableHashMap"
+import * as MutableHashSet from "effect/MutableHashSet"
 import * as Option from "effect/Option"
-import * as PubSub from "effect/PubSub"
-import * as Schedule from "effect/Schedule"
-import type * as Scope from "effect/Scope"
-import * as Stream from "effect/Stream"
-import * as RefSynchronized from "effect/SynchronizedRef"
-import * as ManagerConfig from "../ManagerConfig.js"
-import type * as Pod from "../Pod.js"
-import type * as PodAddress from "../PodAddress.js"
-import * as Pods from "../Pods.js"
-import * as PodsHealth from "../PodsHealth.js"
-import * as ShardId from "../ShardId.js"
-import * as ShardingEvent from "../ShardingEvent.js"
-import * as ShardingException from "../ShardingException.js"
-import type * as ShardManager from "../ShardManager.js"
-import * as Storage from "../Storage.js"
-import * as PodWithMetadata from "./podWithMetadata.js"
-import * as ShardManagerState from "./shardManagerState.js"
-import { groupBy, minByOption } from "./utils.js"
+import * as Order from "effect/Order"
+import type { Runner } from "../Runner.js"
+import type { RunnerAddress } from "../RunnerAddress.js"
+import { RunnerHealth } from "../RunnerHealth.js"
+import { ShardId } from "../ShardId.js"
+import { ShardStorage } from "../ShardStorage.js"
 
 /** @internal */
-const ShardManagerSymbolKey = "@effect/cluster/ShardManager"
+export class State {
+  static fromStorage = Effect.fnUntraced(function*(numberOfShards: number) {
+    const storage = yield* ShardStorage
+    const runnerHealth = yield* RunnerHealth
+
+    // Fetch registered runners and shard assignments from cluster storage
+    const storedRunners = yield* storage.getRunners
+    const storedAssignments = yield* storage.getAssignments
+
+    // Determine which runners are still alive
+    const deadRunners = Arr.empty<Runner>()
+    const aliveRunners = MutableHashMap.empty<RunnerAddress, Runner>()
+    yield* Effect.forEach(storedRunners, ([address, runner]) =>
+      Effect.map(runnerHealth.isAlive(address), (isAlive) => {
+        if (isAlive) {
+          MutableHashMap.set(aliveRunners, address, runner)
+        } else {
+          deadRunners.push(runner)
+        }
+      }), { concurrency: "unbounded", discard: true })
+    if (deadRunners.length > 0) {
+      yield* Effect.logWarning("Ignoring runners that are no longer considered alive:", deadRunners)
+    }
 
-/** @internal */
-export const ShardManagerTypeId: ShardManager.ShardManagerTypeId = Symbol.for(
-  ShardManagerSymbolKey
-) as ShardManager.ShardManagerTypeId
+    // Determine which shards remain unassigned to a runner
+    const assignedShards = new Map<ShardId, RunnerAddress>()
+    const invalidAssignments = Arr.empty<[ShardId, RunnerAddress]>()
+    for (const [shard, address] of storedAssignments) {
+      if (Option.isSome(address) && MutableHashMap.has(aliveRunners, address.value)) {
+        assignedShards.set(shard, address.value)
+      } else if (Option.isSome(address)) {
+        invalidAssignments.push([shard, address.value])
+      }
+    }
+    if (invalidAssignments.length > 0) {
+      yield* Effect.logWarning(
+        "Ignoring shard assignments for runners that are no longer considered alive: ",
+        invalidAssignments
+      )
+    }
 
-/** @internal */
-export const shardManagerTag = GenericTag<ShardManager.ShardManager>(ShardManagerSymbolKey)
+    // Construct the initial state
+    const now = yield* Clock.currentTimeMillis
+    const runnerState = MutableHashMap.empty<RunnerAddress, RunnerWithMetadata>()
+    for (const [address, runner] of aliveRunners) {
+      MutableHashMap.set(runnerState, address, RunnerWithMetadata({ runner, registeredAt: now }))
+    }
 
-/** @internal */
-function make(
-  layerScope: Scope.Scope,
-  stateRef: RefSynchronized.SynchronizedRef<ShardManagerState.ShardManagerState>,
-  rebalanceSemaphore: Effect.Semaphore,
-  eventsHub: PubSub.PubSub<ShardingEvent.ShardingEvent>,
-  healthApi: PodsHealth.PodsHealth,
-  podApi: Pods.Pods,
-  stateRepository: Storage.Storage,
-  config: ManagerConfig.ManagerConfig
-): ShardManager.ShardManager {
-  const getAssignments: Effect.Effect<HashMap.HashMap<ShardId.ShardId, Option.Option<PodAddress.PodAddress>>> = pipe(
-    RefSynchronized.get(stateRef),
-    Effect.map((_) => _.shards)
-  )
-
-  const getShardingEvents = Stream.fromPubSub(eventsHub)
-
-  function register(pod: Pod.Pod) {
-    return pipe(
-      Effect.logDebug("Registering " + (pod.address) + "@" + pod.version),
-      Effect.zipRight(
-        RefSynchronized.updateAndGetEffect(stateRef, (state) =>
-          pipe(
-            Effect.flatMap(Effect.clock, (_) => _.currentTimeMillis),
-            Effect.map((cdt) =>
-              ShardManagerState.make(
-                HashMap.set(state.pods, pod.address, PodWithMetadata.make(pod, cdt)),
-                state.shards
-              )
-            )
-          ))
-      ),
-      Effect.zipLeft(PubSub.publish(eventsHub, ShardingEvent.PodRegistered(pod.address))),
-      Effect.flatMap((state) => Effect.when(rebalance(false), () => HashSet.size(state.unassignedShards) > 0)),
-      Effect.zipRight(Effect.forkIn(layerScope)(persistPods)),
-      Effect.asVoid
-    )
-  }
+    const shardState = new Map<ShardId, Option.Option<RunnerAddress>>()
+    for (let n = 1; n <= numberOfShards; n++) {
+      const shardId = ShardId.make(n)
+      shardState.set(shardId, Option.fromNullable(assignedShards.get(shardId)))
+    }
 
-  function stateHasPod(podAddress: PodAddress.PodAddress) {
-    return pipe(
-      RefSynchronized.get(stateRef),
-      Effect.map((_) => HashMap.has(_.pods, podAddress))
-    )
-  }
+    return new State(runnerState, shardState)
+  })
 
-  function notifyUnhealthyPod(podAddress: PodAddress.PodAddress) {
-    return pipe(
-      Effect.whenEffect(
-        pipe(
-          PubSub.publish(eventsHub, ShardingEvent.PodHealthChecked(podAddress)),
-          Effect.zipRight(
-            Effect.unlessEffect(
-              Effect.zipRight(
-                Effect.logWarning(`${podAddress} is not alive, unregistering`),
-                unregister(podAddress)
-              ),
-              healthApi.isAlive(podAddress)
-            )
-          )
-        ),
-        stateHasPod(podAddress)
-      ),
-      Effect.asVoid
-    )
-  }
+  constructor(
+    readonly runners: MutableHashMap.MutableHashMap<RunnerAddress, RunnerWithMetadata>,
+    readonly shards: Map<ShardId, Option.Option<RunnerAddress>>
+  ) {}
 
-  const checkAllPodsHealth = pipe(
-    RefSynchronized.get(stateRef),
-    Effect.map((_) => HashMap.keySet(_.pods)),
-    Effect.flatMap((_) => (Effect.forEach(_, notifyUnhealthyPod, { concurrency: 4, discard: true })))
-  )
-
-  function unregister(podAddress: PodAddress.PodAddress) {
-    const eff = pipe(
-      Effect.Do,
-      Effect.zipLeft(Effect.logDebug(`Unregistering ${podAddress}`)),
-      Effect.bind("unassignments", (_) =>
-        pipe(
-          stateRef,
-          RefSynchronized.modify((state) => [
-            pipe(
-              state.shards,
-              HashMap.filter((pod) => equals(pod)(Option.some(podAddress))),
-              HashMap.keySet
-            ),
-            {
-              ...state,
-              pods: HashMap.remove(state.pods, podAddress),
-              shards: HashMap.map(state.shards, (_) => equals(_)(Option.some(podAddress)) ? Option.none() : _)
-            }
-          ])
-        )),
-      Effect.tap((_) => PubSub.publish(eventsHub, ShardingEvent.PodUnregistered(podAddress))),
-      Effect.tap((_) =>
-        Effect.when(
-          PubSub.publish(eventsHub, ShardingEvent.ShardsUnassigned(podAddress, _.unassignments)),
-          () => HashSet.size(_.unassignments) > 0
-        )
-      ),
-      Effect.zipLeft(Effect.forkIn(layerScope)(persistPods)),
-      Effect.zipLeft(Effect.forkIn(layerScope)(rebalance(true)))
-    )
-    return Effect.asVoid(Effect.whenEffect(eff, stateHasPod(podAddress)))
+  get maxVersion(): Option.Option<number> {
+    if (MutableHashMap.size(this.runners) === 0) return Option.none()
+    let version: number | undefined = undefined
+    for (const [, meta] of this.runners) {
+      if (version === undefined || meta.runner.version > version) {
+        version = meta.runner.version
+      }
+    }
+    return Option.some(version!)
   }
 
-  function withRetry<A, E>(zio: Effect.Effect<A, E>): Effect.Effect<void> {
-    return pipe(
-      zio,
-      Effect.retry(
-        pipe(
-          Schedule.spaced(config.persistRetryInterval),
-          Schedule.andThen(Schedule.recurs(config.persistRetryCount))
-        )
-      ),
-      Effect.ignore
+  allRunnersHaveVersion(version: Option.Option<number>): boolean {
+    return version.pipe(
+      Option.map((max) => Arr.every(this.runnerVersions, (version) => version === max)),
+      Option.getOrElse(constFalse)
     )
   }
 
-  const persistAssignments = withRetry(
-    pipe(
-      RefSynchronized.get(stateRef),
-      Effect.flatMap((state) => stateRepository.saveAssignments(state.shards))
-    )
-  )
+  get shardsPerRunner(): MutableHashMap.MutableHashMap<RunnerAddress, Set<ShardId>> {
+    const shards = MutableHashMap.empty<RunnerAddress, Set<ShardId>>()
 
-  const persistPods = withRetry(
-    pipe(
-      RefSynchronized.get(stateRef),
-      Effect.flatMap((state) => stateRepository.savePods(HashMap.map(state.pods, (v) => v.pod)))
-    )
-  )
-
-  function updateShardsState(
-    shards: HashSet.HashSet<ShardId.ShardId>,
-    pod: Option.Option<PodAddress.PodAddress>
-  ) {
-    return RefSynchronized.updateEffect(stateRef, (state) => {
-      if (Option.isSome(pod) && !HashMap.has(state.pods, pod.value)) {
-        return Effect.fail(new ShardingException.PodNoLongerRegisteredException({ podAddress: pod.value }))
-      }
-      return Effect.succeed({
-        ...state,
-        shards: pipe(
-          state.shards,
-          HashMap.map((assignment, shard) => HashSet.has(shards, shard) ? pod : assignment)
-        )
-      })
+    if (MutableHashMap.isEmpty(this.runners)) return shards
+    MutableHashMap.forEach(this.runners, (_, address) => {
+      MutableHashMap.set(shards, address, new Set())
     })
-  }
 
-  function rebalance(rebalanceImmediately: boolean): Effect.Effect<void> {
-    const algo = Effect.gen(function*() {
-      const state = yield* RefSynchronized.get(stateRef)
+    for (const [shard, address] of this.shards) {
+      if (Option.isNone(address)) continue
+      const shardIds = Option.getOrUndefined(MutableHashMap.get(shards, address.value))!
+      shardIds.add(shard)
+    }
 
-      const [assignments, unassignments] = rebalanceImmediately || HashSet.size(state.unassignedShards) > 0
-        ? decideAssignmentsForUnassignedShards(state)
-        : decideAssignmentsForUnbalancedShards(state, config.rebalanceRate)
+    return shards
+  }
 
-      const areChanges = HashMap.size(assignments) > 0 || HashMap.size(unassignments) > 0
+  get averageShardsPerRunner(): number {
+    const runnerCount = MutableHashMap.size(this.runners)
+    return runnerCount > 0 ? this.shards.size / runnerCount : 0
+  }
 
-      if (areChanges) {
-        yield* Effect.logDebug(
-          "Rebalance (rebalanceImmidiately=" + JSON.stringify(rebalanceImmediately) + ")"
-        )
+  get unassignedShards(): Array<ShardId> {
+    const shardIds: Array<ShardId> = []
+    for (const [shard, address] of this.shards) {
+      if (Option.isNone(address)) {
+        shardIds.push(shard)
       }
+    }
+    return shardIds
+  }
 
-      const failedPingedPods = yield* pipe(
-        HashSet.union(HashMap.keySet(assignments), HashMap.keySet(unassignments)),
-        Effect.forEach(
-          (pod) =>
-            pipe(
-              podApi.ping(pod),
-              Effect.timeout(config.pingTimeout),
-              Effect.match({
-                onFailure: () => Chunk.fromIterable([pod]),
-                onSuccess: () => Chunk.empty<PodAddress.PodAddress>()
-              })
-            ),
-          { concurrency: "inherit" }
-        ),
-        Effect.map(Chunk.fromIterable),
-        Effect.map((_) => Chunk.flatten(_)),
-        Effect.map(HashSet.fromIterable)
-      )
+  private get runnerVersions(): Array<number> {
+    const runnerVersions: Array<number> = []
+    for (const [, meta] of this.runners) {
+      runnerVersions.push(meta.runner.version)
+    }
+    return runnerVersions
+  }
+}
 
-      const shardsToRemove = pipe(
-        List.fromIterable(assignments),
-        List.appendAll(List.fromIterable(unassignments)),
-        List.filter(([pod, __]) => HashSet.has(failedPingedPods, pod)),
-        List.map(([_, shards]) => List.fromIterable(shards)),
-        List.flatMap((_) => _), // TODO: List is missing flatMap
-        HashSet.fromIterable
-      )
+/** @internal */
+export interface RunnerWithMetadata {
+  readonly runner: Runner
+  readonly registeredAt: number
+}
+/** @internal */
+export const RunnerWithMetadata = (runner: RunnerWithMetadata): RunnerWithMetadata => runner
 
-      const readyAssignments = pipe(
-        assignments,
-        HashMap.map(HashSet.difference(shardsToRemove)),
-        HashMap.filter((__) => HashSet.size(__) > 0)
-      )
+/** @internal */
+export function decideAssignmentsForUnassignedShards(state: State): readonly [
+  assignments: MutableHashMap.MutableHashMap<RunnerAddress, Set<ShardId>>,
+  unassignments: MutableHashMap.MutableHashMap<RunnerAddress, Set<ShardId>>,
+  changes: MutableHashSet.MutableHashSet<RunnerAddress>
+] {
+  return pickNewRunners(state.unassignedShards, state, true, 1)
+}
 
-      const readyUnassignments = pipe(
-        unassignments,
-        HashMap.map(HashSet.difference(shardsToRemove)),
-        HashMap.filter((__) => HashSet.size(__) > 0)
-      )
+const allocationOrder: Order.Order<[ShardId, number, number]> = Order.combine(
+  Order.mapInput(Order.number, ([, shards]) => shards),
+  Order.mapInput(Order.number, ([, , registeredAt]) => registeredAt)
+)
 
-      const [failedUnassignedPods, failedUnassignedShards] = yield* pipe(
-        Effect.forEach(readyUnassignments, ([pod, shards]) =>
-          pipe(
-            podApi.unassignShards(pod, shards),
-            Effect.zipRight(updateShardsState(shards, Option.none())),
-            Effect.matchEffect({
-              onFailure: () => Effect.succeed([HashSet.fromIterable([pod]), shards] as const),
-              onSuccess: () =>
-                pipe(
-                  PubSub.publish(eventsHub, ShardingEvent.ShardsUnassigned(pod, shards)),
-                  Effect.as(
-                    [
-                      HashSet.empty<PodAddress.PodAddress>(),
-                      HashSet.empty<ShardId.ShardId>()
-                    ] as const
-                  )
-                )
-            })
-          ), { concurrency: "inherit" }),
-        Effect.map(Chunk.fromIterable),
-        Effect.map((_) => Chunk.unzip(_)),
-        Effect.map(
-          ([pods, shards]) => [Chunk.map(pods, Chunk.fromIterable), Chunk.map(shards, Chunk.fromIterable)] as const
-        ),
-        Effect.map(
-          ([pods, shards]) =>
-            [
-              HashSet.fromIterable(Chunk.flatten(pods)),
-              HashSet.fromIterable(Chunk.flatten(shards))
-            ] as const
-        )
-      )
+/** @internal */
+export function decideAssignmentsForUnbalancedShards(state: State, rate: number): readonly [
+  assignments: MutableHashMap.MutableHashMap<RunnerAddress, Set<ShardId>>,
+  unassignments: MutableHashMap.MutableHashMap<RunnerAddress, Set<ShardId>>,
+  changes: MutableHashSet.MutableHashSet<RunnerAddress>
+] {
+  const shardsPerRunner = state.shardsPerRunner
+  const maxVersion = state.maxVersion
+  const extraShardsToAllocate = Arr.empty<[ShardId, shardsInverse: number, registeredAt: number]>()
+
+  if (state.allRunnersHaveVersion(maxVersion)) {
+    const averageShardsPerRunner = state.averageShardsPerRunner
+    MutableHashMap.forEach(shardsPerRunner, (shards) => {
+      // Count how many extra shards there are compared to the average
+      const extraShards = Math.max(0, shards.size - averageShardsPerRunner)
+      for (const shard of takeRandom(shards, extraShards)) {
+        const maybeAddress = state.shards.get(shard) ?? Option.none()
+        if (Option.isNone(maybeAddress)) {
+          extraShardsToAllocate.push([shard, Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER])
+          continue
+        }
+        const address = maybeAddress.value
+        extraShardsToAllocate.push([
+          shard,
+          Option.match(MutableHashMap.get(shardsPerRunner, address), {
+            onNone: () => Number.MIN_SAFE_INTEGER,
+            onSome: (shards) => -shards.size
+          }),
+          Option.match(MutableHashMap.get(state.runners, address), {
+            onNone: () => Number.MIN_SAFE_INTEGER,
+            onSome: (meta) => meta.registeredAt
+          })
+        ])
+      }
+    })
+  }
 
-      // remove assignments of shards that couldn't be unassigned, as well as faulty pods.
-      const filteredAssignments = pipe(
-        HashMap.removeMany(readyAssignments, failedUnassignedPods),
-        HashMap.map((shards, __) => HashSet.difference(shards, failedUnassignedShards))
-      )
+  const sortedShardsToRebalance = extraShardsToAllocate.sort(allocationOrder).map(([shard]) => shard)
 
-      // then do the assignments
-      const failedAssignedPods = yield* pipe(
-        Effect.forEach(filteredAssignments, ([pod, shards]) =>
-          pipe(
-            podApi.assignShards(pod, shards),
-            Effect.zipRight(updateShardsState(shards, Option.some(pod))),
-            Effect.matchEffect({
-              onFailure: () => Effect.succeed(Chunk.fromIterable([pod])),
-              onSuccess: () =>
-                pipe(
-                  PubSub.publish(eventsHub, ShardingEvent.ShardsAssigned(pod, shards)),
-                  Effect.as(Chunk.empty())
-                )
-            })
-          ), { concurrency: "inherit" }),
-        Effect.map(Chunk.fromIterable),
-        Effect.map((_) => Chunk.flatten(_)),
-        Effect.map(HashSet.fromIterable)
-      )
+  return pickNewRunners(sortedShardsToRebalance, state, false, rate, shardsPerRunner, maxVersion)
+}
 
-      const failedPods = HashSet.union(
-        HashSet.union(failedPingedPods, failedUnassignedPods),
-        failedAssignedPods
-      )
+function pickNewRunners(
+  shardsToRebalance: ReadonlyArray<ShardId>,
+  state: State,
+  immediate: boolean,
+  rate: number,
+  shardsPerRunner = state.shardsPerRunner,
+  maybeMaxVersion = state.maxVersion
+): readonly [
+  assignments: MutableHashMap.MutableHashMap<RunnerAddress, Set<ShardId>>,
+  unassignments: MutableHashMap.MutableHashMap<RunnerAddress, Set<ShardId>>,
+  changes: MutableHashSet.MutableHashSet<RunnerAddress>
+] {
+  const addressAssignments = MutableHashMap.empty<RunnerAddress, Set<ShardId>>()
+  const unassignments = MutableHashMap.empty<RunnerAddress, Set<ShardId>>()
+  const changes = MutableHashSet.empty<RunnerAddress>()
 
-      // check if failing pods are still up
-      yield* Effect.forkIn(layerScope)(Effect.forEach(failedPods, (_) => notifyUnhealthyPod(_), { discard: true }))
-
-      if (HashSet.size(failedPods) > 0) {
-        yield* Effect.logDebug(
-          "Failed to rebalance pods: " +
-            failedPods +
-            " failed pinged: " + failedPingedPods +
-            " failed assigned: " + failedAssignedPods +
-            " failed unassigned: " + failedUnassignedPods
-        )
+  if (Option.isNone(maybeMaxVersion)) {
+    return [addressAssignments, unassignments, changes]
+  }
+  const maxVersion = maybeMaxVersion.value
+
+  for (const shardId of shardsToRebalance) {
+    // Find the runner with the fewest assigned shards
+    let candidate: RunnerAddress | undefined
+    let candidateShards: Set<ShardId> | undefined
+
+    for (const [address, shards] of shardsPerRunner) {
+      // Keep only runners with the maximum version
+      const maybeRunnerMeta = MutableHashMap.get(state.runners, address)
+      if (Option.isNone(maybeRunnerMeta)) continue
+      const runnerMeta = maybeRunnerMeta.value
+      if (runnerMeta.runner.version !== maxVersion) continue
+
+      // Do not assign to a runner that has unassignments in the same rebalance
+      if (MutableHashMap.has(unassignments, address)) continue
+
+      // Do not assign too many shards to each runner unless rebalancing must
+      // occur immediately
+      if (!immediate) {
+        const assignmentCount = Option.getOrUndefined(MutableHashMap.get(addressAssignments, address))?.size ?? 0
+        if (assignmentCount >= state.shards.size * rate) continue
       }
 
-      // retry rebalancing later if there was any failure
-      if (HashSet.size(failedPods) > 0 && rebalanceImmediately) {
-        yield* pipe(
-          Effect.sleep(config.rebalanceRetryInterval),
-          Effect.zipRight(rebalance(rebalanceImmediately)),
-          Effect.forkIn(layerScope)
-        )
+      if (candidate === undefined || shards.size < candidateShards!.size) {
+        candidate = address
+        candidateShards = shards
       }
+    }
+    if (!candidate || !candidateShards) break
 
-      // persist state changes to Redis
-      if (areChanges) {
-        yield* Effect.forkIn(layerScope)(persistAssignments)
-      }
-    })
+    // If the old runner is the same as the new runner, do nothing
+    const oldRunner = Option.getOrUndefined(state.shards.get(shardId) ?? Option.none())
+    if (oldRunner && oldRunner.toString() === candidate.toString()) {
+      continue
+    }
+    const oldShards = oldRunner && Option.getOrUndefined(MutableHashMap.get(shardsPerRunner, oldRunner))
+
+    // If the new runner has one less, as many, or more shards than the
+    // old runner, do not change anything
+    if (oldShards && candidateShards.size + 1 >= oldShards.size) continue
+
+    // Otherwise create a new assignment
+    MutableHashMap.modifyAt(
+      addressAssignments,
+      candidate,
+      Option.match({
+        onNone: () => Option.some(new Set([shardId])),
+        onSome: (shards) => {
+          shards.add(shardId)
+          return Option.some(shards)
+        }
+      })
+    )
+    if (oldRunner) {
+      MutableHashMap.modifyAt(
+        unassignments,
+        oldRunner,
+        Option.match({
+          onNone: () => Option.some(new Set([shardId])),
+          onSome: (shards) => {
+            shards.add(shardId)
+            return Option.some(shards)
+          }
+        })
+      )
+    }
 
-    return rebalanceSemaphore.withPermits(1)(algo)
-  }
+    // Move the shard to the new runner
+    candidateShards.add(shardId)
+    if (oldShards) {
+      oldShards.delete(shardId)
+    }
 
-  return {
-    getAssignments,
-    getShardingEvents,
-    register,
-    unregister,
-    persistPods,
-    rebalance,
-    notifyUnhealthyPod,
-    checkAllPodsHealth
+    // Track changes
+    MutableHashSet.add(changes, candidate)
+    if (oldRunner) MutableHashSet.add(changes, oldRunner)
   }
-}
 
-/** @internal */
-export function decideAssignmentsForUnassignedShards(state: ShardManagerState.ShardManagerState) {
-  return pickNewPods(List.fromIterable(state.unassignedShards), state, true, 1)
+  return [addressAssignments, unassignments, changes]
 }
 
-/** @internal */
-export function decideAssignmentsForUnbalancedShards(
-  state: ShardManagerState.ShardManagerState,
-  rebalanceRate: number
-) {
-  // don't do regular rebalance in the middle of a rolling update
-  const extraShardsToAllocate = state.allPodsHaveMaxVersion
-    ? pipe(
-      state.shardsPerPod,
-      HashMap.flatMap((shards, _) => {
-        // count how many extra shards compared to the average
-        const extraShards = Math.max(HashSet.size(shards) - state.averageShardsPerPod.value, 0)
-        return pipe(
-          HashMap.empty(),
-          HashMap.set(_, HashSet.fromIterable(List.take(List.fromIterable(shards), extraShards)))
-        )
-      }),
-      HashSet.fromIterable,
-      HashSet.map((_) => _[1]),
-      HashSet.flatMap((_) => _)
-    )
-    : HashSet.empty()
-
-  /*
-        TODO: port sortBy
-
-    val sortedShardsToRebalance = extraShardsToAllocate.toList.sortBy { shard =>
-      // handle unassigned shards first, then shards on the pods with most shards, then shards on old pods
-      state.shards.get(shard).flatten.fold((Int.MinValue, OffsetDateTime.MIN)) { pod =>
-        (
-          state.shardsPerPod.get(pod).fold(Int.MinValue)(-_.size),
-          state.pods.get(pod).fold(OffsetDateTime.MIN)(_.registered)
-        )
-      }
-    }
-* */
-  const sortedShardsToRebalance = List.fromIterable(extraShardsToAllocate)
-  return pickNewPods(sortedShardsToRebalance, state, false, rebalanceRate)
+function takeRandom<A>(self: Iterable<A>, n: number): ReadonlyArray<A> {
+  const array = Array.from(self)
+  let currentIndex = array.length
+  while (currentIndex != 0) {
+    const randomIndex = Math.floor(Math.random() * currentIndex)
+    currentIndex = currentIndex - 1
+    swap(array, currentIndex, randomIndex)
+  }
+  return n < array.length ? array.slice(0, n) : array
 }
 
-function pickNewPods(
-  shardsToRebalance: List.List<ShardId.ShardId>,
-  state: ShardManagerState.ShardManagerState,
-  rebalanceImmediately: boolean,
-  rebalanceRate: number
-): readonly [
-  assignments: HashMap.HashMap<PodAddress.PodAddress, HashSet.HashSet<ShardId.ShardId>>,
-  unassignments: HashMap.HashMap<PodAddress.PodAddress, HashSet.HashSet<ShardId.ShardId>>
-] {
-  const [_, assignments] = pipe(
-    List.reduce(
-      shardsToRebalance,
-      [
-        state.shardsPerPod,
-        List.empty<readonly [ShardId.ShardId, PodAddress.PodAddress]>()
-      ] as const,
-      ([shardsPerPod, assignments], shard) => {
-        const unassignedPods = pipe(
-          assignments,
-          List.flatMap(([shard, _]) =>
-            pipe(
-              HashMap.get(state.shards, shard),
-              Option.flatten,
-              Option.toArray,
-              List.fromIterable
-            )
-          )
-        )
-
-        // find pod with least amount of shards
-        return pipe(
-          // keep only pods with the max version
-          HashMap.filter(shardsPerPod, (_, pod) => {
-            const maxVersion = state.maxVersion
-            if (Option.isNone(maxVersion)) return true
-            return pipe(
-              HashMap.get(state.pods, pod),
-              Option.map(PodWithMetadata.extractVersion),
-              Option.map((_) => PodWithMetadata.compareVersion(_, maxVersion.value) === 0),
-              Option.getOrElse(() => false)
-            )
-          }),
-          // don't assign too many shards to the same pods, unless we need rebalance immediately
-          HashMap.filter((_, pod) => {
-            if (rebalanceImmediately) return true
-            return (
-              pipe(
-                assignments,
-                List.filter(([_, p]) => equals(p)(pod)),
-                List.size
-              ) <
-                HashMap.size(state.shards) * rebalanceRate
-            )
-          }),
-          // don't assign to a pod that was unassigned in the same rebalance
-          HashMap.filter(
-            (_, pod) => !Option.isSome(List.findFirst(unassignedPods, equals(pod)))
-          ),
-          minByOption(([_, pods]) => HashSet.size(pods)),
-          Option.match({
-            onNone: () => [shardsPerPod, assignments] as const,
-            onSome: ([pod, shards]) => {
-              const oldPod = Option.flatten(HashMap.get(state.shards, shard))
-              // if old pod is same as new pod, don't change anything
-              if (equals(oldPod)(pod)) {
-                return [shardsPerPod, assignments] as const
-                // if the new pod has more, as much, or only 1 less shard than the old pod, don't change anything
-              } else if (
-                Option.match(HashMap.get(shardsPerPod, pod), { onNone: () => 0, onSome: HashSet.size }) + 1 >=
-                  Option.match(
-                    oldPod,
-                    {
-                      onNone: () => Number.MAX_SAFE_INTEGER,
-                      onSome: (_) =>
-                        Option.match(HashMap.get(shardsPerPod, _), { onNone: () => 0, onSome: HashSet.size })
-                    }
-                  )
-              ) {
-                return [shardsPerPod, assignments] as const
-
-                // otherwise, create a new assignment
-              } else {
-                const unassigned = Option.match(
-                  oldPod,
-                  {
-                    onNone: () => shardsPerPod,
-                    onSome: (oldPod) => HashMap.modify(shardsPerPod, oldPod, HashSet.remove(shard))
-                  }
-                )
-                return [
-                  HashMap.modify(unassigned, pod, (_) => HashSet.add(shards, shard)),
-                  List.prepend(assignments, [shard, pod] as const)
-                ] as const
-              }
-            }
-          })
-        )
-      }
-    )
-  )
-
-  const unassignments = List.flatMap(assignments, ([shard, _]) =>
-    pipe(
-      Option.flatten(HashMap.get(state.shards, shard)),
-      Option.map((_) => [shard, _] as const),
-      Option.match({ onNone: List.empty, onSome: List.of })
-    ))
-
-  const assignmentsPerPod = pipe(
-    assignments,
-    groupBy(([_, pod]) => pod),
-    HashMap.map(HashSet.map(([shardId, _]) => shardId))
-  )
-  const unassignmentsPerPod = pipe(
-    unassignments,
-    groupBy(([_, pod]) => pod),
-    HashMap.map(HashSet.map(([shardId, _]) => shardId))
-  )
-  return [assignmentsPerPod, unassignmentsPerPod] as const
+function swap<A>(array: Array<A>, i: number, j: number): ReadonlyArray<A> {
+  const tmp = array[i]
+  array[i] = array[j]
+  array[j] = tmp
+  return array
 }
-
-/**
- * @since 1.0.0
- * @category layers
- */
-export const live = Effect.gen(function*() {
-  const config = yield* ManagerConfig.ManagerConfig
-  const stateRepository = yield* Storage.Storage
-  const healthApi = yield* PodsHealth.PodsHealth
-  const podsApi = yield* Pods.Pods
-  const layerScope = yield* Effect.scope
-
-  const pods = yield* stateRepository.getPods
-  const assignments = yield* stateRepository.getAssignments
-
-  const filteredPods = yield* pipe(
-    Effect.filter(pods, ([podAddress]) => healthApi.isAlive(podAddress), { concurrency: "inherit" }),
-    Effect.map(HashMap.fromIterable)
-  )
-  const filteredAssignments = HashMap.filter(
-    assignments,
-    (pod) => Option.isSome(pod) && HashMap.has(filteredPods, pod.value)
-  )
-  const cdt = yield* Clock.currentTimeMillis
-  const initialState = ShardManagerState.make(
-    HashMap.map(filteredPods, (pod) => PodWithMetadata.make(pod, cdt)),
-    HashMap.union(
-      filteredAssignments,
-      pipe(
-        Chunk.range(1, config.numberOfShards),
-        Chunk.map((n) => [ShardId.make(n), Option.none()] as const),
-        HashMap.fromIterable
-      )
-    )
-  )
-  const state = yield* RefSynchronized.make(initialState)
-  const rebalanceSemaphore = yield* Effect.makeSemaphore(1)
-  const eventsHub = yield* PubSub.unbounded<ShardingEvent.ShardingEvent>()
-  const shardManager = make(
-    layerScope,
-    state,
-    rebalanceSemaphore,
-    eventsHub,
-    healthApi,
-    podsApi,
-    stateRepository,
-    config
-  )
-  yield* Effect.forkIn(layerScope)(shardManager.persistPods)
-  // rebalance immediately if there are unassigned shards
-  yield* shardManager.rebalance(HashSet.size(initialState.unassignedShards) > 0)
-  // start a regular rebalance at the given interval
-  yield* pipe(
-    shardManager.rebalance(false),
-    Effect.repeat(Schedule.spaced(config.rebalanceInterval)),
-    Effect.forkIn(layerScope)
-  )
-  // log info events
-  yield* pipe(
-    shardManager.getShardingEvents,
-    Stream.mapEffect((_) => Effect.logDebug(JSON.stringify(_))),
-    Stream.runDrain,
-    Effect.forkIn(layerScope)
-  )
-  yield* Effect.logDebug("Shard Manager loaded")
-  return shardManager
-}).pipe(Layer.scoped(shardManagerTag))
