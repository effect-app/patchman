diff --git a/build/cjs/integrations/anr/index.js b/build/cjs/integrations/anr/index.js
index ac01cd7676b05c25c0b77d516bed4612e1734ed9..15effaa0c80d3023a6222c4865f0fff75a87cb24 100644
--- a/build/cjs/integrations/anr/index.js
+++ b/build/cjs/integrations/anr/index.js
@@ -9,7 +9,7 @@ const debug = require('../../utils/debug.js');
 const { isPromise } = util.types;
 
 // This string is a placeholder that gets overwritten with the worker code.
-const base64WorkerScript = 'LyohIEBzZW50cnkvbm9kZSA5LjEyLjAgKDRlYjc4ZTUpIHwgaHR0cHM6Ly9naXRodWIuY29tL2dldHNlbnRyeS9zZW50cnktamF2YXNjcmlwdCAqLwppbXBvcnR7U2Vzc2lvbiBhcyB0fWZyb20ibm9kZTppbnNwZWN0b3IiO2ltcG9ydHt3b3JrZXJEYXRhIGFzIG4scGFyZW50UG9ydCBhcyBlfWZyb20ibm9kZTp3b3JrZXJfdGhyZWFkcyI7aW1wb3J0e3Bvc2l4IGFzIHIsc2VwIGFzIG99ZnJvbSJub2RlOnBhdGgiO2ltcG9ydCphcyBzIGZyb20ibm9kZTpodHRwIjtpbXBvcnQqYXMgaSBmcm9tIm5vZGU6aHR0cHMiO2ltcG9ydHtSZWFkYWJsZSBhcyBjfWZyb20ibm9kZTpzdHJlYW0iO2ltcG9ydHtjcmVhdGVHemlwIGFzIHV9ZnJvbSJub2RlOnpsaWIiO2ltcG9ydCphcyBhIGZyb20ibm9kZTpuZXQiO2ltcG9ydCphcyBmIGZyb20ibm9kZTp0bHMiO2NvbnN0IGg9InVuZGVmaW5lZCI9PXR5cGVvZiBfX1NFTlRSWV9ERUJVR19ffHxfX1NFTlRSWV9ERUJVR19fLHA9Z2xvYmFsVGhpcyxsPSJ1bmRlZmluZWQiPT10eXBlb2YgX19TRU5UUllfREVCVUdfX3x8X19TRU5UUllfREVCVUdfXyxkPSI5LjEyLjAiO2Z1bmN0aW9uIG0oKXtyZXR1cm4gZyhwKSxwfWZ1bmN0aW9uIGcodCl7Y29uc3Qgbj10Ll9fU0VOVFJZX189dC5fX1NFTlRSWV9ffHx7fTtyZXR1cm4gbi52ZXJzaW9uPW4udmVyc2lvbnx8ZCxuW2RdPW5bZF18fHt9fWZ1bmN0aW9uIHkodCxuLGU9cCl7Y29uc3Qgcj1lLl9fU0VOVFJZX189ZS5fX1NFTlRSWV9ffHx7fSxvPXJbZF09cltkXXx8e307cmV0dXJuIG9bdF18fChvW3RdPW4oKSl9Y29uc3QgYj1bImRlYnVnIiwiaW5mbyIsIndhcm4iLCJlcnJvciIsImxvZyIsImFzc2VydCIsInRyYWNlIl0sXz17fTtmdW5jdGlvbiB2KHQpe2lmKCEoImNvbnNvbGUiaW4gcCkpcmV0dXJuIHQoKTtjb25zdCBuPXAuY29uc29sZSxlPXt9LHI9T2JqZWN0LmtleXMoXyk7ci5mb3JFYWNoKCh0PT57Y29uc3Qgcj1fW3RdO2VbdF09blt0XSxuW3RdPXJ9KSk7dHJ5e3JldHVybiB0KCl9ZmluYWxseXtyLmZvckVhY2goKHQ9PntuW3RdPWVbdF19KSl9fWNvbnN0IHc9eSgibG9nZ2VyIiwoZnVuY3Rpb24oKXtsZXQgdD0hMTtjb25zdCBuPXtlbmFibGU6KCk9Pnt0PSEwfSxkaXNhYmxlOigpPT57dD0hMX0saXNFbmFibGVkOigpPT50fTtyZXR1cm4gbD9iLmZvckVhY2goKGU9PntuW2VdPSguLi5uKT0+e3QmJnYoKCgpPT57cC5jb25zb2xlW2VdKGBTZW50cnkgTG9nZ2VyIFske2V9XTpgLC4uLm4pfSkpfX0pKTpiLmZvckVhY2goKHQ9PntuW3RdPSgpPT57fX0pKSxufSkpLFM9NTAsJD0iPyIsRT0vY2FwdHVyZU1lc3NhZ2V8Y2FwdHVyZUV4Y2VwdGlvbi87ZnVuY3Rpb24geCh0KXtyZXR1cm4gdFt0Lmxlbmd0aC0xXXx8e319Y29uc3QgTj0iPGFub255bW91cz4iO2NvbnN0IFQ9MWUzO2Z1bmN0aW9uIEMoKXtyZXR1cm4gRGF0ZS5ub3coKS9UfWNvbnN0IFI9ZnVuY3Rpb24oKXtjb25zdHtwZXJmb3JtYW5jZTp0fT1wO2lmKCF0Py5ub3cpcmV0dXJuIEM7Y29uc3Qgbj1EYXRlLm5vdygpLXQubm93KCksZT1udWxsPT10LnRpbWVPcmlnaW4/bjp0LnRpbWVPcmlnaW47cmV0dXJuKCk9PihlK3Qubm93KCkpL1R9KCksaz1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO2Z1bmN0aW9uIGoodCxuKXtyZXR1cm4gay5jYWxsKHQpPT09YFtvYmplY3QgJHtufV1gfWZ1bmN0aW9uIEQodCl7cmV0dXJuIGoodCwiU3RyaW5nIil9ZnVuY3Rpb24gSSh0KXtyZXR1cm4gaih0LCJPYmplY3QiKX1mdW5jdGlvbiBPKHQpe3JldHVybiBCb29sZWFuKHQ/LnRoZW4mJiJmdW5jdGlvbiI9PXR5cGVvZiB0LnRoZW4pfWZ1bmN0aW9uIEEodCxuKXt0cnl7cmV0dXJuIHQgaW5zdGFuY2VvZiBufWNhdGNoKHQpe3JldHVybiExfX1jb25zdCBQPXAsVT04MDtmdW5jdGlvbiBNKHQsbil7Y29uc3QgZT10LHI9W107aWYoIWU/LnRhZ05hbWUpcmV0dXJuIiI7aWYoUC5IVE1MRWxlbWVudCYmZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50JiZlLmRhdGFzZXQpe2lmKGUuZGF0YXNldC5zZW50cnlDb21wb25lbnQpcmV0dXJuIGUuZGF0YXNldC5zZW50cnlDb21wb25lbnQ7aWYoZS5kYXRhc2V0LnNlbnRyeUVsZW1lbnQpcmV0dXJuIGUuZGF0YXNldC5zZW50cnlFbGVtZW50fXIucHVzaChlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSk7Y29uc3Qgbz1uPy5sZW5ndGg/bi5maWx0ZXIoKHQ9PmUuZ2V0QXR0cmlidXRlKHQpKSkubWFwKCh0PT5bdCxlLmdldEF0dHJpYnV0ZSh0KV0pKTpudWxsO2lmKG8/Lmxlbmd0aClvLmZvckVhY2goKHQ9PntyLnB1c2goYFske3RbMF19PSIke3RbMV19Il1gKX0pKTtlbHNle2UuaWQmJnIucHVzaChgIyR7ZS5pZH1gKTtjb25zdCB0PWUuY2xhc3NOYW1lO2lmKHQmJkQodCkpe2NvbnN0IG49dC5zcGxpdCgvXHMrLyk7Zm9yKGNvbnN0IHQgb2YgbilyLnB1c2goYC4ke3R9YCl9fWNvbnN0IHM9WyJhcmlhLWxhYmVsIiwidHlwZSIsIm5hbWUiLCJ0aXRsZSIsImFsdCJdO2Zvcihjb25zdCB0IG9mIHMpe2NvbnN0IG49ZS5nZXRBdHRyaWJ1dGUodCk7biYmci5wdXNoKGBbJHt0fT0iJHtufSJdYCl9cmV0dXJuIHIuam9pbigiIil9ZnVuY3Rpb24gTCh0LG49MCl7cmV0dXJuInN0cmluZyIhPXR5cGVvZiB0fHwwPT09bnx8dC5sZW5ndGg8PW4/dDpgJHt0LnNsaWNlKDAsbil9Li4uYH1mdW5jdGlvbiBCKHQpe2lmKGZ1bmN0aW9uKHQpe3N3aXRjaChrLmNhbGwodCkpe2Nhc2UiW29iamVjdCBFcnJvcl0iOmNhc2UiW29iamVjdCBFeGNlcHRpb25dIjpjYXNlIltvYmplY3QgRE9NRXhjZXB0aW9uXSI6Y2FzZSJbb2JqZWN0IFdlYkFzc2VtYmx5LkV4Y2VwdGlvbl0iOnJldHVybiEwO2RlZmF1bHQ6cmV0dXJuIEEodCxFcnJvcil9fSh0KSlyZXR1cm57bWVzc2FnZTp0Lm1lc3NhZ2UsbmFtZTp0Lm5hbWUsc3RhY2s6dC5zdGFjaywuLi5KKHQpfTtpZihuPXQsInVuZGVmaW5lZCIhPXR5cGVvZiBFdmVudCYmQShuLEV2ZW50KSl7Y29uc3Qgbj17dHlwZTp0LnR5cGUsdGFyZ2V0OkcodC50YXJnZXQpLGN1cnJlbnRUYXJnZXQ6Ryh0LmN1cnJlbnRUYXJnZXQpLC4uLkoodCl9O3JldHVybiJ1bmRlZmluZWQiIT10eXBlb2YgQ3VzdG9tRXZlbnQmJkEodCxDdXN0b21FdmVudCkmJihuLmRldGFpbD10LmRldGFpbCksbn1yZXR1cm4gdDt2YXIgbn1mdW5jdGlvbiBHKHQpe3RyeXtyZXR1cm4gbj10LCJ1bmRlZmluZWQiIT10eXBlb2YgRWxlbWVudCYmQShuLEVsZW1lbnQpP2Z1bmN0aW9uKHQsbj17fSl7aWYoIXQpcmV0dXJuIjx1bmtub3duPiI7dHJ5e2xldCBlPXQ7Y29uc3Qgcj01LG89W107bGV0IHM9MCxpPTA7Y29uc3QgYz0iID4gIix1PWMubGVuZ3RoO2xldCBhO2NvbnN0IGY9QXJyYXkuaXNBcnJheShuKT9uOm4ua2V5QXR0cnMsaD0hQXJyYXkuaXNBcnJheShuKSYmbi5tYXhTdHJpbmdMZW5ndGh8fFU7Zm9yKDtlJiZzKys8ciYmKGE9TShlLGYpLCEoImh0bWwiPT09YXx8cz4xJiZpK28ubGVuZ3RoKnUrYS5sZW5ndGg+PWgpKTspby5wdXNoKGEpLGkrPWEubGVuZ3RoLGU9ZS5wYXJlbnROb2RlO3JldHVybiBvLnJldmVyc2UoKS5qb2luKGMpfWNhdGNoKHQpe3JldHVybiI8dW5rbm93bj4ifX0odCk6T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpfWNhdGNoKHQpe3JldHVybiI8dW5rbm93bj4ifXZhciBufWZ1bmN0aW9uIEoodCl7aWYoIm9iamVjdCI9PXR5cGVvZiB0JiZudWxsIT09dCl7Y29uc3Qgbj17fTtmb3IoY29uc3QgZSBpbiB0KU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LGUpJiYobltlXT10W2VdKTtyZXR1cm4gbn1yZXR1cm57fX1mdW5jdGlvbiBZKHQ9ZnVuY3Rpb24oKXtjb25zdCB0PXA7cmV0dXJuIHQuY3J5cHRvfHx0Lm1zQ3J5cHRvfSgpKXtsZXQgbj0oKT0+MTYqTWF0aC5yYW5kb20oKTt0cnl7aWYodD8ucmFuZG9tVVVJRClyZXR1cm4gdC5yYW5kb21VVUlEKCkucmVwbGFjZSgvLS9nLCIiKTt0Py5nZXRSYW5kb21WYWx1ZXMmJihuPSgpPT57Y29uc3Qgbj1uZXcgVWludDhBcnJheSgxKTtyZXR1cm4gdC5nZXRSYW5kb21WYWx1ZXMobiksblswXX0pfWNhdGNoKHQpe31yZXR1cm4oWzFlN10rMWUzKzRlMys4ZTMrMWUxMSkucmVwbGFjZSgvWzAxOF0vZywodD0+KHReKDE1Jm4oKSk+PnQvNCkudG9TdHJpbmcoMTYpKSl9dmFyIHo7ZnVuY3Rpb24gSCh0KXtyZXR1cm4gbmV3IEYoKG49PntuKHQpfSkpfSFmdW5jdGlvbih0KXt0W3QuUEVORElORz0wXT0iUEVORElORyI7dFt0LlJFU09MVkVEPTFdPSJSRVNPTFZFRCI7dFt0LlJFSkVDVEVEPTJdPSJSRUpFQ1RFRCJ9KHp8fCh6PXt9KSk7Y2xhc3MgRntjb25zdHJ1Y3Rvcih0KXt0aGlzLnQ9ei5QRU5ESU5HLHRoaXMubz1bXSx0aGlzLmkodCl9dGhlbih0LG4pe3JldHVybiBuZXcgRigoKGUscik9Pnt0aGlzLm8ucHVzaChbITEsbj0+e2lmKHQpdHJ5e2UodChuKSl9Y2F0Y2godCl7cih0KX1lbHNlIGUobil9LHQ9PntpZihuKXRyeXtlKG4odCkpfWNhdGNoKHQpe3IodCl9ZWxzZSByKHQpfV0pLHRoaXMudSgpfSkpfWNhdGNoKHQpe3JldHVybiB0aGlzLnRoZW4oKHQ9PnQpLHQpfWZpbmFsbHkodCl7cmV0dXJuIG5ldyBGKCgobixlKT0+e2xldCByLG87cmV0dXJuIHRoaXMudGhlbigobj0+e289ITEscj1uLHQmJnQoKX0pLChuPT57bz0hMCxyPW4sdCYmdCgpfSkpLnRoZW4oKCgpPT57bz9lKHIpOm4ocil9KSl9KSl9dSgpe2lmKHRoaXMudD09PXouUEVORElORylyZXR1cm47Y29uc3QgdD10aGlzLm8uc2xpY2UoKTt0aGlzLm89W10sdC5mb3JFYWNoKCh0PT57dFswXXx8KHRoaXMudD09PXouUkVTT0xWRUQmJnRbMV0odGhpcy5oKSx0aGlzLnQ9PT16LlJFSkVDVEVEJiZ0WzJdKHRoaXMuaCksdFswXT0hMCl9KSl9aSh0KXtjb25zdCBuPSh0LG4pPT57dGhpcy50PT09ei5QRU5ESU5HJiYoTyhuKT9uLnRoZW4oZSxyKToodGhpcy50PXQsdGhpcy5oPW4sdGhpcy51KCkpKX0sZT10PT57bih6LlJFU09MVkVELHQpfSxyPXQ9PntuKHouUkVKRUNURUQsdCl9O3RyeXt0KGUscil9Y2F0Y2godCl7cih0KX19fWZ1bmN0aW9uIFcodCl7Y29uc3Qgbj1SKCksZT17c2lkOlkoKSxpbml0OiEwLHRpbWVzdGFtcDpuLHN0YXJ0ZWQ6bixkdXJhdGlvbjowLHN0YXR1czoib2siLGVycm9yczowLGlnbm9yZUR1cmF0aW9uOiExLHRvSlNPTjooKT0+ZnVuY3Rpb24odCl7cmV0dXJue3NpZDpgJHt0LnNpZH1gLGluaXQ6dC5pbml0LHN0YXJ0ZWQ6bmV3IERhdGUoMWUzKnQuc3RhcnRlZCkudG9JU09TdHJpbmcoKSx0aW1lc3RhbXA6bmV3IERhdGUoMWUzKnQudGltZXN0YW1wKS50b0lTT1N0cmluZygpLHN0YXR1czp0LnN0YXR1cyxlcnJvcnM6dC5lcnJvcnMsZGlkOiJudW1iZXIiPT10eXBlb2YgdC5kaWR8fCJzdHJpbmciPT10eXBlb2YgdC5kaWQ/YCR7dC5kaWR9YDp2b2lkIDAsZHVyYXRpb246dC5kdXJhdGlvbixhYm5vcm1hbF9tZWNoYW5pc206dC5hYm5vcm1hbF9tZWNoYW5pc20sYXR0cnM6e3JlbGVhc2U6dC5yZWxlYXNlLGVudmlyb25tZW50OnQuZW52aXJvbm1lbnQsaXBfYWRkcmVzczp0LmlwQWRkcmVzcyx1c2VyX2FnZW50OnQudXNlckFnZW50fX19KGUpfTtyZXR1cm4gdCYmSyhlLHQpLGV9ZnVuY3Rpb24gSyh0LG49e30pe2lmKG4udXNlciYmKCF0LmlwQWRkcmVzcyYmbi51c2VyLmlwX2FkZHJlc3MmJih0LmlwQWRkcmVzcz1uLnVzZXIuaXBfYWRkcmVzcyksdC5kaWR8fG4uZGlkfHwodC5kaWQ9bi51c2VyLmlkfHxuLnVzZXIuZW1haWx8fG4udXNlci51c2VybmFtZSkpLHQudGltZXN0YW1wPW4udGltZXN0YW1wfHxSKCksbi5hYm5vcm1hbF9tZWNoYW5pc20mJih0LmFibm9ybWFsX21lY2hhbmlzbT1uLmFibm9ybWFsX21lY2hhbmlzbSksbi5pZ25vcmVEdXJhdGlvbiYmKHQuaWdub3JlRHVyYXRpb249bi5pZ25vcmVEdXJhdGlvbiksbi5zaWQmJih0LnNpZD0zMj09PW4uc2lkLmxlbmd0aD9uLnNpZDpZKCkpLHZvaWQgMCE9PW4uaW5pdCYmKHQuaW5pdD1uLmluaXQpLCF0LmRpZCYmbi5kaWQmJih0LmRpZD1gJHtuLmRpZH1gKSwibnVtYmVyIj09dHlwZW9mIG4uc3RhcnRlZCYmKHQuc3RhcnRlZD1uLnN0YXJ0ZWQpLHQuaWdub3JlRHVyYXRpb24pdC5kdXJhdGlvbj12b2lkIDA7ZWxzZSBpZigibnVtYmVyIj09dHlwZW9mIG4uZHVyYXRpb24pdC5kdXJhdGlvbj1uLmR1cmF0aW9uO2Vsc2V7Y29uc3Qgbj10LnRpbWVzdGFtcC10LnN0YXJ0ZWQ7dC5kdXJhdGlvbj1uPj0wP246MH1uLnJlbGVhc2UmJih0LnJlbGVhc2U9bi5yZWxlYXNlKSxuLmVudmlyb25tZW50JiYodC5lbnZpcm9ubWVudD1uLmVudmlyb25tZW50KSwhdC5pcEFkZHJlc3MmJm4uaXBBZGRyZXNzJiYodC5pcEFkZHJlc3M9bi5pcEFkZHJlc3MpLCF0LnVzZXJBZ2VudCYmbi51c2VyQWdlbnQmJih0LnVzZXJBZ2VudD1uLnVzZXJBZ2VudCksIm51bWJlciI9PXR5cGVvZiBuLmVycm9ycyYmKHQuZXJyb3JzPW4uZXJyb3JzKSxuLnN0YXR1cyYmKHQuc3RhdHVzPW4uc3RhdHVzKX1mdW5jdGlvbiBWKCl7cmV0dXJuIFkoKX1mdW5jdGlvbiBaKCl7cmV0dXJuIFkoKS5zdWJzdHJpbmcoMTYpfWZ1bmN0aW9uIHEodCxuLGU9Mil7aWYoIW58fCJvYmplY3QiIT10eXBlb2Ygbnx8ZTw9MClyZXR1cm4gbjtpZih0JiYwPT09T2JqZWN0LmtleXMobikubGVuZ3RoKXJldHVybiB0O2NvbnN0IHI9ey4uLnR9O2Zvcihjb25zdCB0IGluIG4pT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sdCkmJihyW3RdPXEoclt0XSxuW3RdLGUtMSkpO3JldHVybiByfWNvbnN0IFE9Il9zZW50cnlTcGFuIjtmdW5jdGlvbiBYKHQsbil7bj9mdW5jdGlvbih0LG4sZSl7dHJ5e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4se3ZhbHVlOmUsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfSl9Y2F0Y2goZSl7bCYmdy5sb2coYEZhaWxlZCB0byBhZGQgbm9uLWVudW1lcmFibGUgcHJvcGVydHkgIiR7bn0iIHRvIG9iamVjdGAsdCl9fSh0LFEsbik6ZGVsZXRlIHRbUV19ZnVuY3Rpb24gdHQodCl7cmV0dXJuIHRbUV19Y2xhc3MgbnR7Y29uc3RydWN0b3IoKXt0aGlzLnA9ITEsdGhpcy5sPVtdLHRoaXMubT1bXSx0aGlzLl89W10sdGhpcy52PVtdLHRoaXMuUz17fSx0aGlzLk49e30sdGhpcy5UPXt9LHRoaXMuQz17fSx0aGlzLlI9e30sdGhpcy5rPXt0cmFjZUlkOlYoKSxzYW1wbGVSYW5kOk1hdGgucmFuZG9tKCl9fWNsb25lKCl7Y29uc3QgdD1uZXcgbnQ7cmV0dXJuIHQuXz1bLi4udGhpcy5fXSx0Lk49ey4uLnRoaXMuTn0sdC5UPXsuLi50aGlzLlR9LHQuQz17Li4udGhpcy5DfSx0aGlzLkMuZmxhZ3MmJih0LkMuZmxhZ3M9e3ZhbHVlczpbLi4udGhpcy5DLmZsYWdzLnZhbHVlc119KSx0LlM9dGhpcy5TLHQuaj10aGlzLmosdC5EPXRoaXMuRCx0Lkk9dGhpcy5JLHQuTz10aGlzLk8sdC5tPVsuLi50aGlzLm1dLHQudj1bLi4udGhpcy52XSx0LlI9ey4uLnRoaXMuUn0sdC5rPXsuLi50aGlzLmt9LHQuQT10aGlzLkEsdC5QPXRoaXMuUCxYKHQsdHQodGhpcykpLHR9c2V0Q2xpZW50KHQpe3RoaXMuQT10fXNldExhc3RFdmVudElkKHQpe3RoaXMuUD10fWdldENsaWVudCgpe3JldHVybiB0aGlzLkF9bGFzdEV2ZW50SWQoKXtyZXR1cm4gdGhpcy5QfWFkZFNjb3BlTGlzdGVuZXIodCl7dGhpcy5sLnB1c2godCl9YWRkRXZlbnRQcm9jZXNzb3IodCl7cmV0dXJuIHRoaXMubS5wdXNoKHQpLHRoaXN9c2V0VXNlcih0KXtyZXR1cm4gdGhpcy5TPXR8fHtlbWFpbDp2b2lkIDAsaWQ6dm9pZCAwLGlwX2FkZHJlc3M6dm9pZCAwLHVzZXJuYW1lOnZvaWQgMH0sdGhpcy5EJiZLKHRoaXMuRCx7dXNlcjp0fSksdGhpcy5VKCksdGhpc31nZXRVc2VyKCl7cmV0dXJuIHRoaXMuU31zZXRUYWdzKHQpe3JldHVybiB0aGlzLk49ey4uLnRoaXMuTiwuLi50fSx0aGlzLlUoKSx0aGlzfXNldFRhZyh0LG4pe3JldHVybiB0aGlzLk49ey4uLnRoaXMuTixbdF06bn0sdGhpcy5VKCksdGhpc31zZXRFeHRyYXModCl7cmV0dXJuIHRoaXMuVD17Li4udGhpcy5ULC4uLnR9LHRoaXMuVSgpLHRoaXN9c2V0RXh0cmEodCxuKXtyZXR1cm4gdGhpcy5UPXsuLi50aGlzLlQsW3RdOm59LHRoaXMuVSgpLHRoaXN9c2V0RmluZ2VycHJpbnQodCl7cmV0dXJuIHRoaXMuTz10LHRoaXMuVSgpLHRoaXN9c2V0TGV2ZWwodCl7cmV0dXJuIHRoaXMuaj10LHRoaXMuVSgpLHRoaXN9c2V0VHJhbnNhY3Rpb25OYW1lKHQpe3JldHVybiB0aGlzLkk9dCx0aGlzLlUoKSx0aGlzfXNldENvbnRleHQodCxuKXtyZXR1cm4gbnVsbD09PW4/ZGVsZXRlIHRoaXMuQ1t0XTp0aGlzLkNbdF09bix0aGlzLlUoKSx0aGlzfXNldFNlc3Npb24odCl7cmV0dXJuIHQ/dGhpcy5EPXQ6ZGVsZXRlIHRoaXMuRCx0aGlzLlUoKSx0aGlzfWdldFNlc3Npb24oKXtyZXR1cm4gdGhpcy5EfXVwZGF0ZSh0KXtpZighdClyZXR1cm4gdGhpcztjb25zdCBuPSJmdW5jdGlvbiI9PXR5cGVvZiB0P3QodGhpcyk6dCxlPW4gaW5zdGFuY2VvZiBudD9uLmdldFNjb3BlRGF0YSgpOkkobik/dDp2b2lkIDAse3RhZ3M6cixleHRyYTpvLHVzZXI6cyxjb250ZXh0czppLGxldmVsOmMsZmluZ2VycHJpbnQ6dT1bXSxwcm9wYWdhdGlvbkNvbnRleHQ6YX09ZXx8e307cmV0dXJuIHRoaXMuTj17Li4udGhpcy5OLC4uLnJ9LHRoaXMuVD17Li4udGhpcy5ULC4uLm99LHRoaXMuQz17Li4udGhpcy5DLC4uLml9LHMmJk9iamVjdC5rZXlzKHMpLmxlbmd0aCYmKHRoaXMuUz1zKSxjJiYodGhpcy5qPWMpLHUubGVuZ3RoJiYodGhpcy5PPXUpLGEmJih0aGlzLms9YSksdGhpc31jbGVhcigpe3JldHVybiB0aGlzLl89W10sdGhpcy5OPXt9LHRoaXMuVD17fSx0aGlzLlM9e30sdGhpcy5DPXt9LHRoaXMuaj12b2lkIDAsdGhpcy5JPXZvaWQgMCx0aGlzLk89dm9pZCAwLHRoaXMuRD12b2lkIDAsWCh0aGlzLHZvaWQgMCksdGhpcy52PVtdLHRoaXMuc2V0UHJvcGFnYXRpb25Db250ZXh0KHt0cmFjZUlkOlYoKSxzYW1wbGVSYW5kOk1hdGgucmFuZG9tKCl9KSx0aGlzLlUoKSx0aGlzfWFkZEJyZWFkY3J1bWIodCxuKXtjb25zdCBlPSJudW1iZXIiPT10eXBlb2Ygbj9uOjEwMDtpZihlPD0wKXJldHVybiB0aGlzO2NvbnN0IHI9e3RpbWVzdGFtcDpDKCksLi4udCxtZXNzYWdlOnQubWVzc2FnZT9MKHQubWVzc2FnZSwyMDQ4KTp0Lm1lc3NhZ2V9O3JldHVybiB0aGlzLl8ucHVzaChyKSx0aGlzLl8ubGVuZ3RoPmUmJih0aGlzLl89dGhpcy5fLnNsaWNlKC1lKSx0aGlzLkE/LnJlY29yZERyb3BwZWRFdmVudCgiYnVmZmVyX292ZXJmbG93IiwibG9nX2l0ZW0iKSksdGhpcy5VKCksdGhpc31nZXRMYXN0QnJlYWRjcnVtYigpe3JldHVybiB0aGlzLl9bdGhpcy5fLmxlbmd0aC0xXX1jbGVhckJyZWFkY3J1bWJzKCl7cmV0dXJuIHRoaXMuXz1bXSx0aGlzLlUoKSx0aGlzfWFkZEF0dGFjaG1lbnQodCl7cmV0dXJuIHRoaXMudi5wdXNoKHQpLHRoaXN9Y2xlYXJBdHRhY2htZW50cygpe3JldHVybiB0aGlzLnY9W10sdGhpc31nZXRTY29wZURhdGEoKXtyZXR1cm57YnJlYWRjcnVtYnM6dGhpcy5fLGF0dGFjaG1lbnRzOnRoaXMudixjb250ZXh0czp0aGlzLkMsdGFnczp0aGlzLk4sZXh0cmE6dGhpcy5ULHVzZXI6dGhpcy5TLGxldmVsOnRoaXMuaixmaW5nZXJwcmludDp0aGlzLk98fFtdLGV2ZW50UHJvY2Vzc29yczp0aGlzLm0scHJvcGFnYXRpb25Db250ZXh0OnRoaXMuayxzZGtQcm9jZXNzaW5nTWV0YWRhdGE6dGhpcy5SLHRyYW5zYWN0aW9uTmFtZTp0aGlzLkksc3Bhbjp0dCh0aGlzKX19c2V0U0RLUHJvY2Vzc2luZ01ldGFkYXRhKHQpe3JldHVybiB0aGlzLlI9cSh0aGlzLlIsdCwyKSx0aGlzfXNldFByb3BhZ2F0aW9uQ29udGV4dCh0KXtyZXR1cm4gdGhpcy5rPXQsdGhpc31nZXRQcm9wYWdhdGlvbkNvbnRleHQoKXtyZXR1cm4gdGhpcy5rfWNhcHR1cmVFeGNlcHRpb24odCxuKXtjb25zdCBlPW4/LmV2ZW50X2lkfHxZKCk7aWYoIXRoaXMuQSlyZXR1cm4gdy53YXJuKCJObyBjbGllbnQgY29uZmlndXJlZCBvbiBzY29wZSAtIHdpbGwgbm90IGNhcHR1cmUgZXhjZXB0aW9uISIpLGU7Y29uc3Qgcj1uZXcgRXJyb3IoIlNlbnRyeSBzeW50aGV0aWNFeGNlcHRpb24iKTtyZXR1cm4gdGhpcy5BLmNhcHR1cmVFeGNlcHRpb24odCx7b3JpZ2luYWxFeGNlcHRpb246dCxzeW50aGV0aWNFeGNlcHRpb246ciwuLi5uLGV2ZW50X2lkOmV9LHRoaXMpLGV9Y2FwdHVyZU1lc3NhZ2UodCxuLGUpe2NvbnN0IHI9ZT8uZXZlbnRfaWR8fFkoKTtpZighdGhpcy5BKXJldHVybiB3Lndhcm4oIk5vIGNsaWVudCBjb25maWd1cmVkIG9uIHNjb3BlIC0gd2lsbCBub3QgY2FwdHVyZSBtZXNzYWdlISIpLHI7Y29uc3Qgbz1uZXcgRXJyb3IodCk7cmV0dXJuIHRoaXMuQS5jYXB0dXJlTWVzc2FnZSh0LG4se29yaWdpbmFsRXhjZXB0aW9uOnQsc3ludGhldGljRXhjZXB0aW9uOm8sLi4uZSxldmVudF9pZDpyfSx0aGlzKSxyfWNhcHR1cmVFdmVudCh0LG4pe2NvbnN0IGU9bj8uZXZlbnRfaWR8fFkoKTtyZXR1cm4gdGhpcy5BPyh0aGlzLkEuY2FwdHVyZUV2ZW50KHQsey4uLm4sZXZlbnRfaWQ6ZX0sdGhpcyksZSk6KHcud2FybigiTm8gY2xpZW50IGNvbmZpZ3VyZWQgb24gc2NvcGUgLSB3aWxsIG5vdCBjYXB0dXJlIGV2ZW50ISIpLGUpfVUoKXt0aGlzLnB8fCh0aGlzLnA9ITAsdGhpcy5sLmZvckVhY2goKHQ9Pnt0KHRoaXMpfSkpLHRoaXMucD0hMSl9fWNsYXNzIGV0e2NvbnN0cnVjdG9yKHQsbil7bGV0IGUscjtlPXR8fG5ldyBudCxyPW58fG5ldyBudCx0aGlzLk09W3tzY29wZTplfV0sdGhpcy5MPXJ9d2l0aFNjb3BlKHQpe2NvbnN0IG49dGhpcy5CKCk7bGV0IGU7dHJ5e2U9dChuKX1jYXRjaCh0KXt0aHJvdyB0aGlzLkcoKSx0fXJldHVybiBPKGUpP2UudGhlbigodD0+KHRoaXMuRygpLHQpKSwodD0+e3Rocm93IHRoaXMuRygpLHR9KSk6KHRoaXMuRygpLGUpfWdldENsaWVudCgpe3JldHVybiB0aGlzLmdldFN0YWNrVG9wKCkuY2xpZW50fWdldFNjb3BlKCl7cmV0dXJuIHRoaXMuZ2V0U3RhY2tUb3AoKS5zY29wZX1nZXRJc29sYXRpb25TY29wZSgpe3JldHVybiB0aGlzLkx9Z2V0U3RhY2tUb3AoKXtyZXR1cm4gdGhpcy5NW3RoaXMuTS5sZW5ndGgtMV19Qigpe2NvbnN0IHQ9dGhpcy5nZXRTY29wZSgpLmNsb25lKCk7cmV0dXJuIHRoaXMuTS5wdXNoKHtjbGllbnQ6dGhpcy5nZXRDbGllbnQoKSxzY29wZTp0fSksdH1HKCl7cmV0dXJuISh0aGlzLk0ubGVuZ3RoPD0xKSYmISF0aGlzLk0ucG9wKCl9fWZ1bmN0aW9uIHJ0KCl7Y29uc3QgdD1nKG0oKSk7cmV0dXJuIHQuc3RhY2s9dC5zdGFja3x8bmV3IGV0KHkoImRlZmF1bHRDdXJyZW50U2NvcGUiLCgoKT0+bmV3IG50KSkseSgiZGVmYXVsdElzb2xhdGlvblNjb3BlIiwoKCk9Pm5ldyBudCkpKX1mdW5jdGlvbiBvdCh0KXtyZXR1cm4gcnQoKS53aXRoU2NvcGUodCl9ZnVuY3Rpb24gc3QodCxuKXtjb25zdCBlPXJ0KCk7cmV0dXJuIGUud2l0aFNjb3BlKCgoKT0+KGUuZ2V0U3RhY2tUb3AoKS5zY29wZT10LG4odCkpKSl9ZnVuY3Rpb24gaXQodCl7cmV0dXJuIHJ0KCkud2l0aFNjb3BlKCgoKT0+dChydCgpLmdldElzb2xhdGlvblNjb3BlKCkpKSl9ZnVuY3Rpb24gY3QodCl7Y29uc3Qgbj1nKHQpO3JldHVybiBuLmFjcz9uLmFjczp7d2l0aElzb2xhdGlvblNjb3BlOml0LHdpdGhTY29wZTpvdCx3aXRoU2V0U2NvcGU6c3Qsd2l0aFNldElzb2xhdGlvblNjb3BlOih0LG4pPT5pdChuKSxnZXRDdXJyZW50U2NvcGU6KCk9PnJ0KCkuZ2V0U2NvcGUoKSxnZXRJc29sYXRpb25TY29wZTooKT0+cnQoKS5nZXRJc29sYXRpb25TY29wZSgpfX1mdW5jdGlvbiB1dCgpe3JldHVybiBjdChtKCkpLmdldEN1cnJlbnRTY29wZSgpLmdldENsaWVudCgpfWNvbnN0IGF0PSJzZW50cnkuc291cmNlIixmdD0ic2VudHJ5LnNhbXBsZV9yYXRlIixodD0ic2VudHJ5Lm9wIixwdD0ic2VudHJ5Lm9yaWdpbiIsbHQ9MCxkdD0xLG10PSJfc2VudHJ5U2NvcGUiLGd0PSJfc2VudHJ5SXNvbGF0aW9uU2NvcGUiO2Z1bmN0aW9uIHl0KHQpe3JldHVybntzY29wZTp0W210XSxpc29sYXRpb25TY29wZTp0W2d0XX19Y29uc3QgYnQ9InNlbnRyeS0iLF90PS9ec2VudHJ5LS87ZnVuY3Rpb24gdnQodCl7Y29uc3Qgbj1mdW5jdGlvbih0KXtpZighdHx8IUQodCkmJiFBcnJheS5pc0FycmF5KHQpKXJldHVybjtpZihBcnJheS5pc0FycmF5KHQpKXJldHVybiB0LnJlZHVjZSgoKHQsbik9Pntjb25zdCBlPXd0KG4pO3JldHVybiBPYmplY3QuZW50cmllcyhlKS5mb3JFYWNoKCgoW24sZV0pPT57dFtuXT1lfSkpLHR9KSx7fSk7cmV0dXJuIHd0KHQpfSh0KTtpZighbilyZXR1cm47Y29uc3QgZT1PYmplY3QuZW50cmllcyhuKS5yZWR1Y2UoKCh0LFtuLGVdKT0+e2lmKG4ubWF0Y2goX3QpKXt0W24uc2xpY2UoYnQubGVuZ3RoKV09ZX1yZXR1cm4gdH0pLHt9KTtyZXR1cm4gT2JqZWN0LmtleXMoZSkubGVuZ3RoPjA/ZTp2b2lkIDB9ZnVuY3Rpb24gd3QodCl7cmV0dXJuIHQuc3BsaXQoIiwiKS5tYXAoKHQ9PnQuc3BsaXQoIj0iKS5tYXAoKHQ9PmRlY29kZVVSSUNvbXBvbmVudCh0LnRyaW0oKSkpKSkpLnJlZHVjZSgoKHQsW24sZV0pPT4obiYmZSYmKHRbbl09ZSksdCkpLHt9KX1jb25zdCBTdD0xO2Z1bmN0aW9uICR0KHQpe2NvbnN0e3NwYW5JZDpuLHRyYWNlSWQ6ZSxpc1JlbW90ZTpyfT10LnNwYW5Db250ZXh0KCksbz1yP246VHQodCkucGFyZW50X3NwYW5faWQscz15dCh0KS5zY29wZTtyZXR1cm57cGFyZW50X3NwYW5faWQ6byxzcGFuX2lkOnI/cz8uZ2V0UHJvcGFnYXRpb25Db250ZXh0KCkucHJvcGFnYXRpb25TcGFuSWR8fFooKTpuLHRyYWNlX2lkOmV9fWZ1bmN0aW9uIEV0KHQpe3JldHVybiB0JiZ0Lmxlbmd0aD4wP3QubWFwKCgoe2NvbnRleHQ6e3NwYW5JZDp0LHRyYWNlSWQ6bix0cmFjZUZsYWdzOmUsLi4ucn0sYXR0cmlidXRlczpvfSk9Pih7c3Bhbl9pZDp0LHRyYWNlX2lkOm4sc2FtcGxlZDplPT09U3QsYXR0cmlidXRlczpvLC4uLnJ9KSkpOnZvaWQgMH1mdW5jdGlvbiB4dCh0KXtyZXR1cm4ibnVtYmVyIj09dHlwZW9mIHQ/TnQodCk6QXJyYXkuaXNBcnJheSh0KT90WzBdK3RbMV0vMWU5OnQgaW5zdGFuY2VvZiBEYXRlP050KHQuZ2V0VGltZSgpKTpSKCl9ZnVuY3Rpb24gTnQodCl7cmV0dXJuIHQ+OTk5OTk5OTk5OT90LzFlMzp0fWZ1bmN0aW9uIFR0KHQpe2lmKGZ1bmN0aW9uKHQpe3JldHVybiJmdW5jdGlvbiI9PXR5cGVvZiB0LmdldFNwYW5KU09OfSh0KSlyZXR1cm4gdC5nZXRTcGFuSlNPTigpO2NvbnN0e3NwYW5JZDpuLHRyYWNlSWQ6ZX09dC5zcGFuQ29udGV4dCgpO2lmKGZ1bmN0aW9uKHQpe2NvbnN0IG49dDtyZXR1cm4hIShuLmF0dHJpYnV0ZXMmJm4uc3RhcnRUaW1lJiZuLm5hbWUmJm4uZW5kVGltZSYmbi5zdGF0dXMpfSh0KSl7Y29uc3R7YXR0cmlidXRlczpyLHN0YXJ0VGltZTpvLG5hbWU6cyxlbmRUaW1lOmkscGFyZW50U3BhbklkOmMsc3RhdHVzOnUsbGlua3M6YX09dDtyZXR1cm57c3Bhbl9pZDpuLHRyYWNlX2lkOmUsZGF0YTpyLGRlc2NyaXB0aW9uOnMscGFyZW50X3NwYW5faWQ6YyxzdGFydF90aW1lc3RhbXA6eHQobyksdGltZXN0YW1wOnh0KGkpfHx2b2lkIDAsc3RhdHVzOkN0KHUpLG9wOnJbaHRdLG9yaWdpbjpyW3B0XSxsaW5rczpFdChhKX19cmV0dXJue3NwYW5faWQ6bix0cmFjZV9pZDplLHN0YXJ0X3RpbWVzdGFtcDowLGRhdGE6e319fWZ1bmN0aW9uIEN0KHQpe2lmKHQmJnQuY29kZSE9PWx0KXJldHVybiB0LmNvZGU9PT1kdD8ib2siOnQubWVzc2FnZXx8InVua25vd25fZXJyb3IifWNvbnN0IFJ0PSJfc2VudHJ5Um9vdFNwYW4iO2Z1bmN0aW9uIGt0KHQpe3JldHVybiB0W1J0XXx8dH1jb25zdCBqdD0icHJvZHVjdGlvbiIsRHQ9Il9mcm96ZW5Ec2MiO2Z1bmN0aW9uIEl0KHQpe2NvbnN0IG49dXQoKTtpZighbilyZXR1cm57fTtjb25zdCBlPWt0KHQpLHI9VHQoZSksbz1yLmRhdGEscz1lLnNwYW5Db250ZXh0KCkudHJhY2VTdGF0ZSxpPXM/LmdldCgic2VudHJ5LnNhbXBsZV9yYXRlIik/P29bZnRdO2Z1bmN0aW9uIGModCl7cmV0dXJuIm51bWJlciIhPXR5cGVvZiBpJiYic3RyaW5nIiE9dHlwZW9mIGl8fCh0LnNhbXBsZV9yYXRlPWAke2l9YCksdH1jb25zdCB1PWVbRHRdO2lmKHUpcmV0dXJuIGModSk7Y29uc3QgYT1zPy5nZXQoInNlbnRyeS5kc2MiKSxmPWEmJnZ0KGEpO2lmKGYpcmV0dXJuIGMoZik7Y29uc3QgaD1mdW5jdGlvbih0LG4pe2NvbnN0IGU9bi5nZXRPcHRpb25zKCkse3B1YmxpY0tleTpyfT1uLmdldERzbigpfHx7fSxvPXtlbnZpcm9ubWVudDplLmVudmlyb25tZW50fHxqdCxyZWxlYXNlOmUucmVsZWFzZSxwdWJsaWNfa2V5OnIsdHJhY2VfaWQ6dH07cmV0dXJuIG4uZW1pdCgiY3JlYXRlRHNjIixvKSxvfSh0LnNwYW5Db250ZXh0KCkudHJhY2VJZCxuKSxwPW9bYXRdLGw9ci5kZXNjcmlwdGlvbjtyZXR1cm4idXJsIiE9PXAmJmwmJihoLnRyYW5zYWN0aW9uPWwpLGZ1bmN0aW9uKHQpe2lmKCJib29sZWFuIj09dHlwZW9mIF9fU0VOVFJZX1RSQUNJTkdfXyYmIV9fU0VOVFJZX1RSQUNJTkdfXylyZXR1cm4hMTtjb25zdCBuPXR8fHV0KCk/LmdldE9wdGlvbnMoKTtyZXR1cm4hKCFufHxudWxsPT1uLnRyYWNlc1NhbXBsZVJhdGUmJiFuLnRyYWNlc1NhbXBsZXIpfSgpJiYoaC5zYW1wbGVkPVN0cmluZyhmdW5jdGlvbih0KXtjb25zdHt0cmFjZUZsYWdzOm59PXQuc3BhbkNvbnRleHQoKTtyZXR1cm4gbj09PVN0fShlKSksaC5zYW1wbGVfcmFuZD1zPy5nZXQoInNlbnRyeS5zYW1wbGVfcmFuZCIpPz95dChlKS5zY29wZT8uZ2V0UHJvcGFnYXRpb25Db250ZXh0KCkuc2FtcGxlUmFuZC50b1N0cmluZygpKSxjKGgpLG4uZW1pdCgiY3JlYXRlRHNjIixoLGUpLGh9ZnVuY3Rpb24gT3QodCxuPSExKXtjb25zdHtob3N0OmUscGF0aDpyLHBhc3M6byxwb3J0OnMscHJvamVjdElkOmkscHJvdG9jb2w6YyxwdWJsaWNLZXk6dX09dDtyZXR1cm5gJHtjfTovLyR7dX0ke24mJm8/YDoke299YDoiIn1AJHtlfSR7cz9gOiR7c31gOiIifS8ke3I/YCR7cn0vYDpyfSR7aX1gfWZ1bmN0aW9uIEF0KHQsbj0xMDAsZT0xLzApe3RyeXtyZXR1cm4gUHQoIiIsdCxuLGUpfWNhdGNoKHQpe3JldHVybntFUlJPUjpgKipub24tc2VyaWFsaXphYmxlKiogKCR7dH0pYH19fWZ1bmN0aW9uIFB0KHQsbixlPTEvMCxyPTEvMCxvPWZ1bmN0aW9uKCl7Y29uc3QgdD1uZXcgV2Vha1NldDtmdW5jdGlvbiBuKG4pe3JldHVybiEhdC5oYXMobil8fCh0LmFkZChuKSwhMSl9ZnVuY3Rpb24gZShuKXt0LmRlbGV0ZShuKX1yZXR1cm5bbixlXX0oKSl7Y29uc3RbcyxpXT1vO2lmKG51bGw9PW58fFsiYm9vbGVhbiIsInN0cmluZyJdLmluY2x1ZGVzKHR5cGVvZiBuKXx8Im51bWJlciI9PXR5cGVvZiBuJiZOdW1iZXIuaXNGaW5pdGUobikpcmV0dXJuIG47Y29uc3QgYz1mdW5jdGlvbih0LG4pe3RyeXtpZigiZG9tYWluIj09PXQmJm4mJiJvYmplY3QiPT10eXBlb2YgbiYmbi5KKXJldHVybiJbRG9tYWluXSI7aWYoImRvbWFpbkVtaXR0ZXIiPT09dClyZXR1cm4iW0RvbWFpbkVtaXR0ZXJdIjtpZigidW5kZWZpbmVkIiE9dHlwZW9mIGdsb2JhbCYmbj09PWdsb2JhbClyZXR1cm4iW0dsb2JhbF0iO2lmKCJ1bmRlZmluZWQiIT10eXBlb2Ygd2luZG93JiZuPT09d2luZG93KXJldHVybiJbV2luZG93XSI7aWYoInVuZGVmaW5lZCIhPXR5cGVvZiBkb2N1bWVudCYmbj09PWRvY3VtZW50KXJldHVybiJbRG9jdW1lbnRdIjtpZigib2JqZWN0Ij09dHlwZW9mKGU9bikmJm51bGwhPT1lJiYoZS5fX2lzVnVlfHxlLlkpKXJldHVybiJbVnVlVmlld01vZGVsXSI7aWYoZnVuY3Rpb24odCl7cmV0dXJuIEkodCkmJiJuYXRpdmVFdmVudCJpbiB0JiYicHJldmVudERlZmF1bHQiaW4gdCYmInN0b3BQcm9wYWdhdGlvbiJpbiB0fShuKSlyZXR1cm4iW1N5bnRoZXRpY0V2ZW50XSI7aWYoIm51bWJlciI9PXR5cGVvZiBuJiYhTnVtYmVyLmlzRmluaXRlKG4pKXJldHVybmBbJHtufV1gO2lmKCJmdW5jdGlvbiI9PXR5cGVvZiBuKXJldHVybmBbRnVuY3Rpb246ICR7ZnVuY3Rpb24odCl7dHJ5e3JldHVybiB0JiYiZnVuY3Rpb24iPT10eXBlb2YgdCYmdC5uYW1lfHxOfWNhdGNoKHQpe3JldHVybiBOfX0obil9XWA7aWYoInN5bWJvbCI9PXR5cGVvZiBuKXJldHVybmBbJHtTdHJpbmcobil9XWA7aWYoImJpZ2ludCI9PXR5cGVvZiBuKXJldHVybmBbQmlnSW50OiAke1N0cmluZyhuKX1dYDtjb25zdCByPWZ1bmN0aW9uKHQpe2NvbnN0IG49T2JqZWN0LmdldFByb3RvdHlwZU9mKHQpO3JldHVybiBuPy5jb25zdHJ1Y3Rvcj9uLmNvbnN0cnVjdG9yLm5hbWU6Im51bGwgcHJvdG90eXBlIn0obik7cmV0dXJuL15IVE1MKFx3KilFbGVtZW50JC8udGVzdChyKT9gW0hUTUxFbGVtZW50OiAke3J9XWA6YFtvYmplY3QgJHtyfV1gfWNhdGNoKHQpe3JldHVybmAqKm5vbi1zZXJpYWxpemFibGUqKiAoJHt0fSlgfXZhciBlfSh0LG4pO2lmKCFjLnN0YXJ0c1dpdGgoIltvYmplY3QgIikpcmV0dXJuIGM7aWYobi5fX3NlbnRyeV9za2lwX25vcm1hbGl6YXRpb25fXylyZXR1cm4gbjtjb25zdCB1PSJudW1iZXIiPT10eXBlb2Ygbi5fX3NlbnRyeV9vdmVycmlkZV9ub3JtYWxpemF0aW9uX2RlcHRoX18/bi5fX3NlbnRyeV9vdmVycmlkZV9ub3JtYWxpemF0aW9uX2RlcHRoX186ZTtpZigwPT09dSlyZXR1cm4gYy5yZXBsYWNlKCJvYmplY3QgIiwiIik7aWYocyhuKSlyZXR1cm4iW0NpcmN1bGFyIH5dIjtjb25zdCBhPW47aWYoYSYmImZ1bmN0aW9uIj09dHlwZW9mIGEudG9KU09OKXRyeXtyZXR1cm4gUHQoIiIsYS50b0pTT04oKSx1LTEscixvKX1jYXRjaCh0KXt9Y29uc3QgZj1BcnJheS5pc0FycmF5KG4pP1tdOnt9O2xldCBoPTA7Y29uc3QgcD1CKG4pO2Zvcihjb25zdCB0IGluIHApe2lmKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocCx0KSljb250aW51ZTtpZihoPj1yKXtmW3RdPSJbTWF4UHJvcGVydGllcyB+XSI7YnJlYWt9Y29uc3Qgbj1wW3RdO2ZbdF09UHQodCxuLHUtMSxyLG8pLGgrK31yZXR1cm4gaShuKSxmfWZ1bmN0aW9uIFV0KHQsbil7Y29uc3QgZT1uLnJlcGxhY2UoL1xcL2csIi8iKS5yZXBsYWNlKC9bfFxce30oKVtcXV4kKyo/Ll0vZywiXFwkJiIpO2xldCByPXQ7dHJ5e3I9ZGVjb2RlVVJJKHQpfWNhdGNoKHQpe31yZXR1cm4gci5yZXBsYWNlKC9cXC9nLCIvIikucmVwbGFjZSgvd2VicGFjazpcLz8vZywiIikucmVwbGFjZShuZXcgUmVnRXhwKGAoZmlsZTovLyk/Lyoke2V9LypgLCJpZyIpLCJhcHA6Ly8vIil9ZnVuY3Rpb24gTXQodCxuPVtdKXtyZXR1cm5bdCxuXX1mdW5jdGlvbiBMdCh0LG4pe2NvbnN0IGU9dFsxXTtmb3IoY29uc3QgdCBvZiBlKXtpZihuKHQsdFswXS50eXBlKSlyZXR1cm4hMH1yZXR1cm4hMX1mdW5jdGlvbiBCdCh0KXtjb25zdCBuPWcocCk7cmV0dXJuIG4uZW5jb2RlUG9seWZpbGw/bi5lbmNvZGVQb2x5ZmlsbCh0KToobmV3IFRleHRFbmNvZGVyKS5lbmNvZGUodCl9ZnVuY3Rpb24gR3QodCl7Y29uc3RbbixlXT10O2xldCByPUpTT04uc3RyaW5naWZ5KG4pO2Z1bmN0aW9uIG8odCl7InN0cmluZyI9PXR5cGVvZiByP3I9InN0cmluZyI9PXR5cGVvZiB0P3IrdDpbQnQociksdF06ci5wdXNoKCJzdHJpbmciPT10eXBlb2YgdD9CdCh0KTp0KX1mb3IoY29uc3QgdCBvZiBlKXtjb25zdFtuLGVdPXQ7aWYobyhgXG4ke0pTT04uc3RyaW5naWZ5KG4pfVxuYCksInN0cmluZyI9PXR5cGVvZiBlfHxlIGluc3RhbmNlb2YgVWludDhBcnJheSlvKGUpO2Vsc2V7bGV0IHQ7dHJ5e3Q9SlNPTi5zdHJpbmdpZnkoZSl9Y2F0Y2gobil7dD1KU09OLnN0cmluZ2lmeShBdChlKSl9byh0KX19cmV0dXJuInN0cmluZyI9PXR5cGVvZiByP3I6ZnVuY3Rpb24odCl7Y29uc3Qgbj10LnJlZHVjZSgoKHQsbik9PnQrbi5sZW5ndGgpLDApLGU9bmV3IFVpbnQ4QXJyYXkobik7bGV0IHI9MDtmb3IoY29uc3QgbiBvZiB0KWUuc2V0KG4scikscis9bi5sZW5ndGg7cmV0dXJuIGV9KHIpfWNvbnN0IEp0PXtzZXNzaW9uOiJzZXNzaW9uIixzZXNzaW9uczoic2Vzc2lvbiIsYXR0YWNobWVudDoiYXR0YWNobWVudCIsdHJhbnNhY3Rpb246InRyYW5zYWN0aW9uIixldmVudDoiZXJyb3IiLGNsaWVudF9yZXBvcnQ6ImludGVybmFsIix1c2VyX3JlcG9ydDoiZGVmYXVsdCIscHJvZmlsZToicHJvZmlsZSIscHJvZmlsZV9jaHVuazoicHJvZmlsZSIscmVwbGF5X2V2ZW50OiJyZXBsYXkiLHJlcGxheV9yZWNvcmRpbmc6InJlcGxheSIsY2hlY2tfaW46Im1vbml0b3IiLGZlZWRiYWNrOiJmZWVkYmFjayIsc3Bhbjoic3BhbiIscmF3X3NlY3VyaXR5OiJzZWN1cml0eSIsb3RlbF9sb2c6ImxvZ19pdGVtIn07ZnVuY3Rpb24gWXQodCl7aWYoIXQ/LnNkaylyZXR1cm47Y29uc3R7bmFtZTpuLHZlcnNpb246ZX09dC5zZGs7cmV0dXJue25hbWU6bix2ZXJzaW9uOmV9fWZ1bmN0aW9uIHp0KHQsbixlLHIpe2NvbnN0IG89WXQoZSkscz10LnR5cGUmJiJyZXBsYXlfZXZlbnQiIT09dC50eXBlP3QudHlwZToiZXZlbnQiOyFmdW5jdGlvbih0LG4pe24mJih0LnNkaz10LnNka3x8e30sdC5zZGsubmFtZT10LnNkay5uYW1lfHxuLm5hbWUsdC5zZGsudmVyc2lvbj10LnNkay52ZXJzaW9ufHxuLnZlcnNpb24sdC5zZGsuaW50ZWdyYXRpb25zPVsuLi50LnNkay5pbnRlZ3JhdGlvbnN8fFtdLC4uLm4uaW50ZWdyYXRpb25zfHxbXV0sdC5zZGsucGFja2FnZXM9Wy4uLnQuc2RrLnBhY2thZ2VzfHxbXSwuLi5uLnBhY2thZ2VzfHxbXV0pfSh0LGU/LnNkayk7Y29uc3QgaT1mdW5jdGlvbih0LG4sZSxyKXtjb25zdCBvPXQuc2RrUHJvY2Vzc2luZ01ldGFkYXRhPy5keW5hbWljU2FtcGxpbmdDb250ZXh0O3JldHVybntldmVudF9pZDp0LmV2ZW50X2lkLHNlbnRfYXQ6KG5ldyBEYXRlKS50b0lTT1N0cmluZygpLC4uLm4mJntzZGs6bn0sLi4uISFlJiZyJiZ7ZHNuOk90KHIpfSwuLi5vJiZ7dHJhY2U6b319fSh0LG8scixuKTtkZWxldGUgdC5zZGtQcm9jZXNzaW5nTWV0YWRhdGE7cmV0dXJuIE10KGksW1t7dHlwZTpzfSx0XV0pfWNvbnN0IEh0PSJfX1NFTlRSWV9TVVBQUkVTU19UUkFDSU5HX18iO2Z1bmN0aW9uIEZ0KHQpe2NvbnN0IG49Y3QobSgpKTtyZXR1cm4gbi5zdXBwcmVzc1RyYWNpbmc/bi5zdXBwcmVzc1RyYWNpbmcodCk6ZnVuY3Rpb24oLi4udCl7Y29uc3Qgbj1jdChtKCkpO2lmKDI9PT10Lmxlbmd0aCl7Y29uc3RbZSxyXT10O3JldHVybiBlP24ud2l0aFNldFNjb3BlKGUscik6bi53aXRoU2NvcGUocil9cmV0dXJuIG4ud2l0aFNjb3BlKHRbMF0pfSgobj0+KG4uc2V0U0RLUHJvY2Vzc2luZ01ldGFkYXRhKHtbSHRdOiEwfSksdCgpKSkpfWZ1bmN0aW9uIFd0KHQsbil7Y29uc3R7ZmluZ2VycHJpbnQ6ZSxzcGFuOnIsYnJlYWRjcnVtYnM6byxzZGtQcm9jZXNzaW5nTWV0YWRhdGE6c309bjshZnVuY3Rpb24odCxuKXtjb25zdHtleHRyYTplLHRhZ3M6cix1c2VyOm8sY29udGV4dHM6cyxsZXZlbDppLHRyYW5zYWN0aW9uTmFtZTpjfT1uO09iamVjdC5rZXlzKGUpLmxlbmd0aCYmKHQuZXh0cmE9ey4uLmUsLi4udC5leHRyYX0pO09iamVjdC5rZXlzKHIpLmxlbmd0aCYmKHQudGFncz17Li4uciwuLi50LnRhZ3N9KTtPYmplY3Qua2V5cyhvKS5sZW5ndGgmJih0LnVzZXI9ey4uLm8sLi4udC51c2VyfSk7T2JqZWN0LmtleXMocykubGVuZ3RoJiYodC5jb250ZXh0cz17Li4ucywuLi50LmNvbnRleHRzfSk7aSYmKHQubGV2ZWw9aSk7YyYmInRyYW5zYWN0aW9uIiE9PXQudHlwZSYmKHQudHJhbnNhY3Rpb249Yyl9KHQsbiksciYmZnVuY3Rpb24odCxuKXt0LmNvbnRleHRzPXt0cmFjZTokdChuKSwuLi50LmNvbnRleHRzfSx0LnNka1Byb2Nlc3NpbmdNZXRhZGF0YT17ZHluYW1pY1NhbXBsaW5nQ29udGV4dDpJdChuKSwuLi50LnNka1Byb2Nlc3NpbmdNZXRhZGF0YX07Y29uc3QgZT1rdChuKSxyPVR0KGUpLmRlc2NyaXB0aW9uO3ImJiF0LnRyYW5zYWN0aW9uJiYidHJhbnNhY3Rpb24iPT09dC50eXBlJiYodC50cmFuc2FjdGlvbj1yKX0odCxyKSxmdW5jdGlvbih0LG4pe3QuZmluZ2VycHJpbnQ9dC5maW5nZXJwcmludD9BcnJheS5pc0FycmF5KHQuZmluZ2VycHJpbnQpP3QuZmluZ2VycHJpbnQ6W3QuZmluZ2VycHJpbnRdOltdLG4mJih0LmZpbmdlcnByaW50PXQuZmluZ2VycHJpbnQuY29uY2F0KG4pKTt0LmZpbmdlcnByaW50Lmxlbmd0aHx8ZGVsZXRlIHQuZmluZ2VycHJpbnR9KHQsZSksZnVuY3Rpb24odCxuKXtjb25zdCBlPVsuLi50LmJyZWFkY3J1bWJzfHxbXSwuLi5uXTt0LmJyZWFkY3J1bWJzPWUubGVuZ3RoP2U6dm9pZCAwfSh0LG8pLGZ1bmN0aW9uKHQsbil7dC5zZGtQcm9jZXNzaW5nTWV0YWRhdGE9ey4uLnQuc2RrUHJvY2Vzc2luZ01ldGFkYXRhLC4uLm59fSh0LHMpfWNvbnN0IEt0PSI3Ijtjb25zdCBWdD1TeW1ib2wuZm9yKCJTZW50cnlCdWZmZXJGdWxsRXJyb3IiKTtmdW5jdGlvbiBadCh0KXtjb25zdCBuPVtdO2Z1bmN0aW9uIGUodCl7cmV0dXJuIG4uc3BsaWNlKG4uaW5kZXhPZih0KSwxKVswXXx8UHJvbWlzZS5yZXNvbHZlKHZvaWQgMCl9cmV0dXJueyQ6bixhZGQ6ZnVuY3Rpb24ocil7aWYoISh2b2lkIDA9PT10fHxuLmxlbmd0aDx0KSlyZXR1cm4gbz1WdCxuZXcgRigoKHQsbik9PntuKG8pfSkpO3ZhciBvO2NvbnN0IHM9cigpO3JldHVybi0xPT09bi5pbmRleE9mKHMpJiZuLnB1c2gocykscy50aGVuKCgoKT0+ZShzKSkpLnRoZW4obnVsbCwoKCk9PmUocykudGhlbihudWxsLCgoKT0+e30pKSkpLHN9LGRyYWluOmZ1bmN0aW9uKHQpe3JldHVybiBuZXcgRigoKGUscik9PntsZXQgbz1uLmxlbmd0aDtpZighbylyZXR1cm4gZSghMCk7Y29uc3Qgcz1zZXRUaW1lb3V0KCgoKT0+e3QmJnQ+MCYmZSghMSl9KSx0KTtuLmZvckVhY2goKHQ9PntIKHQpLnRoZW4oKCgpPT57LS1vfHwoY2xlYXJUaW1lb3V0KHMpLGUoITApKX0pLHIpfSkpfSkpfX19Y29uc3QgcXQ9NmU0O2Z1bmN0aW9uIFF0KHQse3N0YXR1c0NvZGU6bixoZWFkZXJzOmV9LHI9RGF0ZS5ub3coKSl7Y29uc3Qgbz17Li4udH0scz1lPy5bIngtc2VudHJ5LXJhdGUtbGltaXRzIl0saT1lPy5bInJldHJ5LWFmdGVyIl07aWYocylmb3IoY29uc3QgdCBvZiBzLnRyaW0oKS5zcGxpdCgiLCIpKXtjb25zdFtuLGUsLCxzXT10LnNwbGl0KCI6Iiw1KSxpPXBhcnNlSW50KG4sMTApLGM9MWUzKihpc05hTihpKT82MDppKTtpZihlKWZvcihjb25zdCB0IG9mIGUuc3BsaXQoIjsiKSkibWV0cmljX2J1Y2tldCI9PT10JiZzJiYhcy5zcGxpdCgiOyIpLmluY2x1ZGVzKCJjdXN0b20iKXx8KG9bdF09citjKTtlbHNlIG8uYWxsPXIrY31lbHNlIGk/by5hbGw9citmdW5jdGlvbih0LG49RGF0ZS5ub3coKSl7Y29uc3QgZT1wYXJzZUludChgJHt0fWAsMTApO2lmKCFpc05hTihlKSlyZXR1cm4gMWUzKmU7Y29uc3Qgcj1EYXRlLnBhcnNlKGAke3R9YCk7cmV0dXJuIGlzTmFOKHIpP3F0OnItbn0oaSxyKTo0Mjk9PT1uJiYoby5hbGw9cis2ZTQpO3JldHVybiBvfWNvbnN0IFh0PTY0O2Z1bmN0aW9uIHRuKHQsbixlPVp0KHQuYnVmZmVyU2l6ZXx8WHQpKXtsZXQgcj17fTtyZXR1cm57c2VuZDpmdW5jdGlvbih0KXtjb25zdCBvPVtdO2lmKEx0KHQsKCh0LG4pPT57Y29uc3QgZT1mdW5jdGlvbih0KXtyZXR1cm4gSnRbdF19KG4pOyhmdW5jdGlvbih0LG4sZT1EYXRlLm5vdygpKXtyZXR1cm4gZnVuY3Rpb24odCxuKXtyZXR1cm4gdFtuXXx8dC5hbGx8fDB9KHQsbik+ZX0pKHIsZSl8fG8ucHVzaCh0KX0pKSwwPT09by5sZW5ndGgpcmV0dXJuIEgoe30pO2NvbnN0IHM9TXQodFswXSxvKSxpPXQ9PntMdChzLCgodCxuKT0+e30pKX07cmV0dXJuIGUuYWRkKCgoKT0+bih7Ym9keTpHdChzKX0pLnRoZW4oKHQ9Pih2b2lkIDAhPT10LnN0YXR1c0NvZGUmJih0LnN0YXR1c0NvZGU8MjAwfHx0LnN0YXR1c0NvZGU+PTMwMCkmJmgmJncud2FybihgU2VudHJ5IHJlc3BvbmRlZCB3aXRoIHN0YXR1cyBjb2RlICR7dC5zdGF0dXNDb2RlfSB0byBzZW50IGV2ZW50LmApLHI9UXQocix0KSx0KSksKHQ9Pnt0aHJvdyBpKCksaCYmdy5lcnJvcigiRW5jb3VudGVyZWQgZXJyb3IgcnVubmluZyB0cmFuc3BvcnQgcmVxdWVzdDoiLHQpLHR9KSkpKS50aGVuKCh0PT50KSwodD0+e2lmKHQ9PT1WdClyZXR1cm4gaCYmdy5lcnJvcigiU2tpcHBlZCBzZW5kaW5nIGV2ZW50IGJlY2F1c2UgYnVmZmVyIGlzIGZ1bGwuIiksaSgpLEgoe30pO3Rocm93IHR9KSl9LGZsdXNoOnQ9PmUuZHJhaW4odCl9fWNvbnN0IG5uPS9eKFxTKzpcXHxcLz8pKFtcc1xTXSo/KSgoPzpcLnsxLDJ9fFteL1xcXSs/fCkoXC5bXi4vXFxdKnwpKSg/OlsvXFxdKikkLztmdW5jdGlvbiBlbih0KXtjb25zdCBuPWZ1bmN0aW9uKHQpe2NvbnN0IG49dC5sZW5ndGg+MTAyND9gPHRydW5jYXRlZD4ke3Quc2xpY2UoLTEwMjQpfWA6dCxlPW5uLmV4ZWMobik7cmV0dXJuIGU/ZS5zbGljZSgxKTpbXX0odCksZT1uWzBdfHwiIjtsZXQgcj1uWzFdO3JldHVybiBlfHxyPyhyJiYocj1yLnNsaWNlKDAsci5sZW5ndGgtMSkpLGUrcik6Ii4ifWZ1bmN0aW9uIHJuKHQsbj0hMSl7cmV0dXJuIShufHx0JiYhdC5zdGFydHNXaXRoKCIvIikmJiF0Lm1hdGNoKC9eW0EtWl06LykmJiF0LnN0YXJ0c1dpdGgoIi4iKSYmIXQubWF0Y2goL15bYS16QS1aXShbYS16QS1aMC05LlwtK10pKjpcL1wvLykpJiZ2b2lkIDAhPT10JiYhdC5pbmNsdWRlcygibm9kZV9tb2R1bGVzLyIpfWNvbnN0IG9uPVN5bWJvbCgiQWdlbnRCYXNlSW50ZXJuYWxTdGF0ZSIpO2NsYXNzIHNuIGV4dGVuZHMgcy5BZ2VudHtjb25zdHJ1Y3Rvcih0KXtzdXBlcih0KSx0aGlzW29uXT17fX1pc1NlY3VyZUVuZHBvaW50KHQpe2lmKHQpe2lmKCJib29sZWFuIj09dHlwZW9mIHQuc2VjdXJlRW5kcG9pbnQpcmV0dXJuIHQuc2VjdXJlRW5kcG9pbnQ7aWYoInN0cmluZyI9PXR5cGVvZiB0LnByb3RvY29sKXJldHVybiJodHRwczoiPT09dC5wcm90b2NvbH1jb25zdHtzdGFjazpufT1uZXcgRXJyb3I7cmV0dXJuInN0cmluZyI9PXR5cGVvZiBuJiZuLnNwbGl0KCJcbiIpLnNvbWUoKHQ9Pi0xIT09dC5pbmRleE9mKCIoaHR0cHMuanM6Iil8fC0xIT09dC5pbmRleE9mKCJub2RlOmh0dHBzOiIpKSl9Y3JlYXRlU29ja2V0KHQsbixlKXtjb25zdCByPXsuLi5uLHNlY3VyZUVuZHBvaW50OnRoaXMuaXNTZWN1cmVFbmRwb2ludChuKX07UHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKCk9PnRoaXMuY29ubmVjdCh0LHIpKSkudGhlbigobz0+e2lmKG8gaW5zdGFuY2VvZiBzLkFnZW50KXJldHVybiBvLmFkZFJlcXVlc3QodCxyKTt0aGlzW29uXS5jdXJyZW50U29ja2V0PW8sc3VwZXIuY3JlYXRlU29ja2V0KHQsbixlKX0pLGUpfWNyZWF0ZUNvbm5lY3Rpb24oKXtjb25zdCB0PXRoaXNbb25dLmN1cnJlbnRTb2NrZXQ7aWYodGhpc1tvbl0uY3VycmVudFNvY2tldD12b2lkIDAsIXQpdGhyb3cgbmV3IEVycm9yKCJObyBzb2NrZXQgd2FzIHJldHVybmVkIGluIHRoZSBgY29ubmVjdCgpYCBmdW5jdGlvbiIpO3JldHVybiB0fWdldCBkZWZhdWx0UG9ydCgpe3JldHVybiB0aGlzW29uXS5kZWZhdWx0UG9ydD8/KCJodHRwczoiPT09dGhpcy5wcm90b2NvbD80NDM6ODApfXNldCBkZWZhdWx0UG9ydCh0KXt0aGlzW29uXSYmKHRoaXNbb25dLmRlZmF1bHRQb3J0PXQpfWdldCBwcm90b2NvbCgpe3JldHVybiB0aGlzW29uXS5wcm90b2NvbD8/KHRoaXMuaXNTZWN1cmVFbmRwb2ludCgpPyJodHRwczoiOiJodHRwOiIpfXNldCBwcm90b2NvbCh0KXt0aGlzW29uXSYmKHRoaXNbb25dLnByb3RvY29sPXQpfX1mdW5jdGlvbiBjbiguLi50KXt3LmxvZygiW2h0dHBzLXByb3h5LWFnZW50OnBhcnNlLXByb3h5LXJlc3BvbnNlXSIsLi4udCl9ZnVuY3Rpb24gdW4odCl7cmV0dXJuIG5ldyBQcm9taXNlKCgobixlKT0+e2xldCByPTA7Y29uc3Qgbz1bXTtmdW5jdGlvbiBzKCl7Y29uc3QgYz10LnJlYWQoKTtjP2Z1bmN0aW9uKGMpe28ucHVzaChjKSxyKz1jLmxlbmd0aDtjb25zdCB1PUJ1ZmZlci5jb25jYXQobyxyKSxhPXUuaW5kZXhPZigiXHJcblxyXG4iKTtpZigtMT09PWEpcmV0dXJuIGNuKCJoYXZlIG5vdCByZWNlaXZlZCBlbmQgb2YgSFRUUCBoZWFkZXJzIHlldC4uLiIpLHZvaWQgcygpO2NvbnN0IGY9dS5zdWJhcnJheSgwLGEpLnRvU3RyaW5nKCJhc2NpaSIpLnNwbGl0KCJcclxuIiksaD1mLnNoaWZ0KCk7aWYoIWgpcmV0dXJuIHQuZGVzdHJveSgpLGUobmV3IEVycm9yKCJObyBoZWFkZXIgcmVjZWl2ZWQgZnJvbSBwcm94eSBDT05ORUNUIHJlc3BvbnNlIikpO2NvbnN0IHA9aC5zcGxpdCgiICIpLGw9KyhwWzFdfHwwKSxkPXAuc2xpY2UoMikuam9pbigiICIpLG09e307Zm9yKGNvbnN0IG4gb2YgZil7aWYoIW4pY29udGludWU7Y29uc3Qgcj1uLmluZGV4T2YoIjoiKTtpZigtMT09PXIpcmV0dXJuIHQuZGVzdHJveSgpLGUobmV3IEVycm9yKGBJbnZhbGlkIGhlYWRlciBmcm9tIHByb3h5IENPTk5FQ1QgcmVzcG9uc2U6ICIke259ImApKTtjb25zdCBvPW4uc2xpY2UoMCxyKS50b0xvd2VyQ2FzZSgpLHM9bi5zbGljZShyKzEpLnRyaW1TdGFydCgpLGk9bVtvXTsic3RyaW5nIj09dHlwZW9mIGk/bVtvXT1baSxzXTpBcnJheS5pc0FycmF5KGkpP2kucHVzaChzKTptW29dPXN9Y24oImdvdCBwcm94eSBzZXJ2ZXIgcmVzcG9uc2U6ICVvICVvIixoLG0pLGkoKSxuKHtjb25uZWN0OntzdGF0dXNDb2RlOmwsc3RhdHVzVGV4dDpkLGhlYWRlcnM6bX0sYnVmZmVyZWQ6dX0pfShjKTp0Lm9uY2UoInJlYWRhYmxlIixzKX1mdW5jdGlvbiBpKCl7dC5yZW1vdmVMaXN0ZW5lcigiZW5kIixjKSx0LnJlbW92ZUxpc3RlbmVyKCJlcnJvciIsdSksdC5yZW1vdmVMaXN0ZW5lcigicmVhZGFibGUiLHMpfWZ1bmN0aW9uIGMoKXtpKCksY24oIm9uZW5kIiksZShuZXcgRXJyb3IoIlByb3h5IGNvbm5lY3Rpb24gZW5kZWQgYmVmb3JlIHJlY2VpdmluZyBDT05ORUNUIHJlc3BvbnNlIikpfWZ1bmN0aW9uIHUodCl7aSgpLGNuKCJvbmVycm9yICVvIix0KSxlKHQpfXQub24oImVycm9yIix1KSx0Lm9uKCJlbmQiLGMpLHMoKX0pKX1mdW5jdGlvbiBhbiguLi50KXt3LmxvZygiW2h0dHBzLXByb3h5LWFnZW50XSIsLi4udCl9Y2xhc3MgZm4gZXh0ZW5kcyBzbntzdGF0aWMgX19pbml0U3RhdGljKCl7dGhpcy5wcm90b2NvbHM9WyJodHRwIiwiaHR0cHMiXX1jb25zdHJ1Y3Rvcih0LG4pe3N1cGVyKG4pLHRoaXMub3B0aW9ucz17fSx0aGlzLnByb3h5PSJzdHJpbmciPT10eXBlb2YgdD9uZXcgVVJMKHQpOnQsdGhpcy5wcm94eUhlYWRlcnM9bj8uaGVhZGVycz8/e30sYW4oIkNyZWF0aW5nIG5ldyBIdHRwc1Byb3h5QWdlbnQgaW5zdGFuY2U6ICVvIix0aGlzLnByb3h5LmhyZWYpO2NvbnN0IGU9KHRoaXMucHJveHkuaG9zdG5hbWV8fHRoaXMucHJveHkuaG9zdCkucmVwbGFjZSgvXlxbfFxdJC9nLCIiKSxyPXRoaXMucHJveHkucG9ydD9wYXJzZUludCh0aGlzLnByb3h5LnBvcnQsMTApOiJodHRwczoiPT09dGhpcy5wcm94eS5wcm90b2NvbD80NDM6ODA7dGhpcy5jb25uZWN0T3B0cz17QUxQTlByb3RvY29sczpbImh0dHAvMS4xIl0sLi4ubj9wbihuLCJoZWFkZXJzIik6bnVsbCxob3N0OmUscG9ydDpyfX1hc3luYyBjb25uZWN0KHQsbil7Y29uc3R7cHJveHk6ZX09dGhpcztpZighbi5ob3N0KXRocm93IG5ldyBUeXBlRXJyb3IoJ05vICJob3N0IiBwcm92aWRlZCcpO2xldCByO2lmKCJodHRwczoiPT09ZS5wcm90b2NvbCl7YW4oIkNyZWF0aW5nIGB0bHMuU29ja2V0YDogJW8iLHRoaXMuY29ubmVjdE9wdHMpO2NvbnN0IHQ9dGhpcy5jb25uZWN0T3B0cy5zZXJ2ZXJuYW1lfHx0aGlzLmNvbm5lY3RPcHRzLmhvc3Q7cj1mLmNvbm5lY3Qoey4uLnRoaXMuY29ubmVjdE9wdHMsc2VydmVybmFtZTp0JiZhLmlzSVAodCk/dm9pZCAwOnR9KX1lbHNlIGFuKCJDcmVhdGluZyBgbmV0LlNvY2tldGA6ICVvIix0aGlzLmNvbm5lY3RPcHRzKSxyPWEuY29ubmVjdCh0aGlzLmNvbm5lY3RPcHRzKTtjb25zdCBvPSJmdW5jdGlvbiI9PXR5cGVvZiB0aGlzLnByb3h5SGVhZGVycz90aGlzLnByb3h5SGVhZGVycygpOnsuLi50aGlzLnByb3h5SGVhZGVyc30scz1hLmlzSVB2NihuLmhvc3QpP2BbJHtuLmhvc3R9XWA6bi5ob3N0O2xldCBpPWBDT05ORUNUICR7c306JHtuLnBvcnR9IEhUVFAvMS4xXHJcbmA7aWYoZS51c2VybmFtZXx8ZS5wYXNzd29yZCl7Y29uc3QgdD1gJHtkZWNvZGVVUklDb21wb25lbnQoZS51c2VybmFtZSl9OiR7ZGVjb2RlVVJJQ29tcG9uZW50KGUucGFzc3dvcmQpfWA7b1siUHJveHktQXV0aG9yaXphdGlvbiJdPWBCYXNpYyAke0J1ZmZlci5mcm9tKHQpLnRvU3RyaW5nKCJiYXNlNjQiKX1gfW8uSG9zdD1gJHtzfToke24ucG9ydH1gLG9bIlByb3h5LUNvbm5lY3Rpb24iXXx8KG9bIlByb3h5LUNvbm5lY3Rpb24iXT10aGlzLmtlZXBBbGl2ZT8iS2VlcC1BbGl2ZSI6ImNsb3NlIik7Zm9yKGNvbnN0IHQgb2YgT2JqZWN0LmtleXMobykpaSs9YCR7dH06ICR7b1t0XX1cclxuYDtjb25zdCBjPXVuKHIpO3Iud3JpdGUoYCR7aX1cclxuYCk7Y29uc3R7Y29ubmVjdDp1LGJ1ZmZlcmVkOmh9PWF3YWl0IGM7aWYodC5lbWl0KCJwcm94eUNvbm5lY3QiLHUpLHRoaXMuZW1pdCgicHJveHlDb25uZWN0Iix1LHQpLDIwMD09PXUuc3RhdHVzQ29kZSl7aWYodC5vbmNlKCJzb2NrZXQiLGhuKSxuLnNlY3VyZUVuZHBvaW50KXthbigiVXBncmFkaW5nIHNvY2tldCBjb25uZWN0aW9uIHRvIFRMUyIpO2NvbnN0IHQ9bi5zZXJ2ZXJuYW1lfHxuLmhvc3Q7cmV0dXJuIGYuY29ubmVjdCh7Li4ucG4obiwiaG9zdCIsInBhdGgiLCJwb3J0Iiksc29ja2V0OnIsc2VydmVybmFtZTphLmlzSVAodCk/dm9pZCAwOnR9KX1yZXR1cm4gcn1yLmRlc3Ryb3koKTtjb25zdCBwPW5ldyBhLlNvY2tldCh7d3JpdGFibGU6ITF9KTtyZXR1cm4gcC5yZWFkYWJsZT0hMCx0Lm9uY2UoInNvY2tldCIsKHQ9PnthbigiUmVwbGF5aW5nIHByb3h5IGJ1ZmZlciBmb3IgZmFpbGVkIHJlcXVlc3QiKSx0LnB1c2goaCksdC5wdXNoKG51bGwpfSkpLHB9fWZ1bmN0aW9uIGhuKHQpe3QucmVzdW1lKCl9ZnVuY3Rpb24gcG4odCwuLi5uKXtjb25zdCBlPXt9O2xldCByO2ZvcihyIGluIHQpbi5pbmNsdWRlcyhyKXx8KGVbcl09dFtyXSk7cmV0dXJuIGV9Zm4uX19pbml0U3RhdGljKCk7Y29uc3QgbG49MzI3Njg7ZnVuY3Rpb24gZG4odCl7cmV0dXJuIHQucmVwbGFjZSgvXltBLVpdOi8sIiIpLnJlcGxhY2UoL1xcL2csIi8iKX1jb25zdCBtbj1uO2xldCBnbix5bj0wLGJuPXt9O2Z1bmN0aW9uIF9uKHQpe21uLmRlYnVnJiZjb25zb2xlLmxvZyhgW0FOUiBXb3JrZXJdICR7dH1gKX12YXIgdm4sd24sU247Y29uc3QgJG49ZnVuY3Rpb24odCl7bGV0IG47dHJ5e249bmV3IFVSTCh0LnVybCl9Y2F0Y2gobil7cmV0dXJuIHYoKCgpPT57Y29uc29sZS53YXJuKCJbQHNlbnRyeS9ub2RlXTogSW52YWxpZCBkc24gb3IgdHVubmVsIG9wdGlvbiwgd2lsbCBub3Qgc2VuZCBhbnkgZXZlbnRzLiBUaGUgdHVubmVsIG9wdGlvbiBtdXN0IGJlIGEgZnVsbCBVUkwgd2hlbiB1c2VkLiIpfSkpLHRuKHQsKCgpPT5Qcm9taXNlLnJlc29sdmUoe30pKSl9Y29uc3QgZT0iaHR0cHM6Ij09PW4ucHJvdG9jb2wscj1mdW5jdGlvbih0LG4pe2NvbnN0e25vX3Byb3h5OmV9PXByb2Nlc3MuZW52LHI9ZT8uc3BsaXQoIiwiKS5zb21lKChuPT50Lmhvc3QuZW5kc1dpdGgobil8fHQuaG9zdG5hbWUuZW5kc1dpdGgobikpKTtyZXR1cm4gcj92b2lkIDA6bn0obix0LnByb3h5fHwoZT9wcm9jZXNzLmVudi5odHRwc19wcm94eTp2b2lkIDApfHxwcm9jZXNzLmVudi5odHRwX3Byb3h5KSxvPWU/aTpzLGE9dm9pZCAwIT09dC5rZWVwQWxpdmUmJnQua2VlcEFsaXZlLGY9cj9uZXcgZm4ocik6bmV3IG8uQWdlbnQoe2tlZXBBbGl2ZTphLG1heFNvY2tldHM6MzAsdGltZW91dDoyZTN9KSxoPWZ1bmN0aW9uKHQsbixlKXtjb25zdHtob3N0bmFtZTpyLHBhdGhuYW1lOm8scG9ydDpzLHByb3RvY29sOmksc2VhcmNoOmF9PW5ldyBVUkwodC51cmwpO3JldHVybiBmdW5jdGlvbihmKXtyZXR1cm4gbmV3IFByb21pc2UoKChoLHApPT57RnQoKCgpPT57bGV0IGw9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBjKHtyZWFkKCl7dGhpcy5wdXNoKHQpLHRoaXMucHVzaChudWxsKX19KX0oZi5ib2R5KTtjb25zdCBkPXsuLi50LmhlYWRlcnN9O2YuYm9keS5sZW5ndGg+bG4mJihkWyJjb250ZW50LWVuY29kaW5nIl09Imd6aXAiLGw9bC5waXBlKHUoKSkpO2NvbnN0IG09bi5yZXF1ZXN0KHttZXRob2Q6IlBPU1QiLGFnZW50OmUsaGVhZGVyczpkLGhvc3RuYW1lOnIscGF0aDpgJHtvfSR7YX1gLHBvcnQ6cyxwcm90b2NvbDppLGNhOnQuY2FDZXJ0c30sKHQ9Pnt0Lm9uKCJkYXRhIiwoKCk9Pnt9KSksdC5vbigiZW5kIiwoKCk9Pnt9KSksdC5zZXRFbmNvZGluZygidXRmOCIpO2NvbnN0IG49dC5oZWFkZXJzWyJyZXRyeS1hZnRlciJdPz9udWxsLGU9dC5oZWFkZXJzWyJ4LXNlbnRyeS1yYXRlLWxpbWl0cyJdPz9udWxsO2goe3N0YXR1c0NvZGU6dC5zdGF0dXNDb2RlLGhlYWRlcnM6eyJyZXRyeS1hZnRlciI6biwieC1zZW50cnktcmF0ZS1saW1pdHMiOkFycmF5LmlzQXJyYXkoZSk/ZVswXXx8bnVsbDplfX0pfSkpO20ub24oImVycm9yIixwKSxsLnBpcGUobSl9KSl9KSl9fSh0LHQuaHR0cE1vZHVsZT8/byxmKTtyZXR1cm4gdG4odCxoKX0oe3VybDoodm49bW4uZHNuLHduPW1uLnR1bm5lbCxTbj1tbi5zZGtNZXRhZGF0YS5zZGssd258fGAke2Z1bmN0aW9uKHQpe3JldHVybmAke2Z1bmN0aW9uKHQpe2NvbnN0IG49dC5wcm90b2NvbD9gJHt0LnByb3RvY29sfTpgOiIiLGU9dC5wb3J0P2A6JHt0LnBvcnR9YDoiIjtyZXR1cm5gJHtufS8vJHt0Lmhvc3R9JHtlfSR7dC5wYXRoP2AvJHt0LnBhdGh9YDoiIn0vYXBpL2B9KHQpfSR7dC5wcm9qZWN0SWR9L2VudmVsb3BlL2B9KHZuKX0/JHtmdW5jdGlvbih0LG4pe2NvbnN0IGU9e3NlbnRyeV92ZXJzaW9uOkt0fTtyZXR1cm4gdC5wdWJsaWNLZXkmJihlLnNlbnRyeV9rZXk9dC5wdWJsaWNLZXkpLG4mJihlLnNlbnRyeV9jbGllbnQ9YCR7bi5uYW1lfS8ke24udmVyc2lvbn1gKSxuZXcgVVJMU2VhcmNoUGFyYW1zKGUpLnRvU3RyaW5nKCl9KHZuLFNuKX1gKX0pO2FzeW5jIGZ1bmN0aW9uIEVuKCl7aWYoZ24pe19uKCJTZW5kaW5nIGFibm9ybWFsIHNlc3Npb24iKSxLKGduLHtzdGF0dXM6ImFibm9ybWFsIixhYm5vcm1hbF9tZWNoYW5pc206ImFucl9mb3JlZ3JvdW5kIixyZWxlYXNlOm1uLnJlbGVhc2UsZW52aXJvbm1lbnQ6bW4uZW52aXJvbm1lbnR9KTtjb25zdCB0PWZ1bmN0aW9uKHQsbixlLHIpe2NvbnN0IG89WXQoZSk7cmV0dXJuIE10KHtzZW50X2F0OihuZXcgRGF0ZSkudG9JU09TdHJpbmcoKSwuLi5vJiZ7c2RrOm99LC4uLiEhciYmbiYme2RzbjpPdChuKX19LFsiYWdncmVnYXRlcyJpbiB0P1t7dHlwZToic2Vzc2lvbnMifSx0XTpbe3R5cGU6InNlc3Npb24ifSx0LnRvSlNPTigpXV0pfShnbixtbi5kc24sbW4uc2RrTWV0YWRhdGEsbW4udHVubmVsKTtfbihKU09OLnN0cmluZ2lmeSh0KSksYXdhaXQgJG4uc2VuZCh0KTt0cnl7ZT8ucG9zdE1lc3NhZ2UoInNlc3Npb24tZW5kZWQiKX1jYXRjaCh0KXt9fX1mdW5jdGlvbiB4bih0KXtpZighdClyZXR1cm47Y29uc3Qgbj1mdW5jdGlvbih0KXtpZighdC5sZW5ndGgpcmV0dXJuW107Y29uc3Qgbj1BcnJheS5mcm9tKHQpO3JldHVybi9zZW50cnlXcmFwcGVkLy50ZXN0KHgobikuZnVuY3Rpb258fCIiKSYmbi5wb3AoKSxuLnJldmVyc2UoKSxFLnRlc3QoeChuKS5mdW5jdGlvbnx8IiIpJiYobi5wb3AoKSxFLnRlc3QoeChuKS5mdW5jdGlvbnx8IiIpJiZuLnBvcCgpKSxuLnNsaWNlKDAsUykubWFwKCh0PT4oey4uLnQsZmlsZW5hbWU6dC5maWxlbmFtZXx8eChuKS5maWxlbmFtZSxmdW5jdGlvbjp0LmZ1bmN0aW9ufHwkfSkpKX0odCk7aWYobW4uYXBwUm9vdFBhdGgpZm9yKGNvbnN0IHQgb2Ygbil0LmZpbGVuYW1lJiYodC5maWxlbmFtZT1VdCh0LmZpbGVuYW1lLG1uLmFwcFJvb3RQYXRoKSk7cmV0dXJuIG59YXN5bmMgZnVuY3Rpb24gTm4odCxuKXtpZih5bj49bW4ubWF4QW5yRXZlbnRzKXJldHVybjt5bis9MSxhd2FpdCBFbigpLF9uKCJTZW5kaW5nIGV2ZW50Iik7Y29uc3QgZT17ZXZlbnRfaWQ6WSgpLGNvbnRleHRzOm1uLmNvbnRleHRzLHJlbGVhc2U6bW4ucmVsZWFzZSxlbnZpcm9ubWVudDptbi5lbnZpcm9ubWVudCxkaXN0Om1uLmRpc3QscGxhdGZvcm06Im5vZGUiLGxldmVsOiJlcnJvciIsZXhjZXB0aW9uOnt2YWx1ZXM6W3t0eXBlOiJBcHBsaWNhdGlvbk5vdFJlc3BvbmRpbmciLHZhbHVlOmBBcHBsaWNhdGlvbiBOb3QgUmVzcG9uZGluZyBmb3IgYXQgbGVhc3QgJHttbi5hbnJUaHJlc2hvbGR9IG1zYCxzdGFja3RyYWNlOntmcmFtZXM6eG4odCl9LG1lY2hhbmlzbTp7dHlwZToiQU5SIn19XX0sdGFnczptbi5zdGF0aWNUYWdzfTtuJiZmdW5jdGlvbih0LG4pe2lmKFd0KHQsbiksIXQuY29udGV4dHM/LnRyYWNlKXtjb25zdHt0cmFjZUlkOmUscGFyZW50U3BhbklkOnIscHJvcGFnYXRpb25TcGFuSWQ6b309bi5wcm9wYWdhdGlvbkNvbnRleHQ7dC5jb250ZXh0cz17dHJhY2U6e3RyYWNlX2lkOmUsc3Bhbl9pZDpvfHxaKCkscGFyZW50X3NwYW5faWQ6cn0sLi4udC5jb250ZXh0c319fShlLG4pLGZ1bmN0aW9uKHQpe2lmKDA9PT1PYmplY3Qua2V5cyhibikubGVuZ3RoKXJldHVybjtjb25zdCBuPW1uLmFwcFJvb3RQYXRoP3t9OmJuO2lmKG1uLmFwcFJvb3RQYXRoKWZvcihjb25zdFt0LGVdb2YgT2JqZWN0LmVudHJpZXMoYm4pKW5bVXQodCxtbi5hcHBSb290UGF0aCldPWU7Y29uc3QgZT1uZXcgTWFwO2Zvcihjb25zdCByIG9mIHQuZXhjZXB0aW9uPy52YWx1ZXN8fFtdKWZvcihjb25zdCB0IG9mIHIuc3RhY2t0cmFjZT8uZnJhbWVzfHxbXSl7Y29uc3Qgcj10LmFic19wYXRofHx0LmZpbGVuYW1lO3ImJm5bcl0mJmUuc2V0KHIsbltyXSl9aWYoZS5zaXplPjApe2NvbnN0IG49W107Zm9yKGNvbnN0W3Qscl1vZiBlLmVudHJpZXMoKSluLnB1c2goe3R5cGU6InNvdXJjZW1hcCIsY29kZV9maWxlOnQsZGVidWdfaWQ6cn0pO3QuZGVidWdfbWV0YT17aW1hZ2VzOm59fX0oZSk7Y29uc3Qgcj16dChlLG1uLmRzbixtbi5zZGtNZXRhZGF0YSxtbi50dW5uZWwpO19uKEpTT04uc3RyaW5naWZ5KHIpKSxhd2FpdCAkbi5zZW5kKHIpLGF3YWl0ICRuLmZsdXNoKDJlMykseW4+PW1uLm1heEFuckV2ZW50cyYmc2V0VGltZW91dCgoKCk9Pntwcm9jZXNzLmV4aXQoMCl9KSw1ZTMpfWxldCBUbjtpZihfbigiU3RhcnRlZCIpLG1uLmNhcHR1cmVTdGFja1RyYWNlKXtfbigiQ29ubmVjdGluZyB0byBkZWJ1Z2dlciIpO2NvbnN0IG49bmV3IHQ7bi5jb25uZWN0VG9NYWluVGhyZWFkKCksX24oIkNvbm5lY3RlZCB0byBkZWJ1Z2dlciIpO2NvbnN0IGU9bmV3IE1hcDtuLm9uKCJEZWJ1Z2dlci5zY3JpcHRQYXJzZWQiLCh0PT57ZS5zZXQodC5wYXJhbXMuc2NyaXB0SWQsdC5wYXJhbXMudXJsKX0pKSxuLm9uKCJEZWJ1Z2dlci5wYXVzZWQiLCh0PT57aWYoIm90aGVyIj09PXQucGFyYW1zLnJlYXNvbil0cnl7X24oIkRlYnVnZ2VyIHBhdXNlZCIpO2NvbnN0IHM9Wy4uLnQucGFyYW1zLmNhbGxGcmFtZXNdLGk9bW4uYXBwUm9vdFBhdGg/ZnVuY3Rpb24odD0ocHJvY2Vzcy5hcmd2WzFdP2VuKHByb2Nlc3MuYXJndlsxXSk6cHJvY2Vzcy5jd2QoKSksbj0iXFwiPT09byl7Y29uc3QgZT1uP2RuKHQpOnQ7cmV0dXJuIHQ9PntpZighdClyZXR1cm47Y29uc3Qgbz1uP2RuKHQpOnQ7bGV0e2RpcjpzLGJhc2U6aSxleHQ6Y309ci5wYXJzZShvKTsiLmpzIiE9PWMmJiIubWpzIiE9PWMmJiIuY2pzIiE9PWN8fChpPWkuc2xpY2UoMCwtMSpjLmxlbmd0aCkpO2NvbnN0IHU9ZGVjb2RlVVJJQ29tcG9uZW50KGkpO3N8fChzPSIuIik7Y29uc3QgYT1zLmxhc3RJbmRleE9mKCIvbm9kZV9tb2R1bGVzIik7aWYoYT4tMSlyZXR1cm5gJHtzLnNsaWNlKGErMTQpLnJlcGxhY2UoL1wvL2csIi4iKX06JHt1fWA7aWYocy5zdGFydHNXaXRoKGUpKXtjb25zdCB0PXMuc2xpY2UoZS5sZW5ndGgrMSkucmVwbGFjZSgvXC8vZywiLiIpO3JldHVybiB0P2Ake3R9OiR7dX1gOnV9cmV0dXJuIHV9fShtbi5hcHBSb290UGF0aCk6KCk9Pnt9LGM9cy5tYXAoKHQ9PmZ1bmN0aW9uKHQsbixlKXtjb25zdCByPW4/bi5yZXBsYWNlKC9eZmlsZTpcL1wvLywiIik6dm9pZCAwLG89dC5sb2NhdGlvbi5jb2x1bW5OdW1iZXI/dC5sb2NhdGlvbi5jb2x1bW5OdW1iZXIrMTp2b2lkIDAscz10LmxvY2F0aW9uLmxpbmVOdW1iZXI/dC5sb2NhdGlvbi5saW5lTnVtYmVyKzE6dm9pZCAwO3JldHVybntmaWxlbmFtZTpyLG1vZHVsZTplKHIpLGZ1bmN0aW9uOnQuZnVuY3Rpb25OYW1lfHwkLGNvbG5vOm8sbGluZW5vOnMsaW5fYXBwOnI/cm4ocik6dm9pZCAwfX0odCxlLmdldCh0LmxvY2F0aW9uLnNjcmlwdElkKSxpKSkpLHU9c2V0VGltZW91dCgoKCk9PntObihjKS50aGVuKG51bGwsKCgpPT57X24oIlNlbmRpbmcgQU5SIGV2ZW50IGZhaWxlZC4iKX0pKX0pLDVlMyk7bi5wb3N0KCJSdW50aW1lLmV2YWx1YXRlIix7ZXhwcmVzc2lvbjoiZ2xvYmFsLl9fU0VOVFJZX0dFVF9TQ09QRVNfXygpOyIsc2lsZW50OiEwLHJldHVybkJ5VmFsdWU6ITB9LCgodCxlKT0+e3QmJl9uKGBFcnJvciBleGVjdXRpbmcgc2NyaXB0OiAnJHt0Lm1lc3NhZ2V9J2ApLGNsZWFyVGltZW91dCh1KTtjb25zdCByPWU/LnJlc3VsdD9lLnJlc3VsdC52YWx1ZTp2b2lkIDA7bi5wb3N0KCJEZWJ1Z2dlci5yZXN1bWUiKSxuLnBvc3QoIkRlYnVnZ2VyLmRpc2FibGUiKSxObihjLHIpLnRoZW4obnVsbCwoKCk9PntfbigiU2VuZGluZyBBTlIgZXZlbnQgZmFpbGVkLiIpfSkpfSkpfWNhdGNoKHQpe3Rocm93IG4ucG9zdCgiRGVidWdnZXIucmVzdW1lIiksbi5wb3N0KCJEZWJ1Z2dlci5kaXNhYmxlIiksdH19KSksVG49KCk9Pnt0cnl7bi5wb3N0KCJEZWJ1Z2dlci5lbmFibGUiLCgoKT0+e24ucG9zdCgiRGVidWdnZXIucGF1c2UiKX0pKX1jYXRjaCh0KXt9fX1jb25zdHtwb2xsOkNufT1mdW5jdGlvbih0LG4sZSxyKXtjb25zdCBvPXQoKTtsZXQgcz0hMSxpPSEwO3JldHVybiBzZXRJbnRlcnZhbCgoKCk9Pntjb25zdCB0PW8uZ2V0VGltZU1zKCk7ITE9PT1zJiZ0Pm4rZSYmKHM9ITAsaSYmcigpKSx0PG4rZSYmKHM9ITEpfSksMjApLHtwb2xsOigpPT57by5yZXNldCgpfSxlbmFibGVkOnQ9PntpPXR9fX0oKGZ1bmN0aW9uKCl7bGV0IHQ9cHJvY2Vzcy5ocnRpbWUoKTtyZXR1cm57Z2V0VGltZU1zOigpPT57Y29uc3RbbixlXT1wcm9jZXNzLmhydGltZSh0KTtyZXR1cm4gTWF0aC5mbG9vcigxZTMqbitlLzFlNil9LHJlc2V0OigpPT57dD1wcm9jZXNzLmhydGltZSgpfX19KSxtbi5wb2xsSW50ZXJ2YWwsbW4uYW5yVGhyZXNob2xkLChmdW5jdGlvbigpe19uKCJXYXRjaGRvZyB0aW1lb3V0IiksVG4/KF9uKCJQYXVzaW5nIGRlYnVnZ2VyIHRvIGNhcHR1cmUgc3RhY2sgdHJhY2UiKSxUbigpKTooX24oIkNhcHR1cmluZyBldmVudCB3aXRob3V0IGEgc3RhY2sgdHJhY2UiKSxObigpLnRoZW4obnVsbCwoKCk9PntfbigiU2VuZGluZyBBTlIgZXZlbnQgZmFpbGVkIG9uIHdhdGNoZG9nIHRpbWVvdXQuIil9KSkpfSkpO2U/Lm9uKCJtZXNzYWdlIiwodD0+e3Quc2Vzc2lvbiYmKGduPVcodC5zZXNzaW9uKSksdC5kZWJ1Z0ltYWdlcyYmKGJuPXQuZGVidWdJbWFnZXMpLENuKCl9KSk7';
+const base64WorkerScript = 'LyohIEBzZW50cnkvbm9kZSA5LjEyLjAgKDJjZjUzMjJkOSkgfCBodHRwczovL2dpdGh1Yi5jb20vZ2V0c2VudHJ5L3NlbnRyeS1qYXZhc2NyaXB0ICovCmltcG9ydHtTZXNzaW9uIGFzIHR9ZnJvbSJub2RlOmluc3BlY3RvciI7aW1wb3J0e3dvcmtlckRhdGEgYXMgbixwYXJlbnRQb3J0IGFzIGV9ZnJvbSJub2RlOndvcmtlcl90aHJlYWRzIjtpbXBvcnR7cG9zaXggYXMgcixzZXAgYXMgb31mcm9tIm5vZGU6cGF0aCI7aW1wb3J0KmFzIHMgZnJvbSJub2RlOmh0dHAiO2ltcG9ydCphcyBpIGZyb20ibm9kZTpodHRwcyI7aW1wb3J0e1JlYWRhYmxlIGFzIGN9ZnJvbSJub2RlOnN0cmVhbSI7aW1wb3J0e2NyZWF0ZUd6aXAgYXMgdX1mcm9tIm5vZGU6emxpYiI7aW1wb3J0KmFzIGEgZnJvbSJub2RlOm5ldCI7aW1wb3J0KmFzIGYgZnJvbSJub2RlOnRscyI7Y29uc3QgaD0idW5kZWZpbmVkIj09dHlwZW9mIF9fU0VOVFJZX0RFQlVHX198fF9fU0VOVFJZX0RFQlVHX18scD1nbG9iYWxUaGlzLGw9InVuZGVmaW5lZCI9PXR5cGVvZiBfX1NFTlRSWV9ERUJVR19ffHxfX1NFTlRSWV9ERUJVR19fLGQ9IjkuMTIuMCI7ZnVuY3Rpb24gbSgpe3JldHVybiBnKHApLHB9ZnVuY3Rpb24gZyh0KXtjb25zdCBuPXQuX19TRU5UUllfXz10Ll9fU0VOVFJZX198fHt9O3JldHVybiBuLnZlcnNpb249bi52ZXJzaW9ufHxkLG5bZF09bltkXXx8e319ZnVuY3Rpb24geSh0LG4sZT1wKXtjb25zdCByPWUuX19TRU5UUllfXz1lLl9fU0VOVFJZX198fHt9LG89cltkXT1yW2RdfHx7fTtyZXR1cm4gb1t0XXx8KG9bdF09bigpKX1jb25zdCBiPVsiZGVidWciLCJpbmZvIiwid2FybiIsImVycm9yIiwibG9nIiwiYXNzZXJ0IiwidHJhY2UiXSxfPXt9O2Z1bmN0aW9uIHYodCl7aWYoISgiY29uc29sZSJpbiBwKSlyZXR1cm4gdCgpO2NvbnN0IG49cC5jb25zb2xlLGU9e30scj1PYmplY3Qua2V5cyhfKTtyLmZvckVhY2goKHQ9Pntjb25zdCByPV9bdF07ZVt0XT1uW3RdLG5bdF09cn0pKTt0cnl7cmV0dXJuIHQoKX1maW5hbGx5e3IuZm9yRWFjaCgodD0+e25bdF09ZVt0XX0pKX19Y29uc3Qgdz15KCJsb2dnZXIiLChmdW5jdGlvbigpe2xldCB0PSExO2NvbnN0IG49e2VuYWJsZTooKT0+e3Q9ITB9LGRpc2FibGU6KCk9Pnt0PSExfSxpc0VuYWJsZWQ6KCk9PnR9O3JldHVybiBsP2IuZm9yRWFjaCgoZT0+e25bZV09KC4uLm4pPT57dCYmdigoKCk9PntwLmNvbnNvbGVbZV0oYFNlbnRyeSBMb2dnZXIgWyR7ZX1dOmAsLi4ubil9KSl9fSkpOmIuZm9yRWFjaCgodD0+e25bdF09KCk9Pnt9fSkpLG59KSksUz01MCwkPSI/IixFPS9jYXB0dXJlTWVzc2FnZXxjYXB0dXJlRXhjZXB0aW9uLztmdW5jdGlvbiB4KHQpe3JldHVybiB0W3QubGVuZ3RoLTFdfHx7fX1jb25zdCBOPSI8YW5vbnltb3VzPiI7Y29uc3QgVD0xZTM7ZnVuY3Rpb24gQygpe3JldHVybiBEYXRlLm5vdygpL1R9Y29uc3QgUj1mdW5jdGlvbigpe2NvbnN0e3BlcmZvcm1hbmNlOnR9PXA7aWYoIXQ/Lm5vdylyZXR1cm4gQztjb25zdCBuPURhdGUubm93KCktdC5ub3coKSxlPW51bGw9PXQudGltZU9yaWdpbj9uOnQudGltZU9yaWdpbjtyZXR1cm4oKT0+KGUrdC5ub3coKSkvVH0oKSxrPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7ZnVuY3Rpb24gaih0LG4pe3JldHVybiBrLmNhbGwodCk9PT1gW29iamVjdCAke259XWB9ZnVuY3Rpb24gRCh0KXtyZXR1cm4gaih0LCJTdHJpbmciKX1mdW5jdGlvbiBJKHQpe3JldHVybiBqKHQsIk9iamVjdCIpfWZ1bmN0aW9uIE8odCl7cmV0dXJuIEJvb2xlYW4odD8udGhlbiYmImZ1bmN0aW9uIj09dHlwZW9mIHQudGhlbil9ZnVuY3Rpb24gQSh0LG4pe3RyeXtyZXR1cm4gdCBpbnN0YW5jZW9mIG59Y2F0Y2godCl7cmV0dXJuITF9fWNvbnN0IFA9cCxVPTgwO2Z1bmN0aW9uIE0odCxuKXtjb25zdCBlPXQscj1bXTtpZighZT8udGFnTmFtZSlyZXR1cm4iIjtpZihQLkhUTUxFbGVtZW50JiZlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQmJmUuZGF0YXNldCl7aWYoZS5kYXRhc2V0LnNlbnRyeUNvbXBvbmVudClyZXR1cm4gZS5kYXRhc2V0LnNlbnRyeUNvbXBvbmVudDtpZihlLmRhdGFzZXQuc2VudHJ5RWxlbWVudClyZXR1cm4gZS5kYXRhc2V0LnNlbnRyeUVsZW1lbnR9ci5wdXNoKGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKTtjb25zdCBvPW4/Lmxlbmd0aD9uLmZpbHRlcigodD0+ZS5nZXRBdHRyaWJ1dGUodCkpKS5tYXAoKHQ9Plt0LGUuZ2V0QXR0cmlidXRlKHQpXSkpOm51bGw7aWYobz8ubGVuZ3RoKW8uZm9yRWFjaCgodD0+e3IucHVzaChgWyR7dFswXX09IiR7dFsxXX0iXWApfSkpO2Vsc2V7ZS5pZCYmci5wdXNoKGAjJHtlLmlkfWApO2NvbnN0IHQ9ZS5jbGFzc05hbWU7aWYodCYmRCh0KSl7Y29uc3Qgbj10LnNwbGl0KC9ccysvKTtmb3IoY29uc3QgdCBvZiBuKXIucHVzaChgLiR7dH1gKX19Y29uc3Qgcz1bImFyaWEtbGFiZWwiLCJ0eXBlIiwibmFtZSIsInRpdGxlIiwiYWx0Il07Zm9yKGNvbnN0IHQgb2Ygcyl7Y29uc3Qgbj1lLmdldEF0dHJpYnV0ZSh0KTtuJiZyLnB1c2goYFske3R9PSIke259Il1gKX1yZXR1cm4gci5qb2luKCIiKX1mdW5jdGlvbiBMKHQsbj0wKXtyZXR1cm4ic3RyaW5nIiE9dHlwZW9mIHR8fDA9PT1ufHx0Lmxlbmd0aDw9bj90OmAke3Quc2xpY2UoMCxuKX0uLi5gfWZ1bmN0aW9uIEIodCl7aWYoZnVuY3Rpb24odCl7c3dpdGNoKGsuY2FsbCh0KSl7Y2FzZSJbb2JqZWN0IEVycm9yXSI6Y2FzZSJbb2JqZWN0IEV4Y2VwdGlvbl0iOmNhc2UiW29iamVjdCBET01FeGNlcHRpb25dIjpjYXNlIltvYmplY3QgV2ViQXNzZW1ibHkuRXhjZXB0aW9uXSI6cmV0dXJuITA7ZGVmYXVsdDpyZXR1cm4gQSh0LEVycm9yKX19KHQpKXJldHVybnttZXNzYWdlOnQubWVzc2FnZSxuYW1lOnQubmFtZSxzdGFjazp0LnN0YWNrLC4uLkoodCl9O2lmKG49dCwidW5kZWZpbmVkIiE9dHlwZW9mIEV2ZW50JiZBKG4sRXZlbnQpKXtjb25zdCBuPXt0eXBlOnQudHlwZSx0YXJnZXQ6Ryh0LnRhcmdldCksY3VycmVudFRhcmdldDpHKHQuY3VycmVudFRhcmdldCksLi4uSih0KX07cmV0dXJuInVuZGVmaW5lZCIhPXR5cGVvZiBDdXN0b21FdmVudCYmQSh0LEN1c3RvbUV2ZW50KSYmKG4uZGV0YWlsPXQuZGV0YWlsKSxufXJldHVybiB0O3ZhciBufWZ1bmN0aW9uIEcodCl7dHJ5e3JldHVybiBuPXQsInVuZGVmaW5lZCIhPXR5cGVvZiBFbGVtZW50JiZBKG4sRWxlbWVudCk/ZnVuY3Rpb24odCxuPXt9KXtpZighdClyZXR1cm4iPHVua25vd24+Ijt0cnl7bGV0IGU9dDtjb25zdCByPTUsbz1bXTtsZXQgcz0wLGk9MDtjb25zdCBjPSIgPiAiLHU9Yy5sZW5ndGg7bGV0IGE7Y29uc3QgZj1BcnJheS5pc0FycmF5KG4pP246bi5rZXlBdHRycyxoPSFBcnJheS5pc0FycmF5KG4pJiZuLm1heFN0cmluZ0xlbmd0aHx8VTtmb3IoO2UmJnMrKzxyJiYoYT1NKGUsZiksISgiaHRtbCI9PT1hfHxzPjEmJmkrby5sZW5ndGgqdSthLmxlbmd0aD49aCkpOylvLnB1c2goYSksaSs9YS5sZW5ndGgsZT1lLnBhcmVudE5vZGU7cmV0dXJuIG8ucmV2ZXJzZSgpLmpvaW4oYyl9Y2F0Y2godCl7cmV0dXJuIjx1bmtub3duPiJ9fSh0KTpPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCl9Y2F0Y2godCl7cmV0dXJuIjx1bmtub3duPiJ9dmFyIG59ZnVuY3Rpb24gSih0KXtpZigib2JqZWN0Ij09dHlwZW9mIHQmJm51bGwhPT10KXtjb25zdCBuPXt9O2Zvcihjb25zdCBlIGluIHQpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsZSkmJihuW2VdPXRbZV0pO3JldHVybiBufXJldHVybnt9fWZ1bmN0aW9uIFkodD1mdW5jdGlvbigpe2NvbnN0IHQ9cDtyZXR1cm4gdC5jcnlwdG98fHQubXNDcnlwdG99KCkpe2xldCBuPSgpPT4xNipNYXRoLnJhbmRvbSgpO3RyeXtpZih0Py5yYW5kb21VVUlEKXJldHVybiB0LnJhbmRvbVVVSUQoKS5yZXBsYWNlKC8tL2csIiIpO3Q/LmdldFJhbmRvbVZhbHVlcyYmKG49KCk9Pntjb25zdCBuPW5ldyBVaW50OEFycmF5KDEpO3JldHVybiB0LmdldFJhbmRvbVZhbHVlcyhuKSxuWzBdfSl9Y2F0Y2godCl7fXJldHVybihbMWU3XSsxZTMrNGUzKzhlMysxZTExKS5yZXBsYWNlKC9bMDE4XS9nLCh0PT4odF4oMTUmbigpKT4+dC80KS50b1N0cmluZygxNikpKX12YXIgejtmdW5jdGlvbiBIKHQpe3JldHVybiBuZXcgRigobj0+e24odCl9KSl9IWZ1bmN0aW9uKHQpe3RbdC5QRU5ESU5HPTBdPSJQRU5ESU5HIjt0W3QuUkVTT0xWRUQ9MV09IlJFU09MVkVEIjt0W3QuUkVKRUNURUQ9Ml09IlJFSkVDVEVEIn0oenx8KHo9e30pKTtjbGFzcyBGe2NvbnN0cnVjdG9yKHQpe3RoaXMudD16LlBFTkRJTkcsdGhpcy5vPVtdLHRoaXMuaSh0KX10aGVuKHQsbil7cmV0dXJuIG5ldyBGKCgoZSxyKT0+e3RoaXMuby5wdXNoKFshMSxuPT57aWYodCl0cnl7ZSh0KG4pKX1jYXRjaCh0KXtyKHQpfWVsc2UgZShuKX0sdD0+e2lmKG4pdHJ5e2Uobih0KSl9Y2F0Y2godCl7cih0KX1lbHNlIHIodCl9XSksdGhpcy51KCl9KSl9Y2F0Y2godCl7cmV0dXJuIHRoaXMudGhlbigodD0+dCksdCl9ZmluYWxseSh0KXtyZXR1cm4gbmV3IEYoKChuLGUpPT57bGV0IHIsbztyZXR1cm4gdGhpcy50aGVuKChuPT57bz0hMSxyPW4sdCYmdCgpfSksKG49PntvPSEwLHI9bix0JiZ0KCl9KSkudGhlbigoKCk9PntvP2Uocik6bihyKX0pKX0pKX11KCl7aWYodGhpcy50PT09ei5QRU5ESU5HKXJldHVybjtjb25zdCB0PXRoaXMuby5zbGljZSgpO3RoaXMubz1bXSx0LmZvckVhY2goKHQ9Pnt0WzBdfHwodGhpcy50PT09ei5SRVNPTFZFRCYmdFsxXSh0aGlzLmgpLHRoaXMudD09PXouUkVKRUNURUQmJnRbMl0odGhpcy5oKSx0WzBdPSEwKX0pKX1pKHQpe2NvbnN0IG49KHQsbik9Pnt0aGlzLnQ9PT16LlBFTkRJTkcmJihPKG4pP24udGhlbihlLHIpOih0aGlzLnQ9dCx0aGlzLmg9bix0aGlzLnUoKSkpfSxlPXQ9PntuKHouUkVTT0xWRUQsdCl9LHI9dD0+e24oei5SRUpFQ1RFRCx0KX07dHJ5e3QoZSxyKX1jYXRjaCh0KXtyKHQpfX19ZnVuY3Rpb24gVyh0KXtjb25zdCBuPVIoKSxlPXtzaWQ6WSgpLGluaXQ6ITAsdGltZXN0YW1wOm4sc3RhcnRlZDpuLGR1cmF0aW9uOjAsc3RhdHVzOiJvayIsZXJyb3JzOjAsaWdub3JlRHVyYXRpb246ITEsdG9KU09OOigpPT5mdW5jdGlvbih0KXtyZXR1cm57c2lkOmAke3Quc2lkfWAsaW5pdDp0LmluaXQsc3RhcnRlZDpuZXcgRGF0ZSgxZTMqdC5zdGFydGVkKS50b0lTT1N0cmluZygpLHRpbWVzdGFtcDpuZXcgRGF0ZSgxZTMqdC50aW1lc3RhbXApLnRvSVNPU3RyaW5nKCksc3RhdHVzOnQuc3RhdHVzLGVycm9yczp0LmVycm9ycyxkaWQ6Im51bWJlciI9PXR5cGVvZiB0LmRpZHx8InN0cmluZyI9PXR5cGVvZiB0LmRpZD9gJHt0LmRpZH1gOnZvaWQgMCxkdXJhdGlvbjp0LmR1cmF0aW9uLGFibm9ybWFsX21lY2hhbmlzbTp0LmFibm9ybWFsX21lY2hhbmlzbSxhdHRyczp7cmVsZWFzZTp0LnJlbGVhc2UsZW52aXJvbm1lbnQ6dC5lbnZpcm9ubWVudCxpcF9hZGRyZXNzOnQuaXBBZGRyZXNzLHVzZXJfYWdlbnQ6dC51c2VyQWdlbnR9fX0oZSl9O3JldHVybiB0JiZLKGUsdCksZX1mdW5jdGlvbiBLKHQsbj17fSl7aWYobi51c2VyJiYoIXQuaXBBZGRyZXNzJiZuLnVzZXIuaXBfYWRkcmVzcyYmKHQuaXBBZGRyZXNzPW4udXNlci5pcF9hZGRyZXNzKSx0LmRpZHx8bi5kaWR8fCh0LmRpZD1uLnVzZXIuaWR8fG4udXNlci5lbWFpbHx8bi51c2VyLnVzZXJuYW1lKSksdC50aW1lc3RhbXA9bi50aW1lc3RhbXB8fFIoKSxuLmFibm9ybWFsX21lY2hhbmlzbSYmKHQuYWJub3JtYWxfbWVjaGFuaXNtPW4uYWJub3JtYWxfbWVjaGFuaXNtKSxuLmlnbm9yZUR1cmF0aW9uJiYodC5pZ25vcmVEdXJhdGlvbj1uLmlnbm9yZUR1cmF0aW9uKSxuLnNpZCYmKHQuc2lkPTMyPT09bi5zaWQubGVuZ3RoP24uc2lkOlkoKSksdm9pZCAwIT09bi5pbml0JiYodC5pbml0PW4uaW5pdCksIXQuZGlkJiZuLmRpZCYmKHQuZGlkPWAke24uZGlkfWApLCJudW1iZXIiPT10eXBlb2Ygbi5zdGFydGVkJiYodC5zdGFydGVkPW4uc3RhcnRlZCksdC5pZ25vcmVEdXJhdGlvbil0LmR1cmF0aW9uPXZvaWQgMDtlbHNlIGlmKCJudW1iZXIiPT10eXBlb2Ygbi5kdXJhdGlvbil0LmR1cmF0aW9uPW4uZHVyYXRpb247ZWxzZXtjb25zdCBuPXQudGltZXN0YW1wLXQuc3RhcnRlZDt0LmR1cmF0aW9uPW4+PTA/bjowfW4ucmVsZWFzZSYmKHQucmVsZWFzZT1uLnJlbGVhc2UpLG4uZW52aXJvbm1lbnQmJih0LmVudmlyb25tZW50PW4uZW52aXJvbm1lbnQpLCF0LmlwQWRkcmVzcyYmbi5pcEFkZHJlc3MmJih0LmlwQWRkcmVzcz1uLmlwQWRkcmVzcyksIXQudXNlckFnZW50JiZuLnVzZXJBZ2VudCYmKHQudXNlckFnZW50PW4udXNlckFnZW50KSwibnVtYmVyIj09dHlwZW9mIG4uZXJyb3JzJiYodC5lcnJvcnM9bi5lcnJvcnMpLG4uc3RhdHVzJiYodC5zdGF0dXM9bi5zdGF0dXMpfWZ1bmN0aW9uIFYoKXtyZXR1cm4gWSgpfWZ1bmN0aW9uIFooKXtyZXR1cm4gWSgpLnN1YnN0cmluZygxNil9ZnVuY3Rpb24gcSh0LG4sZT0yKXtpZighbnx8Im9iamVjdCIhPXR5cGVvZiBufHxlPD0wKXJldHVybiBuO2lmKHQmJjA9PT1PYmplY3Qua2V5cyhuKS5sZW5ndGgpcmV0dXJuIHQ7Y29uc3Qgcj17Li4udH07Zm9yKGNvbnN0IHQgaW4gbilPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobix0KSYmKHJbdF09cShyW3RdLG5bdF0sZS0xKSk7cmV0dXJuIHJ9Y29uc3QgUT0iX3NlbnRyeVNwYW4iO2Z1bmN0aW9uIFgodCxuKXtuP2Z1bmN0aW9uKHQsbixlKXt0cnl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbix7dmFsdWU6ZSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9KX1jYXRjaChlKXtsJiZ3LmxvZyhgRmFpbGVkIHRvIGFkZCBub24tZW51bWVyYWJsZSBwcm9wZXJ0eSAiJHtufSIgdG8gb2JqZWN0YCx0KX19KHQsUSxuKTpkZWxldGUgdFtRXX1mdW5jdGlvbiB0dCh0KXtyZXR1cm4gdFtRXX1jbGFzcyBudHtjb25zdHJ1Y3Rvcigpe3RoaXMucD0hMSx0aGlzLmw9W10sdGhpcy5tPVtdLHRoaXMuXz1bXSx0aGlzLnY9W10sdGhpcy5TPXt9LHRoaXMuTj17fSx0aGlzLlQ9e30sdGhpcy5DPXt9LHRoaXMuUj17fSx0aGlzLms9e3RyYWNlSWQ6VigpLHNhbXBsZVJhbmQ6TWF0aC5yYW5kb20oKX19Y2xvbmUoKXtjb25zdCB0PW5ldyBudDtyZXR1cm4gdC5fPVsuLi50aGlzLl9dLHQuTj17Li4udGhpcy5OfSx0LlQ9ey4uLnRoaXMuVH0sdC5DPXsuLi50aGlzLkN9LHRoaXMuQy5mbGFncyYmKHQuQy5mbGFncz17dmFsdWVzOlsuLi50aGlzLkMuZmxhZ3MudmFsdWVzXX0pLHQuUz10aGlzLlMsdC5qPXRoaXMuaix0LkQ9dGhpcy5ELHQuST10aGlzLkksdC5PPXRoaXMuTyx0Lm09Wy4uLnRoaXMubV0sdC52PVsuLi50aGlzLnZdLHQuUj17Li4udGhpcy5SfSx0Lms9ey4uLnRoaXMua30sdC5BPXRoaXMuQSx0LlA9dGhpcy5QLFgodCx0dCh0aGlzKSksdH1zZXRDbGllbnQodCl7dGhpcy5BPXR9c2V0TGFzdEV2ZW50SWQodCl7dGhpcy5QPXR9Z2V0Q2xpZW50KCl7cmV0dXJuIHRoaXMuQX1sYXN0RXZlbnRJZCgpe3JldHVybiB0aGlzLlB9YWRkU2NvcGVMaXN0ZW5lcih0KXt0aGlzLmwucHVzaCh0KX1hZGRFdmVudFByb2Nlc3Nvcih0KXtyZXR1cm4gdGhpcy5tLnB1c2godCksdGhpc31zZXRVc2VyKHQpe3JldHVybiB0aGlzLlM9dHx8e2VtYWlsOnZvaWQgMCxpZDp2b2lkIDAsaXBfYWRkcmVzczp2b2lkIDAsdXNlcm5hbWU6dm9pZCAwfSx0aGlzLkQmJksodGhpcy5ELHt1c2VyOnR9KSx0aGlzLlUoKSx0aGlzfWdldFVzZXIoKXtyZXR1cm4gdGhpcy5TfXNldFRhZ3ModCl7cmV0dXJuIHRoaXMuTj17Li4udGhpcy5OLC4uLnR9LHRoaXMuVSgpLHRoaXN9c2V0VGFnKHQsbil7cmV0dXJuIHRoaXMuTj17Li4udGhpcy5OLFt0XTpufSx0aGlzLlUoKSx0aGlzfXNldEV4dHJhcyh0KXtyZXR1cm4gdGhpcy5UPXsuLi50aGlzLlQsLi4udH0sdGhpcy5VKCksdGhpc31zZXRFeHRyYSh0LG4pe3JldHVybiB0aGlzLlQ9ey4uLnRoaXMuVCxbdF06bn0sdGhpcy5VKCksdGhpc31zZXRGaW5nZXJwcmludCh0KXtyZXR1cm4gdGhpcy5PPXQsdGhpcy5VKCksdGhpc31zZXRMZXZlbCh0KXtyZXR1cm4gdGhpcy5qPXQsdGhpcy5VKCksdGhpc31zZXRUcmFuc2FjdGlvbk5hbWUodCl7cmV0dXJuIHRoaXMuST10LHRoaXMuVSgpLHRoaXN9c2V0Q29udGV4dCh0LG4pe3JldHVybiBudWxsPT09bj9kZWxldGUgdGhpcy5DW3RdOnRoaXMuQ1t0XT1uLHRoaXMuVSgpLHRoaXN9c2V0U2Vzc2lvbih0KXtyZXR1cm4gdD90aGlzLkQ9dDpkZWxldGUgdGhpcy5ELHRoaXMuVSgpLHRoaXN9Z2V0U2Vzc2lvbigpe3JldHVybiB0aGlzLkR9dXBkYXRlKHQpe2lmKCF0KXJldHVybiB0aGlzO2NvbnN0IG49ImZ1bmN0aW9uIj09dHlwZW9mIHQ/dCh0aGlzKTp0LGU9biBpbnN0YW5jZW9mIG50P24uZ2V0U2NvcGVEYXRhKCk6SShuKT90OnZvaWQgMCx7dGFnczpyLGV4dHJhOm8sdXNlcjpzLGNvbnRleHRzOmksbGV2ZWw6YyxmaW5nZXJwcmludDp1PVtdLHByb3BhZ2F0aW9uQ29udGV4dDphfT1lfHx7fTtyZXR1cm4gdGhpcy5OPXsuLi50aGlzLk4sLi4ucn0sdGhpcy5UPXsuLi50aGlzLlQsLi4ub30sdGhpcy5DPXsuLi50aGlzLkMsLi4uaX0scyYmT2JqZWN0LmtleXMocykubGVuZ3RoJiYodGhpcy5TPXMpLGMmJih0aGlzLmo9YyksdS5sZW5ndGgmJih0aGlzLk89dSksYSYmKHRoaXMuaz1hKSx0aGlzfWNsZWFyKCl7cmV0dXJuIHRoaXMuXz1bXSx0aGlzLk49e30sdGhpcy5UPXt9LHRoaXMuUz17fSx0aGlzLkM9e30sdGhpcy5qPXZvaWQgMCx0aGlzLkk9dm9pZCAwLHRoaXMuTz12b2lkIDAsdGhpcy5EPXZvaWQgMCxYKHRoaXMsdm9pZCAwKSx0aGlzLnY9W10sdGhpcy5zZXRQcm9wYWdhdGlvbkNvbnRleHQoe3RyYWNlSWQ6VigpLHNhbXBsZVJhbmQ6TWF0aC5yYW5kb20oKX0pLHRoaXMuVSgpLHRoaXN9YWRkQnJlYWRjcnVtYih0LG4pe2NvbnN0IGU9Im51bWJlciI9PXR5cGVvZiBuP246MTAwO2lmKGU8PTApcmV0dXJuIHRoaXM7Y29uc3Qgcj17dGltZXN0YW1wOkMoKSwuLi50LG1lc3NhZ2U6dC5tZXNzYWdlP0wodC5tZXNzYWdlLDIwNDgpOnQubWVzc2FnZX07cmV0dXJuIHRoaXMuXy5wdXNoKHIpLHRoaXMuXy5sZW5ndGg+ZSYmKHRoaXMuXz10aGlzLl8uc2xpY2UoLWUpLHRoaXMuQT8ucmVjb3JkRHJvcHBlZEV2ZW50KCJidWZmZXJfb3ZlcmZsb3ciLCJsb2dfaXRlbSIpKSx0aGlzLlUoKSx0aGlzfWdldExhc3RCcmVhZGNydW1iKCl7cmV0dXJuIHRoaXMuX1t0aGlzLl8ubGVuZ3RoLTFdfWNsZWFyQnJlYWRjcnVtYnMoKXtyZXR1cm4gdGhpcy5fPVtdLHRoaXMuVSgpLHRoaXN9YWRkQXR0YWNobWVudCh0KXtyZXR1cm4gdGhpcy52LnB1c2godCksdGhpc31jbGVhckF0dGFjaG1lbnRzKCl7cmV0dXJuIHRoaXMudj1bXSx0aGlzfWdldFNjb3BlRGF0YSgpe3JldHVybnticmVhZGNydW1iczp0aGlzLl8sYXR0YWNobWVudHM6dGhpcy52LGNvbnRleHRzOnRoaXMuQyx0YWdzOnRoaXMuTixleHRyYTp0aGlzLlQsdXNlcjp0aGlzLlMsbGV2ZWw6dGhpcy5qLGZpbmdlcnByaW50OnRoaXMuT3x8W10sZXZlbnRQcm9jZXNzb3JzOnRoaXMubSxwcm9wYWdhdGlvbkNvbnRleHQ6dGhpcy5rLHNka1Byb2Nlc3NpbmdNZXRhZGF0YTp0aGlzLlIsdHJhbnNhY3Rpb25OYW1lOnRoaXMuSSxzcGFuOnR0KHRoaXMpfX1zZXRTREtQcm9jZXNzaW5nTWV0YWRhdGEodCl7cmV0dXJuIHRoaXMuUj1xKHRoaXMuUix0LDIpLHRoaXN9c2V0UHJvcGFnYXRpb25Db250ZXh0KHQpe3JldHVybiB0aGlzLms9dCx0aGlzfWdldFByb3BhZ2F0aW9uQ29udGV4dCgpe3JldHVybiB0aGlzLmt9Y2FwdHVyZUV4Y2VwdGlvbih0LG4pe2NvbnN0IGU9bj8uZXZlbnRfaWR8fFkoKTtpZighdGhpcy5BKXJldHVybiB3Lndhcm4oIk5vIGNsaWVudCBjb25maWd1cmVkIG9uIHNjb3BlIC0gd2lsbCBub3QgY2FwdHVyZSBleGNlcHRpb24hIiksZTtjb25zdCByPW5ldyBFcnJvcigiU2VudHJ5IHN5bnRoZXRpY0V4Y2VwdGlvbiIpO3JldHVybiB0aGlzLkEuY2FwdHVyZUV4Y2VwdGlvbih0LHtvcmlnaW5hbEV4Y2VwdGlvbjp0LHN5bnRoZXRpY0V4Y2VwdGlvbjpyLC4uLm4sZXZlbnRfaWQ6ZX0sdGhpcyksZX1jYXB0dXJlTWVzc2FnZSh0LG4sZSl7Y29uc3Qgcj1lPy5ldmVudF9pZHx8WSgpO2lmKCF0aGlzLkEpcmV0dXJuIHcud2FybigiTm8gY2xpZW50IGNvbmZpZ3VyZWQgb24gc2NvcGUgLSB3aWxsIG5vdCBjYXB0dXJlIG1lc3NhZ2UhIikscjtjb25zdCBvPW5ldyBFcnJvcih0KTtyZXR1cm4gdGhpcy5BLmNhcHR1cmVNZXNzYWdlKHQsbix7b3JpZ2luYWxFeGNlcHRpb246dCxzeW50aGV0aWNFeGNlcHRpb246bywuLi5lLGV2ZW50X2lkOnJ9LHRoaXMpLHJ9Y2FwdHVyZUV2ZW50KHQsbil7Y29uc3QgZT1uPy5ldmVudF9pZHx8WSgpO3JldHVybiB0aGlzLkE/KHRoaXMuQS5jYXB0dXJlRXZlbnQodCx7Li4ubixldmVudF9pZDplfSx0aGlzKSxlKToody53YXJuKCJObyBjbGllbnQgY29uZmlndXJlZCBvbiBzY29wZSAtIHdpbGwgbm90IGNhcHR1cmUgZXZlbnQhIiksZSl9VSgpe3RoaXMucHx8KHRoaXMucD0hMCx0aGlzLmwuZm9yRWFjaCgodD0+e3QodGhpcyl9KSksdGhpcy5wPSExKX19Y2xhc3MgZXR7Y29uc3RydWN0b3IodCxuKXtsZXQgZSxyO2U9dHx8bmV3IG50LHI9bnx8bmV3IG50LHRoaXMuTT1be3Njb3BlOmV9XSx0aGlzLkw9cn13aXRoU2NvcGUodCl7Y29uc3Qgbj10aGlzLkIoKTtsZXQgZTt0cnl7ZT10KG4pfWNhdGNoKHQpe3Rocm93IHRoaXMuRygpLHR9cmV0dXJuIE8oZSk/ZS50aGVuKCh0PT4odGhpcy5HKCksdCkpLCh0PT57dGhyb3cgdGhpcy5HKCksdH0pKToodGhpcy5HKCksZSl9Z2V0Q2xpZW50KCl7cmV0dXJuIHRoaXMuZ2V0U3RhY2tUb3AoKS5jbGllbnR9Z2V0U2NvcGUoKXtyZXR1cm4gdGhpcy5nZXRTdGFja1RvcCgpLnNjb3BlfWdldElzb2xhdGlvblNjb3BlKCl7cmV0dXJuIHRoaXMuTH1nZXRTdGFja1RvcCgpe3JldHVybiB0aGlzLk1bdGhpcy5NLmxlbmd0aC0xXX1CKCl7Y29uc3QgdD10aGlzLmdldFNjb3BlKCkuY2xvbmUoKTtyZXR1cm4gdGhpcy5NLnB1c2goe2NsaWVudDp0aGlzLmdldENsaWVudCgpLHNjb3BlOnR9KSx0fUcoKXtyZXR1cm4hKHRoaXMuTS5sZW5ndGg8PTEpJiYhIXRoaXMuTS5wb3AoKX19ZnVuY3Rpb24gcnQoKXtjb25zdCB0PWcobSgpKTtyZXR1cm4gdC5zdGFjaz10LnN0YWNrfHxuZXcgZXQoeSgiZGVmYXVsdEN1cnJlbnRTY29wZSIsKCgpPT5uZXcgbnQpKSx5KCJkZWZhdWx0SXNvbGF0aW9uU2NvcGUiLCgoKT0+bmV3IG50KSkpfWZ1bmN0aW9uIG90KHQpe3JldHVybiBydCgpLndpdGhTY29wZSh0KX1mdW5jdGlvbiBzdCh0LG4pe2NvbnN0IGU9cnQoKTtyZXR1cm4gZS53aXRoU2NvcGUoKCgpPT4oZS5nZXRTdGFja1RvcCgpLnNjb3BlPXQsbih0KSkpKX1mdW5jdGlvbiBpdCh0KXtyZXR1cm4gcnQoKS53aXRoU2NvcGUoKCgpPT50KHJ0KCkuZ2V0SXNvbGF0aW9uU2NvcGUoKSkpKX1mdW5jdGlvbiBjdCh0KXtjb25zdCBuPWcodCk7cmV0dXJuIG4uYWNzP24uYWNzOnt3aXRoSXNvbGF0aW9uU2NvcGU6aXQsd2l0aFNjb3BlOm90LHdpdGhTZXRTY29wZTpzdCx3aXRoU2V0SXNvbGF0aW9uU2NvcGU6KHQsbik9Pml0KG4pLGdldEN1cnJlbnRTY29wZTooKT0+cnQoKS5nZXRTY29wZSgpLGdldElzb2xhdGlvblNjb3BlOigpPT5ydCgpLmdldElzb2xhdGlvblNjb3BlKCl9fWZ1bmN0aW9uIHV0KCl7cmV0dXJuIGN0KG0oKSkuZ2V0Q3VycmVudFNjb3BlKCkuZ2V0Q2xpZW50KCl9Y29uc3QgYXQ9InNlbnRyeS5zb3VyY2UiLGZ0PSJzZW50cnkuc2FtcGxlX3JhdGUiLGh0PSJzZW50cnkub3AiLHB0PSJzZW50cnkub3JpZ2luIixsdD0wLGR0PTEsbXQ9Il9zZW50cnlTY29wZSIsZ3Q9Il9zZW50cnlJc29sYXRpb25TY29wZSI7ZnVuY3Rpb24geXQodCl7cmV0dXJue3Njb3BlOnRbbXRdLGlzb2xhdGlvblNjb3BlOnRbZ3RdfX1jb25zdCBidD0ic2VudHJ5LSIsX3Q9L15zZW50cnktLztmdW5jdGlvbiB2dCh0KXtjb25zdCBuPWZ1bmN0aW9uKHQpe2lmKCF0fHwhRCh0KSYmIUFycmF5LmlzQXJyYXkodCkpcmV0dXJuO2lmKEFycmF5LmlzQXJyYXkodCkpcmV0dXJuIHQucmVkdWNlKCgodCxuKT0+e2NvbnN0IGU9d3Qobik7cmV0dXJuIE9iamVjdC5lbnRyaWVzKGUpLmZvckVhY2goKChbbixlXSk9Pnt0W25dPWV9KSksdH0pLHt9KTtyZXR1cm4gd3QodCl9KHQpO2lmKCFuKXJldHVybjtjb25zdCBlPU9iamVjdC5lbnRyaWVzKG4pLnJlZHVjZSgoKHQsW24sZV0pPT57aWYobi5tYXRjaChfdCkpe3Rbbi5zbGljZShidC5sZW5ndGgpXT1lfXJldHVybiB0fSkse30pO3JldHVybiBPYmplY3Qua2V5cyhlKS5sZW5ndGg+MD9lOnZvaWQgMH1mdW5jdGlvbiB3dCh0KXtyZXR1cm4gdC5zcGxpdCgiLCIpLm1hcCgodD0+dC5zcGxpdCgiPSIpLm1hcCgodD0+ZGVjb2RlVVJJQ29tcG9uZW50KHQudHJpbSgpKSkpKSkucmVkdWNlKCgodCxbbixlXSk9PihuJiZlJiYodFtuXT1lKSx0KSkse30pfWNvbnN0IFN0PTE7ZnVuY3Rpb24gJHQodCl7Y29uc3R7c3BhbklkOm4sdHJhY2VJZDplLGlzUmVtb3RlOnJ9PXQuc3BhbkNvbnRleHQoKSxvPXI/bjpUdCh0KS5wYXJlbnRfc3Bhbl9pZCxzPXl0KHQpLnNjb3BlO3JldHVybntwYXJlbnRfc3Bhbl9pZDpvLHNwYW5faWQ6cj9zPy5nZXRQcm9wYWdhdGlvbkNvbnRleHQoKS5wcm9wYWdhdGlvblNwYW5JZHx8WigpOm4sdHJhY2VfaWQ6ZX19ZnVuY3Rpb24gRXQodCl7cmV0dXJuIHQmJnQubGVuZ3RoPjA/dC5tYXAoKCh7Y29udGV4dDp7c3BhbklkOnQsdHJhY2VJZDpuLHRyYWNlRmxhZ3M6ZSwuLi5yfSxhdHRyaWJ1dGVzOm99KT0+KHtzcGFuX2lkOnQsdHJhY2VfaWQ6bixzYW1wbGVkOmU9PT1TdCxhdHRyaWJ1dGVzOm8sLi4ucn0pKSk6dm9pZCAwfWZ1bmN0aW9uIHh0KHQpe3JldHVybiJudW1iZXIiPT10eXBlb2YgdD9OdCh0KTpBcnJheS5pc0FycmF5KHQpP3RbMF0rdFsxXS8xZTk6dCBpbnN0YW5jZW9mIERhdGU/TnQodC5nZXRUaW1lKCkpOlIoKX1mdW5jdGlvbiBOdCh0KXtyZXR1cm4gdD45OTk5OTk5OTk5P3QvMWUzOnR9ZnVuY3Rpb24gVHQodCl7aWYoZnVuY3Rpb24odCl7cmV0dXJuImZ1bmN0aW9uIj09dHlwZW9mIHQuZ2V0U3BhbkpTT059KHQpKXJldHVybiB0LmdldFNwYW5KU09OKCk7Y29uc3R7c3BhbklkOm4sdHJhY2VJZDplfT10LnNwYW5Db250ZXh0KCk7aWYoZnVuY3Rpb24odCl7Y29uc3Qgbj10O3JldHVybiEhKG4uYXR0cmlidXRlcyYmbi5zdGFydFRpbWUmJm4ubmFtZSYmbi5lbmRUaW1lJiZuLnN0YXR1cyl9KHQpKXtjb25zdHthdHRyaWJ1dGVzOnIsc3RhcnRUaW1lOm8sbmFtZTpzLGVuZFRpbWU6aSxzdGF0dXM6YyxsaW5rczp1fT10LGE9dC5wYXJlbnRTcGFuQ29udGV4dD8uc3BhbklkO3JldHVybntzcGFuX2lkOm4sdHJhY2VfaWQ6ZSxkYXRhOnIsZGVzY3JpcHRpb246cyxwYXJlbnRfc3Bhbl9pZDphLHN0YXJ0X3RpbWVzdGFtcDp4dChvKSx0aW1lc3RhbXA6eHQoaSl8fHZvaWQgMCxzdGF0dXM6Q3QoYyksb3A6cltodF0sb3JpZ2luOnJbcHRdLGxpbmtzOkV0KHUpfX1yZXR1cm57c3Bhbl9pZDpuLHRyYWNlX2lkOmUsc3RhcnRfdGltZXN0YW1wOjAsZGF0YTp7fX19ZnVuY3Rpb24gQ3QodCl7aWYodCYmdC5jb2RlIT09bHQpcmV0dXJuIHQuY29kZT09PWR0PyJvayI6dC5tZXNzYWdlfHwidW5rbm93bl9lcnJvciJ9Y29uc3QgUnQ9Il9zZW50cnlSb290U3BhbiI7ZnVuY3Rpb24ga3QodCl7cmV0dXJuIHRbUnRdfHx0fWNvbnN0IGp0PSJwcm9kdWN0aW9uIixEdD0iX2Zyb3plbkRzYyI7ZnVuY3Rpb24gSXQodCl7Y29uc3Qgbj11dCgpO2lmKCFuKXJldHVybnt9O2NvbnN0IGU9a3QodCkscj1UdChlKSxvPXIuZGF0YSxzPWUuc3BhbkNvbnRleHQoKS50cmFjZVN0YXRlLGk9cz8uZ2V0KCJzZW50cnkuc2FtcGxlX3JhdGUiKT8/b1tmdF07ZnVuY3Rpb24gYyh0KXtyZXR1cm4ibnVtYmVyIiE9dHlwZW9mIGkmJiJzdHJpbmciIT10eXBlb2YgaXx8KHQuc2FtcGxlX3JhdGU9YCR7aX1gKSx0fWNvbnN0IHU9ZVtEdF07aWYodSlyZXR1cm4gYyh1KTtjb25zdCBhPXM/LmdldCgic2VudHJ5LmRzYyIpLGY9YSYmdnQoYSk7aWYoZilyZXR1cm4gYyhmKTtjb25zdCBoPWZ1bmN0aW9uKHQsbil7Y29uc3QgZT1uLmdldE9wdGlvbnMoKSx7cHVibGljS2V5OnJ9PW4uZ2V0RHNuKCl8fHt9LG89e2Vudmlyb25tZW50OmUuZW52aXJvbm1lbnR8fGp0LHJlbGVhc2U6ZS5yZWxlYXNlLHB1YmxpY19rZXk6cix0cmFjZV9pZDp0fTtyZXR1cm4gbi5lbWl0KCJjcmVhdGVEc2MiLG8pLG99KHQuc3BhbkNvbnRleHQoKS50cmFjZUlkLG4pLHA9b1thdF0sbD1yLmRlc2NyaXB0aW9uO3JldHVybiJ1cmwiIT09cCYmbCYmKGgudHJhbnNhY3Rpb249bCksZnVuY3Rpb24odCl7aWYoImJvb2xlYW4iPT10eXBlb2YgX19TRU5UUllfVFJBQ0lOR19fJiYhX19TRU5UUllfVFJBQ0lOR19fKXJldHVybiExO2NvbnN0IG49dHx8dXQoKT8uZ2V0T3B0aW9ucygpO3JldHVybiEoIW58fG51bGw9PW4udHJhY2VzU2FtcGxlUmF0ZSYmIW4udHJhY2VzU2FtcGxlcil9KCkmJihoLnNhbXBsZWQ9U3RyaW5nKGZ1bmN0aW9uKHQpe2NvbnN0e3RyYWNlRmxhZ3M6bn09dC5zcGFuQ29udGV4dCgpO3JldHVybiBuPT09U3R9KGUpKSxoLnNhbXBsZV9yYW5kPXM/LmdldCgic2VudHJ5LnNhbXBsZV9yYW5kIik/P3l0KGUpLnNjb3BlPy5nZXRQcm9wYWdhdGlvbkNvbnRleHQoKS5zYW1wbGVSYW5kLnRvU3RyaW5nKCkpLGMoaCksbi5lbWl0KCJjcmVhdGVEc2MiLGgsZSksaH1mdW5jdGlvbiBPdCh0LG49ITEpe2NvbnN0e2hvc3Q6ZSxwYXRoOnIscGFzczpvLHBvcnQ6cyxwcm9qZWN0SWQ6aSxwcm90b2NvbDpjLHB1YmxpY0tleTp1fT10O3JldHVybmAke2N9Oi8vJHt1fSR7biYmbz9gOiR7b31gOiIifUAke2V9JHtzP2A6JHtzfWA6IiJ9LyR7cj9gJHtyfS9gOnJ9JHtpfWB9ZnVuY3Rpb24gQXQodCxuPTEwMCxlPTEvMCl7dHJ5e3JldHVybiBQdCgiIix0LG4sZSl9Y2F0Y2godCl7cmV0dXJue0VSUk9SOmAqKm5vbi1zZXJpYWxpemFibGUqKiAoJHt0fSlgfX19ZnVuY3Rpb24gUHQodCxuLGU9MS8wLHI9MS8wLG89ZnVuY3Rpb24oKXtjb25zdCB0PW5ldyBXZWFrU2V0O2Z1bmN0aW9uIG4obil7cmV0dXJuISF0LmhhcyhuKXx8KHQuYWRkKG4pLCExKX1mdW5jdGlvbiBlKG4pe3QuZGVsZXRlKG4pfXJldHVybltuLGVdfSgpKXtjb25zdFtzLGldPW87aWYobnVsbD09bnx8WyJib29sZWFuIiwic3RyaW5nIl0uaW5jbHVkZXModHlwZW9mIG4pfHwibnVtYmVyIj09dHlwZW9mIG4mJk51bWJlci5pc0Zpbml0ZShuKSlyZXR1cm4gbjtjb25zdCBjPWZ1bmN0aW9uKHQsbil7dHJ5e2lmKCJkb21haW4iPT09dCYmbiYmIm9iamVjdCI9PXR5cGVvZiBuJiZuLkopcmV0dXJuIltEb21haW5dIjtpZigiZG9tYWluRW1pdHRlciI9PT10KXJldHVybiJbRG9tYWluRW1pdHRlcl0iO2lmKCJ1bmRlZmluZWQiIT10eXBlb2YgZ2xvYmFsJiZuPT09Z2xvYmFsKXJldHVybiJbR2xvYmFsXSI7aWYoInVuZGVmaW5lZCIhPXR5cGVvZiB3aW5kb3cmJm49PT13aW5kb3cpcmV0dXJuIltXaW5kb3ddIjtpZigidW5kZWZpbmVkIiE9dHlwZW9mIGRvY3VtZW50JiZuPT09ZG9jdW1lbnQpcmV0dXJuIltEb2N1bWVudF0iO2lmKCJvYmplY3QiPT10eXBlb2YoZT1uKSYmbnVsbCE9PWUmJihlLl9faXNWdWV8fGUuWSkpcmV0dXJuIltWdWVWaWV3TW9kZWxdIjtpZihmdW5jdGlvbih0KXtyZXR1cm4gSSh0KSYmIm5hdGl2ZUV2ZW50ImluIHQmJiJwcmV2ZW50RGVmYXVsdCJpbiB0JiYic3RvcFByb3BhZ2F0aW9uImluIHR9KG4pKXJldHVybiJbU3ludGhldGljRXZlbnRdIjtpZigibnVtYmVyIj09dHlwZW9mIG4mJiFOdW1iZXIuaXNGaW5pdGUobikpcmV0dXJuYFske259XWA7aWYoImZ1bmN0aW9uIj09dHlwZW9mIG4pcmV0dXJuYFtGdW5jdGlvbjogJHtmdW5jdGlvbih0KXt0cnl7cmV0dXJuIHQmJiJmdW5jdGlvbiI9PXR5cGVvZiB0JiZ0Lm5hbWV8fE59Y2F0Y2godCl7cmV0dXJuIE59fShuKX1dYDtpZigic3ltYm9sIj09dHlwZW9mIG4pcmV0dXJuYFske1N0cmluZyhuKX1dYDtpZigiYmlnaW50Ij09dHlwZW9mIG4pcmV0dXJuYFtCaWdJbnQ6ICR7U3RyaW5nKG4pfV1gO2NvbnN0IHI9ZnVuY3Rpb24odCl7Y29uc3Qgbj1PYmplY3QuZ2V0UHJvdG90eXBlT2YodCk7cmV0dXJuIG4/LmNvbnN0cnVjdG9yP24uY29uc3RydWN0b3IubmFtZToibnVsbCBwcm90b3R5cGUifShuKTtyZXR1cm4vXkhUTUwoXHcqKUVsZW1lbnQkLy50ZXN0KHIpP2BbSFRNTEVsZW1lbnQ6ICR7cn1dYDpgW29iamVjdCAke3J9XWB9Y2F0Y2godCl7cmV0dXJuYCoqbm9uLXNlcmlhbGl6YWJsZSoqICgke3R9KWB9dmFyIGV9KHQsbik7aWYoIWMuc3RhcnRzV2l0aCgiW29iamVjdCAiKSlyZXR1cm4gYztpZihuLl9fc2VudHJ5X3NraXBfbm9ybWFsaXphdGlvbl9fKXJldHVybiBuO2NvbnN0IHU9Im51bWJlciI9PXR5cGVvZiBuLl9fc2VudHJ5X292ZXJyaWRlX25vcm1hbGl6YXRpb25fZGVwdGhfXz9uLl9fc2VudHJ5X292ZXJyaWRlX25vcm1hbGl6YXRpb25fZGVwdGhfXzplO2lmKDA9PT11KXJldHVybiBjLnJlcGxhY2UoIm9iamVjdCAiLCIiKTtpZihzKG4pKXJldHVybiJbQ2lyY3VsYXIgfl0iO2NvbnN0IGE9bjtpZihhJiYiZnVuY3Rpb24iPT10eXBlb2YgYS50b0pTT04pdHJ5e3JldHVybiBQdCgiIixhLnRvSlNPTigpLHUtMSxyLG8pfWNhdGNoKHQpe31jb25zdCBmPUFycmF5LmlzQXJyYXkobik/W106e307bGV0IGg9MDtjb25zdCBwPUIobik7Zm9yKGNvbnN0IHQgaW4gcCl7aWYoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwLHQpKWNvbnRpbnVlO2lmKGg+PXIpe2ZbdF09IltNYXhQcm9wZXJ0aWVzIH5dIjticmVha31jb25zdCBuPXBbdF07Zlt0XT1QdCh0LG4sdS0xLHIsbyksaCsrfXJldHVybiBpKG4pLGZ9ZnVuY3Rpb24gVXQodCxuKXtjb25zdCBlPW4ucmVwbGFjZSgvXFwvZywiLyIpLnJlcGxhY2UoL1t8XFx7fSgpW1xdXiQrKj8uXS9nLCJcXCQmIik7bGV0IHI9dDt0cnl7cj1kZWNvZGVVUkkodCl9Y2F0Y2godCl7fXJldHVybiByLnJlcGxhY2UoL1xcL2csIi8iKS5yZXBsYWNlKC93ZWJwYWNrOlwvPy9nLCIiKS5yZXBsYWNlKG5ldyBSZWdFeHAoYChmaWxlOi8vKT8vKiR7ZX0vKmAsImlnIiksImFwcDovLy8iKX1mdW5jdGlvbiBNdCh0LG49W10pe3JldHVyblt0LG5dfWZ1bmN0aW9uIEx0KHQsbil7Y29uc3QgZT10WzFdO2Zvcihjb25zdCB0IG9mIGUpe2lmKG4odCx0WzBdLnR5cGUpKXJldHVybiEwfXJldHVybiExfWZ1bmN0aW9uIEJ0KHQpe2NvbnN0IG49ZyhwKTtyZXR1cm4gbi5lbmNvZGVQb2x5ZmlsbD9uLmVuY29kZVBvbHlmaWxsKHQpOihuZXcgVGV4dEVuY29kZXIpLmVuY29kZSh0KX1mdW5jdGlvbiBHdCh0KXtjb25zdFtuLGVdPXQ7bGV0IHI9SlNPTi5zdHJpbmdpZnkobik7ZnVuY3Rpb24gbyh0KXsic3RyaW5nIj09dHlwZW9mIHI/cj0ic3RyaW5nIj09dHlwZW9mIHQ/cit0OltCdChyKSx0XTpyLnB1c2goInN0cmluZyI9PXR5cGVvZiB0P0J0KHQpOnQpfWZvcihjb25zdCB0IG9mIGUpe2NvbnN0W24sZV09dDtpZihvKGBcbiR7SlNPTi5zdHJpbmdpZnkobil9XG5gKSwic3RyaW5nIj09dHlwZW9mIGV8fGUgaW5zdGFuY2VvZiBVaW50OEFycmF5KW8oZSk7ZWxzZXtsZXQgdDt0cnl7dD1KU09OLnN0cmluZ2lmeShlKX1jYXRjaChuKXt0PUpTT04uc3RyaW5naWZ5KEF0KGUpKX1vKHQpfX1yZXR1cm4ic3RyaW5nIj09dHlwZW9mIHI/cjpmdW5jdGlvbih0KXtjb25zdCBuPXQucmVkdWNlKCgodCxuKT0+dCtuLmxlbmd0aCksMCksZT1uZXcgVWludDhBcnJheShuKTtsZXQgcj0wO2Zvcihjb25zdCBuIG9mIHQpZS5zZXQobixyKSxyKz1uLmxlbmd0aDtyZXR1cm4gZX0ocil9Y29uc3QgSnQ9e3Nlc3Npb246InNlc3Npb24iLHNlc3Npb25zOiJzZXNzaW9uIixhdHRhY2htZW50OiJhdHRhY2htZW50Iix0cmFuc2FjdGlvbjoidHJhbnNhY3Rpb24iLGV2ZW50OiJlcnJvciIsY2xpZW50X3JlcG9ydDoiaW50ZXJuYWwiLHVzZXJfcmVwb3J0OiJkZWZhdWx0Iixwcm9maWxlOiJwcm9maWxlIixwcm9maWxlX2NodW5rOiJwcm9maWxlIixyZXBsYXlfZXZlbnQ6InJlcGxheSIscmVwbGF5X3JlY29yZGluZzoicmVwbGF5IixjaGVja19pbjoibW9uaXRvciIsZmVlZGJhY2s6ImZlZWRiYWNrIixzcGFuOiJzcGFuIixyYXdfc2VjdXJpdHk6InNlY3VyaXR5IixvdGVsX2xvZzoibG9nX2l0ZW0ifTtmdW5jdGlvbiBZdCh0KXtpZighdD8uc2RrKXJldHVybjtjb25zdHtuYW1lOm4sdmVyc2lvbjplfT10LnNkaztyZXR1cm57bmFtZTpuLHZlcnNpb246ZX19ZnVuY3Rpb24genQodCxuLGUscil7Y29uc3Qgbz1ZdChlKSxzPXQudHlwZSYmInJlcGxheV9ldmVudCIhPT10LnR5cGU/dC50eXBlOiJldmVudCI7IWZ1bmN0aW9uKHQsbil7biYmKHQuc2RrPXQuc2RrfHx7fSx0LnNkay5uYW1lPXQuc2RrLm5hbWV8fG4ubmFtZSx0LnNkay52ZXJzaW9uPXQuc2RrLnZlcnNpb258fG4udmVyc2lvbix0LnNkay5pbnRlZ3JhdGlvbnM9Wy4uLnQuc2RrLmludGVncmF0aW9uc3x8W10sLi4ubi5pbnRlZ3JhdGlvbnN8fFtdXSx0LnNkay5wYWNrYWdlcz1bLi4udC5zZGsucGFja2FnZXN8fFtdLC4uLm4ucGFja2FnZXN8fFtdXSl9KHQsZT8uc2RrKTtjb25zdCBpPWZ1bmN0aW9uKHQsbixlLHIpe2NvbnN0IG89dC5zZGtQcm9jZXNzaW5nTWV0YWRhdGE/LmR5bmFtaWNTYW1wbGluZ0NvbnRleHQ7cmV0dXJue2V2ZW50X2lkOnQuZXZlbnRfaWQsc2VudF9hdDoobmV3IERhdGUpLnRvSVNPU3RyaW5nKCksLi4ubiYme3NkazpufSwuLi4hIWUmJnImJntkc246T3Qocil9LC4uLm8mJnt0cmFjZTpvfX19KHQsbyxyLG4pO2RlbGV0ZSB0LnNka1Byb2Nlc3NpbmdNZXRhZGF0YTtyZXR1cm4gTXQoaSxbW3t0eXBlOnN9LHRdXSl9Y29uc3QgSHQ9Il9fU0VOVFJZX1NVUFBSRVNTX1RSQUNJTkdfXyI7ZnVuY3Rpb24gRnQodCl7Y29uc3Qgbj1jdChtKCkpO3JldHVybiBuLnN1cHByZXNzVHJhY2luZz9uLnN1cHByZXNzVHJhY2luZyh0KTpmdW5jdGlvbiguLi50KXtjb25zdCBuPWN0KG0oKSk7aWYoMj09PXQubGVuZ3RoKXtjb25zdFtlLHJdPXQ7cmV0dXJuIGU/bi53aXRoU2V0U2NvcGUoZSxyKTpuLndpdGhTY29wZShyKX1yZXR1cm4gbi53aXRoU2NvcGUodFswXSl9KChuPT4obi5zZXRTREtQcm9jZXNzaW5nTWV0YWRhdGEoe1tIdF06ITB9KSx0KCkpKSl9ZnVuY3Rpb24gV3QodCxuKXtjb25zdHtmaW5nZXJwcmludDplLHNwYW46cixicmVhZGNydW1iczpvLHNka1Byb2Nlc3NpbmdNZXRhZGF0YTpzfT1uOyFmdW5jdGlvbih0LG4pe2NvbnN0e2V4dHJhOmUsdGFnczpyLHVzZXI6byxjb250ZXh0czpzLGxldmVsOmksdHJhbnNhY3Rpb25OYW1lOmN9PW47T2JqZWN0LmtleXMoZSkubGVuZ3RoJiYodC5leHRyYT17Li4uZSwuLi50LmV4dHJhfSk7T2JqZWN0LmtleXMocikubGVuZ3RoJiYodC50YWdzPXsuLi5yLC4uLnQudGFnc30pO09iamVjdC5rZXlzKG8pLmxlbmd0aCYmKHQudXNlcj17Li4ubywuLi50LnVzZXJ9KTtPYmplY3Qua2V5cyhzKS5sZW5ndGgmJih0LmNvbnRleHRzPXsuLi5zLC4uLnQuY29udGV4dHN9KTtpJiYodC5sZXZlbD1pKTtjJiYidHJhbnNhY3Rpb24iIT09dC50eXBlJiYodC50cmFuc2FjdGlvbj1jKX0odCxuKSxyJiZmdW5jdGlvbih0LG4pe3QuY29udGV4dHM9e3RyYWNlOiR0KG4pLC4uLnQuY29udGV4dHN9LHQuc2RrUHJvY2Vzc2luZ01ldGFkYXRhPXtkeW5hbWljU2FtcGxpbmdDb250ZXh0Okl0KG4pLC4uLnQuc2RrUHJvY2Vzc2luZ01ldGFkYXRhfTtjb25zdCBlPWt0KG4pLHI9VHQoZSkuZGVzY3JpcHRpb247ciYmIXQudHJhbnNhY3Rpb24mJiJ0cmFuc2FjdGlvbiI9PT10LnR5cGUmJih0LnRyYW5zYWN0aW9uPXIpfSh0LHIpLGZ1bmN0aW9uKHQsbil7dC5maW5nZXJwcmludD10LmZpbmdlcnByaW50P0FycmF5LmlzQXJyYXkodC5maW5nZXJwcmludCk/dC5maW5nZXJwcmludDpbdC5maW5nZXJwcmludF06W10sbiYmKHQuZmluZ2VycHJpbnQ9dC5maW5nZXJwcmludC5jb25jYXQobikpO3QuZmluZ2VycHJpbnQubGVuZ3RofHxkZWxldGUgdC5maW5nZXJwcmludH0odCxlKSxmdW5jdGlvbih0LG4pe2NvbnN0IGU9Wy4uLnQuYnJlYWRjcnVtYnN8fFtdLC4uLm5dO3QuYnJlYWRjcnVtYnM9ZS5sZW5ndGg/ZTp2b2lkIDB9KHQsbyksZnVuY3Rpb24odCxuKXt0LnNka1Byb2Nlc3NpbmdNZXRhZGF0YT17Li4udC5zZGtQcm9jZXNzaW5nTWV0YWRhdGEsLi4ubn19KHQscyl9Y29uc3QgS3Q9IjciO2NvbnN0IFZ0PVN5bWJvbC5mb3IoIlNlbnRyeUJ1ZmZlckZ1bGxFcnJvciIpO2Z1bmN0aW9uIFp0KHQpe2NvbnN0IG49W107ZnVuY3Rpb24gZSh0KXtyZXR1cm4gbi5zcGxpY2Uobi5pbmRleE9mKHQpLDEpWzBdfHxQcm9taXNlLnJlc29sdmUodm9pZCAwKX1yZXR1cm57JDpuLGFkZDpmdW5jdGlvbihyKXtpZighKHZvaWQgMD09PXR8fG4ubGVuZ3RoPHQpKXJldHVybiBvPVZ0LG5ldyBGKCgodCxuKT0+e24obyl9KSk7dmFyIG87Y29uc3Qgcz1yKCk7cmV0dXJuLTE9PT1uLmluZGV4T2YocykmJm4ucHVzaChzKSxzLnRoZW4oKCgpPT5lKHMpKSkudGhlbihudWxsLCgoKT0+ZShzKS50aGVuKG51bGwsKCgpPT57fSkpKSksc30sZHJhaW46ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBGKCgoZSxyKT0+e2xldCBvPW4ubGVuZ3RoO2lmKCFvKXJldHVybiBlKCEwKTtjb25zdCBzPXNldFRpbWVvdXQoKCgpPT57dCYmdD4wJiZlKCExKX0pLHQpO24uZm9yRWFjaCgodD0+e0godCkudGhlbigoKCk9PnstLW98fChjbGVhclRpbWVvdXQocyksZSghMCkpfSkscil9KSl9KSl9fX1jb25zdCBxdD02ZTQ7ZnVuY3Rpb24gUXQodCx7c3RhdHVzQ29kZTpuLGhlYWRlcnM6ZX0scj1EYXRlLm5vdygpKXtjb25zdCBvPXsuLi50fSxzPWU/LlsieC1zZW50cnktcmF0ZS1saW1pdHMiXSxpPWU/LlsicmV0cnktYWZ0ZXIiXTtpZihzKWZvcihjb25zdCB0IG9mIHMudHJpbSgpLnNwbGl0KCIsIikpe2NvbnN0W24sZSwsLHNdPXQuc3BsaXQoIjoiLDUpLGk9cGFyc2VJbnQobiwxMCksYz0xZTMqKGlzTmFOKGkpPzYwOmkpO2lmKGUpZm9yKGNvbnN0IHQgb2YgZS5zcGxpdCgiOyIpKSJtZXRyaWNfYnVja2V0Ij09PXQmJnMmJiFzLnNwbGl0KCI7IikuaW5jbHVkZXMoImN1c3RvbSIpfHwob1t0XT1yK2MpO2Vsc2Ugby5hbGw9citjfWVsc2UgaT9vLmFsbD1yK2Z1bmN0aW9uKHQsbj1EYXRlLm5vdygpKXtjb25zdCBlPXBhcnNlSW50KGAke3R9YCwxMCk7aWYoIWlzTmFOKGUpKXJldHVybiAxZTMqZTtjb25zdCByPURhdGUucGFyc2UoYCR7dH1gKTtyZXR1cm4gaXNOYU4ocik/cXQ6ci1ufShpLHIpOjQyOT09PW4mJihvLmFsbD1yKzZlNCk7cmV0dXJuIG99Y29uc3QgWHQ9NjQ7ZnVuY3Rpb24gdG4odCxuLGU9WnQodC5idWZmZXJTaXplfHxYdCkpe2xldCByPXt9O3JldHVybntzZW5kOmZ1bmN0aW9uKHQpe2NvbnN0IG89W107aWYoTHQodCwoKHQsbik9Pntjb25zdCBlPWZ1bmN0aW9uKHQpe3JldHVybiBKdFt0XX0obik7KGZ1bmN0aW9uKHQsbixlPURhdGUubm93KCkpe3JldHVybiBmdW5jdGlvbih0LG4pe3JldHVybiB0W25dfHx0LmFsbHx8MH0odCxuKT5lfSkocixlKXx8by5wdXNoKHQpfSkpLDA9PT1vLmxlbmd0aClyZXR1cm4gSCh7fSk7Y29uc3Qgcz1NdCh0WzBdLG8pLGk9dD0+e0x0KHMsKCh0LG4pPT57fSkpfTtyZXR1cm4gZS5hZGQoKCgpPT5uKHtib2R5Okd0KHMpfSkudGhlbigodD0+KHZvaWQgMCE9PXQuc3RhdHVzQ29kZSYmKHQuc3RhdHVzQ29kZTwyMDB8fHQuc3RhdHVzQ29kZT49MzAwKSYmaCYmdy53YXJuKGBTZW50cnkgcmVzcG9uZGVkIHdpdGggc3RhdHVzIGNvZGUgJHt0LnN0YXR1c0NvZGV9IHRvIHNlbnQgZXZlbnQuYCkscj1RdChyLHQpLHQpKSwodD0+e3Rocm93IGkoKSxoJiZ3LmVycm9yKCJFbmNvdW50ZXJlZCBlcnJvciBydW5uaW5nIHRyYW5zcG9ydCByZXF1ZXN0OiIsdCksdH0pKSkpLnRoZW4oKHQ9PnQpLCh0PT57aWYodD09PVZ0KXJldHVybiBoJiZ3LmVycm9yKCJTa2lwcGVkIHNlbmRpbmcgZXZlbnQgYmVjYXVzZSBidWZmZXIgaXMgZnVsbC4iKSxpKCksSCh7fSk7dGhyb3cgdH0pKX0sZmx1c2g6dD0+ZS5kcmFpbih0KX19Y29uc3Qgbm49L14oXFMrOlxcfFwvPykoW1xzXFNdKj8pKCg/OlwuezEsMn18W14vXFxdKz98KShcLlteLi9cXF0qfCkpKD86Wy9cXF0qKSQvO2Z1bmN0aW9uIGVuKHQpe2NvbnN0IG49ZnVuY3Rpb24odCl7Y29uc3Qgbj10Lmxlbmd0aD4xMDI0P2A8dHJ1bmNhdGVkPiR7dC5zbGljZSgtMTAyNCl9YDp0LGU9bm4uZXhlYyhuKTtyZXR1cm4gZT9lLnNsaWNlKDEpOltdfSh0KSxlPW5bMF18fCIiO2xldCByPW5bMV07cmV0dXJuIGV8fHI/KHImJihyPXIuc2xpY2UoMCxyLmxlbmd0aC0xKSksZStyKToiLiJ9ZnVuY3Rpb24gcm4odCxuPSExKXtyZXR1cm4hKG58fHQmJiF0LnN0YXJ0c1dpdGgoIi8iKSYmIXQubWF0Y2goL15bQS1aXTovKSYmIXQuc3RhcnRzV2l0aCgiLiIpJiYhdC5tYXRjaCgvXlthLXpBLVpdKFthLXpBLVowLTkuXC0rXSkqOlwvXC8vKSkmJnZvaWQgMCE9PXQmJiF0LmluY2x1ZGVzKCJub2RlX21vZHVsZXMvIil9Y29uc3Qgb249U3ltYm9sKCJBZ2VudEJhc2VJbnRlcm5hbFN0YXRlIik7Y2xhc3Mgc24gZXh0ZW5kcyBzLkFnZW50e2NvbnN0cnVjdG9yKHQpe3N1cGVyKHQpLHRoaXNbb25dPXt9fWlzU2VjdXJlRW5kcG9pbnQodCl7aWYodCl7aWYoImJvb2xlYW4iPT10eXBlb2YgdC5zZWN1cmVFbmRwb2ludClyZXR1cm4gdC5zZWN1cmVFbmRwb2ludDtpZigic3RyaW5nIj09dHlwZW9mIHQucHJvdG9jb2wpcmV0dXJuImh0dHBzOiI9PT10LnByb3RvY29sfWNvbnN0e3N0YWNrOm59PW5ldyBFcnJvcjtyZXR1cm4ic3RyaW5nIj09dHlwZW9mIG4mJm4uc3BsaXQoIlxuIikuc29tZSgodD0+LTEhPT10LmluZGV4T2YoIihodHRwcy5qczoiKXx8LTEhPT10LmluZGV4T2YoIm5vZGU6aHR0cHM6IikpKX1jcmVhdGVTb2NrZXQodCxuLGUpe2NvbnN0IHI9ey4uLm4sc2VjdXJlRW5kcG9pbnQ6dGhpcy5pc1NlY3VyZUVuZHBvaW50KG4pfTtQcm9taXNlLnJlc29sdmUoKS50aGVuKCgoKT0+dGhpcy5jb25uZWN0KHQscikpKS50aGVuKChvPT57aWYobyBpbnN0YW5jZW9mIHMuQWdlbnQpcmV0dXJuIG8uYWRkUmVxdWVzdCh0LHIpO3RoaXNbb25dLmN1cnJlbnRTb2NrZXQ9byxzdXBlci5jcmVhdGVTb2NrZXQodCxuLGUpfSksZSl9Y3JlYXRlQ29ubmVjdGlvbigpe2NvbnN0IHQ9dGhpc1tvbl0uY3VycmVudFNvY2tldDtpZih0aGlzW29uXS5jdXJyZW50U29ja2V0PXZvaWQgMCwhdCl0aHJvdyBuZXcgRXJyb3IoIk5vIHNvY2tldCB3YXMgcmV0dXJuZWQgaW4gdGhlIGBjb25uZWN0KClgIGZ1bmN0aW9uIik7cmV0dXJuIHR9Z2V0IGRlZmF1bHRQb3J0KCl7cmV0dXJuIHRoaXNbb25dLmRlZmF1bHRQb3J0Pz8oImh0dHBzOiI9PT10aGlzLnByb3RvY29sPzQ0Mzo4MCl9c2V0IGRlZmF1bHRQb3J0KHQpe3RoaXNbb25dJiYodGhpc1tvbl0uZGVmYXVsdFBvcnQ9dCl9Z2V0IHByb3RvY29sKCl7cmV0dXJuIHRoaXNbb25dLnByb3RvY29sPz8odGhpcy5pc1NlY3VyZUVuZHBvaW50KCk/Imh0dHBzOiI6Imh0dHA6Iil9c2V0IHByb3RvY29sKHQpe3RoaXNbb25dJiYodGhpc1tvbl0ucHJvdG9jb2w9dCl9fWZ1bmN0aW9uIGNuKC4uLnQpe3cubG9nKCJbaHR0cHMtcHJveHktYWdlbnQ6cGFyc2UtcHJveHktcmVzcG9uc2VdIiwuLi50KX1mdW5jdGlvbiB1bih0KXtyZXR1cm4gbmV3IFByb21pc2UoKChuLGUpPT57bGV0IHI9MDtjb25zdCBvPVtdO2Z1bmN0aW9uIHMoKXtjb25zdCBjPXQucmVhZCgpO2M/ZnVuY3Rpb24oYyl7by5wdXNoKGMpLHIrPWMubGVuZ3RoO2NvbnN0IHU9QnVmZmVyLmNvbmNhdChvLHIpLGE9dS5pbmRleE9mKCJcclxuXHJcbiIpO2lmKC0xPT09YSlyZXR1cm4gY24oImhhdmUgbm90IHJlY2VpdmVkIGVuZCBvZiBIVFRQIGhlYWRlcnMgeWV0Li4uIiksdm9pZCBzKCk7Y29uc3QgZj11LnN1YmFycmF5KDAsYSkudG9TdHJpbmcoImFzY2lpIikuc3BsaXQoIlxyXG4iKSxoPWYuc2hpZnQoKTtpZighaClyZXR1cm4gdC5kZXN0cm95KCksZShuZXcgRXJyb3IoIk5vIGhlYWRlciByZWNlaXZlZCBmcm9tIHByb3h5IENPTk5FQ1QgcmVzcG9uc2UiKSk7Y29uc3QgcD1oLnNwbGl0KCIgIiksbD0rKHBbMV18fDApLGQ9cC5zbGljZSgyKS5qb2luKCIgIiksbT17fTtmb3IoY29uc3QgbiBvZiBmKXtpZighbiljb250aW51ZTtjb25zdCByPW4uaW5kZXhPZigiOiIpO2lmKC0xPT09cilyZXR1cm4gdC5kZXN0cm95KCksZShuZXcgRXJyb3IoYEludmFsaWQgaGVhZGVyIGZyb20gcHJveHkgQ09OTkVDVCByZXNwb25zZTogIiR7bn0iYCkpO2NvbnN0IG89bi5zbGljZSgwLHIpLnRvTG93ZXJDYXNlKCkscz1uLnNsaWNlKHIrMSkudHJpbVN0YXJ0KCksaT1tW29dOyJzdHJpbmciPT10eXBlb2YgaT9tW29dPVtpLHNdOkFycmF5LmlzQXJyYXkoaSk/aS5wdXNoKHMpOm1bb109c31jbigiZ290IHByb3h5IHNlcnZlciByZXNwb25zZTogJW8gJW8iLGgsbSksaSgpLG4oe2Nvbm5lY3Q6e3N0YXR1c0NvZGU6bCxzdGF0dXNUZXh0OmQsaGVhZGVyczptfSxidWZmZXJlZDp1fSl9KGMpOnQub25jZSgicmVhZGFibGUiLHMpfWZ1bmN0aW9uIGkoKXt0LnJlbW92ZUxpc3RlbmVyKCJlbmQiLGMpLHQucmVtb3ZlTGlzdGVuZXIoImVycm9yIix1KSx0LnJlbW92ZUxpc3RlbmVyKCJyZWFkYWJsZSIscyl9ZnVuY3Rpb24gYygpe2koKSxjbigib25lbmQiKSxlKG5ldyBFcnJvcigiUHJveHkgY29ubmVjdGlvbiBlbmRlZCBiZWZvcmUgcmVjZWl2aW5nIENPTk5FQ1QgcmVzcG9uc2UiKSl9ZnVuY3Rpb24gdSh0KXtpKCksY24oIm9uZXJyb3IgJW8iLHQpLGUodCl9dC5vbigiZXJyb3IiLHUpLHQub24oImVuZCIsYykscygpfSkpfWZ1bmN0aW9uIGFuKC4uLnQpe3cubG9nKCJbaHR0cHMtcHJveHktYWdlbnRdIiwuLi50KX1jbGFzcyBmbiBleHRlbmRzIHNue3N0YXRpYyBfX2luaXRTdGF0aWMoKXt0aGlzLnByb3RvY29scz1bImh0dHAiLCJodHRwcyJdfWNvbnN0cnVjdG9yKHQsbil7c3VwZXIobiksdGhpcy5vcHRpb25zPXt9LHRoaXMucHJveHk9InN0cmluZyI9PXR5cGVvZiB0P25ldyBVUkwodCk6dCx0aGlzLnByb3h5SGVhZGVycz1uPy5oZWFkZXJzPz97fSxhbigiQ3JlYXRpbmcgbmV3IEh0dHBzUHJveHlBZ2VudCBpbnN0YW5jZTogJW8iLHRoaXMucHJveHkuaHJlZik7Y29uc3QgZT0odGhpcy5wcm94eS5ob3N0bmFtZXx8dGhpcy5wcm94eS5ob3N0KS5yZXBsYWNlKC9eXFt8XF0kL2csIiIpLHI9dGhpcy5wcm94eS5wb3J0P3BhcnNlSW50KHRoaXMucHJveHkucG9ydCwxMCk6Imh0dHBzOiI9PT10aGlzLnByb3h5LnByb3RvY29sPzQ0Mzo4MDt0aGlzLmNvbm5lY3RPcHRzPXtBTFBOUHJvdG9jb2xzOlsiaHR0cC8xLjEiXSwuLi5uP3BuKG4sImhlYWRlcnMiKTpudWxsLGhvc3Q6ZSxwb3J0OnJ9fWFzeW5jIGNvbm5lY3QodCxuKXtjb25zdHtwcm94eTplfT10aGlzO2lmKCFuLmhvc3QpdGhyb3cgbmV3IFR5cGVFcnJvcignTm8gImhvc3QiIHByb3ZpZGVkJyk7bGV0IHI7aWYoImh0dHBzOiI9PT1lLnByb3RvY29sKXthbigiQ3JlYXRpbmcgYHRscy5Tb2NrZXRgOiAlbyIsdGhpcy5jb25uZWN0T3B0cyk7Y29uc3QgdD10aGlzLmNvbm5lY3RPcHRzLnNlcnZlcm5hbWV8fHRoaXMuY29ubmVjdE9wdHMuaG9zdDtyPWYuY29ubmVjdCh7Li4udGhpcy5jb25uZWN0T3B0cyxzZXJ2ZXJuYW1lOnQmJmEuaXNJUCh0KT92b2lkIDA6dH0pfWVsc2UgYW4oIkNyZWF0aW5nIGBuZXQuU29ja2V0YDogJW8iLHRoaXMuY29ubmVjdE9wdHMpLHI9YS5jb25uZWN0KHRoaXMuY29ubmVjdE9wdHMpO2NvbnN0IG89ImZ1bmN0aW9uIj09dHlwZW9mIHRoaXMucHJveHlIZWFkZXJzP3RoaXMucHJveHlIZWFkZXJzKCk6ey4uLnRoaXMucHJveHlIZWFkZXJzfSxzPWEuaXNJUHY2KG4uaG9zdCk/YFske24uaG9zdH1dYDpuLmhvc3Q7bGV0IGk9YENPTk5FQ1QgJHtzfToke24ucG9ydH0gSFRUUC8xLjFcclxuYDtpZihlLnVzZXJuYW1lfHxlLnBhc3N3b3JkKXtjb25zdCB0PWAke2RlY29kZVVSSUNvbXBvbmVudChlLnVzZXJuYW1lKX06JHtkZWNvZGVVUklDb21wb25lbnQoZS5wYXNzd29yZCl9YDtvWyJQcm94eS1BdXRob3JpemF0aW9uIl09YEJhc2ljICR7QnVmZmVyLmZyb20odCkudG9TdHJpbmcoImJhc2U2NCIpfWB9by5Ib3N0PWAke3N9OiR7bi5wb3J0fWAsb1siUHJveHktQ29ubmVjdGlvbiJdfHwob1siUHJveHktQ29ubmVjdGlvbiJdPXRoaXMua2VlcEFsaXZlPyJLZWVwLUFsaXZlIjoiY2xvc2UiKTtmb3IoY29uc3QgdCBvZiBPYmplY3Qua2V5cyhvKSlpKz1gJHt0fTogJHtvW3RdfVxyXG5gO2NvbnN0IGM9dW4ocik7ci53cml0ZShgJHtpfVxyXG5gKTtjb25zdHtjb25uZWN0OnUsYnVmZmVyZWQ6aH09YXdhaXQgYztpZih0LmVtaXQoInByb3h5Q29ubmVjdCIsdSksdGhpcy5lbWl0KCJwcm94eUNvbm5lY3QiLHUsdCksMjAwPT09dS5zdGF0dXNDb2RlKXtpZih0Lm9uY2UoInNvY2tldCIsaG4pLG4uc2VjdXJlRW5kcG9pbnQpe2FuKCJVcGdyYWRpbmcgc29ja2V0IGNvbm5lY3Rpb24gdG8gVExTIik7Y29uc3QgdD1uLnNlcnZlcm5hbWV8fG4uaG9zdDtyZXR1cm4gZi5jb25uZWN0KHsuLi5wbihuLCJob3N0IiwicGF0aCIsInBvcnQiKSxzb2NrZXQ6cixzZXJ2ZXJuYW1lOmEuaXNJUCh0KT92b2lkIDA6dH0pfXJldHVybiByfXIuZGVzdHJveSgpO2NvbnN0IHA9bmV3IGEuU29ja2V0KHt3cml0YWJsZTohMX0pO3JldHVybiBwLnJlYWRhYmxlPSEwLHQub25jZSgic29ja2V0IiwodD0+e2FuKCJSZXBsYXlpbmcgcHJveHkgYnVmZmVyIGZvciBmYWlsZWQgcmVxdWVzdCIpLHQucHVzaChoKSx0LnB1c2gobnVsbCl9KSkscH19ZnVuY3Rpb24gaG4odCl7dC5yZXN1bWUoKX1mdW5jdGlvbiBwbih0LC4uLm4pe2NvbnN0IGU9e307bGV0IHI7Zm9yKHIgaW4gdCluLmluY2x1ZGVzKHIpfHwoZVtyXT10W3JdKTtyZXR1cm4gZX1mbi5fX2luaXRTdGF0aWMoKTtjb25zdCBsbj0zMjc2ODtmdW5jdGlvbiBkbih0KXtyZXR1cm4gdC5yZXBsYWNlKC9eW0EtWl06LywiIikucmVwbGFjZSgvXFwvZywiLyIpfWNvbnN0IG1uPW47bGV0IGduLHluPTAsYm49e307ZnVuY3Rpb24gX24odCl7bW4uZGVidWcmJmNvbnNvbGUubG9nKGBbQU5SIFdvcmtlcl0gJHt0fWApfXZhciB2bix3bixTbjtjb25zdCAkbj1mdW5jdGlvbih0KXtsZXQgbjt0cnl7bj1uZXcgVVJMKHQudXJsKX1jYXRjaChuKXtyZXR1cm4gdigoKCk9Pntjb25zb2xlLndhcm4oIltAc2VudHJ5L25vZGVdOiBJbnZhbGlkIGRzbiBvciB0dW5uZWwgb3B0aW9uLCB3aWxsIG5vdCBzZW5kIGFueSBldmVudHMuIFRoZSB0dW5uZWwgb3B0aW9uIG11c3QgYmUgYSBmdWxsIFVSTCB3aGVuIHVzZWQuIil9KSksdG4odCwoKCk9PlByb21pc2UucmVzb2x2ZSh7fSkpKX1jb25zdCBlPSJodHRwczoiPT09bi5wcm90b2NvbCxyPWZ1bmN0aW9uKHQsbil7Y29uc3R7bm9fcHJveHk6ZX09cHJvY2Vzcy5lbnYscj1lPy5zcGxpdCgiLCIpLnNvbWUoKG49PnQuaG9zdC5lbmRzV2l0aChuKXx8dC5ob3N0bmFtZS5lbmRzV2l0aChuKSkpO3JldHVybiByP3ZvaWQgMDpufShuLHQucHJveHl8fChlP3Byb2Nlc3MuZW52Lmh0dHBzX3Byb3h5OnZvaWQgMCl8fHByb2Nlc3MuZW52Lmh0dHBfcHJveHkpLG89ZT9pOnMsYT12b2lkIDAhPT10LmtlZXBBbGl2ZSYmdC5rZWVwQWxpdmUsZj1yP25ldyBmbihyKTpuZXcgby5BZ2VudCh7a2VlcEFsaXZlOmEsbWF4U29ja2V0czozMCx0aW1lb3V0OjJlM30pLGg9ZnVuY3Rpb24odCxuLGUpe2NvbnN0e2hvc3RuYW1lOnIscGF0aG5hbWU6byxwb3J0OnMscHJvdG9jb2w6aSxzZWFyY2g6YX09bmV3IFVSTCh0LnVybCk7cmV0dXJuIGZ1bmN0aW9uKGYpe3JldHVybiBuZXcgUHJvbWlzZSgoKGgscCk9PntGdCgoKCk9PntsZXQgbD1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGMoe3JlYWQoKXt0aGlzLnB1c2godCksdGhpcy5wdXNoKG51bGwpfX0pfShmLmJvZHkpO2NvbnN0IGQ9ey4uLnQuaGVhZGVyc307Zi5ib2R5Lmxlbmd0aD5sbiYmKGRbImNvbnRlbnQtZW5jb2RpbmciXT0iZ3ppcCIsbD1sLnBpcGUodSgpKSk7Y29uc3QgbT1uLnJlcXVlc3Qoe21ldGhvZDoiUE9TVCIsYWdlbnQ6ZSxoZWFkZXJzOmQsaG9zdG5hbWU6cixwYXRoOmAke299JHthfWAscG9ydDpzLHByb3RvY29sOmksY2E6dC5jYUNlcnRzfSwodD0+e3Qub24oImRhdGEiLCgoKT0+e30pKSx0Lm9uKCJlbmQiLCgoKT0+e30pKSx0LnNldEVuY29kaW5nKCJ1dGY4Iik7Y29uc3Qgbj10LmhlYWRlcnNbInJldHJ5LWFmdGVyIl0/P251bGwsZT10LmhlYWRlcnNbIngtc2VudHJ5LXJhdGUtbGltaXRzIl0/P251bGw7aCh7c3RhdHVzQ29kZTp0LnN0YXR1c0NvZGUsaGVhZGVyczp7InJldHJ5LWFmdGVyIjpuLCJ4LXNlbnRyeS1yYXRlLWxpbWl0cyI6QXJyYXkuaXNBcnJheShlKT9lWzBdfHxudWxsOmV9fSl9KSk7bS5vbigiZXJyb3IiLHApLGwucGlwZShtKX0pKX0pKX19KHQsdC5odHRwTW9kdWxlPz9vLGYpO3JldHVybiB0bih0LGgpfSh7dXJsOih2bj1tbi5kc24sd249bW4udHVubmVsLFNuPW1uLnNka01ldGFkYXRhLnNkayx3bnx8YCR7ZnVuY3Rpb24odCl7cmV0dXJuYCR7ZnVuY3Rpb24odCl7Y29uc3Qgbj10LnByb3RvY29sP2Ake3QucHJvdG9jb2x9OmA6IiIsZT10LnBvcnQ/YDoke3QucG9ydH1gOiIiO3JldHVybmAke259Ly8ke3QuaG9zdH0ke2V9JHt0LnBhdGg/YC8ke3QucGF0aH1gOiIifS9hcGkvYH0odCl9JHt0LnByb2plY3RJZH0vZW52ZWxvcGUvYH0odm4pfT8ke2Z1bmN0aW9uKHQsbil7Y29uc3QgZT17c2VudHJ5X3ZlcnNpb246S3R9O3JldHVybiB0LnB1YmxpY0tleSYmKGUuc2VudHJ5X2tleT10LnB1YmxpY0tleSksbiYmKGUuc2VudHJ5X2NsaWVudD1gJHtuLm5hbWV9LyR7bi52ZXJzaW9ufWApLG5ldyBVUkxTZWFyY2hQYXJhbXMoZSkudG9TdHJpbmcoKX0odm4sU24pfWApfSk7YXN5bmMgZnVuY3Rpb24gRW4oKXtpZihnbil7X24oIlNlbmRpbmcgYWJub3JtYWwgc2Vzc2lvbiIpLEsoZ24se3N0YXR1czoiYWJub3JtYWwiLGFibm9ybWFsX21lY2hhbmlzbToiYW5yX2ZvcmVncm91bmQiLHJlbGVhc2U6bW4ucmVsZWFzZSxlbnZpcm9ubWVudDptbi5lbnZpcm9ubWVudH0pO2NvbnN0IHQ9ZnVuY3Rpb24odCxuLGUscil7Y29uc3Qgbz1ZdChlKTtyZXR1cm4gTXQoe3NlbnRfYXQ6KG5ldyBEYXRlKS50b0lTT1N0cmluZygpLC4uLm8mJntzZGs6b30sLi4uISFyJiZuJiZ7ZHNuOk90KG4pfX0sWyJhZ2dyZWdhdGVzImluIHQ/W3t0eXBlOiJzZXNzaW9ucyJ9LHRdOlt7dHlwZToic2Vzc2lvbiJ9LHQudG9KU09OKCldXSl9KGduLG1uLmRzbixtbi5zZGtNZXRhZGF0YSxtbi50dW5uZWwpO19uKEpTT04uc3RyaW5naWZ5KHQpKSxhd2FpdCAkbi5zZW5kKHQpO3RyeXtlPy5wb3N0TWVzc2FnZSgic2Vzc2lvbi1lbmRlZCIpfWNhdGNoKHQpe319fWZ1bmN0aW9uIHhuKHQpe2lmKCF0KXJldHVybjtjb25zdCBuPWZ1bmN0aW9uKHQpe2lmKCF0Lmxlbmd0aClyZXR1cm5bXTtjb25zdCBuPUFycmF5LmZyb20odCk7cmV0dXJuL3NlbnRyeVdyYXBwZWQvLnRlc3QoeChuKS5mdW5jdGlvbnx8IiIpJiZuLnBvcCgpLG4ucmV2ZXJzZSgpLEUudGVzdCh4KG4pLmZ1bmN0aW9ufHwiIikmJihuLnBvcCgpLEUudGVzdCh4KG4pLmZ1bmN0aW9ufHwiIikmJm4ucG9wKCkpLG4uc2xpY2UoMCxTKS5tYXAoKHQ9Pih7Li4udCxmaWxlbmFtZTp0LmZpbGVuYW1lfHx4KG4pLmZpbGVuYW1lLGZ1bmN0aW9uOnQuZnVuY3Rpb258fCR9KSkpfSh0KTtpZihtbi5hcHBSb290UGF0aClmb3IoY29uc3QgdCBvZiBuKXQuZmlsZW5hbWUmJih0LmZpbGVuYW1lPVV0KHQuZmlsZW5hbWUsbW4uYXBwUm9vdFBhdGgpKTtyZXR1cm4gbn1hc3luYyBmdW5jdGlvbiBObih0LG4pe2lmKHluPj1tbi5tYXhBbnJFdmVudHMpcmV0dXJuO3luKz0xLGF3YWl0IEVuKCksX24oIlNlbmRpbmcgZXZlbnQiKTtjb25zdCBlPXtldmVudF9pZDpZKCksY29udGV4dHM6bW4uY29udGV4dHMscmVsZWFzZTptbi5yZWxlYXNlLGVudmlyb25tZW50Om1uLmVudmlyb25tZW50LGRpc3Q6bW4uZGlzdCxwbGF0Zm9ybToibm9kZSIsbGV2ZWw6ImVycm9yIixleGNlcHRpb246e3ZhbHVlczpbe3R5cGU6IkFwcGxpY2F0aW9uTm90UmVzcG9uZGluZyIsdmFsdWU6YEFwcGxpY2F0aW9uIE5vdCBSZXNwb25kaW5nIGZvciBhdCBsZWFzdCAke21uLmFuclRocmVzaG9sZH0gbXNgLHN0YWNrdHJhY2U6e2ZyYW1lczp4bih0KX0sbWVjaGFuaXNtOnt0eXBlOiJBTlIifX1dfSx0YWdzOm1uLnN0YXRpY1RhZ3N9O24mJmZ1bmN0aW9uKHQsbil7aWYoV3QodCxuKSwhdC5jb250ZXh0cz8udHJhY2Upe2NvbnN0e3RyYWNlSWQ6ZSxwYXJlbnRTcGFuSWQ6cixwcm9wYWdhdGlvblNwYW5JZDpvfT1uLnByb3BhZ2F0aW9uQ29udGV4dDt0LmNvbnRleHRzPXt0cmFjZTp7dHJhY2VfaWQ6ZSxzcGFuX2lkOm98fFooKSxwYXJlbnRfc3Bhbl9pZDpyfSwuLi50LmNvbnRleHRzfX19KGUsbiksZnVuY3Rpb24odCl7aWYoMD09PU9iamVjdC5rZXlzKGJuKS5sZW5ndGgpcmV0dXJuO2NvbnN0IG49bW4uYXBwUm9vdFBhdGg/e306Ym47aWYobW4uYXBwUm9vdFBhdGgpZm9yKGNvbnN0W3QsZV1vZiBPYmplY3QuZW50cmllcyhibikpbltVdCh0LG1uLmFwcFJvb3RQYXRoKV09ZTtjb25zdCBlPW5ldyBNYXA7Zm9yKGNvbnN0IHIgb2YgdC5leGNlcHRpb24/LnZhbHVlc3x8W10pZm9yKGNvbnN0IHQgb2Ygci5zdGFja3RyYWNlPy5mcmFtZXN8fFtdKXtjb25zdCByPXQuYWJzX3BhdGh8fHQuZmlsZW5hbWU7ciYmbltyXSYmZS5zZXQocixuW3JdKX1pZihlLnNpemU+MCl7Y29uc3Qgbj1bXTtmb3IoY29uc3RbdCxyXW9mIGUuZW50cmllcygpKW4ucHVzaCh7dHlwZToic291cmNlbWFwIixjb2RlX2ZpbGU6dCxkZWJ1Z19pZDpyfSk7dC5kZWJ1Z19tZXRhPXtpbWFnZXM6bn19fShlKTtjb25zdCByPXp0KGUsbW4uZHNuLG1uLnNka01ldGFkYXRhLG1uLnR1bm5lbCk7X24oSlNPTi5zdHJpbmdpZnkocikpLGF3YWl0ICRuLnNlbmQociksYXdhaXQgJG4uZmx1c2goMmUzKSx5bj49bW4ubWF4QW5yRXZlbnRzJiZzZXRUaW1lb3V0KCgoKT0+e3Byb2Nlc3MuZXhpdCgwKX0pLDVlMyl9bGV0IFRuO2lmKF9uKCJTdGFydGVkIiksbW4uY2FwdHVyZVN0YWNrVHJhY2Upe19uKCJDb25uZWN0aW5nIHRvIGRlYnVnZ2VyIik7Y29uc3Qgbj1uZXcgdDtuLmNvbm5lY3RUb01haW5UaHJlYWQoKSxfbigiQ29ubmVjdGVkIHRvIGRlYnVnZ2VyIik7Y29uc3QgZT1uZXcgTWFwO24ub24oIkRlYnVnZ2VyLnNjcmlwdFBhcnNlZCIsKHQ9PntlLnNldCh0LnBhcmFtcy5zY3JpcHRJZCx0LnBhcmFtcy51cmwpfSkpLG4ub24oIkRlYnVnZ2VyLnBhdXNlZCIsKHQ9PntpZigib3RoZXIiPT09dC5wYXJhbXMucmVhc29uKXRyeXtfbigiRGVidWdnZXIgcGF1c2VkIik7Y29uc3Qgcz1bLi4udC5wYXJhbXMuY2FsbEZyYW1lc10saT1tbi5hcHBSb290UGF0aD9mdW5jdGlvbih0PShwcm9jZXNzLmFyZ3ZbMV0/ZW4ocHJvY2Vzcy5hcmd2WzFdKTpwcm9jZXNzLmN3ZCgpKSxuPSJcXCI9PT1vKXtjb25zdCBlPW4/ZG4odCk6dDtyZXR1cm4gdD0+e2lmKCF0KXJldHVybjtjb25zdCBvPW4/ZG4odCk6dDtsZXR7ZGlyOnMsYmFzZTppLGV4dDpjfT1yLnBhcnNlKG8pOyIuanMiIT09YyYmIi5tanMiIT09YyYmIi5janMiIT09Y3x8KGk9aS5zbGljZSgwLC0xKmMubGVuZ3RoKSk7Y29uc3QgdT1kZWNvZGVVUklDb21wb25lbnQoaSk7c3x8KHM9Ii4iKTtjb25zdCBhPXMubGFzdEluZGV4T2YoIi9ub2RlX21vZHVsZXMiKTtpZihhPi0xKXJldHVybmAke3Muc2xpY2UoYSsxNCkucmVwbGFjZSgvXC8vZywiLiIpfToke3V9YDtpZihzLnN0YXJ0c1dpdGgoZSkpe2NvbnN0IHQ9cy5zbGljZShlLmxlbmd0aCsxKS5yZXBsYWNlKC9cLy9nLCIuIik7cmV0dXJuIHQ/YCR7dH06JHt1fWA6dX1yZXR1cm4gdX19KG1uLmFwcFJvb3RQYXRoKTooKT0+e30sYz1zLm1hcCgodD0+ZnVuY3Rpb24odCxuLGUpe2NvbnN0IHI9bj9uLnJlcGxhY2UoL15maWxlOlwvXC8vLCIiKTp2b2lkIDAsbz10LmxvY2F0aW9uLmNvbHVtbk51bWJlcj90LmxvY2F0aW9uLmNvbHVtbk51bWJlcisxOnZvaWQgMCxzPXQubG9jYXRpb24ubGluZU51bWJlcj90LmxvY2F0aW9uLmxpbmVOdW1iZXIrMTp2b2lkIDA7cmV0dXJue2ZpbGVuYW1lOnIsbW9kdWxlOmUociksZnVuY3Rpb246dC5mdW5jdGlvbk5hbWV8fCQsY29sbm86byxsaW5lbm86cyxpbl9hcHA6cj9ybihyKTp2b2lkIDB9fSh0LGUuZ2V0KHQubG9jYXRpb24uc2NyaXB0SWQpLGkpKSksdT1zZXRUaW1lb3V0KCgoKT0+e05uKGMpLnRoZW4obnVsbCwoKCk9PntfbigiU2VuZGluZyBBTlIgZXZlbnQgZmFpbGVkLiIpfSkpfSksNWUzKTtuLnBvc3QoIlJ1bnRpbWUuZXZhbHVhdGUiLHtleHByZXNzaW9uOiJnbG9iYWwuX19TRU5UUllfR0VUX1NDT1BFU19fKCk7IixzaWxlbnQ6ITAscmV0dXJuQnlWYWx1ZTohMH0sKCh0LGUpPT57dCYmX24oYEVycm9yIGV4ZWN1dGluZyBzY3JpcHQ6ICcke3QubWVzc2FnZX0nYCksY2xlYXJUaW1lb3V0KHUpO2NvbnN0IHI9ZT8ucmVzdWx0P2UucmVzdWx0LnZhbHVlOnZvaWQgMDtuLnBvc3QoIkRlYnVnZ2VyLnJlc3VtZSIpLG4ucG9zdCgiRGVidWdnZXIuZGlzYWJsZSIpLE5uKGMscikudGhlbihudWxsLCgoKT0+e19uKCJTZW5kaW5nIEFOUiBldmVudCBmYWlsZWQuIil9KSl9KSl9Y2F0Y2godCl7dGhyb3cgbi5wb3N0KCJEZWJ1Z2dlci5yZXN1bWUiKSxuLnBvc3QoIkRlYnVnZ2VyLmRpc2FibGUiKSx0fX0pKSxUbj0oKT0+e3RyeXtuLnBvc3QoIkRlYnVnZ2VyLmVuYWJsZSIsKCgpPT57bi5wb3N0KCJEZWJ1Z2dlci5wYXVzZSIpfSkpfWNhdGNoKHQpe319fWNvbnN0e3BvbGw6Q259PWZ1bmN0aW9uKHQsbixlLHIpe2NvbnN0IG89dCgpO2xldCBzPSExLGk9ITA7cmV0dXJuIHNldEludGVydmFsKCgoKT0+e2NvbnN0IHQ9by5nZXRUaW1lTXMoKTshMT09PXMmJnQ+bitlJiYocz0hMCxpJiZyKCkpLHQ8bitlJiYocz0hMSl9KSwyMCkse3BvbGw6KCk9PntvLnJlc2V0KCl9LGVuYWJsZWQ6dD0+e2k9dH19fSgoZnVuY3Rpb24oKXtsZXQgdD1wcm9jZXNzLmhydGltZSgpO3JldHVybntnZXRUaW1lTXM6KCk9Pntjb25zdFtuLGVdPXByb2Nlc3MuaHJ0aW1lKHQpO3JldHVybiBNYXRoLmZsb29yKDFlMypuK2UvMWU2KX0scmVzZXQ6KCk9Pnt0PXByb2Nlc3MuaHJ0aW1lKCl9fX0pLG1uLnBvbGxJbnRlcnZhbCxtbi5hbnJUaHJlc2hvbGQsKGZ1bmN0aW9uKCl7X24oIldhdGNoZG9nIHRpbWVvdXQiKSxUbj8oX24oIlBhdXNpbmcgZGVidWdnZXIgdG8gY2FwdHVyZSBzdGFjayB0cmFjZSIpLFRuKCkpOihfbigiQ2FwdHVyaW5nIGV2ZW50IHdpdGhvdXQgYSBzdGFjayB0cmFjZSIpLE5uKCkudGhlbihudWxsLCgoKT0+e19uKCJTZW5kaW5nIEFOUiBldmVudCBmYWlsZWQgb24gd2F0Y2hkb2cgdGltZW91dC4iKX0pKSl9KSk7ZT8ub24oIm1lc3NhZ2UiLCh0PT57dC5zZXNzaW9uJiYoZ249Vyh0LnNlc3Npb24pKSx0LmRlYnVnSW1hZ2VzJiYoYm49dC5kZWJ1Z0ltYWdlcyksQ24oKX0pKTs=';
 
 const DEFAULT_INTERVAL = 50;
 const DEFAULT_HANG_THRESHOLD = 5000;
diff --git a/build/cjs/integrations/http/SentryHttpInstrumentation.js b/build/cjs/integrations/http/SentryHttpInstrumentation.js
index 09bcf651ba8b71406c25c4a640f5c2d6e31a4a44..148aa096d6bf7415c8116fbee38fa12fde3a8357 100644
--- a/build/cjs/integrations/http/SentryHttpInstrumentation.js
+++ b/build/cjs/integrations/http/SentryHttpInstrumentation.js
@@ -1,9 +1,8 @@
 Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
 
 const api = require('@opentelemetry/api');
-const core = require('@opentelemetry/core');
 const instrumentation = require('@opentelemetry/instrumentation');
-const core$1 = require('@sentry/core');
+const core = require('@sentry/core');
 const debugBuild = require('../../debug-build.js');
 const getRequestUrl = require('../../utils/getRequestUrl.js');
 const utils = require('./utils.js');
@@ -29,7 +28,7 @@ const MAX_BODY_BYTE_LENGTH = 1024 * 1024;
  */
 class SentryHttpInstrumentation extends instrumentation.InstrumentationBase {
    constructor(config = {}) {
-    super('@sentry/instrumentation-http', core.VERSION, config);
+    super('@sentry/instrumentation-http', '2.0.0', config);
   }
 
   /** @inheritdoc */
@@ -100,11 +99,11 @@ class SentryHttpInstrumentation extends instrumentation.InstrumentationBase {
 
         instrumentation._diag.debug('http instrumentation for incoming request');
 
-        const isolationScope = core$1.getIsolationScope().clone();
+        const isolationScope = core.getIsolationScope().clone();
         const request = args[1] ;
         const response = args[2] ;
 
-        const normalizedRequest = core$1.httpRequestToRequestData(request);
+        const normalizedRequest = core.httpRequestToRequestData(request);
 
         // request.ip is non-standard but some frameworks set this
         const ipAddress = (request ).ip || request.socket?.remoteAddress;
@@ -121,7 +120,7 @@ class SentryHttpInstrumentation extends instrumentation.InstrumentationBase {
         // Ideally, framework instrumentations coming after the HttpInstrumentation
         // update the transactionName once we get a parameterized route.
         const httpMethod = (request.method || 'GET').toUpperCase();
-        const httpTarget = core$1.stripUrlQueryAndFragment(url);
+        const httpTarget = core.stripUrlQueryAndFragment(url);
 
         const bestEffortTransactionName = `${httpMethod} ${httpTarget}`;
 
@@ -135,11 +134,11 @@ class SentryHttpInstrumentation extends instrumentation.InstrumentationBase {
           });
         }
 
-        return core$1.withIsolationScope(isolationScope, () => {
+        return core.withIsolationScope(isolationScope, () => {
           // Set a new propagationSpanId for this request
           // We rely on the fact that `withIsolationScope()` will implicitly also fork the current scope
           // This way we can save an "unnecessary" `withScope()` invocation
-          core$1.getCurrentScope().getPropagationContext().propagationSpanId = core$1.generateSpanId();
+          core.getCurrentScope().getPropagationContext().propagationSpanId = core.generateSpanId();
 
           // If we don't want to extract the trace from the header, we can skip this
           if (!instrumentation.getConfig().extractIncomingTraceFromHeader) {
@@ -233,9 +232,9 @@ function addRequestBreadcrumb(request, response) {
   const data = getBreadcrumbData(request);
 
   const statusCode = response.statusCode;
-  const level = core$1.getBreadcrumbLogLevelFromHttpStatusCode(statusCode);
+  const level = core.getBreadcrumbLogLevelFromHttpStatusCode(statusCode);
 
-  core$1.addBreadcrumb(
+  core.addBreadcrumb(
     {
       category: 'http',
       data: {
@@ -258,10 +257,10 @@ function getBreadcrumbData(request) {
     // `request.host` does not contain the port, but the host header does
     const host = request.getHeader('host') || request.host;
     const url = new URL(request.path, `${request.protocol}//${host}`);
-    const parsedUrl = core$1.parseUrl(url.toString());
+    const parsedUrl = core.parseUrl(url.toString());
 
     const data = {
-      url: core$1.getSanitizedUrlString(parsedUrl),
+      url: core.getSanitizedUrlString(parsedUrl),
       'http.method': request.method || 'GET',
     };
 
@@ -313,7 +312,7 @@ function patchRequestToCaptureBody(req, isolationScope) {
                 const chunk = args[0] ;
                 chunks.push(chunk);
               } else if (debugBuild.DEBUG_BUILD) {
-                core$1.logger.log(
+                core.logger.log(
                   `Dropping request body chunk because it maximum body length of ${MAX_BODY_BYTE_LENGTH}b is exceeded.`,
                 );
               }
@@ -399,11 +398,11 @@ function recordRequestSession({
   });
   response.once('close', () => {
     // We need to grab the client off the current scope instead of the isolation scope because the isolation scope doesn't hold any client out of the box.
-    const client = core$1.getClient();
+    const client = core.getClient();
     const requestSession = requestIsolationScope.getScopeData().sdkProcessingMetadata.requestSession;
 
     if (client && requestSession) {
-      debugBuild.DEBUG_BUILD && core$1.logger.debug(`Recorded request session with status: ${requestSession.status}`);
+      debugBuild.DEBUG_BUILD && core.logger.debug(`Recorded request session with status: ${requestSession.status}`);
 
       const roundedDate = new Date();
       roundedDate.setSeconds(0, 0);
@@ -416,7 +415,7 @@ function recordRequestSession({
       if (existingClientAggregate) {
         existingClientAggregate[dateBucketKey] = bucket;
       } else {
-        debugBuild.DEBUG_BUILD && core$1.logger.debug('Opened new request session aggregate.');
+        debugBuild.DEBUG_BUILD && core.logger.debug('Opened new request session aggregate.');
         const newClientAggregate = { [dateBucketKey]: bucket };
         clientToRequestSessionAggregatesMap.set(client, newClientAggregate);
 
@@ -437,11 +436,11 @@ function recordRequestSession({
         };
 
         const unregisterClientFlushHook = client.on('flush', () => {
-          debugBuild.DEBUG_BUILD && core$1.logger.debug('Sending request session aggregate due to client flush');
+          debugBuild.DEBUG_BUILD && core.logger.debug('Sending request session aggregate due to client flush');
           flushPendingClientAggregates();
         });
         const timeout = setTimeout(() => {
-          debugBuild.DEBUG_BUILD && core$1.logger.debug('Sending request session aggregate due to flushing schedule');
+          debugBuild.DEBUG_BUILD && core.logger.debug('Sending request session aggregate due to flushing schedule');
           flushPendingClientAggregates();
         }, sessionFlushingDelayMS).unref();
       }
diff --git a/build/cjs/integrations/http/SentryHttpInstrumentation.js.map b/build/cjs/integrations/http/SentryHttpInstrumentation.js.map
index 92fdc01bc4f8ad6332e05cee168ee4d84ef4ab7f..143dd1b1993fe15d001f1892224d8c70379f61e5 100644
--- a/build/cjs/integrations/http/SentryHttpInstrumentation.js.map
+++ b/build/cjs/integrations/http/SentryHttpInstrumentation.js.map
@@ -1 +1 @@
-{"version":3,"file":"SentryHttpInstrumentation.js","sources":["../../../../src/integrations/http/SentryHttpInstrumentation.ts"],"sourcesContent":["/* eslint-disable max-lines */\nimport { context, propagation } from '@opentelemetry/api';\nimport { VERSION } from '@opentelemetry/core';\nimport type { InstrumentationConfig } from '@opentelemetry/instrumentation';\nimport { InstrumentationBase, InstrumentationNodeModuleDefinition } from '@opentelemetry/instrumentation';\nimport type { AggregationCounts, Client, RequestEventData, SanitizedRequestData, Scope } from '@sentry/core';\nimport {\n  addBreadcrumb,\n  generateSpanId,\n  getBreadcrumbLogLevelFromHttpStatusCode,\n  getClient,\n  getCurrentScope,\n  getIsolationScope,\n  getSanitizedUrlString,\n  httpRequestToRequestData,\n  logger,\n  parseUrl,\n  stripUrlQueryAndFragment,\n  withIsolationScope,\n} from '@sentry/core';\nimport type * as http from 'node:http';\nimport type { IncomingMessage, RequestOptions } from 'node:http';\nimport type * as https from 'node:https';\nimport type { EventEmitter } from 'node:stream';\nimport { DEBUG_BUILD } from '../../debug-build';\nimport { getRequestUrl } from '../../utils/getRequestUrl';\nimport { stealthWrap } from './utils';\nimport { getRequestInfo } from './vendor/getRequestInfo';\n\ntype Http = typeof http;\ntype Https = typeof https;\n\nexport type SentryHttpInstrumentationOptions = InstrumentationConfig & {\n  /**\n   * Whether breadcrumbs should be recorded for requests.\n   *\n   * @default `true`\n   */\n  breadcrumbs?: boolean;\n\n  /**\n   * Whether to extract the trace ID from the `sentry-trace` header for incoming requests.\n   * By default this is done by the HttpInstrumentation, but if that is not added (e.g. because tracing is disabled, ...)\n   * then this instrumentation can take over.\n   *\n   * @default `false`\n   */\n  extractIncomingTraceFromHeader?: boolean;\n\n  /**\n   * Do not capture breadcrumbs for outgoing HTTP requests to URLs where the given callback returns `true`.\n   * For the scope of this instrumentation, this callback only controls breadcrumb creation.\n   * The same option can be passed to the top-level httpIntegration where it controls both, breadcrumb and\n   * span creation.\n   *\n   * @param url Contains the entire URL, including query string (if any), protocol, host, etc. of the outgoing request.\n   * @param request Contains the {@type RequestOptions} object used to make the outgoing request.\n   */\n  ignoreOutgoingRequests?: (url: string, request: RequestOptions) => boolean;\n\n  /**\n   * Do not capture the request body for incoming HTTP requests to URLs where the given callback returns `true`.\n   * This can be useful for long running requests where the body is not needed and we want to avoid capturing it.\n   *\n   * @param url Contains the entire URL, including query string (if any), protocol, host, etc. of the outgoing request.\n   * @param request Contains the {@type RequestOptions} object used to make the outgoing request.\n   */\n  ignoreIncomingRequestBody?: (url: string, request: RequestOptions) => boolean;\n\n  /**\n   * Whether the integration should create [Sessions](https://docs.sentry.io/product/releases/health/#sessions) for incoming requests to track the health and crash-free rate of your releases in Sentry.\n   * Read more about Release Health: https://docs.sentry.io/product/releases/health/\n   *\n   * Defaults to `true`.\n   */\n  trackIncomingRequestsAsSessions?: boolean;\n\n  /**\n   * Number of milliseconds until sessions tracked with `trackIncomingRequestsAsSessions` will be flushed as a session aggregate.\n   *\n   * Defaults to `60000` (60s).\n   */\n  sessionFlushingDelayMS?: number;\n};\n\n// We only want to capture request bodies up to 1mb.\nconst MAX_BODY_BYTE_LENGTH = 1024 * 1024;\n\n/**\n * This custom HTTP instrumentation is used to isolate incoming requests and annotate them with additional information.\n * It does not emit any spans.\n *\n * The reason this is isolated from the OpenTelemetry instrumentation is that users may overwrite this,\n * which would lead to Sentry not working as expected.\n *\n * Important note: Contrary to other OTEL instrumentation, this one cannot be unwrapped.\n * It only does minimal things though and does not emit any spans.\n *\n * This is heavily inspired & adapted from:\n * https://github.com/open-telemetry/opentelemetry-js/blob/f8ab5592ddea5cba0a3b33bf8d74f27872c0367f/experimental/packages/opentelemetry-instrumentation-http/src/http.ts\n */\nexport class SentryHttpInstrumentation extends InstrumentationBase<SentryHttpInstrumentationOptions> {\n  public constructor(config: SentryHttpInstrumentationOptions = {}) {\n    super('@sentry/instrumentation-http', VERSION, config);\n  }\n\n  /** @inheritdoc */\n  public init(): [InstrumentationNodeModuleDefinition, InstrumentationNodeModuleDefinition] {\n    return [this._getHttpsInstrumentation(), this._getHttpInstrumentation()];\n  }\n\n  /** Get the instrumentation for the http module. */\n  private _getHttpInstrumentation(): InstrumentationNodeModuleDefinition {\n    return new InstrumentationNodeModuleDefinition(\n      'http',\n      ['*'],\n      (moduleExports: Http): Http => {\n        // Patch incoming requests for request isolation\n        stealthWrap(moduleExports.Server.prototype, 'emit', this._getPatchIncomingRequestFunction());\n\n        // Patch outgoing requests for breadcrumbs\n        const patchedRequest = stealthWrap(moduleExports, 'request', this._getPatchOutgoingRequestFunction());\n        stealthWrap(moduleExports, 'get', this._getPatchOutgoingGetFunction(patchedRequest));\n\n        return moduleExports;\n      },\n      () => {\n        // no unwrap here\n      },\n    );\n  }\n\n  /** Get the instrumentation for the https module. */\n  private _getHttpsInstrumentation(): InstrumentationNodeModuleDefinition {\n    return new InstrumentationNodeModuleDefinition(\n      'https',\n      ['*'],\n      (moduleExports: Https): Https => {\n        // Patch incoming requests for request isolation\n        stealthWrap(moduleExports.Server.prototype, 'emit', this._getPatchIncomingRequestFunction());\n\n        // Patch outgoing requests for breadcrumbs\n        const patchedRequest = stealthWrap(moduleExports, 'request', this._getPatchOutgoingRequestFunction());\n        stealthWrap(moduleExports, 'get', this._getPatchOutgoingGetFunction(patchedRequest));\n\n        return moduleExports;\n      },\n      () => {\n        // no unwrap here\n      },\n    );\n  }\n\n  /**\n   * Patch the incoming request function for request isolation.\n   */\n  private _getPatchIncomingRequestFunction(): (\n    original: (event: string, ...args: unknown[]) => boolean,\n  ) => (this: unknown, event: string, ...args: unknown[]) => boolean {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const instrumentation = this;\n    const { ignoreIncomingRequestBody } = instrumentation.getConfig();\n\n    return (\n      original: (event: string, ...args: unknown[]) => boolean,\n    ): ((this: unknown, event: string, ...args: unknown[]) => boolean) => {\n      return function incomingRequest(this: unknown, ...args: [event: string, ...args: unknown[]]): boolean {\n        // Only traces request events\n        if (args[0] !== 'request') {\n          return original.apply(this, args);\n        }\n\n        instrumentation._diag.debug('http instrumentation for incoming request');\n\n        const isolationScope = getIsolationScope().clone();\n        const request = args[1] as http.IncomingMessage;\n        const response = args[2] as http.OutgoingMessage;\n\n        const normalizedRequest = httpRequestToRequestData(request);\n\n        // request.ip is non-standard but some frameworks set this\n        const ipAddress = (request as { ip?: string }).ip || request.socket?.remoteAddress;\n\n        const url = request.url || '/';\n        if (!ignoreIncomingRequestBody?.(url, request)) {\n          patchRequestToCaptureBody(request, isolationScope);\n        }\n\n        // Update the isolation scope, isolate this request\n        isolationScope.setSDKProcessingMetadata({ normalizedRequest, ipAddress });\n\n        // attempt to update the scope's `transactionName` based on the request URL\n        // Ideally, framework instrumentations coming after the HttpInstrumentation\n        // update the transactionName once we get a parameterized route.\n        const httpMethod = (request.method || 'GET').toUpperCase();\n        const httpTarget = stripUrlQueryAndFragment(url);\n\n        const bestEffortTransactionName = `${httpMethod} ${httpTarget}`;\n\n        isolationScope.setTransactionName(bestEffortTransactionName);\n\n        if (instrumentation.getConfig().trackIncomingRequestsAsSessions !== false) {\n          recordRequestSession({\n            requestIsolationScope: isolationScope,\n            response,\n            sessionFlushingDelayMS: instrumentation.getConfig().sessionFlushingDelayMS ?? 60_000,\n          });\n        }\n\n        return withIsolationScope(isolationScope, () => {\n          // Set a new propagationSpanId for this request\n          // We rely on the fact that `withIsolationScope()` will implicitly also fork the current scope\n          // This way we can save an \"unnecessary\" `withScope()` invocation\n          getCurrentScope().getPropagationContext().propagationSpanId = generateSpanId();\n\n          // If we don't want to extract the trace from the header, we can skip this\n          if (!instrumentation.getConfig().extractIncomingTraceFromHeader) {\n            return original.apply(this, args);\n          }\n\n          const ctx = propagation.extract(context.active(), normalizedRequest.headers);\n          return context.with(ctx, () => {\n            return original.apply(this, args);\n          });\n        });\n      };\n    };\n  }\n\n  /**\n   * Patch the outgoing request function for breadcrumbs.\n   */\n  private _getPatchOutgoingRequestFunction(): (\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    original: (...args: any[]) => http.ClientRequest,\n  ) => (options: URL | http.RequestOptions | string, ...args: unknown[]) => http.ClientRequest {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const instrumentation = this;\n\n    return (original: (...args: unknown[]) => http.ClientRequest): ((...args: unknown[]) => http.ClientRequest) => {\n      return function outgoingRequest(this: unknown, ...args: unknown[]): http.ClientRequest {\n        instrumentation._diag.debug('http instrumentation for outgoing requests');\n\n        // Making a copy to avoid mutating the original args array\n        // We need to access and reconstruct the request options object passed to `ignoreOutgoingRequests`\n        // so that it matches what Otel instrumentation passes to `ignoreOutgoingRequestHook`.\n        // @see https://github.com/open-telemetry/opentelemetry-js/blob/7293e69c1e55ca62e15d0724d22605e61bd58952/experimental/packages/opentelemetry-instrumentation-http/src/http.ts#L756-L789\n        const argsCopy = [...args];\n\n        const options = argsCopy.shift() as URL | http.RequestOptions | string;\n\n        const extraOptions =\n          typeof argsCopy[0] === 'object' && (typeof options === 'string' || options instanceof URL)\n            ? (argsCopy.shift() as http.RequestOptions)\n            : undefined;\n\n        const { optionsParsed } = getRequestInfo(instrumentation._diag, options, extraOptions);\n\n        const request = original.apply(this, args) as ReturnType<typeof http.request>;\n\n        request.prependListener('response', (response: http.IncomingMessage) => {\n          const _breadcrumbs = instrumentation.getConfig().breadcrumbs;\n          const breadCrumbsEnabled = typeof _breadcrumbs === 'undefined' ? true : _breadcrumbs;\n\n          const _ignoreOutgoingRequests = instrumentation.getConfig().ignoreOutgoingRequests;\n          const shouldCreateBreadcrumb =\n            typeof _ignoreOutgoingRequests === 'function'\n              ? !_ignoreOutgoingRequests(getRequestUrl(request), optionsParsed)\n              : true;\n\n          if (breadCrumbsEnabled && shouldCreateBreadcrumb) {\n            addRequestBreadcrumb(request, response);\n          }\n        });\n\n        return request;\n      };\n    };\n  }\n\n  /** Path the outgoing get function for breadcrumbs. */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private _getPatchOutgoingGetFunction(clientRequest: (...args: any[]) => http.ClientRequest) {\n    return (_original: unknown): ((...args: unknown[]) => http.ClientRequest) => {\n      // Re-implement http.get. This needs to be done (instead of using\n      // getPatchOutgoingRequestFunction to patch it) because we need to\n      // set the trace context header before the returned http.ClientRequest is\n      // ended. The Node.js docs state that the only differences between\n      // request and get are that (1) get defaults to the HTTP GET method and\n      // (2) the returned request object is ended immediately. The former is\n      // already true (at least in supported Node versions up to v10), so we\n      // simply follow the latter. Ref:\n      // https://nodejs.org/dist/latest/docs/api/http.html#http_http_get_options_callback\n      // https://github.com/googleapis/cloud-trace-nodejs/blob/master/src/instrumentations/instrumentation-http.ts#L198\n      return function outgoingGetRequest(...args: unknown[]): http.ClientRequest {\n        const req = clientRequest(...args);\n        req.end();\n        return req;\n      };\n    };\n  }\n}\n\n/** Add a breadcrumb for outgoing requests. */\nfunction addRequestBreadcrumb(request: http.ClientRequest, response: http.IncomingMessage): void {\n  const data = getBreadcrumbData(request);\n\n  const statusCode = response.statusCode;\n  const level = getBreadcrumbLogLevelFromHttpStatusCode(statusCode);\n\n  addBreadcrumb(\n    {\n      category: 'http',\n      data: {\n        status_code: statusCode,\n        ...data,\n      },\n      type: 'http',\n      level,\n    },\n    {\n      event: 'response',\n      request,\n      response,\n    },\n  );\n}\n\nfunction getBreadcrumbData(request: http.ClientRequest): Partial<SanitizedRequestData> {\n  try {\n    // `request.host` does not contain the port, but the host header does\n    const host = request.getHeader('host') || request.host;\n    const url = new URL(request.path, `${request.protocol}//${host}`);\n    const parsedUrl = parseUrl(url.toString());\n\n    const data: Partial<SanitizedRequestData> = {\n      url: getSanitizedUrlString(parsedUrl),\n      'http.method': request.method || 'GET',\n    };\n\n    if (parsedUrl.search) {\n      data['http.query'] = parsedUrl.search;\n    }\n    if (parsedUrl.hash) {\n      data['http.fragment'] = parsedUrl.hash;\n    }\n\n    return data;\n  } catch {\n    return {};\n  }\n}\n\n/**\n * This method patches the request object to capture the body.\n * Instead of actually consuming the streamed body ourselves, which has potential side effects,\n * we monkey patch `req.on('data')` to intercept the body chunks.\n * This way, we only read the body if the user also consumes the body, ensuring we do not change any behavior in unexpected ways.\n */\nfunction patchRequestToCaptureBody(req: IncomingMessage, isolationScope: Scope): void {\n  const chunks: Buffer[] = [];\n\n  function getChunksSize(): number {\n    return chunks.reduce((acc, chunk) => acc + chunk.byteLength, 0);\n  }\n\n  /**\n   * We need to keep track of the original callbacks, in order to be able to remove listeners again.\n   * Since `off` depends on having the exact same function reference passed in, we need to be able to map\n   * original listeners to our wrapped ones.\n   */\n  const callbackMap = new WeakMap();\n\n  try {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    req.on = new Proxy(req.on, {\n      apply: (target, thisArg, args: Parameters<typeof req.on>) => {\n        const [event, listener, ...restArgs] = args;\n\n        if (event === 'data') {\n          const callback = new Proxy(listener, {\n            apply: (target, thisArg, args: Parameters<typeof listener>) => {\n              // If we have already read more than the max body length, we stop adding chunks\n              // To avoid growing the memory indefinitely if a response is e.g. streamed\n              if (getChunksSize() < MAX_BODY_BYTE_LENGTH) {\n                const chunk = args[0] as Buffer;\n                chunks.push(chunk);\n              } else if (DEBUG_BUILD) {\n                logger.log(\n                  `Dropping request body chunk because it maximum body length of ${MAX_BODY_BYTE_LENGTH}b is exceeded.`,\n                );\n              }\n\n              return Reflect.apply(target, thisArg, args);\n            },\n          });\n\n          callbackMap.set(listener, callback);\n\n          return Reflect.apply(target, thisArg, [event, callback, ...restArgs]);\n        }\n\n        if (event === 'end') {\n          const callback = new Proxy(listener, {\n            apply: (target, thisArg, args) => {\n              try {\n                const body = Buffer.concat(chunks).toString('utf-8');\n\n                if (body) {\n                  const normalizedRequest = { data: body } satisfies RequestEventData;\n                  isolationScope.setSDKProcessingMetadata({ normalizedRequest });\n                }\n              } catch {\n                // ignore errors here\n              }\n\n              return Reflect.apply(target, thisArg, args);\n            },\n          });\n\n          callbackMap.set(listener, callback);\n\n          return Reflect.apply(target, thisArg, [event, callback, ...restArgs]);\n        }\n\n        return Reflect.apply(target, thisArg, args);\n      },\n    });\n\n    // Ensure we also remove callbacks correctly\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    req.off = new Proxy(req.off, {\n      apply: (target, thisArg, args: Parameters<typeof req.off>) => {\n        const [, listener] = args;\n\n        const callback = callbackMap.get(listener);\n        if (callback) {\n          callbackMap.delete(listener);\n\n          const modifiedArgs = args.slice();\n          modifiedArgs[1] = callback;\n          return Reflect.apply(target, thisArg, modifiedArgs);\n        }\n\n        return Reflect.apply(target, thisArg, args);\n      },\n    });\n  } catch {\n    // ignore errors if we can't patch stuff\n  }\n}\n\n/**\n * Starts a session and tracks it in the context of a given isolation scope.\n * When the passed response is finished, the session is put into a task and is\n * aggregated with other sessions that may happen in a certain time window\n * (sessionFlushingDelayMs).\n *\n * The sessions are always aggregated by the client that is on the current scope\n * at the time of ending the response (if there is one).\n */\n// Exported for unit tests\nexport function recordRequestSession({\n  requestIsolationScope,\n  response,\n  sessionFlushingDelayMS,\n}: {\n  requestIsolationScope: Scope;\n  response: EventEmitter;\n  sessionFlushingDelayMS?: number;\n}): void {\n  requestIsolationScope.setSDKProcessingMetadata({\n    requestSession: { status: 'ok' },\n  });\n  response.once('close', () => {\n    // We need to grab the client off the current scope instead of the isolation scope because the isolation scope doesn't hold any client out of the box.\n    const client = getClient();\n    const requestSession = requestIsolationScope.getScopeData().sdkProcessingMetadata.requestSession;\n\n    if (client && requestSession) {\n      DEBUG_BUILD && logger.debug(`Recorded request session with status: ${requestSession.status}`);\n\n      const roundedDate = new Date();\n      roundedDate.setSeconds(0, 0);\n      const dateBucketKey = roundedDate.toISOString();\n\n      const existingClientAggregate = clientToRequestSessionAggregatesMap.get(client);\n      const bucket = existingClientAggregate?.[dateBucketKey] || { exited: 0, crashed: 0, errored: 0 };\n      bucket[({ ok: 'exited', crashed: 'crashed', errored: 'errored' } as const)[requestSession.status]]++;\n\n      if (existingClientAggregate) {\n        existingClientAggregate[dateBucketKey] = bucket;\n      } else {\n        DEBUG_BUILD && logger.debug('Opened new request session aggregate.');\n        const newClientAggregate = { [dateBucketKey]: bucket };\n        clientToRequestSessionAggregatesMap.set(client, newClientAggregate);\n\n        const flushPendingClientAggregates = (): void => {\n          clearTimeout(timeout);\n          unregisterClientFlushHook();\n          clientToRequestSessionAggregatesMap.delete(client);\n\n          const aggregatePayload: AggregationCounts[] = Object.entries(newClientAggregate).map(\n            ([timestamp, value]) => ({\n              started: timestamp,\n              exited: value.exited,\n              errored: value.errored,\n              crashed: value.crashed,\n            }),\n          );\n          client.sendSession({ aggregates: aggregatePayload });\n        };\n\n        const unregisterClientFlushHook = client.on('flush', () => {\n          DEBUG_BUILD && logger.debug('Sending request session aggregate due to client flush');\n          flushPendingClientAggregates();\n        });\n        const timeout = setTimeout(() => {\n          DEBUG_BUILD && logger.debug('Sending request session aggregate due to flushing schedule');\n          flushPendingClientAggregates();\n        }, sessionFlushingDelayMS).unref();\n      }\n    }\n  });\n}\n\nconst clientToRequestSessionAggregatesMap = new Map<\n  Client,\n  { [timestampRoundedToSeconds: string]: { exited: number; crashed: number; errored: number } }\n>();\n"],"names":["InstrumentationBase","VERSION","InstrumentationNodeModuleDefinition","stealthWrap","getIsolationScope","httpRequestToRequestData","stripUrlQueryAndFragment","withIsolationScope","getCurrentScope","generateSpanId","propagation","context","getRequestInfo","getRequestUrl","getBreadcrumbLogLevelFromHttpStatusCode","addBreadcrumb","parseUrl","getSanitizedUrlString","DEBUG_BUILD","logger","getClient"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"SentryHttpInstrumentation.js","sources":["../../../../src/integrations/http/SentryHttpInstrumentation.ts"],"sourcesContent":["/* eslint-disable max-lines */\nimport { context, propagation } from '@opentelemetry/api';\nimport type { InstrumentationConfig } from '@opentelemetry/instrumentation';\nimport { InstrumentationBase, InstrumentationNodeModuleDefinition } from '@opentelemetry/instrumentation';\nimport type { AggregationCounts, Client, RequestEventData, SanitizedRequestData, Scope } from '@sentry/core';\nimport {\n  addBreadcrumb,\n  generateSpanId,\n  getBreadcrumbLogLevelFromHttpStatusCode,\n  getClient,\n  getCurrentScope,\n  getIsolationScope,\n  getSanitizedUrlString,\n  httpRequestToRequestData,\n  logger,\n  parseUrl,\n  stripUrlQueryAndFragment,\n  withIsolationScope,\n} from '@sentry/core';\nimport type * as http from 'node:http';\nimport type { IncomingMessage, RequestOptions } from 'node:http';\nimport type * as https from 'node:https';\nimport type { EventEmitter } from 'node:stream';\nimport { DEBUG_BUILD } from '../../debug-build';\nimport { getRequestUrl } from '../../utils/getRequestUrl';\nimport { stealthWrap } from './utils';\nimport { getRequestInfo } from './vendor/getRequestInfo';\n\ntype Http = typeof http;\ntype Https = typeof https;\n\nexport type SentryHttpInstrumentationOptions = InstrumentationConfig & {\n  /**\n   * Whether breadcrumbs should be recorded for requests.\n   *\n   * @default `true`\n   */\n  breadcrumbs?: boolean;\n\n  /**\n   * Whether to extract the trace ID from the `sentry-trace` header for incoming requests.\n   * By default this is done by the HttpInstrumentation, but if that is not added (e.g. because tracing is disabled, ...)\n   * then this instrumentation can take over.\n   *\n   * @default `false`\n   */\n  extractIncomingTraceFromHeader?: boolean;\n\n  /**\n   * Do not capture breadcrumbs for outgoing HTTP requests to URLs where the given callback returns `true`.\n   * For the scope of this instrumentation, this callback only controls breadcrumb creation.\n   * The same option can be passed to the top-level httpIntegration where it controls both, breadcrumb and\n   * span creation.\n   *\n   * @param url Contains the entire URL, including query string (if any), protocol, host, etc. of the outgoing request.\n   * @param request Contains the {@type RequestOptions} object used to make the outgoing request.\n   */\n  ignoreOutgoingRequests?: (url: string, request: RequestOptions) => boolean;\n\n  /**\n   * Do not capture the request body for incoming HTTP requests to URLs where the given callback returns `true`.\n   * This can be useful for long running requests where the body is not needed and we want to avoid capturing it.\n   *\n   * @param url Contains the entire URL, including query string (if any), protocol, host, etc. of the outgoing request.\n   * @param request Contains the {@type RequestOptions} object used to make the outgoing request.\n   */\n  ignoreIncomingRequestBody?: (url: string, request: RequestOptions) => boolean;\n\n  /**\n   * Whether the integration should create [Sessions](https://docs.sentry.io/product/releases/health/#sessions) for incoming requests to track the health and crash-free rate of your releases in Sentry.\n   * Read more about Release Health: https://docs.sentry.io/product/releases/health/\n   *\n   * Defaults to `true`.\n   */\n  trackIncomingRequestsAsSessions?: boolean;\n\n  /**\n   * Number of milliseconds until sessions tracked with `trackIncomingRequestsAsSessions` will be flushed as a session aggregate.\n   *\n   * Defaults to `60000` (60s).\n   */\n  sessionFlushingDelayMS?: number;\n};\n\n// We only want to capture request bodies up to 1mb.\nconst MAX_BODY_BYTE_LENGTH = 1024 * 1024;\n\n/**\n * This custom HTTP instrumentation is used to isolate incoming requests and annotate them with additional information.\n * It does not emit any spans.\n *\n * The reason this is isolated from the OpenTelemetry instrumentation is that users may overwrite this,\n * which would lead to Sentry not working as expected.\n *\n * Important note: Contrary to other OTEL instrumentation, this one cannot be unwrapped.\n * It only does minimal things though and does not emit any spans.\n *\n * This is heavily inspired & adapted from:\n * https://github.com/open-telemetry/opentelemetry-js/blob/f8ab5592ddea5cba0a3b33bf8d74f27872c0367f/experimental/packages/opentelemetry-instrumentation-http/src/http.ts\n */\nexport class SentryHttpInstrumentation extends InstrumentationBase<SentryHttpInstrumentationOptions> {\n  public constructor(config: SentryHttpInstrumentationOptions = {}) {\n    super('@sentry/instrumentation-http', '2.0.0', config);\n  }\n\n  /** @inheritdoc */\n  public init(): [InstrumentationNodeModuleDefinition, InstrumentationNodeModuleDefinition] {\n    return [this._getHttpsInstrumentation(), this._getHttpInstrumentation()];\n  }\n\n  /** Get the instrumentation for the http module. */\n  private _getHttpInstrumentation(): InstrumentationNodeModuleDefinition {\n    return new InstrumentationNodeModuleDefinition(\n      'http',\n      ['*'],\n      (moduleExports: Http): Http => {\n        // Patch incoming requests for request isolation\n        stealthWrap(moduleExports.Server.prototype, 'emit', this._getPatchIncomingRequestFunction());\n\n        // Patch outgoing requests for breadcrumbs\n        const patchedRequest = stealthWrap(moduleExports, 'request', this._getPatchOutgoingRequestFunction());\n        stealthWrap(moduleExports, 'get', this._getPatchOutgoingGetFunction(patchedRequest));\n\n        return moduleExports;\n      },\n      () => {\n        // no unwrap here\n      },\n    );\n  }\n\n  /** Get the instrumentation for the https module. */\n  private _getHttpsInstrumentation(): InstrumentationNodeModuleDefinition {\n    return new InstrumentationNodeModuleDefinition(\n      'https',\n      ['*'],\n      (moduleExports: Https): Https => {\n        // Patch incoming requests for request isolation\n        stealthWrap(moduleExports.Server.prototype, 'emit', this._getPatchIncomingRequestFunction());\n\n        // Patch outgoing requests for breadcrumbs\n        const patchedRequest = stealthWrap(moduleExports, 'request', this._getPatchOutgoingRequestFunction());\n        stealthWrap(moduleExports, 'get', this._getPatchOutgoingGetFunction(patchedRequest));\n\n        return moduleExports;\n      },\n      () => {\n        // no unwrap here\n      },\n    );\n  }\n\n  /**\n   * Patch the incoming request function for request isolation.\n   */\n  private _getPatchIncomingRequestFunction(): (\n    original: (event: string, ...args: unknown[]) => boolean,\n  ) => (this: unknown, event: string, ...args: unknown[]) => boolean {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const instrumentation = this;\n    const { ignoreIncomingRequestBody } = instrumentation.getConfig();\n\n    return (\n      original: (event: string, ...args: unknown[]) => boolean,\n    ): ((this: unknown, event: string, ...args: unknown[]) => boolean) => {\n      return function incomingRequest(this: unknown, ...args: [event: string, ...args: unknown[]]): boolean {\n        // Only traces request events\n        if (args[0] !== 'request') {\n          return original.apply(this, args);\n        }\n\n        instrumentation._diag.debug('http instrumentation for incoming request');\n\n        const isolationScope = getIsolationScope().clone();\n        const request = args[1] as http.IncomingMessage;\n        const response = args[2] as http.OutgoingMessage;\n\n        const normalizedRequest = httpRequestToRequestData(request);\n\n        // request.ip is non-standard but some frameworks set this\n        const ipAddress = (request as { ip?: string }).ip || request.socket?.remoteAddress;\n\n        const url = request.url || '/';\n        if (!ignoreIncomingRequestBody?.(url, request)) {\n          patchRequestToCaptureBody(request, isolationScope);\n        }\n\n        // Update the isolation scope, isolate this request\n        isolationScope.setSDKProcessingMetadata({ normalizedRequest, ipAddress });\n\n        // attempt to update the scope's `transactionName` based on the request URL\n        // Ideally, framework instrumentations coming after the HttpInstrumentation\n        // update the transactionName once we get a parameterized route.\n        const httpMethod = (request.method || 'GET').toUpperCase();\n        const httpTarget = stripUrlQueryAndFragment(url);\n\n        const bestEffortTransactionName = `${httpMethod} ${httpTarget}`;\n\n        isolationScope.setTransactionName(bestEffortTransactionName);\n\n        if (instrumentation.getConfig().trackIncomingRequestsAsSessions !== false) {\n          recordRequestSession({\n            requestIsolationScope: isolationScope,\n            response,\n            sessionFlushingDelayMS: instrumentation.getConfig().sessionFlushingDelayMS ?? 60_000,\n          });\n        }\n\n        return withIsolationScope(isolationScope, () => {\n          // Set a new propagationSpanId for this request\n          // We rely on the fact that `withIsolationScope()` will implicitly also fork the current scope\n          // This way we can save an \"unnecessary\" `withScope()` invocation\n          getCurrentScope().getPropagationContext().propagationSpanId = generateSpanId();\n\n          // If we don't want to extract the trace from the header, we can skip this\n          if (!instrumentation.getConfig().extractIncomingTraceFromHeader) {\n            return original.apply(this, args);\n          }\n\n          const ctx = propagation.extract(context.active(), normalizedRequest.headers);\n          return context.with(ctx, () => {\n            return original.apply(this, args);\n          });\n        });\n      };\n    };\n  }\n\n  /**\n   * Patch the outgoing request function for breadcrumbs.\n   */\n  private _getPatchOutgoingRequestFunction(): (\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    original: (...args: any[]) => http.ClientRequest,\n  ) => (options: URL | http.RequestOptions | string, ...args: unknown[]) => http.ClientRequest {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const instrumentation = this;\n\n    return (original: (...args: unknown[]) => http.ClientRequest): ((...args: unknown[]) => http.ClientRequest) => {\n      return function outgoingRequest(this: unknown, ...args: unknown[]): http.ClientRequest {\n        instrumentation._diag.debug('http instrumentation for outgoing requests');\n\n        // Making a copy to avoid mutating the original args array\n        // We need to access and reconstruct the request options object passed to `ignoreOutgoingRequests`\n        // so that it matches what Otel instrumentation passes to `ignoreOutgoingRequestHook`.\n        // @see https://github.com/open-telemetry/opentelemetry-js/blob/7293e69c1e55ca62e15d0724d22605e61bd58952/experimental/packages/opentelemetry-instrumentation-http/src/http.ts#L756-L789\n        const argsCopy = [...args];\n\n        const options = argsCopy.shift() as URL | http.RequestOptions | string;\n\n        const extraOptions =\n          typeof argsCopy[0] === 'object' && (typeof options === 'string' || options instanceof URL)\n            ? (argsCopy.shift() as http.RequestOptions)\n            : undefined;\n\n        const { optionsParsed } = getRequestInfo(instrumentation._diag, options, extraOptions);\n\n        const request = original.apply(this, args) as ReturnType<typeof http.request>;\n\n        request.prependListener('response', (response: http.IncomingMessage) => {\n          const _breadcrumbs = instrumentation.getConfig().breadcrumbs;\n          const breadCrumbsEnabled = typeof _breadcrumbs === 'undefined' ? true : _breadcrumbs;\n\n          const _ignoreOutgoingRequests = instrumentation.getConfig().ignoreOutgoingRequests;\n          const shouldCreateBreadcrumb =\n            typeof _ignoreOutgoingRequests === 'function'\n              ? !_ignoreOutgoingRequests(getRequestUrl(request), optionsParsed)\n              : true;\n\n          if (breadCrumbsEnabled && shouldCreateBreadcrumb) {\n            addRequestBreadcrumb(request, response);\n          }\n        });\n\n        return request;\n      };\n    };\n  }\n\n  /** Path the outgoing get function for breadcrumbs. */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private _getPatchOutgoingGetFunction(clientRequest: (...args: any[]) => http.ClientRequest) {\n    return (_original: unknown): ((...args: unknown[]) => http.ClientRequest) => {\n      // Re-implement http.get. This needs to be done (instead of using\n      // getPatchOutgoingRequestFunction to patch it) because we need to\n      // set the trace context header before the returned http.ClientRequest is\n      // ended. The Node.js docs state that the only differences between\n      // request and get are that (1) get defaults to the HTTP GET method and\n      // (2) the returned request object is ended immediately. The former is\n      // already true (at least in supported Node versions up to v10), so we\n      // simply follow the latter. Ref:\n      // https://nodejs.org/dist/latest/docs/api/http.html#http_http_get_options_callback\n      // https://github.com/googleapis/cloud-trace-nodejs/blob/master/src/instrumentations/instrumentation-http.ts#L198\n      return function outgoingGetRequest(...args: unknown[]): http.ClientRequest {\n        const req = clientRequest(...args);\n        req.end();\n        return req;\n      };\n    };\n  }\n}\n\n/** Add a breadcrumb for outgoing requests. */\nfunction addRequestBreadcrumb(request: http.ClientRequest, response: http.IncomingMessage): void {\n  const data = getBreadcrumbData(request);\n\n  const statusCode = response.statusCode;\n  const level = getBreadcrumbLogLevelFromHttpStatusCode(statusCode);\n\n  addBreadcrumb(\n    {\n      category: 'http',\n      data: {\n        status_code: statusCode,\n        ...data,\n      },\n      type: 'http',\n      level,\n    },\n    {\n      event: 'response',\n      request,\n      response,\n    },\n  );\n}\n\nfunction getBreadcrumbData(request: http.ClientRequest): Partial<SanitizedRequestData> {\n  try {\n    // `request.host` does not contain the port, but the host header does\n    const host = request.getHeader('host') || request.host;\n    const url = new URL(request.path, `${request.protocol}//${host}`);\n    const parsedUrl = parseUrl(url.toString());\n\n    const data: Partial<SanitizedRequestData> = {\n      url: getSanitizedUrlString(parsedUrl),\n      'http.method': request.method || 'GET',\n    };\n\n    if (parsedUrl.search) {\n      data['http.query'] = parsedUrl.search;\n    }\n    if (parsedUrl.hash) {\n      data['http.fragment'] = parsedUrl.hash;\n    }\n\n    return data;\n  } catch {\n    return {};\n  }\n}\n\n/**\n * This method patches the request object to capture the body.\n * Instead of actually consuming the streamed body ourselves, which has potential side effects,\n * we monkey patch `req.on('data')` to intercept the body chunks.\n * This way, we only read the body if the user also consumes the body, ensuring we do not change any behavior in unexpected ways.\n */\nfunction patchRequestToCaptureBody(req: IncomingMessage, isolationScope: Scope): void {\n  const chunks: Buffer[] = [];\n\n  function getChunksSize(): number {\n    return chunks.reduce((acc, chunk) => acc + chunk.byteLength, 0);\n  }\n\n  /**\n   * We need to keep track of the original callbacks, in order to be able to remove listeners again.\n   * Since `off` depends on having the exact same function reference passed in, we need to be able to map\n   * original listeners to our wrapped ones.\n   */\n  const callbackMap = new WeakMap();\n\n  try {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    req.on = new Proxy(req.on, {\n      apply: (target, thisArg, args: Parameters<typeof req.on>) => {\n        const [event, listener, ...restArgs] = args;\n\n        if (event === 'data') {\n          const callback = new Proxy(listener, {\n            apply: (target, thisArg, args: Parameters<typeof listener>) => {\n              // If we have already read more than the max body length, we stop adding chunks\n              // To avoid growing the memory indefinitely if a response is e.g. streamed\n              if (getChunksSize() < MAX_BODY_BYTE_LENGTH) {\n                const chunk = args[0] as Buffer;\n                chunks.push(chunk);\n              } else if (DEBUG_BUILD) {\n                logger.log(\n                  `Dropping request body chunk because it maximum body length of ${MAX_BODY_BYTE_LENGTH}b is exceeded.`,\n                );\n              }\n\n              return Reflect.apply(target, thisArg, args);\n            },\n          });\n\n          callbackMap.set(listener, callback);\n\n          return Reflect.apply(target, thisArg, [event, callback, ...restArgs]);\n        }\n\n        if (event === 'end') {\n          const callback = new Proxy(listener, {\n            apply: (target, thisArg, args) => {\n              try {\n                const body = Buffer.concat(chunks).toString('utf-8');\n\n                if (body) {\n                  const normalizedRequest = { data: body } satisfies RequestEventData;\n                  isolationScope.setSDKProcessingMetadata({ normalizedRequest });\n                }\n              } catch {\n                // ignore errors here\n              }\n\n              return Reflect.apply(target, thisArg, args);\n            },\n          });\n\n          callbackMap.set(listener, callback);\n\n          return Reflect.apply(target, thisArg, [event, callback, ...restArgs]);\n        }\n\n        return Reflect.apply(target, thisArg, args);\n      },\n    });\n\n    // Ensure we also remove callbacks correctly\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    req.off = new Proxy(req.off, {\n      apply: (target, thisArg, args: Parameters<typeof req.off>) => {\n        const [, listener] = args;\n\n        const callback = callbackMap.get(listener);\n        if (callback) {\n          callbackMap.delete(listener);\n\n          const modifiedArgs = args.slice();\n          modifiedArgs[1] = callback;\n          return Reflect.apply(target, thisArg, modifiedArgs);\n        }\n\n        return Reflect.apply(target, thisArg, args);\n      },\n    });\n  } catch {\n    // ignore errors if we can't patch stuff\n  }\n}\n\n/**\n * Starts a session and tracks it in the context of a given isolation scope.\n * When the passed response is finished, the session is put into a task and is\n * aggregated with other sessions that may happen in a certain time window\n * (sessionFlushingDelayMs).\n *\n * The sessions are always aggregated by the client that is on the current scope\n * at the time of ending the response (if there is one).\n */\n// Exported for unit tests\nexport function recordRequestSession({\n  requestIsolationScope,\n  response,\n  sessionFlushingDelayMS,\n}: {\n  requestIsolationScope: Scope;\n  response: EventEmitter;\n  sessionFlushingDelayMS?: number;\n}): void {\n  requestIsolationScope.setSDKProcessingMetadata({\n    requestSession: { status: 'ok' },\n  });\n  response.once('close', () => {\n    // We need to grab the client off the current scope instead of the isolation scope because the isolation scope doesn't hold any client out of the box.\n    const client = getClient();\n    const requestSession = requestIsolationScope.getScopeData().sdkProcessingMetadata.requestSession;\n\n    if (client && requestSession) {\n      DEBUG_BUILD && logger.debug(`Recorded request session with status: ${requestSession.status}`);\n\n      const roundedDate = new Date();\n      roundedDate.setSeconds(0, 0);\n      const dateBucketKey = roundedDate.toISOString();\n\n      const existingClientAggregate = clientToRequestSessionAggregatesMap.get(client);\n      const bucket = existingClientAggregate?.[dateBucketKey] || { exited: 0, crashed: 0, errored: 0 };\n      bucket[({ ok: 'exited', crashed: 'crashed', errored: 'errored' } as const)[requestSession.status]]++;\n\n      if (existingClientAggregate) {\n        existingClientAggregate[dateBucketKey] = bucket;\n      } else {\n        DEBUG_BUILD && logger.debug('Opened new request session aggregate.');\n        const newClientAggregate = { [dateBucketKey]: bucket };\n        clientToRequestSessionAggregatesMap.set(client, newClientAggregate);\n\n        const flushPendingClientAggregates = (): void => {\n          clearTimeout(timeout);\n          unregisterClientFlushHook();\n          clientToRequestSessionAggregatesMap.delete(client);\n\n          const aggregatePayload: AggregationCounts[] = Object.entries(newClientAggregate).map(\n            ([timestamp, value]) => ({\n              started: timestamp,\n              exited: value.exited,\n              errored: value.errored,\n              crashed: value.crashed,\n            }),\n          );\n          client.sendSession({ aggregates: aggregatePayload });\n        };\n\n        const unregisterClientFlushHook = client.on('flush', () => {\n          DEBUG_BUILD && logger.debug('Sending request session aggregate due to client flush');\n          flushPendingClientAggregates();\n        });\n        const timeout = setTimeout(() => {\n          DEBUG_BUILD && logger.debug('Sending request session aggregate due to flushing schedule');\n          flushPendingClientAggregates();\n        }, sessionFlushingDelayMS).unref();\n      }\n    }\n  });\n}\n\nconst clientToRequestSessionAggregatesMap = new Map<\n  Client,\n  { [timestampRoundedToSeconds: string]: { exited: number; crashed: number; errored: number } }\n>();\n"],"names":["InstrumentationBase","InstrumentationNodeModuleDefinition","stealthWrap","getIsolationScope","httpRequestToRequestData","stripUrlQueryAndFragment","withIsolationScope","getCurrentScope","generateSpanId","propagation","context","getRequestInfo","getRequestUrl","getBreadcrumbLogLevelFromHttpStatusCode","addBreadcrumb","parseUrl","getSanitizedUrlString","DEBUG_BUILD","logger","getClient"],"mappings":";;;;;;;;;;AAAA;;AAoFA;AACA,MAAM,oBAAqB,GAAE,IAAK,GAAE,IAAI;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAM,yBAAA,SAAkCA,mCAAmB,CAAmC;AACrG,GAAS,WAAW,CAAC,MAAM,GAAqC,EAAE,EAAE;AACpE,IAAI,KAAK,CAAC,8BAA8B,EAAE,OAAO,EAAE,MAAM,CAAC;AAC1D;;AAEA;AACA,GAAS,IAAI,GAA+E;AAC5F,IAAI,OAAO,CAAC,IAAI,CAAC,wBAAwB,EAAE,EAAE,IAAI,CAAC,uBAAuB,EAAE,CAAC;AAC5E;;AAEA;AACA,GAAU,uBAAuB,GAAwC;AACzE,IAAI,OAAO,IAAIC,mDAAmC;AAClD,MAAM,MAAM;AACZ,MAAM,CAAC,GAAG,CAAC;AACX,MAAM,CAAC,aAAa,KAAiB;AACrC;AACA,QAAQC,iBAAW,CAAC,aAAa,CAAC,MAAM,CAAC,SAAS,EAAE,MAAM,EAAE,IAAI,CAAC,gCAAgC,EAAE,CAAC;;AAEpG;AACA,QAAQ,MAAM,cAAA,GAAiBA,iBAAW,CAAC,aAAa,EAAE,SAAS,EAAE,IAAI,CAAC,gCAAgC,EAAE,CAAC;AAC7G,QAAQA,iBAAW,CAAC,aAAa,EAAE,KAAK,EAAE,IAAI,CAAC,4BAA4B,CAAC,cAAc,CAAC,CAAC;;AAE5F,QAAQ,OAAO,aAAa;AAC5B,OAAO;AACP,MAAM,MAAM;AACZ;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA,GAAU,wBAAwB,GAAwC;AAC1E,IAAI,OAAO,IAAID,mDAAmC;AAClD,MAAM,OAAO;AACb,MAAM,CAAC,GAAG,CAAC;AACX,MAAM,CAAC,aAAa,KAAmB;AACvC;AACA,QAAQC,iBAAW,CAAC,aAAa,CAAC,MAAM,CAAC,SAAS,EAAE,MAAM,EAAE,IAAI,CAAC,gCAAgC,EAAE,CAAC;;AAEpG;AACA,QAAQ,MAAM,cAAA,GAAiBA,iBAAW,CAAC,aAAa,EAAE,SAAS,EAAE,IAAI,CAAC,gCAAgC,EAAE,CAAC;AAC7G,QAAQA,iBAAW,CAAC,aAAa,EAAE,KAAK,EAAE,IAAI,CAAC,4BAA4B,CAAC,cAAc,CAAC,CAAC;;AAE5F,QAAQ,OAAO,aAAa;AAC5B,OAAO;AACP,MAAM,MAAM;AACZ;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA,GAAU,gCAAgC;;AAExC,CAAmE;AACrE;AACA,IAAI,MAAM,eAAgB,GAAE,IAAI;AAChC,IAAI,MAAM,EAAE,yBAA0B,EAAA,GAAI,eAAe,CAAC,SAAS,EAAE;;AAErE,IAAI,OAAO;AACX,MAAM,QAAQ;AACd,SAA0E;AAC1E,MAAM,OAAO,SAAS,eAAe,EAAgB,GAAG,IAAI,EAAgD;AAC5G;AACA,QAAQ,IAAI,IAAI,CAAC,CAAC,CAAE,KAAI,SAAS,EAAE;AACnC,UAAU,OAAO,QAAQ,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC;AAC3C;;AAEA,QAAQ,eAAe,CAAC,KAAK,CAAC,KAAK,CAAC,2CAA2C,CAAC;;AAEhF,QAAQ,MAAM,iBAAiBC,sBAAiB,EAAE,CAAC,KAAK,EAAE;AAC1D,QAAQ,MAAM,OAAQ,GAAE,IAAI,CAAC,CAAC,CAAE;AAChC,QAAQ,MAAM,QAAS,GAAE,IAAI,CAAC,CAAC,CAAE;;AAEjC,QAAQ,MAAM,iBAAkB,GAAEC,6BAAwB,CAAC,OAAO,CAAC;;AAEnE;AACA,QAAQ,MAAM,SAAA,GAAY,CAAC,OAAQ,GAAoB,EAAA,IAAM,OAAO,CAAC,MAAM,EAAE,aAAa;;AAE1F,QAAQ,MAAM,GAAI,GAAE,OAAO,CAAC,GAAA,IAAO,GAAG;AACtC,QAAQ,IAAI,CAAC,yBAAyB,GAAG,GAAG,EAAE,OAAO,CAAC,EAAE;AACxD,UAAU,yBAAyB,CAAC,OAAO,EAAE,cAAc,CAAC;AAC5D;;AAEA;AACA,QAAQ,cAAc,CAAC,wBAAwB,CAAC,EAAE,iBAAiB,EAAE,SAAU,EAAC,CAAC;;AAEjF;AACA;AACA;AACA,QAAQ,MAAM,UAAA,GAAa,CAAC,OAAO,CAAC,MAAO,IAAG,KAAK,EAAE,WAAW,EAAE;AAClE,QAAQ,MAAM,UAAW,GAAEC,6BAAwB,CAAC,GAAG,CAAC;;AAExD,QAAQ,MAAM,yBAAA,GAA4B,CAAC,EAAA,UAAA,CAAA,CAAA,EAAA,UAAA,CAAA,CAAA;;AAEA,QAAA,cAAA,CAAA,kBAAA,CAAA,yBAAA,CAAA;;AAEA,QAAA,IAAA,eAAA,CAAA,SAAA,EAAA,CAAA,+BAAA,KAAA,KAAA,EAAA;AACA,UAAA,oBAAA,CAAA;AACA,YAAA,qBAAA,EAAA,cAAA;AACA,YAAA,QAAA;AACA,YAAA,sBAAA,EAAA,eAAA,CAAA,SAAA,EAAA,CAAA,sBAAA,IAAA,KAAA;AACA,WAAA,CAAA;AACA;;AAEA,QAAA,OAAAC,uBAAA,CAAA,cAAA,EAAA,MAAA;AACA;AACA;AACA;AACA,UAAAC,oBAAA,EAAA,CAAA,qBAAA,EAAA,CAAA,iBAAA,GAAAC,mBAAA,EAAA;;AAEA;AACA,UAAA,IAAA,CAAA,eAAA,CAAA,SAAA,EAAA,CAAA,8BAAA,EAAA;AACA,YAAA,OAAA,QAAA,CAAA,KAAA,CAAA,IAAA,EAAA,IAAA,CAAA;AACA;;AAEA,UAAA,MAAA,GAAA,GAAAC,eAAA,CAAA,OAAA,CAAAC,WAAA,CAAA,MAAA,EAAA,EAAA,iBAAA,CAAA,OAAA,CAAA;AACA,UAAA,OAAAA,WAAA,CAAA,IAAA,CAAA,GAAA,EAAA,MAAA;AACA,YAAA,OAAA,QAAA,CAAA,KAAA,CAAA,IAAA,EAAA,IAAA,CAAA;AACA,WAAA,CAAA;AACA,SAAA,CAAA;AACA,OAAA;AACA,KAAA;AACA;;AAEA;AACA;AACA;AACA,GAAA,gCAAA;;AAGA,CAAA;AACA;AACA,IAAA,MAAA,eAAA,GAAA,IAAA;;AAEA,IAAA,OAAA,CAAA,QAAA,KAAA;AACA,MAAA,OAAA,SAAA,eAAA,EAAA,GAAA,IAAA,EAAA;AACA,QAAA,eAAA,CAAA,KAAA,CAAA,KAAA,CAAA,4CAAA,CAAA;;AAEA;AACA;AACA;AACA;AACA,QAAA,MAAA,QAAA,GAAA,CAAA,GAAA,IAAA,CAAA;;AAEA,QAAA,MAAA,OAAA,GAAA,QAAA,CAAA,KAAA,EAAA;;AAEA,QAAA,MAAA,YAAA;AACA,UAAA,OAAA,QAAA,CAAA,CAAA,CAAA,KAAA,QAAA,KAAA,OAAA,OAAA,KAAA,QAAA,IAAA,OAAA,YAAA,GAAA;AACA,eAAA,QAAA,CAAA,KAAA,EAAA;AACA,cAAA,SAAA;;AAEA,QAAA,MAAA,EAAA,aAAA,EAAA,GAAAC,6BAAA,CAAA,eAAA,CAAA,KAAA,EAAA,OAAA,EAAA,YAAA,CAAA;;AAEA,QAAA,MAAA,OAAA,GAAA,QAAA,CAAA,KAAA,CAAA,IAAA,EAAA,IAAA,CAAA;;AAEA,QAAA,OAAA,CAAA,eAAA,CAAA,UAAA,EAAA,CAAA,QAAA,KAAA;AACA,UAAA,MAAA,YAAA,GAAA,eAAA,CAAA,SAAA,EAAA,CAAA,WAAA;AACA,UAAA,MAAA,kBAAA,GAAA,OAAA,YAAA,KAAA,WAAA,GAAA,IAAA,GAAA,YAAA;;AAEA,UAAA,MAAA,uBAAA,GAAA,eAAA,CAAA,SAAA,EAAA,CAAA,sBAAA;AACA,UAAA,MAAA,sBAAA;AACA,YAAA,OAAA,uBAAA,KAAA;AACA,gBAAA,CAAA,uBAAA,CAAAC,2BAAA,CAAA,OAAA,CAAA,EAAA,aAAA;AACA,gBAAA,IAAA;;AAEA,UAAA,IAAA,kBAAA,IAAA,sBAAA,EAAA;AACA,YAAA,oBAAA,CAAA,OAAA,EAAA,QAAA,CAAA;AACA;AACA,SAAA,CAAA;;AAEA,QAAA,OAAA,OAAA;AACA,OAAA;AACA,KAAA;AACA;;AAEA;AACA;AACA,GAAA,4BAAA,CAAA,aAAA,EAAA;AACA,IAAA,OAAA,CAAA,SAAA,KAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAA,OAAA,SAAA,kBAAA,CAAA,GAAA,IAAA,EAAA;AACA,QAAA,MAAA,GAAA,GAAA,aAAA,CAAA,GAAA,IAAA,CAAA;AACA,QAAA,GAAA,CAAA,GAAA,EAAA;AACA,QAAA,OAAA,GAAA;AACA,OAAA;AACA,KAAA;AACA;AACA;;AAEA;AACA,SAAA,oBAAA,CAAA,OAAA,EAAA,QAAA,EAAA;AACA,EAAA,MAAA,IAAA,GAAA,iBAAA,CAAA,OAAA,CAAA;;AAEA,EAAA,MAAA,UAAA,GAAA,QAAA,CAAA,UAAA;AACA,EAAA,MAAA,KAAA,GAAAC,4CAAA,CAAA,UAAA,CAAA;;AAEA,EAAAC,kBAAA;AACA,IAAA;AACA,MAAA,QAAA,EAAA,MAAA;AACA,MAAA,IAAA,EAAA;AACA,QAAA,WAAA,EAAA,UAAA;AACA,QAAA,GAAA,IAAA;AACA,OAAA;AACA,MAAA,IAAA,EAAA,MAAA;AACA,MAAA,KAAA;AACA,KAAA;AACA,IAAA;AACA,MAAA,KAAA,EAAA,UAAA;AACA,MAAA,OAAA;AACA,MAAA,QAAA;AACA,KAAA;AACA,GAAA;AACA;;AAEA,SAAA,iBAAA,CAAA,OAAA,EAAA;AACA,EAAA,IAAA;AACA;AACA,IAAA,MAAA,IAAA,GAAA,OAAA,CAAA,SAAA,CAAA,MAAA,CAAA,IAAA,OAAA,CAAA,IAAA;AACA,IAAA,MAAA,GAAA,GAAA,IAAA,GAAA,CAAA,OAAA,CAAA,IAAA,EAAA,CAAA,EAAA,OAAA,CAAA,QAAA,CAAA,EAAA,EAAA,IAAA,CAAA,CAAA,CAAA;AACA,IAAA,MAAA,SAAA,GAAAC,aAAA,CAAA,GAAA,CAAA,QAAA,EAAA,CAAA;;AAEA,IAAA,MAAA,IAAA,GAAA;AACA,MAAA,GAAA,EAAAC,0BAAA,CAAA,SAAA,CAAA;AACA,MAAA,aAAA,EAAA,OAAA,CAAA,MAAA,IAAA,KAAA;AACA,KAAA;;AAEA,IAAA,IAAA,SAAA,CAAA,MAAA,EAAA;AACA,MAAA,IAAA,CAAA,YAAA,CAAA,GAAA,SAAA,CAAA,MAAA;AACA;AACA,IAAA,IAAA,SAAA,CAAA,IAAA,EAAA;AACA,MAAA,IAAA,CAAA,eAAA,CAAA,GAAA,SAAA,CAAA,IAAA;AACA;;AAEA,IAAA,OAAA,IAAA;AACA,GAAA,CAAA,MAAA;AACA,IAAA,OAAA,EAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAA,yBAAA,CAAA,GAAA,EAAA,cAAA,EAAA;AACA,EAAA,MAAA,MAAA,GAAA,EAAA;;AAEA,EAAA,SAAA,aAAA,GAAA;AACA,IAAA,OAAA,MAAA,CAAA,MAAA,CAAA,CAAA,GAAA,EAAA,KAAA,KAAA,GAAA,GAAA,KAAA,CAAA,UAAA,EAAA,CAAA,CAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAA,MAAA,WAAA,GAAA,IAAA,OAAA,EAAA;;AAEA,EAAA,IAAA;AACA;AACA,IAAA,GAAA,CAAA,EAAA,GAAA,IAAA,KAAA,CAAA,GAAA,CAAA,EAAA,EAAA;AACA,MAAA,KAAA,EAAA,CAAA,MAAA,EAAA,OAAA,EAAA,IAAA,KAAA;AACA,QAAA,MAAA,CAAA,KAAA,EAAA,QAAA,EAAA,GAAA,QAAA,CAAA,GAAA,IAAA;;AAEA,QAAA,IAAA,KAAA,KAAA,MAAA,EAAA;AACA,UAAA,MAAA,QAAA,GAAA,IAAA,KAAA,CAAA,QAAA,EAAA;AACA,YAAA,KAAA,EAAA,CAAA,MAAA,EAAA,OAAA,EAAA,IAAA,KAAA;AACA;AACA;AACA,cAAA,IAAA,aAAA,EAAA,GAAA,oBAAA,EAAA;AACA,gBAAA,MAAA,KAAA,GAAA,IAAA,CAAA,CAAA,CAAA;AACA,gBAAA,MAAA,CAAA,IAAA,CAAA,KAAA,CAAA;AACA,eAAA,MAAA,IAAAC,sBAAA,EAAA;AACA,gBAAAC,WAAA,CAAA,GAAA;AACA,kBAAA,CAAA,8DAAA,EAAA,oBAAA,CAAA,cAAA,CAAA;AACA,iBAAA;AACA;;AAEA,cAAA,OAAA,OAAA,CAAA,KAAA,CAAA,MAAA,EAAA,OAAA,EAAA,IAAA,CAAA;AACA,aAAA;AACA,WAAA,CAAA;;AAEA,UAAA,WAAA,CAAA,GAAA,CAAA,QAAA,EAAA,QAAA,CAAA;;AAEA,UAAA,OAAA,OAAA,CAAA,KAAA,CAAA,MAAA,EAAA,OAAA,EAAA,CAAA,KAAA,EAAA,QAAA,EAAA,GAAA,QAAA,CAAA,CAAA;AACA;;AAEA,QAAA,IAAA,KAAA,KAAA,KAAA,EAAA;AACA,UAAA,MAAA,QAAA,GAAA,IAAA,KAAA,CAAA,QAAA,EAAA;AACA,YAAA,KAAA,EAAA,CAAA,MAAA,EAAA,OAAA,EAAA,IAAA,KAAA;AACA,cAAA,IAAA;AACA,gBAAA,MAAA,IAAA,GAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,CAAA,QAAA,CAAA,OAAA,CAAA;;AAEA,gBAAA,IAAA,IAAA,EAAA;AACA,kBAAA,MAAA,iBAAA,GAAA,EAAA,IAAA,EAAA,IAAA,EAAA;AACA,kBAAA,cAAA,CAAA,wBAAA,CAAA,EAAA,iBAAA,EAAA,CAAA;AACA;AACA,eAAA,CAAA,MAAA;AACA;AACA;;AAEA,cAAA,OAAA,OAAA,CAAA,KAAA,CAAA,MAAA,EAAA,OAAA,EAAA,IAAA,CAAA;AACA,aAAA;AACA,WAAA,CAAA;;AAEA,UAAA,WAAA,CAAA,GAAA,CAAA,QAAA,EAAA,QAAA,CAAA;;AAEA,UAAA,OAAA,OAAA,CAAA,KAAA,CAAA,MAAA,EAAA,OAAA,EAAA,CAAA,KAAA,EAAA,QAAA,EAAA,GAAA,QAAA,CAAA,CAAA;AACA;;AAEA,QAAA,OAAA,OAAA,CAAA,KAAA,CAAA,MAAA,EAAA,OAAA,EAAA,IAAA,CAAA;AACA,OAAA;AACA,KAAA,CAAA;;AAEA;AACA;AACA,IAAA,GAAA,CAAA,GAAA,GAAA,IAAA,KAAA,CAAA,GAAA,CAAA,GAAA,EAAA;AACA,MAAA,KAAA,EAAA,CAAA,MAAA,EAAA,OAAA,EAAA,IAAA,KAAA;AACA,QAAA,MAAA,GAAA,QAAA,CAAA,GAAA,IAAA;;AAEA,QAAA,MAAA,QAAA,GAAA,WAAA,CAAA,GAAA,CAAA,QAAA,CAAA;AACA,QAAA,IAAA,QAAA,EAAA;AACA,UAAA,WAAA,CAAA,MAAA,CAAA,QAAA,CAAA;;AAEA,UAAA,MAAA,YAAA,GAAA,IAAA,CAAA,KAAA,EAAA;AACA,UAAA,YAAA,CAAA,CAAA,CAAA,GAAA,QAAA;AACA,UAAA,OAAA,OAAA,CAAA,KAAA,CAAA,MAAA,EAAA,OAAA,EAAA,YAAA,CAAA;AACA;;AAEA,QAAA,OAAA,OAAA,CAAA,KAAA,CAAA,MAAA,EAAA,OAAA,EAAA,IAAA,CAAA;AACA,OAAA;AACA,KAAA,CAAA;AACA,GAAA,CAAA,MAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAA,oBAAA,CAAA;AACA,EAAA,qBAAA;AACA,EAAA,QAAA;AACA,EAAA,sBAAA;AACA;;AAIA,EAAA;AACA,EAAA,qBAAA,CAAA,wBAAA,CAAA;AACA,IAAA,cAAA,EAAA,EAAA,MAAA,EAAA,IAAA,EAAA;AACA,GAAA,CAAA;AACA,EAAA,QAAA,CAAA,IAAA,CAAA,OAAA,EAAA,MAAA;AACA;AACA,IAAA,MAAA,MAAA,GAAAC,cAAA,EAAA;AACA,IAAA,MAAA,cAAA,GAAA,qBAAA,CAAA,YAAA,EAAA,CAAA,qBAAA,CAAA,cAAA;;AAEA,IAAA,IAAA,MAAA,IAAA,cAAA,EAAA;AACA,MAAAF,sBAAA,IAAAC,WAAA,CAAA,KAAA,CAAA,CAAA,sCAAA,EAAA,cAAA,CAAA,MAAA,CAAA,CAAA,CAAA;;AAEA,MAAA,MAAA,WAAA,GAAA,IAAA,IAAA,EAAA;AACA,MAAA,WAAA,CAAA,UAAA,CAAA,CAAA,EAAA,CAAA,CAAA;AACA,MAAA,MAAA,aAAA,GAAA,WAAA,CAAA,WAAA,EAAA;;AAEA,MAAA,MAAA,uBAAA,GAAA,mCAAA,CAAA,GAAA,CAAA,MAAA,CAAA;AACA,MAAA,MAAA,MAAA,GAAA,uBAAA,GAAA,aAAA,CAAA,IAAA,EAAA,MAAA,EAAA,CAAA,EAAA,OAAA,EAAA,CAAA,EAAA,OAAA,EAAA,CAAA,EAAA;AACA,MAAA,MAAA,CAAA,CAAA,EAAA,EAAA,EAAA,QAAA,EAAA,OAAA,EAAA,SAAA,EAAA,OAAA,EAAA,SAAA,EAAA,GAAA,cAAA,CAAA,MAAA,CAAA,CAAA,EAAA;;AAEA,MAAA,IAAA,uBAAA,EAAA;AACA,QAAA,uBAAA,CAAA,aAAA,CAAA,GAAA,MAAA;AACA,OAAA,MAAA;AACA,QAAAD,sBAAA,IAAAC,WAAA,CAAA,KAAA,CAAA,uCAAA,CAAA;AACA,QAAA,MAAA,kBAAA,GAAA,EAAA,CAAA,aAAA,GAAA,MAAA,EAAA;AACA,QAAA,mCAAA,CAAA,GAAA,CAAA,MAAA,EAAA,kBAAA,CAAA;;AAEA,QAAA,MAAA,4BAAA,GAAA,MAAA;AACA,UAAA,YAAA,CAAA,OAAA,CAAA;AACA,UAAA,yBAAA,EAAA;AACA,UAAA,mCAAA,CAAA,MAAA,CAAA,MAAA,CAAA;;AAEA,UAAA,MAAA,gBAAA,GAAA,MAAA,CAAA,OAAA,CAAA,kBAAA,CAAA,CAAA,GAAA;AACA,YAAA,CAAA,CAAA,SAAA,EAAA,KAAA,CAAA,MAAA;AACA,cAAA,OAAA,EAAA,SAAA;AACA,cAAA,MAAA,EAAA,KAAA,CAAA,MAAA;AACA,cAAA,OAAA,EAAA,KAAA,CAAA,OAAA;AACA,cAAA,OAAA,EAAA,KAAA,CAAA,OAAA;AACA,aAAA,CAAA;AACA,WAAA;AACA,UAAA,MAAA,CAAA,WAAA,CAAA,EAAA,UAAA,EAAA,gBAAA,EAAA,CAAA;AACA,SAAA;;AAEA,QAAA,MAAA,yBAAA,GAAA,MAAA,CAAA,EAAA,CAAA,OAAA,EAAA,MAAA;AACA,UAAAD,sBAAA,IAAAC,WAAA,CAAA,KAAA,CAAA,uDAAA,CAAA;AACA,UAAA,4BAAA,EAAA;AACA,SAAA,CAAA;AACA,QAAA,MAAA,OAAA,GAAA,UAAA,CAAA,MAAA;AACA,UAAAD,sBAAA,IAAAC,WAAA,CAAA,KAAA,CAAA,4DAAA,CAAA;AACA,UAAA,4BAAA,EAAA;AACA,SAAA,EAAA,sBAAA,CAAA,CAAA,KAAA,EAAA;AACA;AACA;AACA,GAAA,CAAA;AACA;;AAEA,MAAA,mCAAA,GAAA,IAAA;;AAGA,EAAA;;;;;"}
\ No newline at end of file
diff --git a/build/cjs/integrations/http/SentryHttpInstrumentationBeforeOtel.js b/build/cjs/integrations/http/SentryHttpInstrumentationBeforeOtel.js
index b6fb48556e709d27edbd33d1c00d2e3c75ae1d87..ff795dabc83eb82499a846e493cde062f2acefca 100644
--- a/build/cjs/integrations/http/SentryHttpInstrumentationBeforeOtel.js
+++ b/build/cjs/integrations/http/SentryHttpInstrumentationBeforeOtel.js
@@ -1,8 +1,7 @@
 Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
 
-const core = require('@opentelemetry/core');
 const instrumentation = require('@opentelemetry/instrumentation');
-const core$1 = require('@sentry/core');
+const core = require('@sentry/core');
 const debugBuild = require('../../debug-build.js');
 const utils = require('./utils.js');
 
@@ -22,7 +21,7 @@ const utils = require('./utils.js');
  */
 class SentryHttpInstrumentationBeforeOtel extends instrumentation.InstrumentationBase {
    constructor() {
-    super('@sentry/instrumentation-http-before-otel', core.VERSION, {});
+    super('@sentry/instrumentation-http-before-otel', "2.0.0", {});
   }
 
   // eslint-disable-next-line jsdoc/require-jsdoc
@@ -93,7 +92,7 @@ function patchResponseToFlushOnServerlessPlatforms(res) {
       // eslint-disable-next-line @typescript-eslint/unbound-method
       res.end = new Proxy(res.end, {
         apply(target, thisArg, argArray) {
-          core$1.vercelWaitUntil(
+          core.vercelWaitUntil(
             new Promise(finishWaitUntil => {
               // Define a timeout that unblocks the lambda just to be safe so we're not indefinitely keeping it alive, exploding server bills
               const timeout = setTimeout(() => {
@@ -102,8 +101,8 @@ function patchResponseToFlushOnServerlessPlatforms(res) {
 
               onEndDonePromise
                 .then(() => {
-                  debugBuild.DEBUG_BUILD && core$1.logger.log('Flushing events before Vercel Lambda freeze');
-                  return core$1.flush(2000);
+                  debugBuild.DEBUG_BUILD && core.logger.log('Flushing events before Vercel Lambda freeze');
+                  return core.flush(2000);
                 })
                 .then(
                   () => {
@@ -112,7 +111,7 @@ function patchResponseToFlushOnServerlessPlatforms(res) {
                   },
                   e => {
                     clearTimeout(timeout);
-                    debugBuild.DEBUG_BUILD && core$1.logger.log('Error while flushing events for Vercel:\n', e);
+                    debugBuild.DEBUG_BUILD && core.logger.log('Error while flushing events for Vercel:\n', e);
                     finishWaitUntil();
                   },
                 );
diff --git a/build/cjs/integrations/http/SentryHttpInstrumentationBeforeOtel.js.map b/build/cjs/integrations/http/SentryHttpInstrumentationBeforeOtel.js.map
index 5bafcafc76f50009d55ea90451bc39b811cf90fd..e6a3e37339558e819f415c75e8282f1a2bf0a9bb 100644
--- a/build/cjs/integrations/http/SentryHttpInstrumentationBeforeOtel.js.map
+++ b/build/cjs/integrations/http/SentryHttpInstrumentationBeforeOtel.js.map
@@ -1 +1 @@
-{"version":3,"file":"SentryHttpInstrumentationBeforeOtel.js","sources":["../../../../src/integrations/http/SentryHttpInstrumentationBeforeOtel.ts"],"sourcesContent":["import { VERSION } from '@opentelemetry/core';\nimport { InstrumentationBase, InstrumentationNodeModuleDefinition } from '@opentelemetry/instrumentation';\nimport { flush, logger, vercelWaitUntil } from '@sentry/core';\nimport type * as http from 'node:http';\nimport type * as https from 'node:https';\nimport { DEBUG_BUILD } from '../../debug-build';\nimport { stealthWrap } from './utils';\n\ntype Http = typeof http;\ntype Https = typeof https;\n\n// The reason this \"before OTEL\" integration even exists is due to timing reasons. We need to be able to register a\n// `res.on('close')` handler **after** OTEL registers its own handler (which it uses to end spans), so that we can do\n// something (ie. flush) after OTEL has ended a span for a request. If you think about it like an onion:\n//\n// (Sentry after OTEL instrumentation\n//   (OTEL instrumentation\n//     (Sentry before OTEL instrumentation\n//       (orig HTTP request handler))))\n//\n// registering an instrumentation before OTEL allows us to do this for incoming requests.\n\n/**\n * A Sentry specific http instrumentation that is applied before the otel instrumentation.\n */\nexport class SentryHttpInstrumentationBeforeOtel extends InstrumentationBase {\n  public constructor() {\n    super('@sentry/instrumentation-http-before-otel', VERSION, {});\n  }\n\n  // eslint-disable-next-line jsdoc/require-jsdoc\n  public init(): [InstrumentationNodeModuleDefinition, InstrumentationNodeModuleDefinition] {\n    return [this._getHttpsInstrumentation(), this._getHttpInstrumentation()];\n  }\n\n  /** Get the instrumentation for the http module. */\n  private _getHttpInstrumentation(): InstrumentationNodeModuleDefinition {\n    return new InstrumentationNodeModuleDefinition('http', ['*'], (moduleExports: Http): Http => {\n      // Patch incoming requests\n      stealthWrap(moduleExports.Server.prototype, 'emit', this._getPatchIncomingRequestFunction());\n\n      return moduleExports;\n    });\n  }\n\n  /** Get the instrumentation for the https module. */\n  private _getHttpsInstrumentation(): InstrumentationNodeModuleDefinition {\n    return new InstrumentationNodeModuleDefinition('https', ['*'], (moduleExports: Https): Https => {\n      // Patch incoming requests\n      stealthWrap(moduleExports.Server.prototype, 'emit', this._getPatchIncomingRequestFunction());\n\n      return moduleExports;\n    });\n  }\n\n  /**\n   * Patch the incoming request function for request isolation.\n   */\n  private _getPatchIncomingRequestFunction(): (\n    original: (event: string, ...args: unknown[]) => boolean,\n  ) => (this: unknown, event: string, ...args: unknown[]) => boolean {\n    return (\n      original: (event: string, ...args: unknown[]) => boolean,\n    ): ((this: unknown, event: string, ...args: unknown[]) => boolean) => {\n      return function incomingRequest(this: unknown, ...args: [event: string, ...args: unknown[]]): boolean {\n        // Only traces request events\n        if (args[0] !== 'request') {\n          return original.apply(this, args);\n        }\n\n        const response = args[1] as http.OutgoingMessage;\n\n        patchResponseToFlushOnServerlessPlatforms(response);\n\n        return original.apply(this, args);\n      };\n    };\n  }\n}\n\nfunction patchResponseToFlushOnServerlessPlatforms(res: http.OutgoingMessage): void {\n  // Freely extend this function with other platforms if necessary\n  if (process.env.VERCEL) {\n    // In some cases res.end does not seem to be defined leading to errors if passed to Proxy\n    // https://github.com/getsentry/sentry-javascript/issues/15759\n    if (typeof res.end === 'function') {\n      let markOnEndDone = (): void => undefined;\n      const onEndDonePromise = new Promise<void>(res => {\n        markOnEndDone = res;\n      });\n\n      res.on('close', () => {\n        markOnEndDone();\n      });\n\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      res.end = new Proxy(res.end, {\n        apply(target, thisArg, argArray) {\n          vercelWaitUntil(\n            new Promise<void>(finishWaitUntil => {\n              // Define a timeout that unblocks the lambda just to be safe so we're not indefinitely keeping it alive, exploding server bills\n              const timeout = setTimeout(() => {\n                finishWaitUntil();\n              }, 2000);\n\n              onEndDonePromise\n                .then(() => {\n                  DEBUG_BUILD && logger.log('Flushing events before Vercel Lambda freeze');\n                  return flush(2000);\n                })\n                .then(\n                  () => {\n                    clearTimeout(timeout);\n                    finishWaitUntil();\n                  },\n                  e => {\n                    clearTimeout(timeout);\n                    DEBUG_BUILD && logger.log('Error while flushing events for Vercel:\\n', e);\n                    finishWaitUntil();\n                  },\n                );\n            }),\n          );\n\n          return target.apply(thisArg, argArray);\n        },\n      });\n    }\n  }\n}\n"],"names":["InstrumentationBase","VERSION","InstrumentationNodeModuleDefinition","stealthWrap","vercelWaitUntil","DEBUG_BUILD","logger","flush"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"SentryHttpInstrumentationBeforeOtel.js","sources":["../../../../src/integrations/http/SentryHttpInstrumentationBeforeOtel.ts"],"sourcesContent":["import { InstrumentationBase, InstrumentationNodeModuleDefinition } from '@opentelemetry/instrumentation';\nimport { flush, logger, vercelWaitUntil } from '@sentry/core';\nimport type * as http from 'node:http';\nimport type * as https from 'node:https';\nimport { DEBUG_BUILD } from '../../debug-build';\nimport { stealthWrap } from './utils';\n\ntype Http = typeof http;\ntype Https = typeof https;\n\n// The reason this \"before OTEL\" integration even exists is due to timing reasons. We need to be able to register a\n// `res.on('close')` handler **after** OTEL registers its own handler (which it uses to end spans), so that we can do\n// something (ie. flush) after OTEL has ended a span for a request. If you think about it like an onion:\n//\n// (Sentry after OTEL instrumentation\n//   (OTEL instrumentation\n//     (Sentry before OTEL instrumentation\n//       (orig HTTP request handler))))\n//\n// registering an instrumentation before OTEL allows us to do this for incoming requests.\n\n/**\n * A Sentry specific http instrumentation that is applied before the otel instrumentation.\n */\nexport class SentryHttpInstrumentationBeforeOtel extends InstrumentationBase {\n  public constructor() {\n    super('@sentry/instrumentation-http-before-otel', \"2.0.0\", {});\n  }\n\n  // eslint-disable-next-line jsdoc/require-jsdoc\n  public init(): [InstrumentationNodeModuleDefinition, InstrumentationNodeModuleDefinition] {\n    return [this._getHttpsInstrumentation(), this._getHttpInstrumentation()];\n  }\n\n  /** Get the instrumentation for the http module. */\n  private _getHttpInstrumentation(): InstrumentationNodeModuleDefinition {\n    return new InstrumentationNodeModuleDefinition('http', ['*'], (moduleExports: Http): Http => {\n      // Patch incoming requests\n      stealthWrap(moduleExports.Server.prototype, 'emit', this._getPatchIncomingRequestFunction());\n\n      return moduleExports;\n    });\n  }\n\n  /** Get the instrumentation for the https module. */\n  private _getHttpsInstrumentation(): InstrumentationNodeModuleDefinition {\n    return new InstrumentationNodeModuleDefinition('https', ['*'], (moduleExports: Https): Https => {\n      // Patch incoming requests\n      stealthWrap(moduleExports.Server.prototype, 'emit', this._getPatchIncomingRequestFunction());\n\n      return moduleExports;\n    });\n  }\n\n  /**\n   * Patch the incoming request function for request isolation.\n   */\n  private _getPatchIncomingRequestFunction(): (\n    original: (event: string, ...args: unknown[]) => boolean,\n  ) => (this: unknown, event: string, ...args: unknown[]) => boolean {\n    return (\n      original: (event: string, ...args: unknown[]) => boolean,\n    ): ((this: unknown, event: string, ...args: unknown[]) => boolean) => {\n      return function incomingRequest(this: unknown, ...args: [event: string, ...args: unknown[]]): boolean {\n        // Only traces request events\n        if (args[0] !== 'request') {\n          return original.apply(this, args);\n        }\n\n        const response = args[1] as http.OutgoingMessage;\n\n        patchResponseToFlushOnServerlessPlatforms(response);\n\n        return original.apply(this, args);\n      };\n    };\n  }\n}\n\nfunction patchResponseToFlushOnServerlessPlatforms(res: http.OutgoingMessage): void {\n  // Freely extend this function with other platforms if necessary\n  if (process.env.VERCEL) {\n    // In some cases res.end does not seem to be defined leading to errors if passed to Proxy\n    // https://github.com/getsentry/sentry-javascript/issues/15759\n    if (typeof res.end === 'function') {\n      let markOnEndDone = (): void => undefined;\n      const onEndDonePromise = new Promise<void>(res => {\n        markOnEndDone = res;\n      });\n\n      res.on('close', () => {\n        markOnEndDone();\n      });\n\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      res.end = new Proxy(res.end, {\n        apply(target, thisArg, argArray) {\n          vercelWaitUntil(\n            new Promise<void>(finishWaitUntil => {\n              // Define a timeout that unblocks the lambda just to be safe so we're not indefinitely keeping it alive, exploding server bills\n              const timeout = setTimeout(() => {\n                finishWaitUntil();\n              }, 2000);\n\n              onEndDonePromise\n                .then(() => {\n                  DEBUG_BUILD && logger.log('Flushing events before Vercel Lambda freeze');\n                  return flush(2000);\n                })\n                .then(\n                  () => {\n                    clearTimeout(timeout);\n                    finishWaitUntil();\n                  },\n                  e => {\n                    clearTimeout(timeout);\n                    DEBUG_BUILD && logger.log('Error while flushing events for Vercel:\\n', e);\n                    finishWaitUntil();\n                  },\n                );\n            }),\n          );\n\n          return target.apply(thisArg, argArray);\n        },\n      });\n    }\n  }\n}\n"],"names":["InstrumentationBase","InstrumentationNodeModuleDefinition","stealthWrap","vercelWaitUntil","DEBUG_BUILD","logger","flush"],"mappings":"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"}
\ No newline at end of file
diff --git a/build/cjs/integrations/local-variables/local-variables-async.js b/build/cjs/integrations/local-variables/local-variables-async.js
index c3565cf888473a26f0c2a1e378bdf5dcbcd5d70c..55177854497cbab0e1739bbd9471a94eb24198d4 100644
--- a/build/cjs/integrations/local-variables/local-variables-async.js
+++ b/build/cjs/integrations/local-variables/local-variables-async.js
@@ -6,7 +6,7 @@ const debug = require('../../utils/debug.js');
 const common = require('./common.js');
 
 // This string is a placeholder that gets overwritten with the worker code.
-const base64WorkerScript = 'LyohIEBzZW50cnkvbm9kZSA5LjEyLjAgKDRlYjc4ZTUpIHwgaHR0cHM6Ly9naXRodWIuY29tL2dldHNlbnRyeS9zZW50cnktamF2YXNjcmlwdCAqLwppbXBvcnR7U2Vzc2lvbiBhcyBlfWZyb20ibm9kZTppbnNwZWN0b3IvcHJvbWlzZXMiO2ltcG9ydHt3b3JrZXJEYXRhIGFzIHR9ZnJvbSJub2RlOndvcmtlcl90aHJlYWRzIjtjb25zdCBuPWdsb2JhbFRoaXMsbz0idW5kZWZpbmVkIj09dHlwZW9mIF9fU0VOVFJZX0RFQlVHX198fF9fU0VOVFJZX0RFQlVHX18saT0iOS4xMi4wIjtjb25zdCBhPVsiZGVidWciLCJpbmZvIiwid2FybiIsImVycm9yIiwibG9nIiwiYXNzZXJ0IiwidHJhY2UiXSxzPXt9O2Z1bmN0aW9uIGMoZSl7aWYoISgiY29uc29sZSJpbiBuKSlyZXR1cm4gZSgpO2NvbnN0IHQ9bi5jb25zb2xlLG89e30saT1PYmplY3Qua2V5cyhzKTtpLmZvckVhY2goKGU9Pntjb25zdCBuPXNbZV07b1tlXT10W2VdLHRbZV09bn0pKTt0cnl7cmV0dXJuIGUoKX1maW5hbGx5e2kuZm9yRWFjaCgoZT0+e3RbZV09b1tlXX0pKX19IWZ1bmN0aW9uKGUsdCxvPW4pe2NvbnN0IGE9by5fX1NFTlRSWV9fPW8uX19TRU5UUllfX3x8e30scz1hW2ldPWFbaV18fHt9O3NbZV18fChzW2VdPXQoKSl9KCJsb2dnZXIiLChmdW5jdGlvbigpe2xldCBlPSExO2NvbnN0IHQ9e2VuYWJsZTooKT0+e2U9ITB9LGRpc2FibGU6KCk9PntlPSExfSxpc0VuYWJsZWQ6KCk9PmV9O3JldHVybiBvP2EuZm9yRWFjaCgobz0+e3Rbb109KC4uLnQpPT57ZSYmYygoKCk9PntuLmNvbnNvbGVbb10oYFNlbnRyeSBMb2dnZXIgWyR7b31dOmAsLi4udCl9KSl9fSkpOmEuZm9yRWFjaCgoZT0+e3RbZV09KCk9Pnt9fSkpLHR9KSk7Y29uc3Qgcj0iX19TRU5UUllfRVJST1JfTE9DQUxfVkFSSUFCTEVTX18iO2NvbnN0IHU9dDtmdW5jdGlvbiBsKC4uLmUpe3UuZGVidWcmJmMoKCgpPT5jb25zb2xlLmxvZygiW0xvY2FsVmFyaWFibGVzIFdvcmtlcl0iLC4uLmUpKSl9YXN5bmMgZnVuY3Rpb24gZihlLHQsbixvKXtjb25zdCBpPWF3YWl0IGUucG9zdCgiUnVudGltZS5nZXRQcm9wZXJ0aWVzIix7b2JqZWN0SWQ6dCxvd25Qcm9wZXJ0aWVzOiEwfSk7b1tuXT1pLnJlc3VsdC5maWx0ZXIoKGU9PiJsZW5ndGgiIT09ZS5uYW1lJiYhaXNOYU4ocGFyc2VJbnQoZS5uYW1lLDEwKSkpKS5zb3J0KCgoZSx0KT0+cGFyc2VJbnQoZS5uYW1lLDEwKS1wYXJzZUludCh0Lm5hbWUsMTApKSkubWFwKChlPT5lLnZhbHVlPy52YWx1ZSkpfWFzeW5jIGZ1bmN0aW9uIGcoZSx0LG4sbyl7Y29uc3QgaT1hd2FpdCBlLnBvc3QoIlJ1bnRpbWUuZ2V0UHJvcGVydGllcyIse29iamVjdElkOnQsb3duUHJvcGVydGllczohMH0pO29bbl09aS5yZXN1bHQubWFwKChlPT5bZS5uYW1lLGUudmFsdWU/LnZhbHVlXSkpLnJlZHVjZSgoKGUsW3Qsbl0pPT4oZVt0XT1uLGUpKSx7fSl9ZnVuY3Rpb24gZChlLHQpe2UudmFsdWUmJigidmFsdWUiaW4gZS52YWx1ZT92b2lkIDA9PT1lLnZhbHVlLnZhbHVlfHxudWxsPT09ZS52YWx1ZS52YWx1ZT90W2UubmFtZV09YDwke2UudmFsdWUudmFsdWV9PmA6dFtlLm5hbWVdPWUudmFsdWUudmFsdWU6ImRlc2NyaXB0aW9uImluIGUudmFsdWUmJiJmdW5jdGlvbiIhPT1lLnZhbHVlLnR5cGU/dFtlLm5hbWVdPWA8JHtlLnZhbHVlLmRlc2NyaXB0aW9ufT5gOiJ1bmRlZmluZWQiPT09ZS52YWx1ZS50eXBlJiYodFtlLm5hbWVdPSI8dW5kZWZpbmVkPiIpKX1hc3luYyBmdW5jdGlvbiBiKGUsdCl7Y29uc3Qgbj1hd2FpdCBlLnBvc3QoIlJ1bnRpbWUuZ2V0UHJvcGVydGllcyIse29iamVjdElkOnQsb3duUHJvcGVydGllczohMH0pLG89e307Zm9yKGNvbnN0IHQgb2Ygbi5yZXN1bHQpaWYodC52YWx1ZT8ub2JqZWN0SWQmJiJBcnJheSI9PT10LnZhbHVlLmNsYXNzTmFtZSl7Y29uc3Qgbj10LnZhbHVlLm9iamVjdElkO2F3YWl0IGYoZSxuLHQubmFtZSxvKX1lbHNlIGlmKHQudmFsdWU/Lm9iamVjdElkJiYiT2JqZWN0Ij09PXQudmFsdWUuY2xhc3NOYW1lKXtjb25zdCBuPXQudmFsdWUub2JqZWN0SWQ7YXdhaXQgZyhlLG4sdC5uYW1lLG8pfWVsc2UgdC52YWx1ZSYmZCh0LG8pO3JldHVybiBvfWxldCBwOyhhc3luYyBmdW5jdGlvbigpe2NvbnN0IHQ9bmV3IGU7dC5jb25uZWN0VG9NYWluVGhyZWFkKCksbCgiQ29ubmVjdGVkIHRvIG1haW4gdGhyZWFkIik7bGV0IG49ITE7dC5vbigiRGVidWdnZXIucmVzdW1lZCIsKCgpPT57bj0hMX0pKSx0Lm9uKCJEZWJ1Z2dlci5wYXVzZWQiLChlPT57bj0hMCxhc3luYyBmdW5jdGlvbihlLHtyZWFzb246dCxkYXRhOntvYmplY3RJZDpufSxjYWxsRnJhbWVzOm99KXtpZigiZXhjZXB0aW9uIiE9PXQmJiJwcm9taXNlUmVqZWN0aW9uIiE9PXQpcmV0dXJuO2lmKHA/LigpLG51bGw9PW4pcmV0dXJuO2NvbnN0IGk9W107Zm9yKGxldCB0PTA7dDxvLmxlbmd0aDt0Kyspe2NvbnN0e3Njb3BlQ2hhaW46bixmdW5jdGlvbk5hbWU6YSx0aGlzOnN9PW9bdF0sYz1uLmZpbmQoKGU9PiJsb2NhbCI9PT1lLnR5cGUpKSxyPSJnbG9iYWwiIT09cy5jbGFzc05hbWUmJnMuY2xhc3NOYW1lP2Ake3MuY2xhc3NOYW1lfS4ke2F9YDphO2lmKHZvaWQgMD09PWM/Lm9iamVjdC5vYmplY3RJZClpW3RdPXtmdW5jdGlvbjpyfTtlbHNle2NvbnN0IG49YXdhaXQgYihlLGMub2JqZWN0Lm9iamVjdElkKTtpW3RdPXtmdW5jdGlvbjpyLHZhcnM6bn19fWF3YWl0IGUucG9zdCgiUnVudGltZS5jYWxsRnVuY3Rpb25PbiIse2Z1bmN0aW9uRGVjbGFyYXRpb246YGZ1bmN0aW9uKCkgeyB0aGlzLiR7cn0gPSB0aGlzLiR7cn0gfHwgJHtKU09OLnN0cmluZ2lmeShpKX07IH1gLHNpbGVudDohMCxvYmplY3RJZDpufSksYXdhaXQgZS5wb3N0KCJSdW50aW1lLnJlbGVhc2VPYmplY3QiLHtvYmplY3RJZDpufSl9KHQsZS5wYXJhbXMpLnRoZW4oKGFzeW5jKCk9PntuJiZhd2FpdCB0LnBvc3QoIkRlYnVnZ2VyLnJlc3VtZSIpfSksKGFzeW5jIGU9PntuJiZhd2FpdCB0LnBvc3QoIkRlYnVnZ2VyLnJlc3VtZSIpfSkpfSkpLGF3YWl0IHQucG9zdCgiRGVidWdnZXIuZW5hYmxlIik7Y29uc3Qgbz0hMSE9PXUuY2FwdHVyZUFsbEV4Y2VwdGlvbnM7aWYoYXdhaXQgdC5wb3N0KCJEZWJ1Z2dlci5zZXRQYXVzZU9uRXhjZXB0aW9ucyIse3N0YXRlOm8/ImFsbCI6InVuY2F1Z2h0In0pLG8pe2NvbnN0IGU9dS5tYXhFeGNlcHRpb25zUGVyU2Vjb25kfHw1MDtwPWZ1bmN0aW9uKGUsdCxuKXtsZXQgbz0wLGk9NSxhPTA7cmV0dXJuIHNldEludGVydmFsKCgoKT0+ezA9PT1hP28+ZSYmKGkqPTIsbihpKSxpPjg2NDAwJiYoaT04NjQwMCksYT1pKTooYS09MSwwPT09YSYmdCgpKSxvPTB9KSwxZTMpLnVucmVmKCksKCk9PntvKz0xfX0oZSwoYXN5bmMoKT0+e2woIlJhdGUtbGltaXQgbGlmdGVkLiIpLGF3YWl0IHQucG9zdCgiRGVidWdnZXIuc2V0UGF1c2VPbkV4Y2VwdGlvbnMiLHtzdGF0ZToiYWxsIn0pfSksKGFzeW5jIGU9PntsKGBSYXRlLWxpbWl0IGV4Y2VlZGVkLiBEaXNhYmxpbmcgY2FwdHVyaW5nIG9mIGNhdWdodCBleGNlcHRpb25zIGZvciAke2V9IHNlY29uZHMuYCksYXdhaXQgdC5wb3N0KCJEZWJ1Z2dlci5zZXRQYXVzZU9uRXhjZXB0aW9ucyIse3N0YXRlOiJ1bmNhdWdodCJ9KX0pKX19KSgpLmNhdGNoKChlPT57bCgiRmFpbGVkIHRvIHN0YXJ0IGRlYnVnZ2VyIixlKX0pKSxzZXRJbnRlcnZhbCgoKCk9Pnt9KSwxZTQpOw==';
+const base64WorkerScript = 'LyohIEBzZW50cnkvbm9kZSA5LjEyLjAgKDJjZjUzMjJkOSkgfCBodHRwczovL2dpdGh1Yi5jb20vZ2V0c2VudHJ5L3NlbnRyeS1qYXZhc2NyaXB0ICovCmltcG9ydHtTZXNzaW9uIGFzIGV9ZnJvbSJub2RlOmluc3BlY3Rvci9wcm9taXNlcyI7aW1wb3J0e3dvcmtlckRhdGEgYXMgdH1mcm9tIm5vZGU6d29ya2VyX3RocmVhZHMiO2NvbnN0IG49Z2xvYmFsVGhpcyxvPSJ1bmRlZmluZWQiPT10eXBlb2YgX19TRU5UUllfREVCVUdfX3x8X19TRU5UUllfREVCVUdfXyxpPSI5LjEyLjAiO2NvbnN0IGE9WyJkZWJ1ZyIsImluZm8iLCJ3YXJuIiwiZXJyb3IiLCJsb2ciLCJhc3NlcnQiLCJ0cmFjZSJdLHM9e307ZnVuY3Rpb24gYyhlKXtpZighKCJjb25zb2xlImluIG4pKXJldHVybiBlKCk7Y29uc3QgdD1uLmNvbnNvbGUsbz17fSxpPU9iamVjdC5rZXlzKHMpO2kuZm9yRWFjaCgoZT0+e2NvbnN0IG49c1tlXTtvW2VdPXRbZV0sdFtlXT1ufSkpO3RyeXtyZXR1cm4gZSgpfWZpbmFsbHl7aS5mb3JFYWNoKChlPT57dFtlXT1vW2VdfSkpfX0hZnVuY3Rpb24oZSx0LG89bil7Y29uc3QgYT1vLl9fU0VOVFJZX189by5fX1NFTlRSWV9ffHx7fSxzPWFbaV09YVtpXXx8e307c1tlXXx8KHNbZV09dCgpKX0oImxvZ2dlciIsKGZ1bmN0aW9uKCl7bGV0IGU9ITE7Y29uc3QgdD17ZW5hYmxlOigpPT57ZT0hMH0sZGlzYWJsZTooKT0+e2U9ITF9LGlzRW5hYmxlZDooKT0+ZX07cmV0dXJuIG8/YS5mb3JFYWNoKChvPT57dFtvXT0oLi4udCk9PntlJiZjKCgoKT0+e24uY29uc29sZVtvXShgU2VudHJ5IExvZ2dlciBbJHtvfV06YCwuLi50KX0pKX19KSk6YS5mb3JFYWNoKChlPT57dFtlXT0oKT0+e319KSksdH0pKTtjb25zdCByPSJfX1NFTlRSWV9FUlJPUl9MT0NBTF9WQVJJQUJMRVNfXyI7Y29uc3QgdT10O2Z1bmN0aW9uIGwoLi4uZSl7dS5kZWJ1ZyYmYygoKCk9PmNvbnNvbGUubG9nKCJbTG9jYWxWYXJpYWJsZXMgV29ya2VyXSIsLi4uZSkpKX1hc3luYyBmdW5jdGlvbiBmKGUsdCxuLG8pe2NvbnN0IGk9YXdhaXQgZS5wb3N0KCJSdW50aW1lLmdldFByb3BlcnRpZXMiLHtvYmplY3RJZDp0LG93blByb3BlcnRpZXM6ITB9KTtvW25dPWkucmVzdWx0LmZpbHRlcigoZT0+Imxlbmd0aCIhPT1lLm5hbWUmJiFpc05hTihwYXJzZUludChlLm5hbWUsMTApKSkpLnNvcnQoKChlLHQpPT5wYXJzZUludChlLm5hbWUsMTApLXBhcnNlSW50KHQubmFtZSwxMCkpKS5tYXAoKGU9PmUudmFsdWU/LnZhbHVlKSl9YXN5bmMgZnVuY3Rpb24gZyhlLHQsbixvKXtjb25zdCBpPWF3YWl0IGUucG9zdCgiUnVudGltZS5nZXRQcm9wZXJ0aWVzIix7b2JqZWN0SWQ6dCxvd25Qcm9wZXJ0aWVzOiEwfSk7b1tuXT1pLnJlc3VsdC5tYXAoKGU9PltlLm5hbWUsZS52YWx1ZT8udmFsdWVdKSkucmVkdWNlKCgoZSxbdCxuXSk9PihlW3RdPW4sZSkpLHt9KX1mdW5jdGlvbiBkKGUsdCl7ZS52YWx1ZSYmKCJ2YWx1ZSJpbiBlLnZhbHVlP3ZvaWQgMD09PWUudmFsdWUudmFsdWV8fG51bGw9PT1lLnZhbHVlLnZhbHVlP3RbZS5uYW1lXT1gPCR7ZS52YWx1ZS52YWx1ZX0+YDp0W2UubmFtZV09ZS52YWx1ZS52YWx1ZToiZGVzY3JpcHRpb24iaW4gZS52YWx1ZSYmImZ1bmN0aW9uIiE9PWUudmFsdWUudHlwZT90W2UubmFtZV09YDwke2UudmFsdWUuZGVzY3JpcHRpb259PmA6InVuZGVmaW5lZCI9PT1lLnZhbHVlLnR5cGUmJih0W2UubmFtZV09Ijx1bmRlZmluZWQ+IikpfWFzeW5jIGZ1bmN0aW9uIGIoZSx0KXtjb25zdCBuPWF3YWl0IGUucG9zdCgiUnVudGltZS5nZXRQcm9wZXJ0aWVzIix7b2JqZWN0SWQ6dCxvd25Qcm9wZXJ0aWVzOiEwfSksbz17fTtmb3IoY29uc3QgdCBvZiBuLnJlc3VsdClpZih0LnZhbHVlPy5vYmplY3RJZCYmIkFycmF5Ij09PXQudmFsdWUuY2xhc3NOYW1lKXtjb25zdCBuPXQudmFsdWUub2JqZWN0SWQ7YXdhaXQgZihlLG4sdC5uYW1lLG8pfWVsc2UgaWYodC52YWx1ZT8ub2JqZWN0SWQmJiJPYmplY3QiPT09dC52YWx1ZS5jbGFzc05hbWUpe2NvbnN0IG49dC52YWx1ZS5vYmplY3RJZDthd2FpdCBnKGUsbix0Lm5hbWUsbyl9ZWxzZSB0LnZhbHVlJiZkKHQsbyk7cmV0dXJuIG99bGV0IHA7KGFzeW5jIGZ1bmN0aW9uKCl7Y29uc3QgdD1uZXcgZTt0LmNvbm5lY3RUb01haW5UaHJlYWQoKSxsKCJDb25uZWN0ZWQgdG8gbWFpbiB0aHJlYWQiKTtsZXQgbj0hMTt0Lm9uKCJEZWJ1Z2dlci5yZXN1bWVkIiwoKCk9PntuPSExfSkpLHQub24oIkRlYnVnZ2VyLnBhdXNlZCIsKGU9PntuPSEwLGFzeW5jIGZ1bmN0aW9uKGUse3JlYXNvbjp0LGRhdGE6e29iamVjdElkOm59LGNhbGxGcmFtZXM6b30pe2lmKCJleGNlcHRpb24iIT09dCYmInByb21pc2VSZWplY3Rpb24iIT09dClyZXR1cm47aWYocD8uKCksbnVsbD09bilyZXR1cm47Y29uc3QgaT1bXTtmb3IobGV0IHQ9MDt0PG8ubGVuZ3RoO3QrKyl7Y29uc3R7c2NvcGVDaGFpbjpuLGZ1bmN0aW9uTmFtZTphLHRoaXM6c309b1t0XSxjPW4uZmluZCgoZT0+ImxvY2FsIj09PWUudHlwZSkpLHI9Imdsb2JhbCIhPT1zLmNsYXNzTmFtZSYmcy5jbGFzc05hbWU/YCR7cy5jbGFzc05hbWV9LiR7YX1gOmE7aWYodm9pZCAwPT09Yz8ub2JqZWN0Lm9iamVjdElkKWlbdF09e2Z1bmN0aW9uOnJ9O2Vsc2V7Y29uc3Qgbj1hd2FpdCBiKGUsYy5vYmplY3Qub2JqZWN0SWQpO2lbdF09e2Z1bmN0aW9uOnIsdmFyczpufX19YXdhaXQgZS5wb3N0KCJSdW50aW1lLmNhbGxGdW5jdGlvbk9uIix7ZnVuY3Rpb25EZWNsYXJhdGlvbjpgZnVuY3Rpb24oKSB7IHRoaXMuJHtyfSA9IHRoaXMuJHtyfSB8fCAke0pTT04uc3RyaW5naWZ5KGkpfTsgfWAsc2lsZW50OiEwLG9iamVjdElkOm59KSxhd2FpdCBlLnBvc3QoIlJ1bnRpbWUucmVsZWFzZU9iamVjdCIse29iamVjdElkOm59KX0odCxlLnBhcmFtcykudGhlbigoYXN5bmMoKT0+e24mJmF3YWl0IHQucG9zdCgiRGVidWdnZXIucmVzdW1lIil9KSwoYXN5bmMgZT0+e24mJmF3YWl0IHQucG9zdCgiRGVidWdnZXIucmVzdW1lIil9KSl9KSksYXdhaXQgdC5wb3N0KCJEZWJ1Z2dlci5lbmFibGUiKTtjb25zdCBvPSExIT09dS5jYXB0dXJlQWxsRXhjZXB0aW9ucztpZihhd2FpdCB0LnBvc3QoIkRlYnVnZ2VyLnNldFBhdXNlT25FeGNlcHRpb25zIix7c3RhdGU6bz8iYWxsIjoidW5jYXVnaHQifSksbyl7Y29uc3QgZT11Lm1heEV4Y2VwdGlvbnNQZXJTZWNvbmR8fDUwO3A9ZnVuY3Rpb24oZSx0LG4pe2xldCBvPTAsaT01LGE9MDtyZXR1cm4gc2V0SW50ZXJ2YWwoKCgpPT57MD09PWE/bz5lJiYoaSo9MixuKGkpLGk+ODY0MDAmJihpPTg2NDAwKSxhPWkpOihhLT0xLDA9PT1hJiZ0KCkpLG89MH0pLDFlMykudW5yZWYoKSwoKT0+e28rPTF9fShlLChhc3luYygpPT57bCgiUmF0ZS1saW1pdCBsaWZ0ZWQuIiksYXdhaXQgdC5wb3N0KCJEZWJ1Z2dlci5zZXRQYXVzZU9uRXhjZXB0aW9ucyIse3N0YXRlOiJhbGwifSl9KSwoYXN5bmMgZT0+e2woYFJhdGUtbGltaXQgZXhjZWVkZWQuIERpc2FibGluZyBjYXB0dXJpbmcgb2YgY2F1Z2h0IGV4Y2VwdGlvbnMgZm9yICR7ZX0gc2Vjb25kcy5gKSxhd2FpdCB0LnBvc3QoIkRlYnVnZ2VyLnNldFBhdXNlT25FeGNlcHRpb25zIix7c3RhdGU6InVuY2F1Z2h0In0pfSkpfX0pKCkuY2F0Y2goKGU9PntsKCJGYWlsZWQgdG8gc3RhcnQgZGVidWdnZXIiLGUpfSkpLHNldEludGVydmFsKCgoKT0+e30pLDFlNCk7';
 
 function log(...args) {
   core.logger.log('[LocalVariables]', ...args);
diff --git a/build/cjs/integrations/node-fetch/SentryNodeFetchInstrumentation.js b/build/cjs/integrations/node-fetch/SentryNodeFetchInstrumentation.js
index 82d1e25ee3f7da9c71bf429133b0a5118c7b0703..75d18cedd8314ec952e6d703962d7dbb257a0624 100644
--- a/build/cjs/integrations/node-fetch/SentryNodeFetchInstrumentation.js
+++ b/build/cjs/integrations/node-fetch/SentryNodeFetchInstrumentation.js
@@ -1,8 +1,7 @@
 Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
 
-const core = require('@opentelemetry/core');
 const instrumentation = require('@opentelemetry/instrumentation');
-const core$1 = require('@sentry/core');
+const core = require('@sentry/core');
 const opentelemetry = require('@sentry/opentelemetry');
 const diagch = require('diagnostics_channel');
 const nodeVersion = require('../../nodeVersion.js');
@@ -29,9 +28,9 @@ class SentryNodeFetchInstrumentation extends instrumentation.InstrumentationBase
   // unsubscribing.
 
    constructor(config = {}) {
-    super('@sentry/instrumentation-node-fetch', core.VERSION, config);
+    super('@sentry/instrumentation-node-fetch', '2.0.0', config);
     this._channelSubs = [];
-    this._propagationDecisionMap = new core$1.LRUMap(100);
+    this._propagationDecisionMap = new core.LRUMap(100);
   }
 
   /** No need to instrument files/modules. */
@@ -97,9 +96,9 @@ class SentryNodeFetchInstrumentation extends instrumentation.InstrumentationBase
     // Note: We do not use `propagation.inject()` here, because our propagator relies on an active span
     // Which we do not have in this case
     // The propagator _may_ overwrite this, but this should be fine as it is the same data
-    const tracePropagationTargets = core$1.getClient()?.getOptions().tracePropagationTargets;
+    const tracePropagationTargets = core.getClient()?.getOptions().tracePropagationTargets;
     const addedHeaders = opentelemetry.shouldPropagateTraceForUrl(url, tracePropagationTargets, this._propagationDecisionMap)
-      ? core$1.getTraceData()
+      ? core.getTraceData()
       : undefined;
 
     if (!addedHeaders) {
@@ -205,9 +204,9 @@ function addRequestBreadcrumb(request, response) {
   const data = getBreadcrumbData(request);
 
   const statusCode = response.statusCode;
-  const level = core$1.getBreadcrumbLogLevelFromHttpStatusCode(statusCode);
+  const level = core.getBreadcrumbLogLevelFromHttpStatusCode(statusCode);
 
-  core$1.addBreadcrumb(
+  core.addBreadcrumb(
     {
       category: 'http',
       data: {
@@ -228,10 +227,10 @@ function addRequestBreadcrumb(request, response) {
 function getBreadcrumbData(request) {
   try {
     const url = getAbsoluteUrl(request.origin, request.path);
-    const parsedUrl = core$1.parseUrl(url);
+    const parsedUrl = core.parseUrl(url);
 
     const data = {
-      url: core$1.getSanitizedUrlString(parsedUrl),
+      url: core.getSanitizedUrlString(parsedUrl),
       'http.method': request.method || 'GET',
     };
 
diff --git a/build/cjs/integrations/node-fetch/SentryNodeFetchInstrumentation.js.map b/build/cjs/integrations/node-fetch/SentryNodeFetchInstrumentation.js.map
index 241a8bc33db09f82cf2fe68e5e7fbf60f6a57d20..e7be198fabcab60d795925c9375b20e0329b0529 100644
--- a/build/cjs/integrations/node-fetch/SentryNodeFetchInstrumentation.js.map
+++ b/build/cjs/integrations/node-fetch/SentryNodeFetchInstrumentation.js.map
@@ -1 +1 @@
-{"version":3,"file":"SentryNodeFetchInstrumentation.js","sources":["../../../../src/integrations/node-fetch/SentryNodeFetchInstrumentation.ts"],"sourcesContent":["import { VERSION } from '@opentelemetry/core';\nimport type { InstrumentationConfig } from '@opentelemetry/instrumentation';\nimport { InstrumentationBase } from '@opentelemetry/instrumentation';\nimport type { SanitizedRequestData } from '@sentry/core';\nimport { LRUMap, getClient, getTraceData } from '@sentry/core';\nimport { addBreadcrumb, getBreadcrumbLogLevelFromHttpStatusCode, getSanitizedUrlString, parseUrl } from '@sentry/core';\nimport { shouldPropagateTraceForUrl } from '@sentry/opentelemetry';\nimport * as diagch from 'diagnostics_channel';\nimport { NODE_MAJOR, NODE_MINOR } from '../../nodeVersion';\nimport { mergeBaggageHeaders } from '../../utils/baggage';\nimport type { UndiciRequest, UndiciResponse } from './types';\n\nconst SENTRY_TRACE_HEADER = 'sentry-trace';\nconst SENTRY_BAGGAGE_HEADER = 'baggage';\n\n// For baggage, we make sure to merge this into a possibly existing header\nconst BAGGAGE_HEADER_REGEX = /baggage: (.*)\\r\\n/;\n\nexport type SentryNodeFetchInstrumentationOptions = InstrumentationConfig & {\n  /**\n   * Whether breadcrumbs should be recorded for requests.\n   *\n   * @default `true`\n   */\n  breadcrumbs?: boolean;\n\n  /**\n   * Do not capture breadcrumbs or inject headers for outgoing fetch requests to URLs where the given callback returns `true`.\n   * The same option can be passed to the top-level httpIntegration where it controls both, breadcrumb and\n   * span creation.\n   *\n   * @param url Contains the entire URL, including query string (if any), protocol, host, etc. of the outgoing request.\n   */\n  ignoreOutgoingRequests?: (url: string) => boolean;\n};\n\ninterface ListenerRecord {\n  name: string;\n  unsubscribe: () => void;\n}\n\n/**\n * This custom node-fetch instrumentation is used to instrument outgoing fetch requests.\n * It does not emit any spans.\n *\n * The reason this is isolated from the OpenTelemetry instrumentation is that users may overwrite this,\n * which would lead to Sentry not working as expected.\n *\n * This is heavily inspired & adapted from:\n * https://github.com/open-telemetry/opentelemetry-js-contrib/blob/28e209a9da36bc4e1f8c2b0db7360170ed46cb80/plugins/node/instrumentation-undici/src/undici.ts\n */\nexport class SentryNodeFetchInstrumentation extends InstrumentationBase<SentryNodeFetchInstrumentationOptions> {\n  // Keep ref to avoid https://github.com/nodejs/node/issues/42170 bug and for\n  // unsubscribing.\n  private _channelSubs: Array<ListenerRecord>;\n  private _propagationDecisionMap: LRUMap<string, boolean>;\n\n  public constructor(config: SentryNodeFetchInstrumentationOptions = {}) {\n    super('@sentry/instrumentation-node-fetch', VERSION, config);\n    this._channelSubs = [];\n    this._propagationDecisionMap = new LRUMap<string, boolean>(100);\n  }\n\n  /** No need to instrument files/modules. */\n  public init(): void {\n    return undefined;\n  }\n\n  /** Disable the instrumentation. */\n  public disable(): void {\n    super.disable();\n    this._channelSubs.forEach(sub => sub.unsubscribe());\n    this._channelSubs = [];\n  }\n\n  /** Enable the instrumentation. */\n  public enable(): void {\n    // \"enabled\" handling is currently a bit messy with InstrumentationBase.\n    // If constructed with `{enabled: false}`, this `.enable()` is still called,\n    // and `this.getConfig().enabled !== this.isEnabled()`, creating confusion.\n    //\n    // For now, this class will setup for instrumenting if `.enable()` is\n    // called, but use `this.getConfig().enabled` to determine if\n    // instrumentation should be generated. This covers the more likely common\n    // case of config being given a construction time, rather than later via\n    // `instance.enable()`, `.disable()`, or `.setConfig()` calls.\n    super.enable();\n\n    // This method is called by the super-class constructor before ours is\n    // called. So we need to ensure the property is initalized.\n    this._channelSubs = this._channelSubs || [];\n\n    // Avoid to duplicate subscriptions\n    if (this._channelSubs.length > 0) {\n      return;\n    }\n\n    this._subscribeToChannel('undici:request:create', this._onRequestCreated.bind(this));\n    this._subscribeToChannel('undici:request:headers', this._onResponseHeaders.bind(this));\n  }\n\n  /**\n   * This method is called when a request is created.\n   * You can still mutate the request here before it is sent.\n   */\n  private _onRequestCreated({ request }: { request: UndiciRequest }): void {\n    const config = this.getConfig();\n    const enabled = config.enabled !== false;\n\n    if (!enabled) {\n      return;\n    }\n\n    // Add trace propagation headers\n    const url = getAbsoluteUrl(request.origin, request.path);\n    const _ignoreOutgoingRequests = config.ignoreOutgoingRequests;\n    const shouldIgnore = _ignoreOutgoingRequests && url && _ignoreOutgoingRequests(url);\n\n    if (shouldIgnore) {\n      return;\n    }\n\n    // Manually add the trace headers, if it applies\n    // Note: We do not use `propagation.inject()` here, because our propagator relies on an active span\n    // Which we do not have in this case\n    // The propagator _may_ overwrite this, but this should be fine as it is the same data\n    const tracePropagationTargets = getClient()?.getOptions().tracePropagationTargets;\n    const addedHeaders = shouldPropagateTraceForUrl(url, tracePropagationTargets, this._propagationDecisionMap)\n      ? getTraceData()\n      : undefined;\n\n    if (!addedHeaders) {\n      return;\n    }\n\n    const { 'sentry-trace': sentryTrace, baggage } = addedHeaders;\n\n    // We do not want to overwrite existing headers here\n    // If the core UndiciInstrumentation is registered, it will already have set the headers\n    // We do not want to add any then\n    if (Array.isArray(request.headers)) {\n      const requestHeaders = request.headers;\n\n      // We do not want to overwrite existing header here, if it was already set\n      if (sentryTrace && !requestHeaders.includes(SENTRY_TRACE_HEADER)) {\n        requestHeaders.push(SENTRY_TRACE_HEADER, sentryTrace);\n      }\n\n      // For baggage, we make sure to merge this into a possibly existing header\n      const existingBaggagePos = requestHeaders.findIndex(header => header === SENTRY_BAGGAGE_HEADER);\n      if (baggage && existingBaggagePos === -1) {\n        requestHeaders.push(SENTRY_BAGGAGE_HEADER, baggage);\n      } else if (baggage) {\n        const existingBaggage = requestHeaders[existingBaggagePos + 1];\n        const merged = mergeBaggageHeaders(existingBaggage, baggage);\n        if (merged) {\n          requestHeaders[existingBaggagePos + 1] = merged;\n        }\n      }\n    } else {\n      const requestHeaders = request.headers;\n      // We do not want to overwrite existing header here, if it was already set\n      if (sentryTrace && !requestHeaders.includes(`${SENTRY_TRACE_HEADER}:`)) {\n        request.headers += `${SENTRY_TRACE_HEADER}: ${sentryTrace}\\r\\n`;\n      }\n\n      const existingBaggage = request.headers.match(BAGGAGE_HEADER_REGEX)?.[1];\n      if (baggage && !existingBaggage) {\n        request.headers += `${SENTRY_BAGGAGE_HEADER}: ${baggage}\\r\\n`;\n      } else if (baggage) {\n        const merged = mergeBaggageHeaders(existingBaggage, baggage);\n        if (merged) {\n          request.headers = request.headers.replace(BAGGAGE_HEADER_REGEX, `baggage: ${merged}\\r\\n`);\n        }\n      }\n    }\n  }\n\n  /**\n   * This method is called when a response is received.\n   */\n  private _onResponseHeaders({ request, response }: { request: UndiciRequest; response: UndiciResponse }): void {\n    const config = this.getConfig();\n    const enabled = config.enabled !== false;\n\n    if (!enabled) {\n      return;\n    }\n\n    const _breadcrumbs = config.breadcrumbs;\n    const breadCrumbsEnabled = typeof _breadcrumbs === 'undefined' ? true : _breadcrumbs;\n\n    const _ignoreOutgoingRequests = config.ignoreOutgoingRequests;\n    const shouldCreateBreadcrumb =\n      typeof _ignoreOutgoingRequests === 'function'\n        ? !_ignoreOutgoingRequests(getAbsoluteUrl(request.origin, request.path))\n        : true;\n\n    if (breadCrumbsEnabled && shouldCreateBreadcrumb) {\n      addRequestBreadcrumb(request, response);\n    }\n  }\n\n  /** Subscribe to a diagnostics channel. */\n  private _subscribeToChannel(\n    diagnosticChannel: string,\n    onMessage: (message: unknown, name: string | symbol) => void,\n  ): void {\n    // `diagnostics_channel` had a ref counting bug until v18.19.0.\n    // https://github.com/nodejs/node/pull/47520\n    const useNewSubscribe = NODE_MAJOR > 18 || (NODE_MAJOR === 18 && NODE_MINOR >= 19);\n\n    let unsubscribe: () => void;\n    if (useNewSubscribe) {\n      diagch.subscribe?.(diagnosticChannel, onMessage);\n      unsubscribe = () => diagch.unsubscribe?.(diagnosticChannel, onMessage);\n    } else {\n      const channel = diagch.channel(diagnosticChannel);\n      channel.subscribe(onMessage);\n      unsubscribe = () => channel.unsubscribe(onMessage);\n    }\n\n    this._channelSubs.push({\n      name: diagnosticChannel,\n      unsubscribe,\n    });\n  }\n}\n\n/** Add a breadcrumb for outgoing requests. */\nfunction addRequestBreadcrumb(request: UndiciRequest, response: UndiciResponse): void {\n  const data = getBreadcrumbData(request);\n\n  const statusCode = response.statusCode;\n  const level = getBreadcrumbLogLevelFromHttpStatusCode(statusCode);\n\n  addBreadcrumb(\n    {\n      category: 'http',\n      data: {\n        status_code: statusCode,\n        ...data,\n      },\n      type: 'http',\n      level,\n    },\n    {\n      event: 'response',\n      request,\n      response,\n    },\n  );\n}\n\nfunction getBreadcrumbData(request: UndiciRequest): Partial<SanitizedRequestData> {\n  try {\n    const url = getAbsoluteUrl(request.origin, request.path);\n    const parsedUrl = parseUrl(url);\n\n    const data: Partial<SanitizedRequestData> = {\n      url: getSanitizedUrlString(parsedUrl),\n      'http.method': request.method || 'GET',\n    };\n\n    if (parsedUrl.search) {\n      data['http.query'] = parsedUrl.search;\n    }\n    if (parsedUrl.hash) {\n      data['http.fragment'] = parsedUrl.hash;\n    }\n\n    return data;\n  } catch {\n    return {};\n  }\n}\n\nfunction getAbsoluteUrl(origin: string, path: string = '/'): string {\n  try {\n    const url = new URL(path, origin);\n    return url.toString();\n  } catch {\n    // fallback: Construct it on our own\n    const url = `${origin}`;\n\n    if (url.endsWith('/') && path.startsWith('/')) {\n      return `${url}${path.slice(1)}`;\n    }\n\n    if (!url.endsWith('/') && !path.startsWith('/')) {\n      return `${url}/${path.slice(1)}`;\n    }\n\n    return `${url}${path}`;\n  }\n}\n"],"names":["InstrumentationBase","VERSION","LRUMap","getClient","shouldPropagateTraceForUrl","getTraceData","baggage","mergeBaggageHeaders","NODE_MAJOR","NODE_MINOR","getBreadcrumbLogLevelFromHttpStatusCode","addBreadcrumb","parseUrl","getSanitizedUrlString"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"SentryNodeFetchInstrumentation.js","sources":["../../../../src/integrations/node-fetch/SentryNodeFetchInstrumentation.ts"],"sourcesContent":["import type { InstrumentationConfig } from '@opentelemetry/instrumentation';\nimport { InstrumentationBase } from '@opentelemetry/instrumentation';\nimport type { SanitizedRequestData } from '@sentry/core';\nimport { LRUMap, getClient, getTraceData } from '@sentry/core';\nimport { addBreadcrumb, getBreadcrumbLogLevelFromHttpStatusCode, getSanitizedUrlString, parseUrl } from '@sentry/core';\nimport { shouldPropagateTraceForUrl } from '@sentry/opentelemetry';\nimport * as diagch from 'diagnostics_channel';\nimport { NODE_MAJOR, NODE_MINOR } from '../../nodeVersion';\nimport { mergeBaggageHeaders } from '../../utils/baggage';\nimport type { UndiciRequest, UndiciResponse } from './types';\n\nconst SENTRY_TRACE_HEADER = 'sentry-trace';\nconst SENTRY_BAGGAGE_HEADER = 'baggage';\n\n// For baggage, we make sure to merge this into a possibly existing header\nconst BAGGAGE_HEADER_REGEX = /baggage: (.*)\\r\\n/;\n\nexport type SentryNodeFetchInstrumentationOptions = InstrumentationConfig & {\n  /**\n   * Whether breadcrumbs should be recorded for requests.\n   *\n   * @default `true`\n   */\n  breadcrumbs?: boolean;\n\n  /**\n   * Do not capture breadcrumbs or inject headers for outgoing fetch requests to URLs where the given callback returns `true`.\n   * The same option can be passed to the top-level httpIntegration where it controls both, breadcrumb and\n   * span creation.\n   *\n   * @param url Contains the entire URL, including query string (if any), protocol, host, etc. of the outgoing request.\n   */\n  ignoreOutgoingRequests?: (url: string) => boolean;\n};\n\ninterface ListenerRecord {\n  name: string;\n  unsubscribe: () => void;\n}\n\n/**\n * This custom node-fetch instrumentation is used to instrument outgoing fetch requests.\n * It does not emit any spans.\n *\n * The reason this is isolated from the OpenTelemetry instrumentation is that users may overwrite this,\n * which would lead to Sentry not working as expected.\n *\n * This is heavily inspired & adapted from:\n * https://github.com/open-telemetry/opentelemetry-js-contrib/blob/28e209a9da36bc4e1f8c2b0db7360170ed46cb80/plugins/node/instrumentation-undici/src/undici.ts\n */\nexport class SentryNodeFetchInstrumentation extends InstrumentationBase<SentryNodeFetchInstrumentationOptions> {\n  // Keep ref to avoid https://github.com/nodejs/node/issues/42170 bug and for\n  // unsubscribing.\n  private _channelSubs: Array<ListenerRecord>;\n  private _propagationDecisionMap: LRUMap<string, boolean>;\n\n  public constructor(config: SentryNodeFetchInstrumentationOptions = {}) {\n    super('@sentry/instrumentation-node-fetch', '2.0.0', config);\n    this._channelSubs = [];\n    this._propagationDecisionMap = new LRUMap<string, boolean>(100);\n  }\n\n  /** No need to instrument files/modules. */\n  public init(): void {\n    return undefined;\n  }\n\n  /** Disable the instrumentation. */\n  public disable(): void {\n    super.disable();\n    this._channelSubs.forEach(sub => sub.unsubscribe());\n    this._channelSubs = [];\n  }\n\n  /** Enable the instrumentation. */\n  public enable(): void {\n    // \"enabled\" handling is currently a bit messy with InstrumentationBase.\n    // If constructed with `{enabled: false}`, this `.enable()` is still called,\n    // and `this.getConfig().enabled !== this.isEnabled()`, creating confusion.\n    //\n    // For now, this class will setup for instrumenting if `.enable()` is\n    // called, but use `this.getConfig().enabled` to determine if\n    // instrumentation should be generated. This covers the more likely common\n    // case of config being given a construction time, rather than later via\n    // `instance.enable()`, `.disable()`, or `.setConfig()` calls.\n    super.enable();\n\n    // This method is called by the super-class constructor before ours is\n    // called. So we need to ensure the property is initalized.\n    this._channelSubs = this._channelSubs || [];\n\n    // Avoid to duplicate subscriptions\n    if (this._channelSubs.length > 0) {\n      return;\n    }\n\n    this._subscribeToChannel('undici:request:create', this._onRequestCreated.bind(this));\n    this._subscribeToChannel('undici:request:headers', this._onResponseHeaders.bind(this));\n  }\n\n  /**\n   * This method is called when a request is created.\n   * You can still mutate the request here before it is sent.\n   */\n  private _onRequestCreated({ request }: { request: UndiciRequest }): void {\n    const config = this.getConfig();\n    const enabled = config.enabled !== false;\n\n    if (!enabled) {\n      return;\n    }\n\n    // Add trace propagation headers\n    const url = getAbsoluteUrl(request.origin, request.path);\n    const _ignoreOutgoingRequests = config.ignoreOutgoingRequests;\n    const shouldIgnore = _ignoreOutgoingRequests && url && _ignoreOutgoingRequests(url);\n\n    if (shouldIgnore) {\n      return;\n    }\n\n    // Manually add the trace headers, if it applies\n    // Note: We do not use `propagation.inject()` here, because our propagator relies on an active span\n    // Which we do not have in this case\n    // The propagator _may_ overwrite this, but this should be fine as it is the same data\n    const tracePropagationTargets = getClient()?.getOptions().tracePropagationTargets;\n    const addedHeaders = shouldPropagateTraceForUrl(url, tracePropagationTargets, this._propagationDecisionMap)\n      ? getTraceData()\n      : undefined;\n\n    if (!addedHeaders) {\n      return;\n    }\n\n    const { 'sentry-trace': sentryTrace, baggage } = addedHeaders;\n\n    // We do not want to overwrite existing headers here\n    // If the core UndiciInstrumentation is registered, it will already have set the headers\n    // We do not want to add any then\n    if (Array.isArray(request.headers)) {\n      const requestHeaders = request.headers;\n\n      // We do not want to overwrite existing header here, if it was already set\n      if (sentryTrace && !requestHeaders.includes(SENTRY_TRACE_HEADER)) {\n        requestHeaders.push(SENTRY_TRACE_HEADER, sentryTrace);\n      }\n\n      // For baggage, we make sure to merge this into a possibly existing header\n      const existingBaggagePos = requestHeaders.findIndex(header => header === SENTRY_BAGGAGE_HEADER);\n      if (baggage && existingBaggagePos === -1) {\n        requestHeaders.push(SENTRY_BAGGAGE_HEADER, baggage);\n      } else if (baggage) {\n        const existingBaggage = requestHeaders[existingBaggagePos + 1];\n        const merged = mergeBaggageHeaders(existingBaggage, baggage);\n        if (merged) {\n          requestHeaders[existingBaggagePos + 1] = merged;\n        }\n      }\n    } else {\n      const requestHeaders = request.headers;\n      // We do not want to overwrite existing header here, if it was already set\n      if (sentryTrace && !requestHeaders.includes(`${SENTRY_TRACE_HEADER}:`)) {\n        request.headers += `${SENTRY_TRACE_HEADER}: ${sentryTrace}\\r\\n`;\n      }\n\n      const existingBaggage = request.headers.match(BAGGAGE_HEADER_REGEX)?.[1];\n      if (baggage && !existingBaggage) {\n        request.headers += `${SENTRY_BAGGAGE_HEADER}: ${baggage}\\r\\n`;\n      } else if (baggage) {\n        const merged = mergeBaggageHeaders(existingBaggage, baggage);\n        if (merged) {\n          request.headers = request.headers.replace(BAGGAGE_HEADER_REGEX, `baggage: ${merged}\\r\\n`);\n        }\n      }\n    }\n  }\n\n  /**\n   * This method is called when a response is received.\n   */\n  private _onResponseHeaders({ request, response }: { request: UndiciRequest; response: UndiciResponse }): void {\n    const config = this.getConfig();\n    const enabled = config.enabled !== false;\n\n    if (!enabled) {\n      return;\n    }\n\n    const _breadcrumbs = config.breadcrumbs;\n    const breadCrumbsEnabled = typeof _breadcrumbs === 'undefined' ? true : _breadcrumbs;\n\n    const _ignoreOutgoingRequests = config.ignoreOutgoingRequests;\n    const shouldCreateBreadcrumb =\n      typeof _ignoreOutgoingRequests === 'function'\n        ? !_ignoreOutgoingRequests(getAbsoluteUrl(request.origin, request.path))\n        : true;\n\n    if (breadCrumbsEnabled && shouldCreateBreadcrumb) {\n      addRequestBreadcrumb(request, response);\n    }\n  }\n\n  /** Subscribe to a diagnostics channel. */\n  private _subscribeToChannel(\n    diagnosticChannel: string,\n    onMessage: (message: unknown, name: string | symbol) => void,\n  ): void {\n    // `diagnostics_channel` had a ref counting bug until v18.19.0.\n    // https://github.com/nodejs/node/pull/47520\n    const useNewSubscribe = NODE_MAJOR > 18 || (NODE_MAJOR === 18 && NODE_MINOR >= 19);\n\n    let unsubscribe: () => void;\n    if (useNewSubscribe) {\n      diagch.subscribe?.(diagnosticChannel, onMessage);\n      unsubscribe = () => diagch.unsubscribe?.(diagnosticChannel, onMessage);\n    } else {\n      const channel = diagch.channel(diagnosticChannel);\n      channel.subscribe(onMessage);\n      unsubscribe = () => channel.unsubscribe(onMessage);\n    }\n\n    this._channelSubs.push({\n      name: diagnosticChannel,\n      unsubscribe,\n    });\n  }\n}\n\n/** Add a breadcrumb for outgoing requests. */\nfunction addRequestBreadcrumb(request: UndiciRequest, response: UndiciResponse): void {\n  const data = getBreadcrumbData(request);\n\n  const statusCode = response.statusCode;\n  const level = getBreadcrumbLogLevelFromHttpStatusCode(statusCode);\n\n  addBreadcrumb(\n    {\n      category: 'http',\n      data: {\n        status_code: statusCode,\n        ...data,\n      },\n      type: 'http',\n      level,\n    },\n    {\n      event: 'response',\n      request,\n      response,\n    },\n  );\n}\n\nfunction getBreadcrumbData(request: UndiciRequest): Partial<SanitizedRequestData> {\n  try {\n    const url = getAbsoluteUrl(request.origin, request.path);\n    const parsedUrl = parseUrl(url);\n\n    const data: Partial<SanitizedRequestData> = {\n      url: getSanitizedUrlString(parsedUrl),\n      'http.method': request.method || 'GET',\n    };\n\n    if (parsedUrl.search) {\n      data['http.query'] = parsedUrl.search;\n    }\n    if (parsedUrl.hash) {\n      data['http.fragment'] = parsedUrl.hash;\n    }\n\n    return data;\n  } catch {\n    return {};\n  }\n}\n\nfunction getAbsoluteUrl(origin: string, path: string = '/'): string {\n  try {\n    const url = new URL(path, origin);\n    return url.toString();\n  } catch {\n    // fallback: Construct it on our own\n    const url = `${origin}`;\n\n    if (url.endsWith('/') && path.startsWith('/')) {\n      return `${url}${path.slice(1)}`;\n    }\n\n    if (!url.endsWith('/') && !path.startsWith('/')) {\n      return `${url}/${path.slice(1)}`;\n    }\n\n    return `${url}${path}`;\n  }\n}\n"],"names":["InstrumentationBase","LRUMap","getClient","shouldPropagateTraceForUrl","getTraceData","baggage","mergeBaggageHeaders","NODE_MAJOR","NODE_MINOR","getBreadcrumbLogLevelFromHttpStatusCode","addBreadcrumb","parseUrl","getSanitizedUrlString"],"mappings":"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"}
\ No newline at end of file
diff --git a/build/cjs/sdk/client.js b/build/cjs/sdk/client.js
index fcb33faf03baf14c7935fca8428f741d854c2ffb..645db7765ee9dd54bd08e912d4b9f2b28bb66cf1 100644
--- a/build/cjs/sdk/client.js
+++ b/build/cjs/sdk/client.js
@@ -72,10 +72,9 @@ class NodeClient extends core.ServerRuntimeClient {
   // eslint-disable-next-line jsdoc/require-jsdoc
    async flush(timeout) {
     const provider = this.traceProvider;
-    const spanProcessor = provider?.activeSpanProcessor;
 
-    if (spanProcessor) {
-      await spanProcessor.forceFlush();
+    if (provider) {
+      await provider.forceFlush();
     }
 
     if (this.getOptions().sendClientReports) {
diff --git a/build/cjs/sdk/client.js.map b/build/cjs/sdk/client.js.map
index ef5b06431393e8d9713477b87d1cee62ab37e83f..51d2d0fb59b38132d2adcbfe54cb1811c2af1517 100644
--- a/build/cjs/sdk/client.js.map
+++ b/build/cjs/sdk/client.js.map
@@ -1 +1 @@
-{"version":3,"file":"client.js","sources":["../../../src/sdk/client.ts"],"sourcesContent":["import * as os from 'node:os';\nimport type { Tracer } from '@opentelemetry/api';\nimport { trace } from '@opentelemetry/api';\nimport { registerInstrumentations } from '@opentelemetry/instrumentation';\nimport type { BasicTracerProvider } from '@opentelemetry/sdk-trace-base';\nimport type { DynamicSamplingContext, Scope, ServerRuntimeClientOptions, TraceContext } from '@sentry/core';\nimport { _INTERNAL_flushLogsBuffer, SDK_VERSION, ServerRuntimeClient, applySdkMetadata, logger } from '@sentry/core';\nimport { getTraceContextForScope } from '@sentry/opentelemetry';\nimport { isMainThread, threadId } from 'worker_threads';\nimport { DEBUG_BUILD } from '../debug-build';\nimport type { NodeClientOptions } from '../types';\n\nconst DEFAULT_CLIENT_REPORT_FLUSH_INTERVAL_MS = 60_000; // 60s was chosen arbitrarily\n\n/** A client for using Sentry with Node & OpenTelemetry. */\nexport class NodeClient extends ServerRuntimeClient<NodeClientOptions> {\n  public traceProvider: BasicTracerProvider | undefined;\n  private _tracer: Tracer | undefined;\n  private _clientReportInterval: NodeJS.Timeout | undefined;\n  private _clientReportOnExitFlushListener: (() => void) | undefined;\n  private _logOnExitFlushListener: (() => void) | undefined;\n\n  public constructor(options: NodeClientOptions) {\n    const serverName = options.serverName || global.process.env.SENTRY_NAME || os.hostname();\n    const clientOptions: ServerRuntimeClientOptions = {\n      ...options,\n      platform: 'node',\n      runtime: { name: 'node', version: global.process.version },\n      serverName,\n    };\n\n    if (options.openTelemetryInstrumentations) {\n      registerInstrumentations({\n        instrumentations: options.openTelemetryInstrumentations,\n      });\n    }\n\n    applySdkMetadata(clientOptions, 'node');\n\n    logger.log(\n      `Initializing Sentry: process: ${process.pid}, thread: ${isMainThread ? 'main' : `worker-${threadId}`}.`,\n    );\n\n    super(clientOptions);\n\n    if (this.getOptions()._experiments?.enableLogs) {\n      this._logOnExitFlushListener = () => {\n        _INTERNAL_flushLogsBuffer(this);\n      };\n\n      if (serverName) {\n        this.on('beforeCaptureLog', log => {\n          log.attributes = {\n            ...log.attributes,\n            'server.address': serverName,\n          };\n        });\n      }\n\n      process.on('beforeExit', this._logOnExitFlushListener);\n    }\n  }\n\n  /** Get the OTEL tracer. */\n  public get tracer(): Tracer {\n    if (this._tracer) {\n      return this._tracer;\n    }\n\n    const name = '@sentry/node';\n    const version = SDK_VERSION;\n    const tracer = trace.getTracer(name, version);\n    this._tracer = tracer;\n\n    return tracer;\n  }\n\n  // Eslint ignore explanation: This is already documented in super.\n  // eslint-disable-next-line jsdoc/require-jsdoc\n  public async flush(timeout?: number): Promise<boolean> {\n    const provider = this.traceProvider;\n    const spanProcessor = provider?.activeSpanProcessor;\n\n    if (spanProcessor) {\n      await spanProcessor.forceFlush();\n    }\n\n    if (this.getOptions().sendClientReports) {\n      this._flushOutcomes();\n    }\n\n    return super.flush(timeout);\n  }\n\n  // Eslint ignore explanation: This is already documented in super.\n  // eslint-disable-next-line jsdoc/require-jsdoc\n  public close(timeout?: number | undefined): PromiseLike<boolean> {\n    if (this._clientReportInterval) {\n      clearInterval(this._clientReportInterval);\n    }\n\n    if (this._clientReportOnExitFlushListener) {\n      process.off('beforeExit', this._clientReportOnExitFlushListener);\n    }\n\n    if (this._logOnExitFlushListener) {\n      process.off('beforeExit', this._logOnExitFlushListener);\n    }\n\n    return super.close(timeout);\n  }\n\n  /**\n   * Will start tracking client reports for this client.\n   *\n   * NOTICE: This method will create an interval that is periodically called and attach a `process.on('beforeExit')`\n   * hook. To clean up these resources, call `.close()` when you no longer intend to use the client. Not doing so will\n   * result in a memory leak.\n   */\n  // The reason client reports need to be manually activated with this method instead of just enabling them in a\n  // constructor, is that if users periodically and unboundedly create new clients, we will create more and more\n  // intervals and beforeExit listeners, thus leaking memory. In these situations, users are required to call\n  // `client.close()` in order to dispose of the acquired resources.\n  // We assume that calling this method in Sentry.init() is a sensible default, because calling Sentry.init() over and\n  // over again would also result in memory leaks.\n  // Note: We have experimented with using `FinalizationRegisty` to clear the interval when the client is garbage\n  // collected, but it did not work, because the cleanup function never got called.\n  public startClientReportTracking(): void {\n    const clientOptions = this.getOptions();\n    if (clientOptions.sendClientReports) {\n      this._clientReportOnExitFlushListener = () => {\n        this._flushOutcomes();\n      };\n\n      this._clientReportInterval = setInterval(() => {\n        DEBUG_BUILD && logger.log('Flushing client reports based on interval.');\n        this._flushOutcomes();\n      }, clientOptions.clientReportFlushInterval ?? DEFAULT_CLIENT_REPORT_FLUSH_INTERVAL_MS)\n        // Unref is critical for not preventing the process from exiting because the interval is active.\n        .unref();\n\n      process.on('beforeExit', this._clientReportOnExitFlushListener);\n    }\n  }\n\n  /** Custom implementation for OTEL, so we can handle scope-span linking. */\n  protected _getTraceInfoFromScope(\n    scope: Scope | undefined,\n  ): [dynamicSamplingContext: Partial<DynamicSamplingContext> | undefined, traceContext: TraceContext | undefined] {\n    if (!scope) {\n      return [undefined, undefined];\n    }\n\n    return getTraceContextForScope(this, scope);\n  }\n}\n"],"names":["ServerRuntimeClient","registerInstrumentations","applySdkMetadata","logger","isMainThread","threadId","_INTERNAL_flushLogsBuffer","SDK_VERSION","trace","DEBUG_BUILD","getTraceContextForScope"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"client.js","sources":["../../../src/sdk/client.ts"],"sourcesContent":["import * as os from 'node:os';\nimport type { Tracer } from '@opentelemetry/api';\nimport { trace } from '@opentelemetry/api';\nimport { registerInstrumentations } from '@opentelemetry/instrumentation';\nimport type { BasicTracerProvider } from '@opentelemetry/sdk-trace-base';\nimport type { DynamicSamplingContext, Scope, ServerRuntimeClientOptions, TraceContext } from '@sentry/core';\nimport { _INTERNAL_flushLogsBuffer, SDK_VERSION, ServerRuntimeClient, applySdkMetadata, logger } from '@sentry/core';\nimport { getTraceContextForScope } from '@sentry/opentelemetry';\nimport { isMainThread, threadId } from 'worker_threads';\nimport { DEBUG_BUILD } from '../debug-build';\nimport type { NodeClientOptions } from '../types';\n\nconst DEFAULT_CLIENT_REPORT_FLUSH_INTERVAL_MS = 60_000; // 60s was chosen arbitrarily\n\n/** A client for using Sentry with Node & OpenTelemetry. */\nexport class NodeClient extends ServerRuntimeClient<NodeClientOptions> {\n  public traceProvider: BasicTracerProvider | undefined;\n  private _tracer: Tracer | undefined;\n  private _clientReportInterval: NodeJS.Timeout | undefined;\n  private _clientReportOnExitFlushListener: (() => void) | undefined;\n  private _logOnExitFlushListener: (() => void) | undefined;\n\n  public constructor(options: NodeClientOptions) {\n    const serverName = options.serverName || global.process.env.SENTRY_NAME || os.hostname();\n    const clientOptions: ServerRuntimeClientOptions = {\n      ...options,\n      platform: 'node',\n      runtime: { name: 'node', version: global.process.version },\n      serverName,\n    };\n\n    if (options.openTelemetryInstrumentations) {\n      registerInstrumentations({\n        instrumentations: options.openTelemetryInstrumentations,\n      });\n    }\n\n    applySdkMetadata(clientOptions, 'node');\n\n    logger.log(\n      `Initializing Sentry: process: ${process.pid}, thread: ${isMainThread ? 'main' : `worker-${threadId}`}.`,\n    );\n\n    super(clientOptions);\n\n    if (this.getOptions()._experiments?.enableLogs) {\n      this._logOnExitFlushListener = () => {\n        _INTERNAL_flushLogsBuffer(this);\n      };\n\n      if (serverName) {\n        this.on('beforeCaptureLog', log => {\n          log.attributes = {\n            ...log.attributes,\n            'server.address': serverName,\n          };\n        });\n      }\n\n      process.on('beforeExit', this._logOnExitFlushListener);\n    }\n  }\n\n  /** Get the OTEL tracer. */\n  public get tracer(): Tracer {\n    if (this._tracer) {\n      return this._tracer;\n    }\n\n    const name = '@sentry/node';\n    const version = SDK_VERSION;\n    const tracer = trace.getTracer(name, version);\n    this._tracer = tracer;\n\n    return tracer;\n  }\n\n  // Eslint ignore explanation: This is already documented in super.\n  // eslint-disable-next-line jsdoc/require-jsdoc\n  public async flush(timeout?: number): Promise<boolean> {\n    const provider = this.traceProvider;\n\n    if (provider) {\n      await provider.forceFlush();\n    }\n\n    if (this.getOptions().sendClientReports) {\n      this._flushOutcomes();\n    }\n\n    return super.flush(timeout);\n  }\n\n  // Eslint ignore explanation: This is already documented in super.\n  // eslint-disable-next-line jsdoc/require-jsdoc\n  public close(timeout?: number | undefined): PromiseLike<boolean> {\n    if (this._clientReportInterval) {\n      clearInterval(this._clientReportInterval);\n    }\n\n    if (this._clientReportOnExitFlushListener) {\n      process.off('beforeExit', this._clientReportOnExitFlushListener);\n    }\n\n    if (this._logOnExitFlushListener) {\n      process.off('beforeExit', this._logOnExitFlushListener);\n    }\n\n    return super.close(timeout);\n  }\n\n  /**\n   * Will start tracking client reports for this client.\n   *\n   * NOTICE: This method will create an interval that is periodically called and attach a `process.on('beforeExit')`\n   * hook. To clean up these resources, call `.close()` when you no longer intend to use the client. Not doing so will\n   * result in a memory leak.\n   */\n  // The reason client reports need to be manually activated with this method instead of just enabling them in a\n  // constructor, is that if users periodically and unboundedly create new clients, we will create more and more\n  // intervals and beforeExit listeners, thus leaking memory. In these situations, users are required to call\n  // `client.close()` in order to dispose of the acquired resources.\n  // We assume that calling this method in Sentry.init() is a sensible default, because calling Sentry.init() over and\n  // over again would also result in memory leaks.\n  // Note: We have experimented with using `FinalizationRegisty` to clear the interval when the client is garbage\n  // collected, but it did not work, because the cleanup function never got called.\n  public startClientReportTracking(): void {\n    const clientOptions = this.getOptions();\n    if (clientOptions.sendClientReports) {\n      this._clientReportOnExitFlushListener = () => {\n        this._flushOutcomes();\n      };\n\n      this._clientReportInterval = setInterval(() => {\n        DEBUG_BUILD && logger.log('Flushing client reports based on interval.');\n        this._flushOutcomes();\n      }, clientOptions.clientReportFlushInterval ?? DEFAULT_CLIENT_REPORT_FLUSH_INTERVAL_MS)\n        // Unref is critical for not preventing the process from exiting because the interval is active.\n        .unref();\n\n      process.on('beforeExit', this._clientReportOnExitFlushListener);\n    }\n  }\n\n  /** Custom implementation for OTEL, so we can handle scope-span linking. */\n  protected _getTraceInfoFromScope(\n    scope: Scope | undefined,\n  ): [dynamicSamplingContext: Partial<DynamicSamplingContext> | undefined, traceContext: TraceContext | undefined] {\n    if (!scope) {\n      return [undefined, undefined];\n    }\n\n    return getTraceContextForScope(this, scope);\n  }\n}\n"],"names":["ServerRuntimeClient","registerInstrumentations","applySdkMetadata","logger","isMainThread","threadId","_INTERNAL_flushLogsBuffer","SDK_VERSION","trace","DEBUG_BUILD","getTraceContextForScope"],"mappings":"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"}
\ No newline at end of file
diff --git a/build/cjs/sdk/initOtel.js b/build/cjs/sdk/initOtel.js
index dab5bcbfdfe659c26e5ef9a8b9d78b87ebf200b0..b9951bdc7fd763900b8dcc8eb610f2306174bf89 100644
--- a/build/cjs/sdk/initOtel.js
+++ b/build/cjs/sdk/initOtel.js
@@ -99,12 +99,14 @@ function setupOtel(client, options = {}) {
   // Create and configure NodeTracerProvider
   const provider = new sdkTraceBase.BasicTracerProvider({
     sampler: new opentelemetry.SentrySampler(client),
-    resource: new resources.Resource({
-      [semanticConventions.ATTR_SERVICE_NAME]: 'node',
-      // eslint-disable-next-line deprecation/deprecation
-      [semanticConventions.SEMRESATTRS_SERVICE_NAMESPACE]: 'sentry',
-      [semanticConventions.ATTR_SERVICE_VERSION]: core.SDK_VERSION,
-    }),
+    resource: resources.defaultResource().merge(
+      resources.resourceFromAttributes({
+        [semanticConventions.ATTR_SERVICE_NAME]: 'node',
+        // eslint-disable-next-line deprecation/deprecation
+        [semanticConventions.SEMRESATTRS_SERVICE_NAMESPACE]: 'sentry',
+        [semanticConventions.ATTR_SERVICE_VERSION]: core.SDK_VERSION,
+      }),
+    ),
     forceFlushTimeoutMillis: 500,
     spanProcessors: [
       new opentelemetry.SentrySpanProcessor({
diff --git a/build/cjs/sdk/initOtel.js.map b/build/cjs/sdk/initOtel.js.map
index 2b38586f5fcf1872d4124ac65c10bd9f8e1a9111..be4447dbabcec02ade7b365bcd152d4dcd5a7a0d 100644
--- a/build/cjs/sdk/initOtel.js.map
+++ b/build/cjs/sdk/initOtel.js.map
@@ -1 +1 @@
-{"version":3,"file":"initOtel.js","sources":["../../../src/sdk/initOtel.ts"],"sourcesContent":["import moduleModule from 'module';\nimport { DiagLogLevel, context, diag, propagation, trace } from '@opentelemetry/api';\nimport { Resource } from '@opentelemetry/resources';\nimport type { SpanProcessor } from '@opentelemetry/sdk-trace-base';\nimport { BasicTracerProvider } from '@opentelemetry/sdk-trace-base';\nimport {\n  ATTR_SERVICE_NAME,\n  ATTR_SERVICE_VERSION,\n  SEMRESATTRS_SERVICE_NAMESPACE,\n} from '@opentelemetry/semantic-conventions';\nimport { GLOBAL_OBJ, SDK_VERSION, consoleSandbox, logger } from '@sentry/core';\nimport { SentryPropagator, SentrySampler, SentrySpanProcessor } from '@sentry/opentelemetry';\nimport { createAddHookMessageChannel } from 'import-in-the-middle';\nimport { DEBUG_BUILD } from '../debug-build';\nimport { getOpenTelemetryInstrumentationToPreload } from '../integrations/tracing';\nimport { SentryContextManager } from '../otel/contextManager';\nimport { isCjs } from '../utils/commonjs';\nimport type { NodeClient } from './client';\n\n// About 277h - this must fit into new Array(len)!\nconst MAX_MAX_SPAN_WAIT_DURATION = 1_000_000;\n\ninterface AdditionalOpenTelemetryOptions {\n  /** Additional SpanProcessor instances that should be used. */\n  spanProcessors?: SpanProcessor[];\n}\n\n/**\n * Initialize OpenTelemetry for Node.\n */\nexport function initOpenTelemetry(client: NodeClient, options: AdditionalOpenTelemetryOptions = {}): void {\n  if (client.getOptions().debug) {\n    setupOpenTelemetryLogger();\n  }\n\n  const provider = setupOtel(client, options);\n  client.traceProvider = provider;\n}\n\n/** Initialize the ESM loader. */\nexport function maybeInitializeEsmLoader(): void {\n  const [nodeMajor = 0, nodeMinor = 0] = process.versions.node.split('.').map(Number);\n\n  // Register hook was added in v20.6.0 and v18.19.0\n  if (nodeMajor >= 22 || (nodeMajor === 20 && nodeMinor >= 6) || (nodeMajor === 18 && nodeMinor >= 19)) {\n    if (!GLOBAL_OBJ._sentryEsmLoaderHookRegistered) {\n      try {\n        const { addHookMessagePort } = createAddHookMessageChannel();\n        // @ts-expect-error register is available in these versions\n        moduleModule.register('import-in-the-middle/hook.mjs', import.meta.url, {\n          data: { addHookMessagePort, include: [] },\n          transferList: [addHookMessagePort],\n        });\n      } catch (error) {\n        logger.warn('Failed to register ESM hook', error);\n      }\n    }\n  } else {\n    consoleSandbox(() => {\n      // eslint-disable-next-line no-console\n      console.warn(\n        '[Sentry] You are using Node.js in ESM mode (\"import syntax\"). The Sentry Node.js SDK is not compatible with ESM in Node.js versions before 18.19.0 or before 20.6.0. Please either build your application with CommonJS (\"require() syntax\"), or upgrade your Node.js version.',\n      );\n    });\n  }\n}\n\ninterface NodePreloadOptions {\n  debug?: boolean;\n  integrations?: string[];\n}\n\n/**\n * Preload OpenTelemetry for Node.\n * This can be used to preload instrumentation early, but set up Sentry later.\n * By preloading the OTEL instrumentation wrapping still happens early enough that everything works.\n */\nexport function preloadOpenTelemetry(options: NodePreloadOptions = {}): void {\n  const { debug } = options;\n\n  if (debug) {\n    logger.enable();\n    setupOpenTelemetryLogger();\n  }\n\n  if (!isCjs()) {\n    maybeInitializeEsmLoader();\n  }\n\n  // These are all integrations that we need to pre-load to ensure they are set up before any other code runs\n  getPreloadMethods(options.integrations).forEach(fn => {\n    fn();\n\n    if (debug) {\n      logger.log(`[Sentry] Preloaded ${fn.id} instrumentation`);\n    }\n  });\n}\n\nfunction getPreloadMethods(integrationNames?: string[]): ((() => void) & { id: string })[] {\n  const instruments = getOpenTelemetryInstrumentationToPreload();\n\n  if (!integrationNames) {\n    return instruments;\n  }\n\n  return instruments.filter(instrumentation => integrationNames.includes(instrumentation.id));\n}\n\n/** Just exported for tests. */\nexport function setupOtel(client: NodeClient, options: AdditionalOpenTelemetryOptions = {}): BasicTracerProvider {\n  // Create and configure NodeTracerProvider\n  const provider = new BasicTracerProvider({\n    sampler: new SentrySampler(client),\n    resource: new Resource({\n      [ATTR_SERVICE_NAME]: 'node',\n      // eslint-disable-next-line deprecation/deprecation\n      [SEMRESATTRS_SERVICE_NAMESPACE]: 'sentry',\n      [ATTR_SERVICE_VERSION]: SDK_VERSION,\n    }),\n    forceFlushTimeoutMillis: 500,\n    spanProcessors: [\n      new SentrySpanProcessor({\n        timeout: _clampSpanProcessorTimeout(client.getOptions().maxSpanWaitDuration),\n      }),\n      ...(options.spanProcessors || []),\n    ],\n  });\n\n  // Register as globals\n  trace.setGlobalTracerProvider(provider);\n  propagation.setGlobalPropagator(new SentryPropagator());\n  context.setGlobalContextManager(new SentryContextManager());\n\n  return provider;\n}\n\n/** Just exported for tests. */\nexport function _clampSpanProcessorTimeout(maxSpanWaitDuration: number | undefined): number | undefined {\n  if (maxSpanWaitDuration == null) {\n    return undefined;\n  }\n\n  // We guard for a max. value here, because we create an array with this length\n  // So if this value is too large, this would fail\n  if (maxSpanWaitDuration > MAX_MAX_SPAN_WAIT_DURATION) {\n    DEBUG_BUILD &&\n      logger.warn(`\\`maxSpanWaitDuration\\` is too high, using the maximum value of ${MAX_MAX_SPAN_WAIT_DURATION}`);\n    return MAX_MAX_SPAN_WAIT_DURATION;\n  } else if (maxSpanWaitDuration <= 0 || Number.isNaN(maxSpanWaitDuration)) {\n    DEBUG_BUILD && logger.warn('`maxSpanWaitDuration` must be a positive number, using default value instead.');\n    return undefined;\n  }\n\n  return maxSpanWaitDuration;\n}\n\n/**\n * Setup the OTEL logger to use our own logger.\n */\nfunction setupOpenTelemetryLogger(): void {\n  const otelLogger = new Proxy(logger as typeof logger & { verbose: (typeof logger)['debug'] }, {\n    get(target, prop, receiver) {\n      const actualProp = prop === 'verbose' ? 'debug' : prop;\n      return Reflect.get(target, actualProp, receiver);\n    },\n  });\n\n  // Disable diag, to ensure this works even if called multiple times\n  diag.disable();\n  diag.setLogger(otelLogger, DiagLogLevel.DEBUG);\n}\n"],"names":["GLOBAL_OBJ","createAddHookMessageChannel","moduleModule","logger","consoleSandbox","isCjs","getOpenTelemetryInstrumentationToPreload","BasicTracerProvider","SentrySampler","Resource","ATTR_SERVICE_NAME","SEMRESATTRS_SERVICE_NAMESPACE","ATTR_SERVICE_VERSION","SDK_VERSION","SentrySpanProcessor","trace","propagation","SentryPropagator","context","SentryContextManager","DEBUG_BUILD","diag","DiagLogLevel"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"initOtel.js","sources":["../../../src/sdk/initOtel.ts"],"sourcesContent":["import moduleModule from 'module';\nimport { DiagLogLevel, context, diag, propagation, trace } from '@opentelemetry/api';\nimport { defaultResource, resourceFromAttributes } from '@opentelemetry/resources';\nimport type { SpanProcessor } from '@opentelemetry/sdk-trace-base';\nimport { BasicTracerProvider } from '@opentelemetry/sdk-trace-base';\nimport {\n  ATTR_SERVICE_NAME,\n  ATTR_SERVICE_VERSION,\n  SEMRESATTRS_SERVICE_NAMESPACE,\n} from '@opentelemetry/semantic-conventions';\nimport { GLOBAL_OBJ, SDK_VERSION, consoleSandbox, logger } from '@sentry/core';\nimport { SentryPropagator, SentrySampler, SentrySpanProcessor } from '@sentry/opentelemetry';\nimport { createAddHookMessageChannel } from 'import-in-the-middle';\nimport { DEBUG_BUILD } from '../debug-build';\nimport { getOpenTelemetryInstrumentationToPreload } from '../integrations/tracing';\nimport { SentryContextManager } from '../otel/contextManager';\nimport { isCjs } from '../utils/commonjs';\nimport type { NodeClient } from './client';\n\n// About 277h - this must fit into new Array(len)!\nconst MAX_MAX_SPAN_WAIT_DURATION = 1_000_000;\n\ninterface AdditionalOpenTelemetryOptions {\n  /** Additional SpanProcessor instances that should be used. */\n  spanProcessors?: SpanProcessor[];\n}\n\n/**\n * Initialize OpenTelemetry for Node.\n */\nexport function initOpenTelemetry(client: NodeClient, options: AdditionalOpenTelemetryOptions = {}): void {\n  if (client.getOptions().debug) {\n    setupOpenTelemetryLogger();\n  }\n\n  const provider = setupOtel(client, options);\n  client.traceProvider = provider;\n}\n\n/** Initialize the ESM loader. */\nexport function maybeInitializeEsmLoader(): void {\n  const [nodeMajor = 0, nodeMinor = 0] = process.versions.node.split('.').map(Number);\n\n  // Register hook was added in v20.6.0 and v18.19.0\n  if (nodeMajor >= 22 || (nodeMajor === 20 && nodeMinor >= 6) || (nodeMajor === 18 && nodeMinor >= 19)) {\n    if (!GLOBAL_OBJ._sentryEsmLoaderHookRegistered) {\n      try {\n        const { addHookMessagePort } = createAddHookMessageChannel();\n        // @ts-expect-error register is available in these versions\n        moduleModule.register('import-in-the-middle/hook.mjs', import.meta.url, {\n          data: { addHookMessagePort, include: [] },\n          transferList: [addHookMessagePort],\n        });\n      } catch (error) {\n        logger.warn('Failed to register ESM hook', error);\n      }\n    }\n  } else {\n    consoleSandbox(() => {\n      // eslint-disable-next-line no-console\n      console.warn(\n        '[Sentry] You are using Node.js in ESM mode (\"import syntax\"). The Sentry Node.js SDK is not compatible with ESM in Node.js versions before 18.19.0 or before 20.6.0. Please either build your application with CommonJS (\"require() syntax\"), or upgrade your Node.js version.',\n      );\n    });\n  }\n}\n\ninterface NodePreloadOptions {\n  debug?: boolean;\n  integrations?: string[];\n}\n\n/**\n * Preload OpenTelemetry for Node.\n * This can be used to preload instrumentation early, but set up Sentry later.\n * By preloading the OTEL instrumentation wrapping still happens early enough that everything works.\n */\nexport function preloadOpenTelemetry(options: NodePreloadOptions = {}): void {\n  const { debug } = options;\n\n  if (debug) {\n    logger.enable();\n    setupOpenTelemetryLogger();\n  }\n\n  if (!isCjs()) {\n    maybeInitializeEsmLoader();\n  }\n\n  // These are all integrations that we need to pre-load to ensure they are set up before any other code runs\n  getPreloadMethods(options.integrations).forEach(fn => {\n    fn();\n\n    if (debug) {\n      logger.log(`[Sentry] Preloaded ${fn.id} instrumentation`);\n    }\n  });\n}\n\nfunction getPreloadMethods(integrationNames?: string[]): ((() => void) & { id: string })[] {\n  const instruments = getOpenTelemetryInstrumentationToPreload();\n\n  if (!integrationNames) {\n    return instruments;\n  }\n\n  return instruments.filter(instrumentation => integrationNames.includes(instrumentation.id));\n}\n\n/** Just exported for tests. */\nexport function setupOtel(client: NodeClient, options: AdditionalOpenTelemetryOptions = {}): BasicTracerProvider {\n  // Create and configure NodeTracerProvider\n  const provider = new BasicTracerProvider({\n    sampler: new SentrySampler(client),\n    resource: defaultResource().merge(\n      resourceFromAttributes({\n        [ATTR_SERVICE_NAME]: 'node',\n        // eslint-disable-next-line deprecation/deprecation\n        [SEMRESATTRS_SERVICE_NAMESPACE]: 'sentry',\n        [ATTR_SERVICE_VERSION]: SDK_VERSION,\n      }),\n    ),\n    forceFlushTimeoutMillis: 500,\n    spanProcessors: [\n      new SentrySpanProcessor({\n        timeout: _clampSpanProcessorTimeout(client.getOptions().maxSpanWaitDuration),\n      }),\n      ...(options.spanProcessors || []),\n    ],\n  });\n\n  // Register as globals\n  trace.setGlobalTracerProvider(provider);\n  propagation.setGlobalPropagator(new SentryPropagator());\n  context.setGlobalContextManager(new SentryContextManager());\n\n  return provider;\n}\n\n/** Just exported for tests. */\nexport function _clampSpanProcessorTimeout(maxSpanWaitDuration: number | undefined): number | undefined {\n  if (maxSpanWaitDuration == null) {\n    return undefined;\n  }\n\n  // We guard for a max. value here, because we create an array with this length\n  // So if this value is too large, this would fail\n  if (maxSpanWaitDuration > MAX_MAX_SPAN_WAIT_DURATION) {\n    DEBUG_BUILD &&\n      logger.warn(`\\`maxSpanWaitDuration\\` is too high, using the maximum value of ${MAX_MAX_SPAN_WAIT_DURATION}`);\n    return MAX_MAX_SPAN_WAIT_DURATION;\n  } else if (maxSpanWaitDuration <= 0 || Number.isNaN(maxSpanWaitDuration)) {\n    DEBUG_BUILD && logger.warn('`maxSpanWaitDuration` must be a positive number, using default value instead.');\n    return undefined;\n  }\n\n  return maxSpanWaitDuration;\n}\n\n/**\n * Setup the OTEL logger to use our own logger.\n */\nfunction setupOpenTelemetryLogger(): void {\n  const otelLogger = new Proxy(logger as typeof logger & { verbose: (typeof logger)['debug'] }, {\n    get(target, prop, receiver) {\n      const actualProp = prop === 'verbose' ? 'debug' : prop;\n      return Reflect.get(target, actualProp, receiver);\n    },\n  });\n\n  // Disable diag, to ensure this works even if called multiple times\n  diag.disable();\n  diag.setLogger(otelLogger, DiagLogLevel.DEBUG);\n}\n"],"names":["GLOBAL_OBJ","createAddHookMessageChannel","moduleModule","logger","consoleSandbox","isCjs","getOpenTelemetryInstrumentationToPreload","BasicTracerProvider","SentrySampler","defaultResource","resourceFromAttributes","ATTR_SERVICE_NAME","SEMRESATTRS_SERVICE_NAMESPACE","ATTR_SERVICE_VERSION","SDK_VERSION","SentrySpanProcessor","trace","propagation","SentryPropagator","context","SentryContextManager","DEBUG_BUILD","diag","DiagLogLevel"],"mappings":"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"}
\ No newline at end of file
diff --git a/build/cjs/utils/ensureIsWrapped.js b/build/cjs/utils/ensureIsWrapped.js
index d002eaa2ae2fd3576eb2be5f41013744b9b46580..f3d812dc23f7b57046aa1e2c2c76764d7146e478 100644
--- a/build/cjs/utils/ensureIsWrapped.js
+++ b/build/cjs/utils/ensureIsWrapped.js
@@ -1,6 +1,6 @@
 Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
 
-const core$1 = require('@opentelemetry/core');
+const instrumentation = require('@opentelemetry/instrumentation');
 const core = require('@sentry/core');
 const commonjs = require('./commonjs.js');
 const createMissingInstrumentationContext = require('./createMissingInstrumentationContext.js');
@@ -15,7 +15,7 @@ function ensureIsWrapped(
   const clientOptions = core.getClient()?.getOptions();
   if (
     !clientOptions?.disableInstrumentationWarnings &&
-    !core$1.isWrapped(maybeWrappedFunction) &&
+    !instrumentation.isWrapped(maybeWrappedFunction) &&
     core.isEnabled() &&
     core.hasSpansEnabled(clientOptions)
   ) {
diff --git a/build/cjs/utils/ensureIsWrapped.js.map b/build/cjs/utils/ensureIsWrapped.js.map
index dd451ecf676538026bcbae6fefd8615dcbc54eaa..41560bec96f708a1ffdafe75f808418cfb7333ee 100644
--- a/build/cjs/utils/ensureIsWrapped.js.map
+++ b/build/cjs/utils/ensureIsWrapped.js.map
@@ -1 +1 @@
-{"version":3,"file":"ensureIsWrapped.js","sources":["../../../src/utils/ensureIsWrapped.ts"],"sourcesContent":["import { isWrapped } from '@opentelemetry/core';\nimport { consoleSandbox, getClient, getGlobalScope, hasSpansEnabled, isEnabled } from '@sentry/core';\nimport type { NodeClient } from '../sdk/client';\nimport { isCjs } from './commonjs';\nimport { createMissingInstrumentationContext } from './createMissingInstrumentationContext';\n\n/**\n * Checks and warns if a framework isn't wrapped by opentelemetry.\n */\nexport function ensureIsWrapped(\n  maybeWrappedFunction: unknown,\n  name: 'express' | 'connect' | 'fastify' | 'hapi' | 'koa',\n): void {\n  const clientOptions = getClient<NodeClient>()?.getOptions();\n  if (\n    !clientOptions?.disableInstrumentationWarnings &&\n    !isWrapped(maybeWrappedFunction) &&\n    isEnabled() &&\n    hasSpansEnabled(clientOptions)\n  ) {\n    consoleSandbox(() => {\n      if (isCjs()) {\n        // eslint-disable-next-line no-console\n        console.warn(\n          `[Sentry] ${name} is not instrumented. This is likely because you required/imported ${name} before calling \\`Sentry.init()\\`.`,\n        );\n      } else {\n        // eslint-disable-next-line no-console\n        console.warn(\n          `[Sentry] ${name} is not instrumented. Please make sure to initialize Sentry in a separate file that you \\`--import\\` when running node, see: https://docs.sentry.io/platforms/javascript/guides/${name}/install/esm/.`,\n        );\n      }\n    });\n\n    getGlobalScope().setContext('missing_instrumentation', createMissingInstrumentationContext(name));\n  }\n}\n"],"names":["getClient","isWrapped","isEnabled","hasSpansEnabled","consoleSandbox","isCjs","getGlobalScope","createMissingInstrumentationContext"],"mappings":";;;;;;;AAMA;AACA;AACA;AACO,SAAS,eAAe;AAC/B,EAAE,oBAAoB;AACtB,EAAE,IAAI;AACN,EAAQ;AACR,EAAE,MAAM,gBAAgBA,cAAS,EAAc,EAAE,UAAU,EAAE;AAC7D,EAAE;AACF,IAAI,CAAC,aAAa,EAAE,8BAA+B;AACnD,IAAI,CAACC,gBAAS,CAAC,oBAAoB,CAAE;AACrC,IAAIC,cAAS,EAAG;AAChB,IAAIC,oBAAe,CAAC,aAAa;AACjC,IAAI;AACJ,IAAIC,mBAAc,CAAC,MAAM;AACzB,MAAM,IAAIC,cAAK,EAAE,EAAE;AACnB;AACA,QAAQ,OAAO,CAAC,IAAI;AACpB,UAAU,CAAC,SAAS,EAAE,IAAI,CAAC,mEAAmE,EAAE,IAAI,CAAC,kCAAkC,CAAC;AACxI,SAAS;AACT,aAAa;AACb;AACA,QAAQ,OAAO,CAAC,IAAI;AACpB,UAAU,CAAC,SAAS,EAAE,IAAI,CAAC,gLAAgL,EAAE,IAAI,CAAC,cAAc,CAAC;AACjO,SAAS;AACT;AACA,KAAK,CAAC;;AAEN,IAAIC,mBAAc,EAAE,CAAC,UAAU,CAAC,yBAAyB,EAAEC,uEAAmC,CAAC,IAAI,CAAC,CAAC;AACrG;AACA;;;;"}
\ No newline at end of file
+{"version":3,"file":"ensureIsWrapped.js","sources":["../../../src/utils/ensureIsWrapped.ts"],"sourcesContent":["import { isWrapped } from '@opentelemetry/instrumentation';\nimport { consoleSandbox, getClient, getGlobalScope, hasSpansEnabled, isEnabled } from '@sentry/core';\nimport type { NodeClient } from '../sdk/client';\nimport { isCjs } from './commonjs';\nimport { createMissingInstrumentationContext } from './createMissingInstrumentationContext';\n\n/**\n * Checks and warns if a framework isn't wrapped by opentelemetry.\n */\nexport function ensureIsWrapped(\n  maybeWrappedFunction: unknown,\n  name: 'express' | 'connect' | 'fastify' | 'hapi' | 'koa',\n): void {\n  const clientOptions = getClient<NodeClient>()?.getOptions();\n  if (\n    !clientOptions?.disableInstrumentationWarnings &&\n    !isWrapped(maybeWrappedFunction) &&\n    isEnabled() &&\n    hasSpansEnabled(clientOptions)\n  ) {\n    consoleSandbox(() => {\n      if (isCjs()) {\n        // eslint-disable-next-line no-console\n        console.warn(\n          `[Sentry] ${name} is not instrumented. This is likely because you required/imported ${name} before calling \\`Sentry.init()\\`.`,\n        );\n      } else {\n        // eslint-disable-next-line no-console\n        console.warn(\n          `[Sentry] ${name} is not instrumented. Please make sure to initialize Sentry in a separate file that you \\`--import\\` when running node, see: https://docs.sentry.io/platforms/javascript/guides/${name}/install/esm/.`,\n        );\n      }\n    });\n\n    getGlobalScope().setContext('missing_instrumentation', createMissingInstrumentationContext(name));\n  }\n}\n"],"names":["getClient","isWrapped","isEnabled","hasSpansEnabled","consoleSandbox","isCjs","getGlobalScope","createMissingInstrumentationContext"],"mappings":";;;;;;;AAMA;AACA;AACA;AACO,SAAS,eAAe;AAC/B,EAAE,oBAAoB;AACtB,EAAE,IAAI;AACN,EAAQ;AACR,EAAE,MAAM,gBAAgBA,cAAS,EAAc,EAAE,UAAU,EAAE;AAC7D,EAAE;AACF,IAAI,CAAC,aAAa,EAAE,8BAA+B;AACnD,IAAI,CAACC,yBAAS,CAAC,oBAAoB,CAAE;AACrC,IAAIC,cAAS,EAAG;AAChB,IAAIC,oBAAe,CAAC,aAAa;AACjC,IAAI;AACJ,IAAIC,mBAAc,CAAC,MAAM;AACzB,MAAM,IAAIC,cAAK,EAAE,EAAE;AACnB;AACA,QAAQ,OAAO,CAAC,IAAI;AACpB,UAAU,CAAC,SAAS,EAAE,IAAI,CAAC,mEAAmE,EAAE,IAAI,CAAC,kCAAkC,CAAC;AACxI,SAAS;AACT,aAAa;AACb;AACA,QAAQ,OAAO,CAAC,IAAI;AACpB,UAAU,CAAC,SAAS,EAAE,IAAI,CAAC,gLAAgL,EAAE,IAAI,CAAC,cAAc,CAAC;AACjO,SAAS;AACT;AACA,KAAK,CAAC;;AAEN,IAAIC,mBAAc,EAAE,CAAC,UAAU,CAAC,yBAAyB,EAAEC,uEAAmC,CAAC,IAAI,CAAC,CAAC;AACrG;AACA;;;;"}
\ No newline at end of file
diff --git a/build/esm/integrations/anr/index.js b/build/esm/integrations/anr/index.js
index 58f87a5cda8f72740dedc827cedddc2072674e37..696c1f76ecefc17d4285b1a4737113644cafb658 100644
--- a/build/esm/integrations/anr/index.js
+++ b/build/esm/integrations/anr/index.js
@@ -7,7 +7,7 @@ import { isDebuggerEnabled } from '../../utils/debug.js';
 const { isPromise } = types;
 
 // This string is a placeholder that gets overwritten with the worker code.
-const base64WorkerScript = 'LyohIEBzZW50cnkvbm9kZSA5LjEyLjAgKDRlYjc4ZTUpIHwgaHR0cHM6Ly9naXRodWIuY29tL2dldHNlbnRyeS9zZW50cnktamF2YXNjcmlwdCAqLwppbXBvcnR7U2Vzc2lvbiBhcyB0fWZyb20ibm9kZTppbnNwZWN0b3IiO2ltcG9ydHt3b3JrZXJEYXRhIGFzIG4scGFyZW50UG9ydCBhcyBlfWZyb20ibm9kZTp3b3JrZXJfdGhyZWFkcyI7aW1wb3J0e3Bvc2l4IGFzIHIsc2VwIGFzIG99ZnJvbSJub2RlOnBhdGgiO2ltcG9ydCphcyBzIGZyb20ibm9kZTpodHRwIjtpbXBvcnQqYXMgaSBmcm9tIm5vZGU6aHR0cHMiO2ltcG9ydHtSZWFkYWJsZSBhcyBjfWZyb20ibm9kZTpzdHJlYW0iO2ltcG9ydHtjcmVhdGVHemlwIGFzIHV9ZnJvbSJub2RlOnpsaWIiO2ltcG9ydCphcyBhIGZyb20ibm9kZTpuZXQiO2ltcG9ydCphcyBmIGZyb20ibm9kZTp0bHMiO2NvbnN0IGg9InVuZGVmaW5lZCI9PXR5cGVvZiBfX1NFTlRSWV9ERUJVR19ffHxfX1NFTlRSWV9ERUJVR19fLHA9Z2xvYmFsVGhpcyxsPSJ1bmRlZmluZWQiPT10eXBlb2YgX19TRU5UUllfREVCVUdfX3x8X19TRU5UUllfREVCVUdfXyxkPSI5LjEyLjAiO2Z1bmN0aW9uIG0oKXtyZXR1cm4gZyhwKSxwfWZ1bmN0aW9uIGcodCl7Y29uc3Qgbj10Ll9fU0VOVFJZX189dC5fX1NFTlRSWV9ffHx7fTtyZXR1cm4gbi52ZXJzaW9uPW4udmVyc2lvbnx8ZCxuW2RdPW5bZF18fHt9fWZ1bmN0aW9uIHkodCxuLGU9cCl7Y29uc3Qgcj1lLl9fU0VOVFJZX189ZS5fX1NFTlRSWV9ffHx7fSxvPXJbZF09cltkXXx8e307cmV0dXJuIG9bdF18fChvW3RdPW4oKSl9Y29uc3QgYj1bImRlYnVnIiwiaW5mbyIsIndhcm4iLCJlcnJvciIsImxvZyIsImFzc2VydCIsInRyYWNlIl0sXz17fTtmdW5jdGlvbiB2KHQpe2lmKCEoImNvbnNvbGUiaW4gcCkpcmV0dXJuIHQoKTtjb25zdCBuPXAuY29uc29sZSxlPXt9LHI9T2JqZWN0LmtleXMoXyk7ci5mb3JFYWNoKCh0PT57Y29uc3Qgcj1fW3RdO2VbdF09blt0XSxuW3RdPXJ9KSk7dHJ5e3JldHVybiB0KCl9ZmluYWxseXtyLmZvckVhY2goKHQ9PntuW3RdPWVbdF19KSl9fWNvbnN0IHc9eSgibG9nZ2VyIiwoZnVuY3Rpb24oKXtsZXQgdD0hMTtjb25zdCBuPXtlbmFibGU6KCk9Pnt0PSEwfSxkaXNhYmxlOigpPT57dD0hMX0saXNFbmFibGVkOigpPT50fTtyZXR1cm4gbD9iLmZvckVhY2goKGU9PntuW2VdPSguLi5uKT0+e3QmJnYoKCgpPT57cC5jb25zb2xlW2VdKGBTZW50cnkgTG9nZ2VyIFske2V9XTpgLC4uLm4pfSkpfX0pKTpiLmZvckVhY2goKHQ9PntuW3RdPSgpPT57fX0pKSxufSkpLFM9NTAsJD0iPyIsRT0vY2FwdHVyZU1lc3NhZ2V8Y2FwdHVyZUV4Y2VwdGlvbi87ZnVuY3Rpb24geCh0KXtyZXR1cm4gdFt0Lmxlbmd0aC0xXXx8e319Y29uc3QgTj0iPGFub255bW91cz4iO2NvbnN0IFQ9MWUzO2Z1bmN0aW9uIEMoKXtyZXR1cm4gRGF0ZS5ub3coKS9UfWNvbnN0IFI9ZnVuY3Rpb24oKXtjb25zdHtwZXJmb3JtYW5jZTp0fT1wO2lmKCF0Py5ub3cpcmV0dXJuIEM7Y29uc3Qgbj1EYXRlLm5vdygpLXQubm93KCksZT1udWxsPT10LnRpbWVPcmlnaW4/bjp0LnRpbWVPcmlnaW47cmV0dXJuKCk9PihlK3Qubm93KCkpL1R9KCksaz1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO2Z1bmN0aW9uIGoodCxuKXtyZXR1cm4gay5jYWxsKHQpPT09YFtvYmplY3QgJHtufV1gfWZ1bmN0aW9uIEQodCl7cmV0dXJuIGoodCwiU3RyaW5nIil9ZnVuY3Rpb24gSSh0KXtyZXR1cm4gaih0LCJPYmplY3QiKX1mdW5jdGlvbiBPKHQpe3JldHVybiBCb29sZWFuKHQ/LnRoZW4mJiJmdW5jdGlvbiI9PXR5cGVvZiB0LnRoZW4pfWZ1bmN0aW9uIEEodCxuKXt0cnl7cmV0dXJuIHQgaW5zdGFuY2VvZiBufWNhdGNoKHQpe3JldHVybiExfX1jb25zdCBQPXAsVT04MDtmdW5jdGlvbiBNKHQsbil7Y29uc3QgZT10LHI9W107aWYoIWU/LnRhZ05hbWUpcmV0dXJuIiI7aWYoUC5IVE1MRWxlbWVudCYmZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50JiZlLmRhdGFzZXQpe2lmKGUuZGF0YXNldC5zZW50cnlDb21wb25lbnQpcmV0dXJuIGUuZGF0YXNldC5zZW50cnlDb21wb25lbnQ7aWYoZS5kYXRhc2V0LnNlbnRyeUVsZW1lbnQpcmV0dXJuIGUuZGF0YXNldC5zZW50cnlFbGVtZW50fXIucHVzaChlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSk7Y29uc3Qgbz1uPy5sZW5ndGg/bi5maWx0ZXIoKHQ9PmUuZ2V0QXR0cmlidXRlKHQpKSkubWFwKCh0PT5bdCxlLmdldEF0dHJpYnV0ZSh0KV0pKTpudWxsO2lmKG8/Lmxlbmd0aClvLmZvckVhY2goKHQ9PntyLnB1c2goYFske3RbMF19PSIke3RbMV19Il1gKX0pKTtlbHNle2UuaWQmJnIucHVzaChgIyR7ZS5pZH1gKTtjb25zdCB0PWUuY2xhc3NOYW1lO2lmKHQmJkQodCkpe2NvbnN0IG49dC5zcGxpdCgvXHMrLyk7Zm9yKGNvbnN0IHQgb2YgbilyLnB1c2goYC4ke3R9YCl9fWNvbnN0IHM9WyJhcmlhLWxhYmVsIiwidHlwZSIsIm5hbWUiLCJ0aXRsZSIsImFsdCJdO2Zvcihjb25zdCB0IG9mIHMpe2NvbnN0IG49ZS5nZXRBdHRyaWJ1dGUodCk7biYmci5wdXNoKGBbJHt0fT0iJHtufSJdYCl9cmV0dXJuIHIuam9pbigiIil9ZnVuY3Rpb24gTCh0LG49MCl7cmV0dXJuInN0cmluZyIhPXR5cGVvZiB0fHwwPT09bnx8dC5sZW5ndGg8PW4/dDpgJHt0LnNsaWNlKDAsbil9Li4uYH1mdW5jdGlvbiBCKHQpe2lmKGZ1bmN0aW9uKHQpe3N3aXRjaChrLmNhbGwodCkpe2Nhc2UiW29iamVjdCBFcnJvcl0iOmNhc2UiW29iamVjdCBFeGNlcHRpb25dIjpjYXNlIltvYmplY3QgRE9NRXhjZXB0aW9uXSI6Y2FzZSJbb2JqZWN0IFdlYkFzc2VtYmx5LkV4Y2VwdGlvbl0iOnJldHVybiEwO2RlZmF1bHQ6cmV0dXJuIEEodCxFcnJvcil9fSh0KSlyZXR1cm57bWVzc2FnZTp0Lm1lc3NhZ2UsbmFtZTp0Lm5hbWUsc3RhY2s6dC5zdGFjaywuLi5KKHQpfTtpZihuPXQsInVuZGVmaW5lZCIhPXR5cGVvZiBFdmVudCYmQShuLEV2ZW50KSl7Y29uc3Qgbj17dHlwZTp0LnR5cGUsdGFyZ2V0OkcodC50YXJnZXQpLGN1cnJlbnRUYXJnZXQ6Ryh0LmN1cnJlbnRUYXJnZXQpLC4uLkoodCl9O3JldHVybiJ1bmRlZmluZWQiIT10eXBlb2YgQ3VzdG9tRXZlbnQmJkEodCxDdXN0b21FdmVudCkmJihuLmRldGFpbD10LmRldGFpbCksbn1yZXR1cm4gdDt2YXIgbn1mdW5jdGlvbiBHKHQpe3RyeXtyZXR1cm4gbj10LCJ1bmRlZmluZWQiIT10eXBlb2YgRWxlbWVudCYmQShuLEVsZW1lbnQpP2Z1bmN0aW9uKHQsbj17fSl7aWYoIXQpcmV0dXJuIjx1bmtub3duPiI7dHJ5e2xldCBlPXQ7Y29uc3Qgcj01LG89W107bGV0IHM9MCxpPTA7Y29uc3QgYz0iID4gIix1PWMubGVuZ3RoO2xldCBhO2NvbnN0IGY9QXJyYXkuaXNBcnJheShuKT9uOm4ua2V5QXR0cnMsaD0hQXJyYXkuaXNBcnJheShuKSYmbi5tYXhTdHJpbmdMZW5ndGh8fFU7Zm9yKDtlJiZzKys8ciYmKGE9TShlLGYpLCEoImh0bWwiPT09YXx8cz4xJiZpK28ubGVuZ3RoKnUrYS5sZW5ndGg+PWgpKTspby5wdXNoKGEpLGkrPWEubGVuZ3RoLGU9ZS5wYXJlbnROb2RlO3JldHVybiBvLnJldmVyc2UoKS5qb2luKGMpfWNhdGNoKHQpe3JldHVybiI8dW5rbm93bj4ifX0odCk6T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpfWNhdGNoKHQpe3JldHVybiI8dW5rbm93bj4ifXZhciBufWZ1bmN0aW9uIEoodCl7aWYoIm9iamVjdCI9PXR5cGVvZiB0JiZudWxsIT09dCl7Y29uc3Qgbj17fTtmb3IoY29uc3QgZSBpbiB0KU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LGUpJiYobltlXT10W2VdKTtyZXR1cm4gbn1yZXR1cm57fX1mdW5jdGlvbiBZKHQ9ZnVuY3Rpb24oKXtjb25zdCB0PXA7cmV0dXJuIHQuY3J5cHRvfHx0Lm1zQ3J5cHRvfSgpKXtsZXQgbj0oKT0+MTYqTWF0aC5yYW5kb20oKTt0cnl7aWYodD8ucmFuZG9tVVVJRClyZXR1cm4gdC5yYW5kb21VVUlEKCkucmVwbGFjZSgvLS9nLCIiKTt0Py5nZXRSYW5kb21WYWx1ZXMmJihuPSgpPT57Y29uc3Qgbj1uZXcgVWludDhBcnJheSgxKTtyZXR1cm4gdC5nZXRSYW5kb21WYWx1ZXMobiksblswXX0pfWNhdGNoKHQpe31yZXR1cm4oWzFlN10rMWUzKzRlMys4ZTMrMWUxMSkucmVwbGFjZSgvWzAxOF0vZywodD0+KHReKDE1Jm4oKSk+PnQvNCkudG9TdHJpbmcoMTYpKSl9dmFyIHo7ZnVuY3Rpb24gSCh0KXtyZXR1cm4gbmV3IEYoKG49PntuKHQpfSkpfSFmdW5jdGlvbih0KXt0W3QuUEVORElORz0wXT0iUEVORElORyI7dFt0LlJFU09MVkVEPTFdPSJSRVNPTFZFRCI7dFt0LlJFSkVDVEVEPTJdPSJSRUpFQ1RFRCJ9KHp8fCh6PXt9KSk7Y2xhc3MgRntjb25zdHJ1Y3Rvcih0KXt0aGlzLnQ9ei5QRU5ESU5HLHRoaXMubz1bXSx0aGlzLmkodCl9dGhlbih0LG4pe3JldHVybiBuZXcgRigoKGUscik9Pnt0aGlzLm8ucHVzaChbITEsbj0+e2lmKHQpdHJ5e2UodChuKSl9Y2F0Y2godCl7cih0KX1lbHNlIGUobil9LHQ9PntpZihuKXRyeXtlKG4odCkpfWNhdGNoKHQpe3IodCl9ZWxzZSByKHQpfV0pLHRoaXMudSgpfSkpfWNhdGNoKHQpe3JldHVybiB0aGlzLnRoZW4oKHQ9PnQpLHQpfWZpbmFsbHkodCl7cmV0dXJuIG5ldyBGKCgobixlKT0+e2xldCByLG87cmV0dXJuIHRoaXMudGhlbigobj0+e289ITEscj1uLHQmJnQoKX0pLChuPT57bz0hMCxyPW4sdCYmdCgpfSkpLnRoZW4oKCgpPT57bz9lKHIpOm4ocil9KSl9KSl9dSgpe2lmKHRoaXMudD09PXouUEVORElORylyZXR1cm47Y29uc3QgdD10aGlzLm8uc2xpY2UoKTt0aGlzLm89W10sdC5mb3JFYWNoKCh0PT57dFswXXx8KHRoaXMudD09PXouUkVTT0xWRUQmJnRbMV0odGhpcy5oKSx0aGlzLnQ9PT16LlJFSkVDVEVEJiZ0WzJdKHRoaXMuaCksdFswXT0hMCl9KSl9aSh0KXtjb25zdCBuPSh0LG4pPT57dGhpcy50PT09ei5QRU5ESU5HJiYoTyhuKT9uLnRoZW4oZSxyKToodGhpcy50PXQsdGhpcy5oPW4sdGhpcy51KCkpKX0sZT10PT57bih6LlJFU09MVkVELHQpfSxyPXQ9PntuKHouUkVKRUNURUQsdCl9O3RyeXt0KGUscil9Y2F0Y2godCl7cih0KX19fWZ1bmN0aW9uIFcodCl7Y29uc3Qgbj1SKCksZT17c2lkOlkoKSxpbml0OiEwLHRpbWVzdGFtcDpuLHN0YXJ0ZWQ6bixkdXJhdGlvbjowLHN0YXR1czoib2siLGVycm9yczowLGlnbm9yZUR1cmF0aW9uOiExLHRvSlNPTjooKT0+ZnVuY3Rpb24odCl7cmV0dXJue3NpZDpgJHt0LnNpZH1gLGluaXQ6dC5pbml0LHN0YXJ0ZWQ6bmV3IERhdGUoMWUzKnQuc3RhcnRlZCkudG9JU09TdHJpbmcoKSx0aW1lc3RhbXA6bmV3IERhdGUoMWUzKnQudGltZXN0YW1wKS50b0lTT1N0cmluZygpLHN0YXR1czp0LnN0YXR1cyxlcnJvcnM6dC5lcnJvcnMsZGlkOiJudW1iZXIiPT10eXBlb2YgdC5kaWR8fCJzdHJpbmciPT10eXBlb2YgdC5kaWQ/YCR7dC5kaWR9YDp2b2lkIDAsZHVyYXRpb246dC5kdXJhdGlvbixhYm5vcm1hbF9tZWNoYW5pc206dC5hYm5vcm1hbF9tZWNoYW5pc20sYXR0cnM6e3JlbGVhc2U6dC5yZWxlYXNlLGVudmlyb25tZW50OnQuZW52aXJvbm1lbnQsaXBfYWRkcmVzczp0LmlwQWRkcmVzcyx1c2VyX2FnZW50OnQudXNlckFnZW50fX19KGUpfTtyZXR1cm4gdCYmSyhlLHQpLGV9ZnVuY3Rpb24gSyh0LG49e30pe2lmKG4udXNlciYmKCF0LmlwQWRkcmVzcyYmbi51c2VyLmlwX2FkZHJlc3MmJih0LmlwQWRkcmVzcz1uLnVzZXIuaXBfYWRkcmVzcyksdC5kaWR8fG4uZGlkfHwodC5kaWQ9bi51c2VyLmlkfHxuLnVzZXIuZW1haWx8fG4udXNlci51c2VybmFtZSkpLHQudGltZXN0YW1wPW4udGltZXN0YW1wfHxSKCksbi5hYm5vcm1hbF9tZWNoYW5pc20mJih0LmFibm9ybWFsX21lY2hhbmlzbT1uLmFibm9ybWFsX21lY2hhbmlzbSksbi5pZ25vcmVEdXJhdGlvbiYmKHQuaWdub3JlRHVyYXRpb249bi5pZ25vcmVEdXJhdGlvbiksbi5zaWQmJih0LnNpZD0zMj09PW4uc2lkLmxlbmd0aD9uLnNpZDpZKCkpLHZvaWQgMCE9PW4uaW5pdCYmKHQuaW5pdD1uLmluaXQpLCF0LmRpZCYmbi5kaWQmJih0LmRpZD1gJHtuLmRpZH1gKSwibnVtYmVyIj09dHlwZW9mIG4uc3RhcnRlZCYmKHQuc3RhcnRlZD1uLnN0YXJ0ZWQpLHQuaWdub3JlRHVyYXRpb24pdC5kdXJhdGlvbj12b2lkIDA7ZWxzZSBpZigibnVtYmVyIj09dHlwZW9mIG4uZHVyYXRpb24pdC5kdXJhdGlvbj1uLmR1cmF0aW9uO2Vsc2V7Y29uc3Qgbj10LnRpbWVzdGFtcC10LnN0YXJ0ZWQ7dC5kdXJhdGlvbj1uPj0wP246MH1uLnJlbGVhc2UmJih0LnJlbGVhc2U9bi5yZWxlYXNlKSxuLmVudmlyb25tZW50JiYodC5lbnZpcm9ubWVudD1uLmVudmlyb25tZW50KSwhdC5pcEFkZHJlc3MmJm4uaXBBZGRyZXNzJiYodC5pcEFkZHJlc3M9bi5pcEFkZHJlc3MpLCF0LnVzZXJBZ2VudCYmbi51c2VyQWdlbnQmJih0LnVzZXJBZ2VudD1uLnVzZXJBZ2VudCksIm51bWJlciI9PXR5cGVvZiBuLmVycm9ycyYmKHQuZXJyb3JzPW4uZXJyb3JzKSxuLnN0YXR1cyYmKHQuc3RhdHVzPW4uc3RhdHVzKX1mdW5jdGlvbiBWKCl7cmV0dXJuIFkoKX1mdW5jdGlvbiBaKCl7cmV0dXJuIFkoKS5zdWJzdHJpbmcoMTYpfWZ1bmN0aW9uIHEodCxuLGU9Mil7aWYoIW58fCJvYmplY3QiIT10eXBlb2Ygbnx8ZTw9MClyZXR1cm4gbjtpZih0JiYwPT09T2JqZWN0LmtleXMobikubGVuZ3RoKXJldHVybiB0O2NvbnN0IHI9ey4uLnR9O2Zvcihjb25zdCB0IGluIG4pT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sdCkmJihyW3RdPXEoclt0XSxuW3RdLGUtMSkpO3JldHVybiByfWNvbnN0IFE9Il9zZW50cnlTcGFuIjtmdW5jdGlvbiBYKHQsbil7bj9mdW5jdGlvbih0LG4sZSl7dHJ5e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4se3ZhbHVlOmUsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfSl9Y2F0Y2goZSl7bCYmdy5sb2coYEZhaWxlZCB0byBhZGQgbm9uLWVudW1lcmFibGUgcHJvcGVydHkgIiR7bn0iIHRvIG9iamVjdGAsdCl9fSh0LFEsbik6ZGVsZXRlIHRbUV19ZnVuY3Rpb24gdHQodCl7cmV0dXJuIHRbUV19Y2xhc3MgbnR7Y29uc3RydWN0b3IoKXt0aGlzLnA9ITEsdGhpcy5sPVtdLHRoaXMubT1bXSx0aGlzLl89W10sdGhpcy52PVtdLHRoaXMuUz17fSx0aGlzLk49e30sdGhpcy5UPXt9LHRoaXMuQz17fSx0aGlzLlI9e30sdGhpcy5rPXt0cmFjZUlkOlYoKSxzYW1wbGVSYW5kOk1hdGgucmFuZG9tKCl9fWNsb25lKCl7Y29uc3QgdD1uZXcgbnQ7cmV0dXJuIHQuXz1bLi4udGhpcy5fXSx0Lk49ey4uLnRoaXMuTn0sdC5UPXsuLi50aGlzLlR9LHQuQz17Li4udGhpcy5DfSx0aGlzLkMuZmxhZ3MmJih0LkMuZmxhZ3M9e3ZhbHVlczpbLi4udGhpcy5DLmZsYWdzLnZhbHVlc119KSx0LlM9dGhpcy5TLHQuaj10aGlzLmosdC5EPXRoaXMuRCx0Lkk9dGhpcy5JLHQuTz10aGlzLk8sdC5tPVsuLi50aGlzLm1dLHQudj1bLi4udGhpcy52XSx0LlI9ey4uLnRoaXMuUn0sdC5rPXsuLi50aGlzLmt9LHQuQT10aGlzLkEsdC5QPXRoaXMuUCxYKHQsdHQodGhpcykpLHR9c2V0Q2xpZW50KHQpe3RoaXMuQT10fXNldExhc3RFdmVudElkKHQpe3RoaXMuUD10fWdldENsaWVudCgpe3JldHVybiB0aGlzLkF9bGFzdEV2ZW50SWQoKXtyZXR1cm4gdGhpcy5QfWFkZFNjb3BlTGlzdGVuZXIodCl7dGhpcy5sLnB1c2godCl9YWRkRXZlbnRQcm9jZXNzb3IodCl7cmV0dXJuIHRoaXMubS5wdXNoKHQpLHRoaXN9c2V0VXNlcih0KXtyZXR1cm4gdGhpcy5TPXR8fHtlbWFpbDp2b2lkIDAsaWQ6dm9pZCAwLGlwX2FkZHJlc3M6dm9pZCAwLHVzZXJuYW1lOnZvaWQgMH0sdGhpcy5EJiZLKHRoaXMuRCx7dXNlcjp0fSksdGhpcy5VKCksdGhpc31nZXRVc2VyKCl7cmV0dXJuIHRoaXMuU31zZXRUYWdzKHQpe3JldHVybiB0aGlzLk49ey4uLnRoaXMuTiwuLi50fSx0aGlzLlUoKSx0aGlzfXNldFRhZyh0LG4pe3JldHVybiB0aGlzLk49ey4uLnRoaXMuTixbdF06bn0sdGhpcy5VKCksdGhpc31zZXRFeHRyYXModCl7cmV0dXJuIHRoaXMuVD17Li4udGhpcy5ULC4uLnR9LHRoaXMuVSgpLHRoaXN9c2V0RXh0cmEodCxuKXtyZXR1cm4gdGhpcy5UPXsuLi50aGlzLlQsW3RdOm59LHRoaXMuVSgpLHRoaXN9c2V0RmluZ2VycHJpbnQodCl7cmV0dXJuIHRoaXMuTz10LHRoaXMuVSgpLHRoaXN9c2V0TGV2ZWwodCl7cmV0dXJuIHRoaXMuaj10LHRoaXMuVSgpLHRoaXN9c2V0VHJhbnNhY3Rpb25OYW1lKHQpe3JldHVybiB0aGlzLkk9dCx0aGlzLlUoKSx0aGlzfXNldENvbnRleHQodCxuKXtyZXR1cm4gbnVsbD09PW4/ZGVsZXRlIHRoaXMuQ1t0XTp0aGlzLkNbdF09bix0aGlzLlUoKSx0aGlzfXNldFNlc3Npb24odCl7cmV0dXJuIHQ/dGhpcy5EPXQ6ZGVsZXRlIHRoaXMuRCx0aGlzLlUoKSx0aGlzfWdldFNlc3Npb24oKXtyZXR1cm4gdGhpcy5EfXVwZGF0ZSh0KXtpZighdClyZXR1cm4gdGhpcztjb25zdCBuPSJmdW5jdGlvbiI9PXR5cGVvZiB0P3QodGhpcyk6dCxlPW4gaW5zdGFuY2VvZiBudD9uLmdldFNjb3BlRGF0YSgpOkkobik/dDp2b2lkIDAse3RhZ3M6cixleHRyYTpvLHVzZXI6cyxjb250ZXh0czppLGxldmVsOmMsZmluZ2VycHJpbnQ6dT1bXSxwcm9wYWdhdGlvbkNvbnRleHQ6YX09ZXx8e307cmV0dXJuIHRoaXMuTj17Li4udGhpcy5OLC4uLnJ9LHRoaXMuVD17Li4udGhpcy5ULC4uLm99LHRoaXMuQz17Li4udGhpcy5DLC4uLml9LHMmJk9iamVjdC5rZXlzKHMpLmxlbmd0aCYmKHRoaXMuUz1zKSxjJiYodGhpcy5qPWMpLHUubGVuZ3RoJiYodGhpcy5PPXUpLGEmJih0aGlzLms9YSksdGhpc31jbGVhcigpe3JldHVybiB0aGlzLl89W10sdGhpcy5OPXt9LHRoaXMuVD17fSx0aGlzLlM9e30sdGhpcy5DPXt9LHRoaXMuaj12b2lkIDAsdGhpcy5JPXZvaWQgMCx0aGlzLk89dm9pZCAwLHRoaXMuRD12b2lkIDAsWCh0aGlzLHZvaWQgMCksdGhpcy52PVtdLHRoaXMuc2V0UHJvcGFnYXRpb25Db250ZXh0KHt0cmFjZUlkOlYoKSxzYW1wbGVSYW5kOk1hdGgucmFuZG9tKCl9KSx0aGlzLlUoKSx0aGlzfWFkZEJyZWFkY3J1bWIodCxuKXtjb25zdCBlPSJudW1iZXIiPT10eXBlb2Ygbj9uOjEwMDtpZihlPD0wKXJldHVybiB0aGlzO2NvbnN0IHI9e3RpbWVzdGFtcDpDKCksLi4udCxtZXNzYWdlOnQubWVzc2FnZT9MKHQubWVzc2FnZSwyMDQ4KTp0Lm1lc3NhZ2V9O3JldHVybiB0aGlzLl8ucHVzaChyKSx0aGlzLl8ubGVuZ3RoPmUmJih0aGlzLl89dGhpcy5fLnNsaWNlKC1lKSx0aGlzLkE/LnJlY29yZERyb3BwZWRFdmVudCgiYnVmZmVyX292ZXJmbG93IiwibG9nX2l0ZW0iKSksdGhpcy5VKCksdGhpc31nZXRMYXN0QnJlYWRjcnVtYigpe3JldHVybiB0aGlzLl9bdGhpcy5fLmxlbmd0aC0xXX1jbGVhckJyZWFkY3J1bWJzKCl7cmV0dXJuIHRoaXMuXz1bXSx0aGlzLlUoKSx0aGlzfWFkZEF0dGFjaG1lbnQodCl7cmV0dXJuIHRoaXMudi5wdXNoKHQpLHRoaXN9Y2xlYXJBdHRhY2htZW50cygpe3JldHVybiB0aGlzLnY9W10sdGhpc31nZXRTY29wZURhdGEoKXtyZXR1cm57YnJlYWRjcnVtYnM6dGhpcy5fLGF0dGFjaG1lbnRzOnRoaXMudixjb250ZXh0czp0aGlzLkMsdGFnczp0aGlzLk4sZXh0cmE6dGhpcy5ULHVzZXI6dGhpcy5TLGxldmVsOnRoaXMuaixmaW5nZXJwcmludDp0aGlzLk98fFtdLGV2ZW50UHJvY2Vzc29yczp0aGlzLm0scHJvcGFnYXRpb25Db250ZXh0OnRoaXMuayxzZGtQcm9jZXNzaW5nTWV0YWRhdGE6dGhpcy5SLHRyYW5zYWN0aW9uTmFtZTp0aGlzLkksc3Bhbjp0dCh0aGlzKX19c2V0U0RLUHJvY2Vzc2luZ01ldGFkYXRhKHQpe3JldHVybiB0aGlzLlI9cSh0aGlzLlIsdCwyKSx0aGlzfXNldFByb3BhZ2F0aW9uQ29udGV4dCh0KXtyZXR1cm4gdGhpcy5rPXQsdGhpc31nZXRQcm9wYWdhdGlvbkNvbnRleHQoKXtyZXR1cm4gdGhpcy5rfWNhcHR1cmVFeGNlcHRpb24odCxuKXtjb25zdCBlPW4/LmV2ZW50X2lkfHxZKCk7aWYoIXRoaXMuQSlyZXR1cm4gdy53YXJuKCJObyBjbGllbnQgY29uZmlndXJlZCBvbiBzY29wZSAtIHdpbGwgbm90IGNhcHR1cmUgZXhjZXB0aW9uISIpLGU7Y29uc3Qgcj1uZXcgRXJyb3IoIlNlbnRyeSBzeW50aGV0aWNFeGNlcHRpb24iKTtyZXR1cm4gdGhpcy5BLmNhcHR1cmVFeGNlcHRpb24odCx7b3JpZ2luYWxFeGNlcHRpb246dCxzeW50aGV0aWNFeGNlcHRpb246ciwuLi5uLGV2ZW50X2lkOmV9LHRoaXMpLGV9Y2FwdHVyZU1lc3NhZ2UodCxuLGUpe2NvbnN0IHI9ZT8uZXZlbnRfaWR8fFkoKTtpZighdGhpcy5BKXJldHVybiB3Lndhcm4oIk5vIGNsaWVudCBjb25maWd1cmVkIG9uIHNjb3BlIC0gd2lsbCBub3QgY2FwdHVyZSBtZXNzYWdlISIpLHI7Y29uc3Qgbz1uZXcgRXJyb3IodCk7cmV0dXJuIHRoaXMuQS5jYXB0dXJlTWVzc2FnZSh0LG4se29yaWdpbmFsRXhjZXB0aW9uOnQsc3ludGhldGljRXhjZXB0aW9uOm8sLi4uZSxldmVudF9pZDpyfSx0aGlzKSxyfWNhcHR1cmVFdmVudCh0LG4pe2NvbnN0IGU9bj8uZXZlbnRfaWR8fFkoKTtyZXR1cm4gdGhpcy5BPyh0aGlzLkEuY2FwdHVyZUV2ZW50KHQsey4uLm4sZXZlbnRfaWQ6ZX0sdGhpcyksZSk6KHcud2FybigiTm8gY2xpZW50IGNvbmZpZ3VyZWQgb24gc2NvcGUgLSB3aWxsIG5vdCBjYXB0dXJlIGV2ZW50ISIpLGUpfVUoKXt0aGlzLnB8fCh0aGlzLnA9ITAsdGhpcy5sLmZvckVhY2goKHQ9Pnt0KHRoaXMpfSkpLHRoaXMucD0hMSl9fWNsYXNzIGV0e2NvbnN0cnVjdG9yKHQsbil7bGV0IGUscjtlPXR8fG5ldyBudCxyPW58fG5ldyBudCx0aGlzLk09W3tzY29wZTplfV0sdGhpcy5MPXJ9d2l0aFNjb3BlKHQpe2NvbnN0IG49dGhpcy5CKCk7bGV0IGU7dHJ5e2U9dChuKX1jYXRjaCh0KXt0aHJvdyB0aGlzLkcoKSx0fXJldHVybiBPKGUpP2UudGhlbigodD0+KHRoaXMuRygpLHQpKSwodD0+e3Rocm93IHRoaXMuRygpLHR9KSk6KHRoaXMuRygpLGUpfWdldENsaWVudCgpe3JldHVybiB0aGlzLmdldFN0YWNrVG9wKCkuY2xpZW50fWdldFNjb3BlKCl7cmV0dXJuIHRoaXMuZ2V0U3RhY2tUb3AoKS5zY29wZX1nZXRJc29sYXRpb25TY29wZSgpe3JldHVybiB0aGlzLkx9Z2V0U3RhY2tUb3AoKXtyZXR1cm4gdGhpcy5NW3RoaXMuTS5sZW5ndGgtMV19Qigpe2NvbnN0IHQ9dGhpcy5nZXRTY29wZSgpLmNsb25lKCk7cmV0dXJuIHRoaXMuTS5wdXNoKHtjbGllbnQ6dGhpcy5nZXRDbGllbnQoKSxzY29wZTp0fSksdH1HKCl7cmV0dXJuISh0aGlzLk0ubGVuZ3RoPD0xKSYmISF0aGlzLk0ucG9wKCl9fWZ1bmN0aW9uIHJ0KCl7Y29uc3QgdD1nKG0oKSk7cmV0dXJuIHQuc3RhY2s9dC5zdGFja3x8bmV3IGV0KHkoImRlZmF1bHRDdXJyZW50U2NvcGUiLCgoKT0+bmV3IG50KSkseSgiZGVmYXVsdElzb2xhdGlvblNjb3BlIiwoKCk9Pm5ldyBudCkpKX1mdW5jdGlvbiBvdCh0KXtyZXR1cm4gcnQoKS53aXRoU2NvcGUodCl9ZnVuY3Rpb24gc3QodCxuKXtjb25zdCBlPXJ0KCk7cmV0dXJuIGUud2l0aFNjb3BlKCgoKT0+KGUuZ2V0U3RhY2tUb3AoKS5zY29wZT10LG4odCkpKSl9ZnVuY3Rpb24gaXQodCl7cmV0dXJuIHJ0KCkud2l0aFNjb3BlKCgoKT0+dChydCgpLmdldElzb2xhdGlvblNjb3BlKCkpKSl9ZnVuY3Rpb24gY3QodCl7Y29uc3Qgbj1nKHQpO3JldHVybiBuLmFjcz9uLmFjczp7d2l0aElzb2xhdGlvblNjb3BlOml0LHdpdGhTY29wZTpvdCx3aXRoU2V0U2NvcGU6c3Qsd2l0aFNldElzb2xhdGlvblNjb3BlOih0LG4pPT5pdChuKSxnZXRDdXJyZW50U2NvcGU6KCk9PnJ0KCkuZ2V0U2NvcGUoKSxnZXRJc29sYXRpb25TY29wZTooKT0+cnQoKS5nZXRJc29sYXRpb25TY29wZSgpfX1mdW5jdGlvbiB1dCgpe3JldHVybiBjdChtKCkpLmdldEN1cnJlbnRTY29wZSgpLmdldENsaWVudCgpfWNvbnN0IGF0PSJzZW50cnkuc291cmNlIixmdD0ic2VudHJ5LnNhbXBsZV9yYXRlIixodD0ic2VudHJ5Lm9wIixwdD0ic2VudHJ5Lm9yaWdpbiIsbHQ9MCxkdD0xLG10PSJfc2VudHJ5U2NvcGUiLGd0PSJfc2VudHJ5SXNvbGF0aW9uU2NvcGUiO2Z1bmN0aW9uIHl0KHQpe3JldHVybntzY29wZTp0W210XSxpc29sYXRpb25TY29wZTp0W2d0XX19Y29uc3QgYnQ9InNlbnRyeS0iLF90PS9ec2VudHJ5LS87ZnVuY3Rpb24gdnQodCl7Y29uc3Qgbj1mdW5jdGlvbih0KXtpZighdHx8IUQodCkmJiFBcnJheS5pc0FycmF5KHQpKXJldHVybjtpZihBcnJheS5pc0FycmF5KHQpKXJldHVybiB0LnJlZHVjZSgoKHQsbik9Pntjb25zdCBlPXd0KG4pO3JldHVybiBPYmplY3QuZW50cmllcyhlKS5mb3JFYWNoKCgoW24sZV0pPT57dFtuXT1lfSkpLHR9KSx7fSk7cmV0dXJuIHd0KHQpfSh0KTtpZighbilyZXR1cm47Y29uc3QgZT1PYmplY3QuZW50cmllcyhuKS5yZWR1Y2UoKCh0LFtuLGVdKT0+e2lmKG4ubWF0Y2goX3QpKXt0W24uc2xpY2UoYnQubGVuZ3RoKV09ZX1yZXR1cm4gdH0pLHt9KTtyZXR1cm4gT2JqZWN0LmtleXMoZSkubGVuZ3RoPjA/ZTp2b2lkIDB9ZnVuY3Rpb24gd3QodCl7cmV0dXJuIHQuc3BsaXQoIiwiKS5tYXAoKHQ9PnQuc3BsaXQoIj0iKS5tYXAoKHQ9PmRlY29kZVVSSUNvbXBvbmVudCh0LnRyaW0oKSkpKSkpLnJlZHVjZSgoKHQsW24sZV0pPT4obiYmZSYmKHRbbl09ZSksdCkpLHt9KX1jb25zdCBTdD0xO2Z1bmN0aW9uICR0KHQpe2NvbnN0e3NwYW5JZDpuLHRyYWNlSWQ6ZSxpc1JlbW90ZTpyfT10LnNwYW5Db250ZXh0KCksbz1yP246VHQodCkucGFyZW50X3NwYW5faWQscz15dCh0KS5zY29wZTtyZXR1cm57cGFyZW50X3NwYW5faWQ6byxzcGFuX2lkOnI/cz8uZ2V0UHJvcGFnYXRpb25Db250ZXh0KCkucHJvcGFnYXRpb25TcGFuSWR8fFooKTpuLHRyYWNlX2lkOmV9fWZ1bmN0aW9uIEV0KHQpe3JldHVybiB0JiZ0Lmxlbmd0aD4wP3QubWFwKCgoe2NvbnRleHQ6e3NwYW5JZDp0LHRyYWNlSWQ6bix0cmFjZUZsYWdzOmUsLi4ucn0sYXR0cmlidXRlczpvfSk9Pih7c3Bhbl9pZDp0LHRyYWNlX2lkOm4sc2FtcGxlZDplPT09U3QsYXR0cmlidXRlczpvLC4uLnJ9KSkpOnZvaWQgMH1mdW5jdGlvbiB4dCh0KXtyZXR1cm4ibnVtYmVyIj09dHlwZW9mIHQ/TnQodCk6QXJyYXkuaXNBcnJheSh0KT90WzBdK3RbMV0vMWU5OnQgaW5zdGFuY2VvZiBEYXRlP050KHQuZ2V0VGltZSgpKTpSKCl9ZnVuY3Rpb24gTnQodCl7cmV0dXJuIHQ+OTk5OTk5OTk5OT90LzFlMzp0fWZ1bmN0aW9uIFR0KHQpe2lmKGZ1bmN0aW9uKHQpe3JldHVybiJmdW5jdGlvbiI9PXR5cGVvZiB0LmdldFNwYW5KU09OfSh0KSlyZXR1cm4gdC5nZXRTcGFuSlNPTigpO2NvbnN0e3NwYW5JZDpuLHRyYWNlSWQ6ZX09dC5zcGFuQ29udGV4dCgpO2lmKGZ1bmN0aW9uKHQpe2NvbnN0IG49dDtyZXR1cm4hIShuLmF0dHJpYnV0ZXMmJm4uc3RhcnRUaW1lJiZuLm5hbWUmJm4uZW5kVGltZSYmbi5zdGF0dXMpfSh0KSl7Y29uc3R7YXR0cmlidXRlczpyLHN0YXJ0VGltZTpvLG5hbWU6cyxlbmRUaW1lOmkscGFyZW50U3BhbklkOmMsc3RhdHVzOnUsbGlua3M6YX09dDtyZXR1cm57c3Bhbl9pZDpuLHRyYWNlX2lkOmUsZGF0YTpyLGRlc2NyaXB0aW9uOnMscGFyZW50X3NwYW5faWQ6YyxzdGFydF90aW1lc3RhbXA6eHQobyksdGltZXN0YW1wOnh0KGkpfHx2b2lkIDAsc3RhdHVzOkN0KHUpLG9wOnJbaHRdLG9yaWdpbjpyW3B0XSxsaW5rczpFdChhKX19cmV0dXJue3NwYW5faWQ6bix0cmFjZV9pZDplLHN0YXJ0X3RpbWVzdGFtcDowLGRhdGE6e319fWZ1bmN0aW9uIEN0KHQpe2lmKHQmJnQuY29kZSE9PWx0KXJldHVybiB0LmNvZGU9PT1kdD8ib2siOnQubWVzc2FnZXx8InVua25vd25fZXJyb3IifWNvbnN0IFJ0PSJfc2VudHJ5Um9vdFNwYW4iO2Z1bmN0aW9uIGt0KHQpe3JldHVybiB0W1J0XXx8dH1jb25zdCBqdD0icHJvZHVjdGlvbiIsRHQ9Il9mcm96ZW5Ec2MiO2Z1bmN0aW9uIEl0KHQpe2NvbnN0IG49dXQoKTtpZighbilyZXR1cm57fTtjb25zdCBlPWt0KHQpLHI9VHQoZSksbz1yLmRhdGEscz1lLnNwYW5Db250ZXh0KCkudHJhY2VTdGF0ZSxpPXM/LmdldCgic2VudHJ5LnNhbXBsZV9yYXRlIik/P29bZnRdO2Z1bmN0aW9uIGModCl7cmV0dXJuIm51bWJlciIhPXR5cGVvZiBpJiYic3RyaW5nIiE9dHlwZW9mIGl8fCh0LnNhbXBsZV9yYXRlPWAke2l9YCksdH1jb25zdCB1PWVbRHRdO2lmKHUpcmV0dXJuIGModSk7Y29uc3QgYT1zPy5nZXQoInNlbnRyeS5kc2MiKSxmPWEmJnZ0KGEpO2lmKGYpcmV0dXJuIGMoZik7Y29uc3QgaD1mdW5jdGlvbih0LG4pe2NvbnN0IGU9bi5nZXRPcHRpb25zKCkse3B1YmxpY0tleTpyfT1uLmdldERzbigpfHx7fSxvPXtlbnZpcm9ubWVudDplLmVudmlyb25tZW50fHxqdCxyZWxlYXNlOmUucmVsZWFzZSxwdWJsaWNfa2V5OnIsdHJhY2VfaWQ6dH07cmV0dXJuIG4uZW1pdCgiY3JlYXRlRHNjIixvKSxvfSh0LnNwYW5Db250ZXh0KCkudHJhY2VJZCxuKSxwPW9bYXRdLGw9ci5kZXNjcmlwdGlvbjtyZXR1cm4idXJsIiE9PXAmJmwmJihoLnRyYW5zYWN0aW9uPWwpLGZ1bmN0aW9uKHQpe2lmKCJib29sZWFuIj09dHlwZW9mIF9fU0VOVFJZX1RSQUNJTkdfXyYmIV9fU0VOVFJZX1RSQUNJTkdfXylyZXR1cm4hMTtjb25zdCBuPXR8fHV0KCk/LmdldE9wdGlvbnMoKTtyZXR1cm4hKCFufHxudWxsPT1uLnRyYWNlc1NhbXBsZVJhdGUmJiFuLnRyYWNlc1NhbXBsZXIpfSgpJiYoaC5zYW1wbGVkPVN0cmluZyhmdW5jdGlvbih0KXtjb25zdHt0cmFjZUZsYWdzOm59PXQuc3BhbkNvbnRleHQoKTtyZXR1cm4gbj09PVN0fShlKSksaC5zYW1wbGVfcmFuZD1zPy5nZXQoInNlbnRyeS5zYW1wbGVfcmFuZCIpPz95dChlKS5zY29wZT8uZ2V0UHJvcGFnYXRpb25Db250ZXh0KCkuc2FtcGxlUmFuZC50b1N0cmluZygpKSxjKGgpLG4uZW1pdCgiY3JlYXRlRHNjIixoLGUpLGh9ZnVuY3Rpb24gT3QodCxuPSExKXtjb25zdHtob3N0OmUscGF0aDpyLHBhc3M6byxwb3J0OnMscHJvamVjdElkOmkscHJvdG9jb2w6YyxwdWJsaWNLZXk6dX09dDtyZXR1cm5gJHtjfTovLyR7dX0ke24mJm8/YDoke299YDoiIn1AJHtlfSR7cz9gOiR7c31gOiIifS8ke3I/YCR7cn0vYDpyfSR7aX1gfWZ1bmN0aW9uIEF0KHQsbj0xMDAsZT0xLzApe3RyeXtyZXR1cm4gUHQoIiIsdCxuLGUpfWNhdGNoKHQpe3JldHVybntFUlJPUjpgKipub24tc2VyaWFsaXphYmxlKiogKCR7dH0pYH19fWZ1bmN0aW9uIFB0KHQsbixlPTEvMCxyPTEvMCxvPWZ1bmN0aW9uKCl7Y29uc3QgdD1uZXcgV2Vha1NldDtmdW5jdGlvbiBuKG4pe3JldHVybiEhdC5oYXMobil8fCh0LmFkZChuKSwhMSl9ZnVuY3Rpb24gZShuKXt0LmRlbGV0ZShuKX1yZXR1cm5bbixlXX0oKSl7Y29uc3RbcyxpXT1vO2lmKG51bGw9PW58fFsiYm9vbGVhbiIsInN0cmluZyJdLmluY2x1ZGVzKHR5cGVvZiBuKXx8Im51bWJlciI9PXR5cGVvZiBuJiZOdW1iZXIuaXNGaW5pdGUobikpcmV0dXJuIG47Y29uc3QgYz1mdW5jdGlvbih0LG4pe3RyeXtpZigiZG9tYWluIj09PXQmJm4mJiJvYmplY3QiPT10eXBlb2YgbiYmbi5KKXJldHVybiJbRG9tYWluXSI7aWYoImRvbWFpbkVtaXR0ZXIiPT09dClyZXR1cm4iW0RvbWFpbkVtaXR0ZXJdIjtpZigidW5kZWZpbmVkIiE9dHlwZW9mIGdsb2JhbCYmbj09PWdsb2JhbClyZXR1cm4iW0dsb2JhbF0iO2lmKCJ1bmRlZmluZWQiIT10eXBlb2Ygd2luZG93JiZuPT09d2luZG93KXJldHVybiJbV2luZG93XSI7aWYoInVuZGVmaW5lZCIhPXR5cGVvZiBkb2N1bWVudCYmbj09PWRvY3VtZW50KXJldHVybiJbRG9jdW1lbnRdIjtpZigib2JqZWN0Ij09dHlwZW9mKGU9bikmJm51bGwhPT1lJiYoZS5fX2lzVnVlfHxlLlkpKXJldHVybiJbVnVlVmlld01vZGVsXSI7aWYoZnVuY3Rpb24odCl7cmV0dXJuIEkodCkmJiJuYXRpdmVFdmVudCJpbiB0JiYicHJldmVudERlZmF1bHQiaW4gdCYmInN0b3BQcm9wYWdhdGlvbiJpbiB0fShuKSlyZXR1cm4iW1N5bnRoZXRpY0V2ZW50XSI7aWYoIm51bWJlciI9PXR5cGVvZiBuJiYhTnVtYmVyLmlzRmluaXRlKG4pKXJldHVybmBbJHtufV1gO2lmKCJmdW5jdGlvbiI9PXR5cGVvZiBuKXJldHVybmBbRnVuY3Rpb246ICR7ZnVuY3Rpb24odCl7dHJ5e3JldHVybiB0JiYiZnVuY3Rpb24iPT10eXBlb2YgdCYmdC5uYW1lfHxOfWNhdGNoKHQpe3JldHVybiBOfX0obil9XWA7aWYoInN5bWJvbCI9PXR5cGVvZiBuKXJldHVybmBbJHtTdHJpbmcobil9XWA7aWYoImJpZ2ludCI9PXR5cGVvZiBuKXJldHVybmBbQmlnSW50OiAke1N0cmluZyhuKX1dYDtjb25zdCByPWZ1bmN0aW9uKHQpe2NvbnN0IG49T2JqZWN0LmdldFByb3RvdHlwZU9mKHQpO3JldHVybiBuPy5jb25zdHJ1Y3Rvcj9uLmNvbnN0cnVjdG9yLm5hbWU6Im51bGwgcHJvdG90eXBlIn0obik7cmV0dXJuL15IVE1MKFx3KilFbGVtZW50JC8udGVzdChyKT9gW0hUTUxFbGVtZW50OiAke3J9XWA6YFtvYmplY3QgJHtyfV1gfWNhdGNoKHQpe3JldHVybmAqKm5vbi1zZXJpYWxpemFibGUqKiAoJHt0fSlgfXZhciBlfSh0LG4pO2lmKCFjLnN0YXJ0c1dpdGgoIltvYmplY3QgIikpcmV0dXJuIGM7aWYobi5fX3NlbnRyeV9za2lwX25vcm1hbGl6YXRpb25fXylyZXR1cm4gbjtjb25zdCB1PSJudW1iZXIiPT10eXBlb2Ygbi5fX3NlbnRyeV9vdmVycmlkZV9ub3JtYWxpemF0aW9uX2RlcHRoX18/bi5fX3NlbnRyeV9vdmVycmlkZV9ub3JtYWxpemF0aW9uX2RlcHRoX186ZTtpZigwPT09dSlyZXR1cm4gYy5yZXBsYWNlKCJvYmplY3QgIiwiIik7aWYocyhuKSlyZXR1cm4iW0NpcmN1bGFyIH5dIjtjb25zdCBhPW47aWYoYSYmImZ1bmN0aW9uIj09dHlwZW9mIGEudG9KU09OKXRyeXtyZXR1cm4gUHQoIiIsYS50b0pTT04oKSx1LTEscixvKX1jYXRjaCh0KXt9Y29uc3QgZj1BcnJheS5pc0FycmF5KG4pP1tdOnt9O2xldCBoPTA7Y29uc3QgcD1CKG4pO2Zvcihjb25zdCB0IGluIHApe2lmKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocCx0KSljb250aW51ZTtpZihoPj1yKXtmW3RdPSJbTWF4UHJvcGVydGllcyB+XSI7YnJlYWt9Y29uc3Qgbj1wW3RdO2ZbdF09UHQodCxuLHUtMSxyLG8pLGgrK31yZXR1cm4gaShuKSxmfWZ1bmN0aW9uIFV0KHQsbil7Y29uc3QgZT1uLnJlcGxhY2UoL1xcL2csIi8iKS5yZXBsYWNlKC9bfFxce30oKVtcXV4kKyo/Ll0vZywiXFwkJiIpO2xldCByPXQ7dHJ5e3I9ZGVjb2RlVVJJKHQpfWNhdGNoKHQpe31yZXR1cm4gci5yZXBsYWNlKC9cXC9nLCIvIikucmVwbGFjZSgvd2VicGFjazpcLz8vZywiIikucmVwbGFjZShuZXcgUmVnRXhwKGAoZmlsZTovLyk/Lyoke2V9LypgLCJpZyIpLCJhcHA6Ly8vIil9ZnVuY3Rpb24gTXQodCxuPVtdKXtyZXR1cm5bdCxuXX1mdW5jdGlvbiBMdCh0LG4pe2NvbnN0IGU9dFsxXTtmb3IoY29uc3QgdCBvZiBlKXtpZihuKHQsdFswXS50eXBlKSlyZXR1cm4hMH1yZXR1cm4hMX1mdW5jdGlvbiBCdCh0KXtjb25zdCBuPWcocCk7cmV0dXJuIG4uZW5jb2RlUG9seWZpbGw/bi5lbmNvZGVQb2x5ZmlsbCh0KToobmV3IFRleHRFbmNvZGVyKS5lbmNvZGUodCl9ZnVuY3Rpb24gR3QodCl7Y29uc3RbbixlXT10O2xldCByPUpTT04uc3RyaW5naWZ5KG4pO2Z1bmN0aW9uIG8odCl7InN0cmluZyI9PXR5cGVvZiByP3I9InN0cmluZyI9PXR5cGVvZiB0P3IrdDpbQnQociksdF06ci5wdXNoKCJzdHJpbmciPT10eXBlb2YgdD9CdCh0KTp0KX1mb3IoY29uc3QgdCBvZiBlKXtjb25zdFtuLGVdPXQ7aWYobyhgXG4ke0pTT04uc3RyaW5naWZ5KG4pfVxuYCksInN0cmluZyI9PXR5cGVvZiBlfHxlIGluc3RhbmNlb2YgVWludDhBcnJheSlvKGUpO2Vsc2V7bGV0IHQ7dHJ5e3Q9SlNPTi5zdHJpbmdpZnkoZSl9Y2F0Y2gobil7dD1KU09OLnN0cmluZ2lmeShBdChlKSl9byh0KX19cmV0dXJuInN0cmluZyI9PXR5cGVvZiByP3I6ZnVuY3Rpb24odCl7Y29uc3Qgbj10LnJlZHVjZSgoKHQsbik9PnQrbi5sZW5ndGgpLDApLGU9bmV3IFVpbnQ4QXJyYXkobik7bGV0IHI9MDtmb3IoY29uc3QgbiBvZiB0KWUuc2V0KG4scikscis9bi5sZW5ndGg7cmV0dXJuIGV9KHIpfWNvbnN0IEp0PXtzZXNzaW9uOiJzZXNzaW9uIixzZXNzaW9uczoic2Vzc2lvbiIsYXR0YWNobWVudDoiYXR0YWNobWVudCIsdHJhbnNhY3Rpb246InRyYW5zYWN0aW9uIixldmVudDoiZXJyb3IiLGNsaWVudF9yZXBvcnQ6ImludGVybmFsIix1c2VyX3JlcG9ydDoiZGVmYXVsdCIscHJvZmlsZToicHJvZmlsZSIscHJvZmlsZV9jaHVuazoicHJvZmlsZSIscmVwbGF5X2V2ZW50OiJyZXBsYXkiLHJlcGxheV9yZWNvcmRpbmc6InJlcGxheSIsY2hlY2tfaW46Im1vbml0b3IiLGZlZWRiYWNrOiJmZWVkYmFjayIsc3Bhbjoic3BhbiIscmF3X3NlY3VyaXR5OiJzZWN1cml0eSIsb3RlbF9sb2c6ImxvZ19pdGVtIn07ZnVuY3Rpb24gWXQodCl7aWYoIXQ/LnNkaylyZXR1cm47Y29uc3R7bmFtZTpuLHZlcnNpb246ZX09dC5zZGs7cmV0dXJue25hbWU6bix2ZXJzaW9uOmV9fWZ1bmN0aW9uIHp0KHQsbixlLHIpe2NvbnN0IG89WXQoZSkscz10LnR5cGUmJiJyZXBsYXlfZXZlbnQiIT09dC50eXBlP3QudHlwZToiZXZlbnQiOyFmdW5jdGlvbih0LG4pe24mJih0LnNkaz10LnNka3x8e30sdC5zZGsubmFtZT10LnNkay5uYW1lfHxuLm5hbWUsdC5zZGsudmVyc2lvbj10LnNkay52ZXJzaW9ufHxuLnZlcnNpb24sdC5zZGsuaW50ZWdyYXRpb25zPVsuLi50LnNkay5pbnRlZ3JhdGlvbnN8fFtdLC4uLm4uaW50ZWdyYXRpb25zfHxbXV0sdC5zZGsucGFja2FnZXM9Wy4uLnQuc2RrLnBhY2thZ2VzfHxbXSwuLi5uLnBhY2thZ2VzfHxbXV0pfSh0LGU/LnNkayk7Y29uc3QgaT1mdW5jdGlvbih0LG4sZSxyKXtjb25zdCBvPXQuc2RrUHJvY2Vzc2luZ01ldGFkYXRhPy5keW5hbWljU2FtcGxpbmdDb250ZXh0O3JldHVybntldmVudF9pZDp0LmV2ZW50X2lkLHNlbnRfYXQ6KG5ldyBEYXRlKS50b0lTT1N0cmluZygpLC4uLm4mJntzZGs6bn0sLi4uISFlJiZyJiZ7ZHNuOk90KHIpfSwuLi5vJiZ7dHJhY2U6b319fSh0LG8scixuKTtkZWxldGUgdC5zZGtQcm9jZXNzaW5nTWV0YWRhdGE7cmV0dXJuIE10KGksW1t7dHlwZTpzfSx0XV0pfWNvbnN0IEh0PSJfX1NFTlRSWV9TVVBQUkVTU19UUkFDSU5HX18iO2Z1bmN0aW9uIEZ0KHQpe2NvbnN0IG49Y3QobSgpKTtyZXR1cm4gbi5zdXBwcmVzc1RyYWNpbmc/bi5zdXBwcmVzc1RyYWNpbmcodCk6ZnVuY3Rpb24oLi4udCl7Y29uc3Qgbj1jdChtKCkpO2lmKDI9PT10Lmxlbmd0aCl7Y29uc3RbZSxyXT10O3JldHVybiBlP24ud2l0aFNldFNjb3BlKGUscik6bi53aXRoU2NvcGUocil9cmV0dXJuIG4ud2l0aFNjb3BlKHRbMF0pfSgobj0+KG4uc2V0U0RLUHJvY2Vzc2luZ01ldGFkYXRhKHtbSHRdOiEwfSksdCgpKSkpfWZ1bmN0aW9uIFd0KHQsbil7Y29uc3R7ZmluZ2VycHJpbnQ6ZSxzcGFuOnIsYnJlYWRjcnVtYnM6byxzZGtQcm9jZXNzaW5nTWV0YWRhdGE6c309bjshZnVuY3Rpb24odCxuKXtjb25zdHtleHRyYTplLHRhZ3M6cix1c2VyOm8sY29udGV4dHM6cyxsZXZlbDppLHRyYW5zYWN0aW9uTmFtZTpjfT1uO09iamVjdC5rZXlzKGUpLmxlbmd0aCYmKHQuZXh0cmE9ey4uLmUsLi4udC5leHRyYX0pO09iamVjdC5rZXlzKHIpLmxlbmd0aCYmKHQudGFncz17Li4uciwuLi50LnRhZ3N9KTtPYmplY3Qua2V5cyhvKS5sZW5ndGgmJih0LnVzZXI9ey4uLm8sLi4udC51c2VyfSk7T2JqZWN0LmtleXMocykubGVuZ3RoJiYodC5jb250ZXh0cz17Li4ucywuLi50LmNvbnRleHRzfSk7aSYmKHQubGV2ZWw9aSk7YyYmInRyYW5zYWN0aW9uIiE9PXQudHlwZSYmKHQudHJhbnNhY3Rpb249Yyl9KHQsbiksciYmZnVuY3Rpb24odCxuKXt0LmNvbnRleHRzPXt0cmFjZTokdChuKSwuLi50LmNvbnRleHRzfSx0LnNka1Byb2Nlc3NpbmdNZXRhZGF0YT17ZHluYW1pY1NhbXBsaW5nQ29udGV4dDpJdChuKSwuLi50LnNka1Byb2Nlc3NpbmdNZXRhZGF0YX07Y29uc3QgZT1rdChuKSxyPVR0KGUpLmRlc2NyaXB0aW9uO3ImJiF0LnRyYW5zYWN0aW9uJiYidHJhbnNhY3Rpb24iPT09dC50eXBlJiYodC50cmFuc2FjdGlvbj1yKX0odCxyKSxmdW5jdGlvbih0LG4pe3QuZmluZ2VycHJpbnQ9dC5maW5nZXJwcmludD9BcnJheS5pc0FycmF5KHQuZmluZ2VycHJpbnQpP3QuZmluZ2VycHJpbnQ6W3QuZmluZ2VycHJpbnRdOltdLG4mJih0LmZpbmdlcnByaW50PXQuZmluZ2VycHJpbnQuY29uY2F0KG4pKTt0LmZpbmdlcnByaW50Lmxlbmd0aHx8ZGVsZXRlIHQuZmluZ2VycHJpbnR9KHQsZSksZnVuY3Rpb24odCxuKXtjb25zdCBlPVsuLi50LmJyZWFkY3J1bWJzfHxbXSwuLi5uXTt0LmJyZWFkY3J1bWJzPWUubGVuZ3RoP2U6dm9pZCAwfSh0LG8pLGZ1bmN0aW9uKHQsbil7dC5zZGtQcm9jZXNzaW5nTWV0YWRhdGE9ey4uLnQuc2RrUHJvY2Vzc2luZ01ldGFkYXRhLC4uLm59fSh0LHMpfWNvbnN0IEt0PSI3Ijtjb25zdCBWdD1TeW1ib2wuZm9yKCJTZW50cnlCdWZmZXJGdWxsRXJyb3IiKTtmdW5jdGlvbiBadCh0KXtjb25zdCBuPVtdO2Z1bmN0aW9uIGUodCl7cmV0dXJuIG4uc3BsaWNlKG4uaW5kZXhPZih0KSwxKVswXXx8UHJvbWlzZS5yZXNvbHZlKHZvaWQgMCl9cmV0dXJueyQ6bixhZGQ6ZnVuY3Rpb24ocil7aWYoISh2b2lkIDA9PT10fHxuLmxlbmd0aDx0KSlyZXR1cm4gbz1WdCxuZXcgRigoKHQsbik9PntuKG8pfSkpO3ZhciBvO2NvbnN0IHM9cigpO3JldHVybi0xPT09bi5pbmRleE9mKHMpJiZuLnB1c2gocykscy50aGVuKCgoKT0+ZShzKSkpLnRoZW4obnVsbCwoKCk9PmUocykudGhlbihudWxsLCgoKT0+e30pKSkpLHN9LGRyYWluOmZ1bmN0aW9uKHQpe3JldHVybiBuZXcgRigoKGUscik9PntsZXQgbz1uLmxlbmd0aDtpZighbylyZXR1cm4gZSghMCk7Y29uc3Qgcz1zZXRUaW1lb3V0KCgoKT0+e3QmJnQ+MCYmZSghMSl9KSx0KTtuLmZvckVhY2goKHQ9PntIKHQpLnRoZW4oKCgpPT57LS1vfHwoY2xlYXJUaW1lb3V0KHMpLGUoITApKX0pLHIpfSkpfSkpfX19Y29uc3QgcXQ9NmU0O2Z1bmN0aW9uIFF0KHQse3N0YXR1c0NvZGU6bixoZWFkZXJzOmV9LHI9RGF0ZS5ub3coKSl7Y29uc3Qgbz17Li4udH0scz1lPy5bIngtc2VudHJ5LXJhdGUtbGltaXRzIl0saT1lPy5bInJldHJ5LWFmdGVyIl07aWYocylmb3IoY29uc3QgdCBvZiBzLnRyaW0oKS5zcGxpdCgiLCIpKXtjb25zdFtuLGUsLCxzXT10LnNwbGl0KCI6Iiw1KSxpPXBhcnNlSW50KG4sMTApLGM9MWUzKihpc05hTihpKT82MDppKTtpZihlKWZvcihjb25zdCB0IG9mIGUuc3BsaXQoIjsiKSkibWV0cmljX2J1Y2tldCI9PT10JiZzJiYhcy5zcGxpdCgiOyIpLmluY2x1ZGVzKCJjdXN0b20iKXx8KG9bdF09citjKTtlbHNlIG8uYWxsPXIrY31lbHNlIGk/by5hbGw9citmdW5jdGlvbih0LG49RGF0ZS5ub3coKSl7Y29uc3QgZT1wYXJzZUludChgJHt0fWAsMTApO2lmKCFpc05hTihlKSlyZXR1cm4gMWUzKmU7Y29uc3Qgcj1EYXRlLnBhcnNlKGAke3R9YCk7cmV0dXJuIGlzTmFOKHIpP3F0OnItbn0oaSxyKTo0Mjk9PT1uJiYoby5hbGw9cis2ZTQpO3JldHVybiBvfWNvbnN0IFh0PTY0O2Z1bmN0aW9uIHRuKHQsbixlPVp0KHQuYnVmZmVyU2l6ZXx8WHQpKXtsZXQgcj17fTtyZXR1cm57c2VuZDpmdW5jdGlvbih0KXtjb25zdCBvPVtdO2lmKEx0KHQsKCh0LG4pPT57Y29uc3QgZT1mdW5jdGlvbih0KXtyZXR1cm4gSnRbdF19KG4pOyhmdW5jdGlvbih0LG4sZT1EYXRlLm5vdygpKXtyZXR1cm4gZnVuY3Rpb24odCxuKXtyZXR1cm4gdFtuXXx8dC5hbGx8fDB9KHQsbik+ZX0pKHIsZSl8fG8ucHVzaCh0KX0pKSwwPT09by5sZW5ndGgpcmV0dXJuIEgoe30pO2NvbnN0IHM9TXQodFswXSxvKSxpPXQ9PntMdChzLCgodCxuKT0+e30pKX07cmV0dXJuIGUuYWRkKCgoKT0+bih7Ym9keTpHdChzKX0pLnRoZW4oKHQ9Pih2b2lkIDAhPT10LnN0YXR1c0NvZGUmJih0LnN0YXR1c0NvZGU8MjAwfHx0LnN0YXR1c0NvZGU+PTMwMCkmJmgmJncud2FybihgU2VudHJ5IHJlc3BvbmRlZCB3aXRoIHN0YXR1cyBjb2RlICR7dC5zdGF0dXNDb2RlfSB0byBzZW50IGV2ZW50LmApLHI9UXQocix0KSx0KSksKHQ9Pnt0aHJvdyBpKCksaCYmdy5lcnJvcigiRW5jb3VudGVyZWQgZXJyb3IgcnVubmluZyB0cmFuc3BvcnQgcmVxdWVzdDoiLHQpLHR9KSkpKS50aGVuKCh0PT50KSwodD0+e2lmKHQ9PT1WdClyZXR1cm4gaCYmdy5lcnJvcigiU2tpcHBlZCBzZW5kaW5nIGV2ZW50IGJlY2F1c2UgYnVmZmVyIGlzIGZ1bGwuIiksaSgpLEgoe30pO3Rocm93IHR9KSl9LGZsdXNoOnQ9PmUuZHJhaW4odCl9fWNvbnN0IG5uPS9eKFxTKzpcXHxcLz8pKFtcc1xTXSo/KSgoPzpcLnsxLDJ9fFteL1xcXSs/fCkoXC5bXi4vXFxdKnwpKSg/OlsvXFxdKikkLztmdW5jdGlvbiBlbih0KXtjb25zdCBuPWZ1bmN0aW9uKHQpe2NvbnN0IG49dC5sZW5ndGg+MTAyND9gPHRydW5jYXRlZD4ke3Quc2xpY2UoLTEwMjQpfWA6dCxlPW5uLmV4ZWMobik7cmV0dXJuIGU/ZS5zbGljZSgxKTpbXX0odCksZT1uWzBdfHwiIjtsZXQgcj1uWzFdO3JldHVybiBlfHxyPyhyJiYocj1yLnNsaWNlKDAsci5sZW5ndGgtMSkpLGUrcik6Ii4ifWZ1bmN0aW9uIHJuKHQsbj0hMSl7cmV0dXJuIShufHx0JiYhdC5zdGFydHNXaXRoKCIvIikmJiF0Lm1hdGNoKC9eW0EtWl06LykmJiF0LnN0YXJ0c1dpdGgoIi4iKSYmIXQubWF0Y2goL15bYS16QS1aXShbYS16QS1aMC05LlwtK10pKjpcL1wvLykpJiZ2b2lkIDAhPT10JiYhdC5pbmNsdWRlcygibm9kZV9tb2R1bGVzLyIpfWNvbnN0IG9uPVN5bWJvbCgiQWdlbnRCYXNlSW50ZXJuYWxTdGF0ZSIpO2NsYXNzIHNuIGV4dGVuZHMgcy5BZ2VudHtjb25zdHJ1Y3Rvcih0KXtzdXBlcih0KSx0aGlzW29uXT17fX1pc1NlY3VyZUVuZHBvaW50KHQpe2lmKHQpe2lmKCJib29sZWFuIj09dHlwZW9mIHQuc2VjdXJlRW5kcG9pbnQpcmV0dXJuIHQuc2VjdXJlRW5kcG9pbnQ7aWYoInN0cmluZyI9PXR5cGVvZiB0LnByb3RvY29sKXJldHVybiJodHRwczoiPT09dC5wcm90b2NvbH1jb25zdHtzdGFjazpufT1uZXcgRXJyb3I7cmV0dXJuInN0cmluZyI9PXR5cGVvZiBuJiZuLnNwbGl0KCJcbiIpLnNvbWUoKHQ9Pi0xIT09dC5pbmRleE9mKCIoaHR0cHMuanM6Iil8fC0xIT09dC5pbmRleE9mKCJub2RlOmh0dHBzOiIpKSl9Y3JlYXRlU29ja2V0KHQsbixlKXtjb25zdCByPXsuLi5uLHNlY3VyZUVuZHBvaW50OnRoaXMuaXNTZWN1cmVFbmRwb2ludChuKX07UHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKCk9PnRoaXMuY29ubmVjdCh0LHIpKSkudGhlbigobz0+e2lmKG8gaW5zdGFuY2VvZiBzLkFnZW50KXJldHVybiBvLmFkZFJlcXVlc3QodCxyKTt0aGlzW29uXS5jdXJyZW50U29ja2V0PW8sc3VwZXIuY3JlYXRlU29ja2V0KHQsbixlKX0pLGUpfWNyZWF0ZUNvbm5lY3Rpb24oKXtjb25zdCB0PXRoaXNbb25dLmN1cnJlbnRTb2NrZXQ7aWYodGhpc1tvbl0uY3VycmVudFNvY2tldD12b2lkIDAsIXQpdGhyb3cgbmV3IEVycm9yKCJObyBzb2NrZXQgd2FzIHJldHVybmVkIGluIHRoZSBgY29ubmVjdCgpYCBmdW5jdGlvbiIpO3JldHVybiB0fWdldCBkZWZhdWx0UG9ydCgpe3JldHVybiB0aGlzW29uXS5kZWZhdWx0UG9ydD8/KCJodHRwczoiPT09dGhpcy5wcm90b2NvbD80NDM6ODApfXNldCBkZWZhdWx0UG9ydCh0KXt0aGlzW29uXSYmKHRoaXNbb25dLmRlZmF1bHRQb3J0PXQpfWdldCBwcm90b2NvbCgpe3JldHVybiB0aGlzW29uXS5wcm90b2NvbD8/KHRoaXMuaXNTZWN1cmVFbmRwb2ludCgpPyJodHRwczoiOiJodHRwOiIpfXNldCBwcm90b2NvbCh0KXt0aGlzW29uXSYmKHRoaXNbb25dLnByb3RvY29sPXQpfX1mdW5jdGlvbiBjbiguLi50KXt3LmxvZygiW2h0dHBzLXByb3h5LWFnZW50OnBhcnNlLXByb3h5LXJlc3BvbnNlXSIsLi4udCl9ZnVuY3Rpb24gdW4odCl7cmV0dXJuIG5ldyBQcm9taXNlKCgobixlKT0+e2xldCByPTA7Y29uc3Qgbz1bXTtmdW5jdGlvbiBzKCl7Y29uc3QgYz10LnJlYWQoKTtjP2Z1bmN0aW9uKGMpe28ucHVzaChjKSxyKz1jLmxlbmd0aDtjb25zdCB1PUJ1ZmZlci5jb25jYXQobyxyKSxhPXUuaW5kZXhPZigiXHJcblxyXG4iKTtpZigtMT09PWEpcmV0dXJuIGNuKCJoYXZlIG5vdCByZWNlaXZlZCBlbmQgb2YgSFRUUCBoZWFkZXJzIHlldC4uLiIpLHZvaWQgcygpO2NvbnN0IGY9dS5zdWJhcnJheSgwLGEpLnRvU3RyaW5nKCJhc2NpaSIpLnNwbGl0KCJcclxuIiksaD1mLnNoaWZ0KCk7aWYoIWgpcmV0dXJuIHQuZGVzdHJveSgpLGUobmV3IEVycm9yKCJObyBoZWFkZXIgcmVjZWl2ZWQgZnJvbSBwcm94eSBDT05ORUNUIHJlc3BvbnNlIikpO2NvbnN0IHA9aC5zcGxpdCgiICIpLGw9KyhwWzFdfHwwKSxkPXAuc2xpY2UoMikuam9pbigiICIpLG09e307Zm9yKGNvbnN0IG4gb2YgZil7aWYoIW4pY29udGludWU7Y29uc3Qgcj1uLmluZGV4T2YoIjoiKTtpZigtMT09PXIpcmV0dXJuIHQuZGVzdHJveSgpLGUobmV3IEVycm9yKGBJbnZhbGlkIGhlYWRlciBmcm9tIHByb3h5IENPTk5FQ1QgcmVzcG9uc2U6ICIke259ImApKTtjb25zdCBvPW4uc2xpY2UoMCxyKS50b0xvd2VyQ2FzZSgpLHM9bi5zbGljZShyKzEpLnRyaW1TdGFydCgpLGk9bVtvXTsic3RyaW5nIj09dHlwZW9mIGk/bVtvXT1baSxzXTpBcnJheS5pc0FycmF5KGkpP2kucHVzaChzKTptW29dPXN9Y24oImdvdCBwcm94eSBzZXJ2ZXIgcmVzcG9uc2U6ICVvICVvIixoLG0pLGkoKSxuKHtjb25uZWN0OntzdGF0dXNDb2RlOmwsc3RhdHVzVGV4dDpkLGhlYWRlcnM6bX0sYnVmZmVyZWQ6dX0pfShjKTp0Lm9uY2UoInJlYWRhYmxlIixzKX1mdW5jdGlvbiBpKCl7dC5yZW1vdmVMaXN0ZW5lcigiZW5kIixjKSx0LnJlbW92ZUxpc3RlbmVyKCJlcnJvciIsdSksdC5yZW1vdmVMaXN0ZW5lcigicmVhZGFibGUiLHMpfWZ1bmN0aW9uIGMoKXtpKCksY24oIm9uZW5kIiksZShuZXcgRXJyb3IoIlByb3h5IGNvbm5lY3Rpb24gZW5kZWQgYmVmb3JlIHJlY2VpdmluZyBDT05ORUNUIHJlc3BvbnNlIikpfWZ1bmN0aW9uIHUodCl7aSgpLGNuKCJvbmVycm9yICVvIix0KSxlKHQpfXQub24oImVycm9yIix1KSx0Lm9uKCJlbmQiLGMpLHMoKX0pKX1mdW5jdGlvbiBhbiguLi50KXt3LmxvZygiW2h0dHBzLXByb3h5LWFnZW50XSIsLi4udCl9Y2xhc3MgZm4gZXh0ZW5kcyBzbntzdGF0aWMgX19pbml0U3RhdGljKCl7dGhpcy5wcm90b2NvbHM9WyJodHRwIiwiaHR0cHMiXX1jb25zdHJ1Y3Rvcih0LG4pe3N1cGVyKG4pLHRoaXMub3B0aW9ucz17fSx0aGlzLnByb3h5PSJzdHJpbmciPT10eXBlb2YgdD9uZXcgVVJMKHQpOnQsdGhpcy5wcm94eUhlYWRlcnM9bj8uaGVhZGVycz8/e30sYW4oIkNyZWF0aW5nIG5ldyBIdHRwc1Byb3h5QWdlbnQgaW5zdGFuY2U6ICVvIix0aGlzLnByb3h5LmhyZWYpO2NvbnN0IGU9KHRoaXMucHJveHkuaG9zdG5hbWV8fHRoaXMucHJveHkuaG9zdCkucmVwbGFjZSgvXlxbfFxdJC9nLCIiKSxyPXRoaXMucHJveHkucG9ydD9wYXJzZUludCh0aGlzLnByb3h5LnBvcnQsMTApOiJodHRwczoiPT09dGhpcy5wcm94eS5wcm90b2NvbD80NDM6ODA7dGhpcy5jb25uZWN0T3B0cz17QUxQTlByb3RvY29sczpbImh0dHAvMS4xIl0sLi4ubj9wbihuLCJoZWFkZXJzIik6bnVsbCxob3N0OmUscG9ydDpyfX1hc3luYyBjb25uZWN0KHQsbil7Y29uc3R7cHJveHk6ZX09dGhpcztpZighbi5ob3N0KXRocm93IG5ldyBUeXBlRXJyb3IoJ05vICJob3N0IiBwcm92aWRlZCcpO2xldCByO2lmKCJodHRwczoiPT09ZS5wcm90b2NvbCl7YW4oIkNyZWF0aW5nIGB0bHMuU29ja2V0YDogJW8iLHRoaXMuY29ubmVjdE9wdHMpO2NvbnN0IHQ9dGhpcy5jb25uZWN0T3B0cy5zZXJ2ZXJuYW1lfHx0aGlzLmNvbm5lY3RPcHRzLmhvc3Q7cj1mLmNvbm5lY3Qoey4uLnRoaXMuY29ubmVjdE9wdHMsc2VydmVybmFtZTp0JiZhLmlzSVAodCk/dm9pZCAwOnR9KX1lbHNlIGFuKCJDcmVhdGluZyBgbmV0LlNvY2tldGA6ICVvIix0aGlzLmNvbm5lY3RPcHRzKSxyPWEuY29ubmVjdCh0aGlzLmNvbm5lY3RPcHRzKTtjb25zdCBvPSJmdW5jdGlvbiI9PXR5cGVvZiB0aGlzLnByb3h5SGVhZGVycz90aGlzLnByb3h5SGVhZGVycygpOnsuLi50aGlzLnByb3h5SGVhZGVyc30scz1hLmlzSVB2NihuLmhvc3QpP2BbJHtuLmhvc3R9XWA6bi5ob3N0O2xldCBpPWBDT05ORUNUICR7c306JHtuLnBvcnR9IEhUVFAvMS4xXHJcbmA7aWYoZS51c2VybmFtZXx8ZS5wYXNzd29yZCl7Y29uc3QgdD1gJHtkZWNvZGVVUklDb21wb25lbnQoZS51c2VybmFtZSl9OiR7ZGVjb2RlVVJJQ29tcG9uZW50KGUucGFzc3dvcmQpfWA7b1siUHJveHktQXV0aG9yaXphdGlvbiJdPWBCYXNpYyAke0J1ZmZlci5mcm9tKHQpLnRvU3RyaW5nKCJiYXNlNjQiKX1gfW8uSG9zdD1gJHtzfToke24ucG9ydH1gLG9bIlByb3h5LUNvbm5lY3Rpb24iXXx8KG9bIlByb3h5LUNvbm5lY3Rpb24iXT10aGlzLmtlZXBBbGl2ZT8iS2VlcC1BbGl2ZSI6ImNsb3NlIik7Zm9yKGNvbnN0IHQgb2YgT2JqZWN0LmtleXMobykpaSs9YCR7dH06ICR7b1t0XX1cclxuYDtjb25zdCBjPXVuKHIpO3Iud3JpdGUoYCR7aX1cclxuYCk7Y29uc3R7Y29ubmVjdDp1LGJ1ZmZlcmVkOmh9PWF3YWl0IGM7aWYodC5lbWl0KCJwcm94eUNvbm5lY3QiLHUpLHRoaXMuZW1pdCgicHJveHlDb25uZWN0Iix1LHQpLDIwMD09PXUuc3RhdHVzQ29kZSl7aWYodC5vbmNlKCJzb2NrZXQiLGhuKSxuLnNlY3VyZUVuZHBvaW50KXthbigiVXBncmFkaW5nIHNvY2tldCBjb25uZWN0aW9uIHRvIFRMUyIpO2NvbnN0IHQ9bi5zZXJ2ZXJuYW1lfHxuLmhvc3Q7cmV0dXJuIGYuY29ubmVjdCh7Li4ucG4obiwiaG9zdCIsInBhdGgiLCJwb3J0Iiksc29ja2V0OnIsc2VydmVybmFtZTphLmlzSVAodCk/dm9pZCAwOnR9KX1yZXR1cm4gcn1yLmRlc3Ryb3koKTtjb25zdCBwPW5ldyBhLlNvY2tldCh7d3JpdGFibGU6ITF9KTtyZXR1cm4gcC5yZWFkYWJsZT0hMCx0Lm9uY2UoInNvY2tldCIsKHQ9PnthbigiUmVwbGF5aW5nIHByb3h5IGJ1ZmZlciBmb3IgZmFpbGVkIHJlcXVlc3QiKSx0LnB1c2goaCksdC5wdXNoKG51bGwpfSkpLHB9fWZ1bmN0aW9uIGhuKHQpe3QucmVzdW1lKCl9ZnVuY3Rpb24gcG4odCwuLi5uKXtjb25zdCBlPXt9O2xldCByO2ZvcihyIGluIHQpbi5pbmNsdWRlcyhyKXx8KGVbcl09dFtyXSk7cmV0dXJuIGV9Zm4uX19pbml0U3RhdGljKCk7Y29uc3QgbG49MzI3Njg7ZnVuY3Rpb24gZG4odCl7cmV0dXJuIHQucmVwbGFjZSgvXltBLVpdOi8sIiIpLnJlcGxhY2UoL1xcL2csIi8iKX1jb25zdCBtbj1uO2xldCBnbix5bj0wLGJuPXt9O2Z1bmN0aW9uIF9uKHQpe21uLmRlYnVnJiZjb25zb2xlLmxvZyhgW0FOUiBXb3JrZXJdICR7dH1gKX12YXIgdm4sd24sU247Y29uc3QgJG49ZnVuY3Rpb24odCl7bGV0IG47dHJ5e249bmV3IFVSTCh0LnVybCl9Y2F0Y2gobil7cmV0dXJuIHYoKCgpPT57Y29uc29sZS53YXJuKCJbQHNlbnRyeS9ub2RlXTogSW52YWxpZCBkc24gb3IgdHVubmVsIG9wdGlvbiwgd2lsbCBub3Qgc2VuZCBhbnkgZXZlbnRzLiBUaGUgdHVubmVsIG9wdGlvbiBtdXN0IGJlIGEgZnVsbCBVUkwgd2hlbiB1c2VkLiIpfSkpLHRuKHQsKCgpPT5Qcm9taXNlLnJlc29sdmUoe30pKSl9Y29uc3QgZT0iaHR0cHM6Ij09PW4ucHJvdG9jb2wscj1mdW5jdGlvbih0LG4pe2NvbnN0e25vX3Byb3h5OmV9PXByb2Nlc3MuZW52LHI9ZT8uc3BsaXQoIiwiKS5zb21lKChuPT50Lmhvc3QuZW5kc1dpdGgobil8fHQuaG9zdG5hbWUuZW5kc1dpdGgobikpKTtyZXR1cm4gcj92b2lkIDA6bn0obix0LnByb3h5fHwoZT9wcm9jZXNzLmVudi5odHRwc19wcm94eTp2b2lkIDApfHxwcm9jZXNzLmVudi5odHRwX3Byb3h5KSxvPWU/aTpzLGE9dm9pZCAwIT09dC5rZWVwQWxpdmUmJnQua2VlcEFsaXZlLGY9cj9uZXcgZm4ocik6bmV3IG8uQWdlbnQoe2tlZXBBbGl2ZTphLG1heFNvY2tldHM6MzAsdGltZW91dDoyZTN9KSxoPWZ1bmN0aW9uKHQsbixlKXtjb25zdHtob3N0bmFtZTpyLHBhdGhuYW1lOm8scG9ydDpzLHByb3RvY29sOmksc2VhcmNoOmF9PW5ldyBVUkwodC51cmwpO3JldHVybiBmdW5jdGlvbihmKXtyZXR1cm4gbmV3IFByb21pc2UoKChoLHApPT57RnQoKCgpPT57bGV0IGw9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBjKHtyZWFkKCl7dGhpcy5wdXNoKHQpLHRoaXMucHVzaChudWxsKX19KX0oZi5ib2R5KTtjb25zdCBkPXsuLi50LmhlYWRlcnN9O2YuYm9keS5sZW5ndGg+bG4mJihkWyJjb250ZW50LWVuY29kaW5nIl09Imd6aXAiLGw9bC5waXBlKHUoKSkpO2NvbnN0IG09bi5yZXF1ZXN0KHttZXRob2Q6IlBPU1QiLGFnZW50OmUsaGVhZGVyczpkLGhvc3RuYW1lOnIscGF0aDpgJHtvfSR7YX1gLHBvcnQ6cyxwcm90b2NvbDppLGNhOnQuY2FDZXJ0c30sKHQ9Pnt0Lm9uKCJkYXRhIiwoKCk9Pnt9KSksdC5vbigiZW5kIiwoKCk9Pnt9KSksdC5zZXRFbmNvZGluZygidXRmOCIpO2NvbnN0IG49dC5oZWFkZXJzWyJyZXRyeS1hZnRlciJdPz9udWxsLGU9dC5oZWFkZXJzWyJ4LXNlbnRyeS1yYXRlLWxpbWl0cyJdPz9udWxsO2goe3N0YXR1c0NvZGU6dC5zdGF0dXNDb2RlLGhlYWRlcnM6eyJyZXRyeS1hZnRlciI6biwieC1zZW50cnktcmF0ZS1saW1pdHMiOkFycmF5LmlzQXJyYXkoZSk/ZVswXXx8bnVsbDplfX0pfSkpO20ub24oImVycm9yIixwKSxsLnBpcGUobSl9KSl9KSl9fSh0LHQuaHR0cE1vZHVsZT8/byxmKTtyZXR1cm4gdG4odCxoKX0oe3VybDoodm49bW4uZHNuLHduPW1uLnR1bm5lbCxTbj1tbi5zZGtNZXRhZGF0YS5zZGssd258fGAke2Z1bmN0aW9uKHQpe3JldHVybmAke2Z1bmN0aW9uKHQpe2NvbnN0IG49dC5wcm90b2NvbD9gJHt0LnByb3RvY29sfTpgOiIiLGU9dC5wb3J0P2A6JHt0LnBvcnR9YDoiIjtyZXR1cm5gJHtufS8vJHt0Lmhvc3R9JHtlfSR7dC5wYXRoP2AvJHt0LnBhdGh9YDoiIn0vYXBpL2B9KHQpfSR7dC5wcm9qZWN0SWR9L2VudmVsb3BlL2B9KHZuKX0/JHtmdW5jdGlvbih0LG4pe2NvbnN0IGU9e3NlbnRyeV92ZXJzaW9uOkt0fTtyZXR1cm4gdC5wdWJsaWNLZXkmJihlLnNlbnRyeV9rZXk9dC5wdWJsaWNLZXkpLG4mJihlLnNlbnRyeV9jbGllbnQ9YCR7bi5uYW1lfS8ke24udmVyc2lvbn1gKSxuZXcgVVJMU2VhcmNoUGFyYW1zKGUpLnRvU3RyaW5nKCl9KHZuLFNuKX1gKX0pO2FzeW5jIGZ1bmN0aW9uIEVuKCl7aWYoZ24pe19uKCJTZW5kaW5nIGFibm9ybWFsIHNlc3Npb24iKSxLKGduLHtzdGF0dXM6ImFibm9ybWFsIixhYm5vcm1hbF9tZWNoYW5pc206ImFucl9mb3JlZ3JvdW5kIixyZWxlYXNlOm1uLnJlbGVhc2UsZW52aXJvbm1lbnQ6bW4uZW52aXJvbm1lbnR9KTtjb25zdCB0PWZ1bmN0aW9uKHQsbixlLHIpe2NvbnN0IG89WXQoZSk7cmV0dXJuIE10KHtzZW50X2F0OihuZXcgRGF0ZSkudG9JU09TdHJpbmcoKSwuLi5vJiZ7c2RrOm99LC4uLiEhciYmbiYme2RzbjpPdChuKX19LFsiYWdncmVnYXRlcyJpbiB0P1t7dHlwZToic2Vzc2lvbnMifSx0XTpbe3R5cGU6InNlc3Npb24ifSx0LnRvSlNPTigpXV0pfShnbixtbi5kc24sbW4uc2RrTWV0YWRhdGEsbW4udHVubmVsKTtfbihKU09OLnN0cmluZ2lmeSh0KSksYXdhaXQgJG4uc2VuZCh0KTt0cnl7ZT8ucG9zdE1lc3NhZ2UoInNlc3Npb24tZW5kZWQiKX1jYXRjaCh0KXt9fX1mdW5jdGlvbiB4bih0KXtpZighdClyZXR1cm47Y29uc3Qgbj1mdW5jdGlvbih0KXtpZighdC5sZW5ndGgpcmV0dXJuW107Y29uc3Qgbj1BcnJheS5mcm9tKHQpO3JldHVybi9zZW50cnlXcmFwcGVkLy50ZXN0KHgobikuZnVuY3Rpb258fCIiKSYmbi5wb3AoKSxuLnJldmVyc2UoKSxFLnRlc3QoeChuKS5mdW5jdGlvbnx8IiIpJiYobi5wb3AoKSxFLnRlc3QoeChuKS5mdW5jdGlvbnx8IiIpJiZuLnBvcCgpKSxuLnNsaWNlKDAsUykubWFwKCh0PT4oey4uLnQsZmlsZW5hbWU6dC5maWxlbmFtZXx8eChuKS5maWxlbmFtZSxmdW5jdGlvbjp0LmZ1bmN0aW9ufHwkfSkpKX0odCk7aWYobW4uYXBwUm9vdFBhdGgpZm9yKGNvbnN0IHQgb2Ygbil0LmZpbGVuYW1lJiYodC5maWxlbmFtZT1VdCh0LmZpbGVuYW1lLG1uLmFwcFJvb3RQYXRoKSk7cmV0dXJuIG59YXN5bmMgZnVuY3Rpb24gTm4odCxuKXtpZih5bj49bW4ubWF4QW5yRXZlbnRzKXJldHVybjt5bis9MSxhd2FpdCBFbigpLF9uKCJTZW5kaW5nIGV2ZW50Iik7Y29uc3QgZT17ZXZlbnRfaWQ6WSgpLGNvbnRleHRzOm1uLmNvbnRleHRzLHJlbGVhc2U6bW4ucmVsZWFzZSxlbnZpcm9ubWVudDptbi5lbnZpcm9ubWVudCxkaXN0Om1uLmRpc3QscGxhdGZvcm06Im5vZGUiLGxldmVsOiJlcnJvciIsZXhjZXB0aW9uOnt2YWx1ZXM6W3t0eXBlOiJBcHBsaWNhdGlvbk5vdFJlc3BvbmRpbmciLHZhbHVlOmBBcHBsaWNhdGlvbiBOb3QgUmVzcG9uZGluZyBmb3IgYXQgbGVhc3QgJHttbi5hbnJUaHJlc2hvbGR9IG1zYCxzdGFja3RyYWNlOntmcmFtZXM6eG4odCl9LG1lY2hhbmlzbTp7dHlwZToiQU5SIn19XX0sdGFnczptbi5zdGF0aWNUYWdzfTtuJiZmdW5jdGlvbih0LG4pe2lmKFd0KHQsbiksIXQuY29udGV4dHM/LnRyYWNlKXtjb25zdHt0cmFjZUlkOmUscGFyZW50U3BhbklkOnIscHJvcGFnYXRpb25TcGFuSWQ6b309bi5wcm9wYWdhdGlvbkNvbnRleHQ7dC5jb250ZXh0cz17dHJhY2U6e3RyYWNlX2lkOmUsc3Bhbl9pZDpvfHxaKCkscGFyZW50X3NwYW5faWQ6cn0sLi4udC5jb250ZXh0c319fShlLG4pLGZ1bmN0aW9uKHQpe2lmKDA9PT1PYmplY3Qua2V5cyhibikubGVuZ3RoKXJldHVybjtjb25zdCBuPW1uLmFwcFJvb3RQYXRoP3t9OmJuO2lmKG1uLmFwcFJvb3RQYXRoKWZvcihjb25zdFt0LGVdb2YgT2JqZWN0LmVudHJpZXMoYm4pKW5bVXQodCxtbi5hcHBSb290UGF0aCldPWU7Y29uc3QgZT1uZXcgTWFwO2Zvcihjb25zdCByIG9mIHQuZXhjZXB0aW9uPy52YWx1ZXN8fFtdKWZvcihjb25zdCB0IG9mIHIuc3RhY2t0cmFjZT8uZnJhbWVzfHxbXSl7Y29uc3Qgcj10LmFic19wYXRofHx0LmZpbGVuYW1lO3ImJm5bcl0mJmUuc2V0KHIsbltyXSl9aWYoZS5zaXplPjApe2NvbnN0IG49W107Zm9yKGNvbnN0W3Qscl1vZiBlLmVudHJpZXMoKSluLnB1c2goe3R5cGU6InNvdXJjZW1hcCIsY29kZV9maWxlOnQsZGVidWdfaWQ6cn0pO3QuZGVidWdfbWV0YT17aW1hZ2VzOm59fX0oZSk7Y29uc3Qgcj16dChlLG1uLmRzbixtbi5zZGtNZXRhZGF0YSxtbi50dW5uZWwpO19uKEpTT04uc3RyaW5naWZ5KHIpKSxhd2FpdCAkbi5zZW5kKHIpLGF3YWl0ICRuLmZsdXNoKDJlMykseW4+PW1uLm1heEFuckV2ZW50cyYmc2V0VGltZW91dCgoKCk9Pntwcm9jZXNzLmV4aXQoMCl9KSw1ZTMpfWxldCBUbjtpZihfbigiU3RhcnRlZCIpLG1uLmNhcHR1cmVTdGFja1RyYWNlKXtfbigiQ29ubmVjdGluZyB0byBkZWJ1Z2dlciIpO2NvbnN0IG49bmV3IHQ7bi5jb25uZWN0VG9NYWluVGhyZWFkKCksX24oIkNvbm5lY3RlZCB0byBkZWJ1Z2dlciIpO2NvbnN0IGU9bmV3IE1hcDtuLm9uKCJEZWJ1Z2dlci5zY3JpcHRQYXJzZWQiLCh0PT57ZS5zZXQodC5wYXJhbXMuc2NyaXB0SWQsdC5wYXJhbXMudXJsKX0pKSxuLm9uKCJEZWJ1Z2dlci5wYXVzZWQiLCh0PT57aWYoIm90aGVyIj09PXQucGFyYW1zLnJlYXNvbil0cnl7X24oIkRlYnVnZ2VyIHBhdXNlZCIpO2NvbnN0IHM9Wy4uLnQucGFyYW1zLmNhbGxGcmFtZXNdLGk9bW4uYXBwUm9vdFBhdGg/ZnVuY3Rpb24odD0ocHJvY2Vzcy5hcmd2WzFdP2VuKHByb2Nlc3MuYXJndlsxXSk6cHJvY2Vzcy5jd2QoKSksbj0iXFwiPT09byl7Y29uc3QgZT1uP2RuKHQpOnQ7cmV0dXJuIHQ9PntpZighdClyZXR1cm47Y29uc3Qgbz1uP2RuKHQpOnQ7bGV0e2RpcjpzLGJhc2U6aSxleHQ6Y309ci5wYXJzZShvKTsiLmpzIiE9PWMmJiIubWpzIiE9PWMmJiIuY2pzIiE9PWN8fChpPWkuc2xpY2UoMCwtMSpjLmxlbmd0aCkpO2NvbnN0IHU9ZGVjb2RlVVJJQ29tcG9uZW50KGkpO3N8fChzPSIuIik7Y29uc3QgYT1zLmxhc3RJbmRleE9mKCIvbm9kZV9tb2R1bGVzIik7aWYoYT4tMSlyZXR1cm5gJHtzLnNsaWNlKGErMTQpLnJlcGxhY2UoL1wvL2csIi4iKX06JHt1fWA7aWYocy5zdGFydHNXaXRoKGUpKXtjb25zdCB0PXMuc2xpY2UoZS5sZW5ndGgrMSkucmVwbGFjZSgvXC8vZywiLiIpO3JldHVybiB0P2Ake3R9OiR7dX1gOnV9cmV0dXJuIHV9fShtbi5hcHBSb290UGF0aCk6KCk9Pnt9LGM9cy5tYXAoKHQ9PmZ1bmN0aW9uKHQsbixlKXtjb25zdCByPW4/bi5yZXBsYWNlKC9eZmlsZTpcL1wvLywiIik6dm9pZCAwLG89dC5sb2NhdGlvbi5jb2x1bW5OdW1iZXI/dC5sb2NhdGlvbi5jb2x1bW5OdW1iZXIrMTp2b2lkIDAscz10LmxvY2F0aW9uLmxpbmVOdW1iZXI/dC5sb2NhdGlvbi5saW5lTnVtYmVyKzE6dm9pZCAwO3JldHVybntmaWxlbmFtZTpyLG1vZHVsZTplKHIpLGZ1bmN0aW9uOnQuZnVuY3Rpb25OYW1lfHwkLGNvbG5vOm8sbGluZW5vOnMsaW5fYXBwOnI/cm4ocik6dm9pZCAwfX0odCxlLmdldCh0LmxvY2F0aW9uLnNjcmlwdElkKSxpKSkpLHU9c2V0VGltZW91dCgoKCk9PntObihjKS50aGVuKG51bGwsKCgpPT57X24oIlNlbmRpbmcgQU5SIGV2ZW50IGZhaWxlZC4iKX0pKX0pLDVlMyk7bi5wb3N0KCJSdW50aW1lLmV2YWx1YXRlIix7ZXhwcmVzc2lvbjoiZ2xvYmFsLl9fU0VOVFJZX0dFVF9TQ09QRVNfXygpOyIsc2lsZW50OiEwLHJldHVybkJ5VmFsdWU6ITB9LCgodCxlKT0+e3QmJl9uKGBFcnJvciBleGVjdXRpbmcgc2NyaXB0OiAnJHt0Lm1lc3NhZ2V9J2ApLGNsZWFyVGltZW91dCh1KTtjb25zdCByPWU/LnJlc3VsdD9lLnJlc3VsdC52YWx1ZTp2b2lkIDA7bi5wb3N0KCJEZWJ1Z2dlci5yZXN1bWUiKSxuLnBvc3QoIkRlYnVnZ2VyLmRpc2FibGUiKSxObihjLHIpLnRoZW4obnVsbCwoKCk9PntfbigiU2VuZGluZyBBTlIgZXZlbnQgZmFpbGVkLiIpfSkpfSkpfWNhdGNoKHQpe3Rocm93IG4ucG9zdCgiRGVidWdnZXIucmVzdW1lIiksbi5wb3N0KCJEZWJ1Z2dlci5kaXNhYmxlIiksdH19KSksVG49KCk9Pnt0cnl7bi5wb3N0KCJEZWJ1Z2dlci5lbmFibGUiLCgoKT0+e24ucG9zdCgiRGVidWdnZXIucGF1c2UiKX0pKX1jYXRjaCh0KXt9fX1jb25zdHtwb2xsOkNufT1mdW5jdGlvbih0LG4sZSxyKXtjb25zdCBvPXQoKTtsZXQgcz0hMSxpPSEwO3JldHVybiBzZXRJbnRlcnZhbCgoKCk9Pntjb25zdCB0PW8uZ2V0VGltZU1zKCk7ITE9PT1zJiZ0Pm4rZSYmKHM9ITAsaSYmcigpKSx0PG4rZSYmKHM9ITEpfSksMjApLHtwb2xsOigpPT57by5yZXNldCgpfSxlbmFibGVkOnQ9PntpPXR9fX0oKGZ1bmN0aW9uKCl7bGV0IHQ9cHJvY2Vzcy5ocnRpbWUoKTtyZXR1cm57Z2V0VGltZU1zOigpPT57Y29uc3RbbixlXT1wcm9jZXNzLmhydGltZSh0KTtyZXR1cm4gTWF0aC5mbG9vcigxZTMqbitlLzFlNil9LHJlc2V0OigpPT57dD1wcm9jZXNzLmhydGltZSgpfX19KSxtbi5wb2xsSW50ZXJ2YWwsbW4uYW5yVGhyZXNob2xkLChmdW5jdGlvbigpe19uKCJXYXRjaGRvZyB0aW1lb3V0IiksVG4/KF9uKCJQYXVzaW5nIGRlYnVnZ2VyIHRvIGNhcHR1cmUgc3RhY2sgdHJhY2UiKSxUbigpKTooX24oIkNhcHR1cmluZyBldmVudCB3aXRob3V0IGEgc3RhY2sgdHJhY2UiKSxObigpLnRoZW4obnVsbCwoKCk9PntfbigiU2VuZGluZyBBTlIgZXZlbnQgZmFpbGVkIG9uIHdhdGNoZG9nIHRpbWVvdXQuIil9KSkpfSkpO2U/Lm9uKCJtZXNzYWdlIiwodD0+e3Quc2Vzc2lvbiYmKGduPVcodC5zZXNzaW9uKSksdC5kZWJ1Z0ltYWdlcyYmKGJuPXQuZGVidWdJbWFnZXMpLENuKCl9KSk7';
+const base64WorkerScript = 'LyohIEBzZW50cnkvbm9kZSA5LjEyLjAgKDJjZjUzMjJkOSkgfCBodHRwczovL2dpdGh1Yi5jb20vZ2V0c2VudHJ5L3NlbnRyeS1qYXZhc2NyaXB0ICovCmltcG9ydHtTZXNzaW9uIGFzIHR9ZnJvbSJub2RlOmluc3BlY3RvciI7aW1wb3J0e3dvcmtlckRhdGEgYXMgbixwYXJlbnRQb3J0IGFzIGV9ZnJvbSJub2RlOndvcmtlcl90aHJlYWRzIjtpbXBvcnR7cG9zaXggYXMgcixzZXAgYXMgb31mcm9tIm5vZGU6cGF0aCI7aW1wb3J0KmFzIHMgZnJvbSJub2RlOmh0dHAiO2ltcG9ydCphcyBpIGZyb20ibm9kZTpodHRwcyI7aW1wb3J0e1JlYWRhYmxlIGFzIGN9ZnJvbSJub2RlOnN0cmVhbSI7aW1wb3J0e2NyZWF0ZUd6aXAgYXMgdX1mcm9tIm5vZGU6emxpYiI7aW1wb3J0KmFzIGEgZnJvbSJub2RlOm5ldCI7aW1wb3J0KmFzIGYgZnJvbSJub2RlOnRscyI7Y29uc3QgaD0idW5kZWZpbmVkIj09dHlwZW9mIF9fU0VOVFJZX0RFQlVHX198fF9fU0VOVFJZX0RFQlVHX18scD1nbG9iYWxUaGlzLGw9InVuZGVmaW5lZCI9PXR5cGVvZiBfX1NFTlRSWV9ERUJVR19ffHxfX1NFTlRSWV9ERUJVR19fLGQ9IjkuMTIuMCI7ZnVuY3Rpb24gbSgpe3JldHVybiBnKHApLHB9ZnVuY3Rpb24gZyh0KXtjb25zdCBuPXQuX19TRU5UUllfXz10Ll9fU0VOVFJZX198fHt9O3JldHVybiBuLnZlcnNpb249bi52ZXJzaW9ufHxkLG5bZF09bltkXXx8e319ZnVuY3Rpb24geSh0LG4sZT1wKXtjb25zdCByPWUuX19TRU5UUllfXz1lLl9fU0VOVFJZX198fHt9LG89cltkXT1yW2RdfHx7fTtyZXR1cm4gb1t0XXx8KG9bdF09bigpKX1jb25zdCBiPVsiZGVidWciLCJpbmZvIiwid2FybiIsImVycm9yIiwibG9nIiwiYXNzZXJ0IiwidHJhY2UiXSxfPXt9O2Z1bmN0aW9uIHYodCl7aWYoISgiY29uc29sZSJpbiBwKSlyZXR1cm4gdCgpO2NvbnN0IG49cC5jb25zb2xlLGU9e30scj1PYmplY3Qua2V5cyhfKTtyLmZvckVhY2goKHQ9Pntjb25zdCByPV9bdF07ZVt0XT1uW3RdLG5bdF09cn0pKTt0cnl7cmV0dXJuIHQoKX1maW5hbGx5e3IuZm9yRWFjaCgodD0+e25bdF09ZVt0XX0pKX19Y29uc3Qgdz15KCJsb2dnZXIiLChmdW5jdGlvbigpe2xldCB0PSExO2NvbnN0IG49e2VuYWJsZTooKT0+e3Q9ITB9LGRpc2FibGU6KCk9Pnt0PSExfSxpc0VuYWJsZWQ6KCk9PnR9O3JldHVybiBsP2IuZm9yRWFjaCgoZT0+e25bZV09KC4uLm4pPT57dCYmdigoKCk9PntwLmNvbnNvbGVbZV0oYFNlbnRyeSBMb2dnZXIgWyR7ZX1dOmAsLi4ubil9KSl9fSkpOmIuZm9yRWFjaCgodD0+e25bdF09KCk9Pnt9fSkpLG59KSksUz01MCwkPSI/IixFPS9jYXB0dXJlTWVzc2FnZXxjYXB0dXJlRXhjZXB0aW9uLztmdW5jdGlvbiB4KHQpe3JldHVybiB0W3QubGVuZ3RoLTFdfHx7fX1jb25zdCBOPSI8YW5vbnltb3VzPiI7Y29uc3QgVD0xZTM7ZnVuY3Rpb24gQygpe3JldHVybiBEYXRlLm5vdygpL1R9Y29uc3QgUj1mdW5jdGlvbigpe2NvbnN0e3BlcmZvcm1hbmNlOnR9PXA7aWYoIXQ/Lm5vdylyZXR1cm4gQztjb25zdCBuPURhdGUubm93KCktdC5ub3coKSxlPW51bGw9PXQudGltZU9yaWdpbj9uOnQudGltZU9yaWdpbjtyZXR1cm4oKT0+KGUrdC5ub3coKSkvVH0oKSxrPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7ZnVuY3Rpb24gaih0LG4pe3JldHVybiBrLmNhbGwodCk9PT1gW29iamVjdCAke259XWB9ZnVuY3Rpb24gRCh0KXtyZXR1cm4gaih0LCJTdHJpbmciKX1mdW5jdGlvbiBJKHQpe3JldHVybiBqKHQsIk9iamVjdCIpfWZ1bmN0aW9uIE8odCl7cmV0dXJuIEJvb2xlYW4odD8udGhlbiYmImZ1bmN0aW9uIj09dHlwZW9mIHQudGhlbil9ZnVuY3Rpb24gQSh0LG4pe3RyeXtyZXR1cm4gdCBpbnN0YW5jZW9mIG59Y2F0Y2godCl7cmV0dXJuITF9fWNvbnN0IFA9cCxVPTgwO2Z1bmN0aW9uIE0odCxuKXtjb25zdCBlPXQscj1bXTtpZighZT8udGFnTmFtZSlyZXR1cm4iIjtpZihQLkhUTUxFbGVtZW50JiZlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQmJmUuZGF0YXNldCl7aWYoZS5kYXRhc2V0LnNlbnRyeUNvbXBvbmVudClyZXR1cm4gZS5kYXRhc2V0LnNlbnRyeUNvbXBvbmVudDtpZihlLmRhdGFzZXQuc2VudHJ5RWxlbWVudClyZXR1cm4gZS5kYXRhc2V0LnNlbnRyeUVsZW1lbnR9ci5wdXNoKGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKTtjb25zdCBvPW4/Lmxlbmd0aD9uLmZpbHRlcigodD0+ZS5nZXRBdHRyaWJ1dGUodCkpKS5tYXAoKHQ9Plt0LGUuZ2V0QXR0cmlidXRlKHQpXSkpOm51bGw7aWYobz8ubGVuZ3RoKW8uZm9yRWFjaCgodD0+e3IucHVzaChgWyR7dFswXX09IiR7dFsxXX0iXWApfSkpO2Vsc2V7ZS5pZCYmci5wdXNoKGAjJHtlLmlkfWApO2NvbnN0IHQ9ZS5jbGFzc05hbWU7aWYodCYmRCh0KSl7Y29uc3Qgbj10LnNwbGl0KC9ccysvKTtmb3IoY29uc3QgdCBvZiBuKXIucHVzaChgLiR7dH1gKX19Y29uc3Qgcz1bImFyaWEtbGFiZWwiLCJ0eXBlIiwibmFtZSIsInRpdGxlIiwiYWx0Il07Zm9yKGNvbnN0IHQgb2Ygcyl7Y29uc3Qgbj1lLmdldEF0dHJpYnV0ZSh0KTtuJiZyLnB1c2goYFske3R9PSIke259Il1gKX1yZXR1cm4gci5qb2luKCIiKX1mdW5jdGlvbiBMKHQsbj0wKXtyZXR1cm4ic3RyaW5nIiE9dHlwZW9mIHR8fDA9PT1ufHx0Lmxlbmd0aDw9bj90OmAke3Quc2xpY2UoMCxuKX0uLi5gfWZ1bmN0aW9uIEIodCl7aWYoZnVuY3Rpb24odCl7c3dpdGNoKGsuY2FsbCh0KSl7Y2FzZSJbb2JqZWN0IEVycm9yXSI6Y2FzZSJbb2JqZWN0IEV4Y2VwdGlvbl0iOmNhc2UiW29iamVjdCBET01FeGNlcHRpb25dIjpjYXNlIltvYmplY3QgV2ViQXNzZW1ibHkuRXhjZXB0aW9uXSI6cmV0dXJuITA7ZGVmYXVsdDpyZXR1cm4gQSh0LEVycm9yKX19KHQpKXJldHVybnttZXNzYWdlOnQubWVzc2FnZSxuYW1lOnQubmFtZSxzdGFjazp0LnN0YWNrLC4uLkoodCl9O2lmKG49dCwidW5kZWZpbmVkIiE9dHlwZW9mIEV2ZW50JiZBKG4sRXZlbnQpKXtjb25zdCBuPXt0eXBlOnQudHlwZSx0YXJnZXQ6Ryh0LnRhcmdldCksY3VycmVudFRhcmdldDpHKHQuY3VycmVudFRhcmdldCksLi4uSih0KX07cmV0dXJuInVuZGVmaW5lZCIhPXR5cGVvZiBDdXN0b21FdmVudCYmQSh0LEN1c3RvbUV2ZW50KSYmKG4uZGV0YWlsPXQuZGV0YWlsKSxufXJldHVybiB0O3ZhciBufWZ1bmN0aW9uIEcodCl7dHJ5e3JldHVybiBuPXQsInVuZGVmaW5lZCIhPXR5cGVvZiBFbGVtZW50JiZBKG4sRWxlbWVudCk/ZnVuY3Rpb24odCxuPXt9KXtpZighdClyZXR1cm4iPHVua25vd24+Ijt0cnl7bGV0IGU9dDtjb25zdCByPTUsbz1bXTtsZXQgcz0wLGk9MDtjb25zdCBjPSIgPiAiLHU9Yy5sZW5ndGg7bGV0IGE7Y29uc3QgZj1BcnJheS5pc0FycmF5KG4pP246bi5rZXlBdHRycyxoPSFBcnJheS5pc0FycmF5KG4pJiZuLm1heFN0cmluZ0xlbmd0aHx8VTtmb3IoO2UmJnMrKzxyJiYoYT1NKGUsZiksISgiaHRtbCI9PT1hfHxzPjEmJmkrby5sZW5ndGgqdSthLmxlbmd0aD49aCkpOylvLnB1c2goYSksaSs9YS5sZW5ndGgsZT1lLnBhcmVudE5vZGU7cmV0dXJuIG8ucmV2ZXJzZSgpLmpvaW4oYyl9Y2F0Y2godCl7cmV0dXJuIjx1bmtub3duPiJ9fSh0KTpPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCl9Y2F0Y2godCl7cmV0dXJuIjx1bmtub3duPiJ9dmFyIG59ZnVuY3Rpb24gSih0KXtpZigib2JqZWN0Ij09dHlwZW9mIHQmJm51bGwhPT10KXtjb25zdCBuPXt9O2Zvcihjb25zdCBlIGluIHQpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsZSkmJihuW2VdPXRbZV0pO3JldHVybiBufXJldHVybnt9fWZ1bmN0aW9uIFkodD1mdW5jdGlvbigpe2NvbnN0IHQ9cDtyZXR1cm4gdC5jcnlwdG98fHQubXNDcnlwdG99KCkpe2xldCBuPSgpPT4xNipNYXRoLnJhbmRvbSgpO3RyeXtpZih0Py5yYW5kb21VVUlEKXJldHVybiB0LnJhbmRvbVVVSUQoKS5yZXBsYWNlKC8tL2csIiIpO3Q/LmdldFJhbmRvbVZhbHVlcyYmKG49KCk9Pntjb25zdCBuPW5ldyBVaW50OEFycmF5KDEpO3JldHVybiB0LmdldFJhbmRvbVZhbHVlcyhuKSxuWzBdfSl9Y2F0Y2godCl7fXJldHVybihbMWU3XSsxZTMrNGUzKzhlMysxZTExKS5yZXBsYWNlKC9bMDE4XS9nLCh0PT4odF4oMTUmbigpKT4+dC80KS50b1N0cmluZygxNikpKX12YXIgejtmdW5jdGlvbiBIKHQpe3JldHVybiBuZXcgRigobj0+e24odCl9KSl9IWZ1bmN0aW9uKHQpe3RbdC5QRU5ESU5HPTBdPSJQRU5ESU5HIjt0W3QuUkVTT0xWRUQ9MV09IlJFU09MVkVEIjt0W3QuUkVKRUNURUQ9Ml09IlJFSkVDVEVEIn0oenx8KHo9e30pKTtjbGFzcyBGe2NvbnN0cnVjdG9yKHQpe3RoaXMudD16LlBFTkRJTkcsdGhpcy5vPVtdLHRoaXMuaSh0KX10aGVuKHQsbil7cmV0dXJuIG5ldyBGKCgoZSxyKT0+e3RoaXMuby5wdXNoKFshMSxuPT57aWYodCl0cnl7ZSh0KG4pKX1jYXRjaCh0KXtyKHQpfWVsc2UgZShuKX0sdD0+e2lmKG4pdHJ5e2Uobih0KSl9Y2F0Y2godCl7cih0KX1lbHNlIHIodCl9XSksdGhpcy51KCl9KSl9Y2F0Y2godCl7cmV0dXJuIHRoaXMudGhlbigodD0+dCksdCl9ZmluYWxseSh0KXtyZXR1cm4gbmV3IEYoKChuLGUpPT57bGV0IHIsbztyZXR1cm4gdGhpcy50aGVuKChuPT57bz0hMSxyPW4sdCYmdCgpfSksKG49PntvPSEwLHI9bix0JiZ0KCl9KSkudGhlbigoKCk9PntvP2Uocik6bihyKX0pKX0pKX11KCl7aWYodGhpcy50PT09ei5QRU5ESU5HKXJldHVybjtjb25zdCB0PXRoaXMuby5zbGljZSgpO3RoaXMubz1bXSx0LmZvckVhY2goKHQ9Pnt0WzBdfHwodGhpcy50PT09ei5SRVNPTFZFRCYmdFsxXSh0aGlzLmgpLHRoaXMudD09PXouUkVKRUNURUQmJnRbMl0odGhpcy5oKSx0WzBdPSEwKX0pKX1pKHQpe2NvbnN0IG49KHQsbik9Pnt0aGlzLnQ9PT16LlBFTkRJTkcmJihPKG4pP24udGhlbihlLHIpOih0aGlzLnQ9dCx0aGlzLmg9bix0aGlzLnUoKSkpfSxlPXQ9PntuKHouUkVTT0xWRUQsdCl9LHI9dD0+e24oei5SRUpFQ1RFRCx0KX07dHJ5e3QoZSxyKX1jYXRjaCh0KXtyKHQpfX19ZnVuY3Rpb24gVyh0KXtjb25zdCBuPVIoKSxlPXtzaWQ6WSgpLGluaXQ6ITAsdGltZXN0YW1wOm4sc3RhcnRlZDpuLGR1cmF0aW9uOjAsc3RhdHVzOiJvayIsZXJyb3JzOjAsaWdub3JlRHVyYXRpb246ITEsdG9KU09OOigpPT5mdW5jdGlvbih0KXtyZXR1cm57c2lkOmAke3Quc2lkfWAsaW5pdDp0LmluaXQsc3RhcnRlZDpuZXcgRGF0ZSgxZTMqdC5zdGFydGVkKS50b0lTT1N0cmluZygpLHRpbWVzdGFtcDpuZXcgRGF0ZSgxZTMqdC50aW1lc3RhbXApLnRvSVNPU3RyaW5nKCksc3RhdHVzOnQuc3RhdHVzLGVycm9yczp0LmVycm9ycyxkaWQ6Im51bWJlciI9PXR5cGVvZiB0LmRpZHx8InN0cmluZyI9PXR5cGVvZiB0LmRpZD9gJHt0LmRpZH1gOnZvaWQgMCxkdXJhdGlvbjp0LmR1cmF0aW9uLGFibm9ybWFsX21lY2hhbmlzbTp0LmFibm9ybWFsX21lY2hhbmlzbSxhdHRyczp7cmVsZWFzZTp0LnJlbGVhc2UsZW52aXJvbm1lbnQ6dC5lbnZpcm9ubWVudCxpcF9hZGRyZXNzOnQuaXBBZGRyZXNzLHVzZXJfYWdlbnQ6dC51c2VyQWdlbnR9fX0oZSl9O3JldHVybiB0JiZLKGUsdCksZX1mdW5jdGlvbiBLKHQsbj17fSl7aWYobi51c2VyJiYoIXQuaXBBZGRyZXNzJiZuLnVzZXIuaXBfYWRkcmVzcyYmKHQuaXBBZGRyZXNzPW4udXNlci5pcF9hZGRyZXNzKSx0LmRpZHx8bi5kaWR8fCh0LmRpZD1uLnVzZXIuaWR8fG4udXNlci5lbWFpbHx8bi51c2VyLnVzZXJuYW1lKSksdC50aW1lc3RhbXA9bi50aW1lc3RhbXB8fFIoKSxuLmFibm9ybWFsX21lY2hhbmlzbSYmKHQuYWJub3JtYWxfbWVjaGFuaXNtPW4uYWJub3JtYWxfbWVjaGFuaXNtKSxuLmlnbm9yZUR1cmF0aW9uJiYodC5pZ25vcmVEdXJhdGlvbj1uLmlnbm9yZUR1cmF0aW9uKSxuLnNpZCYmKHQuc2lkPTMyPT09bi5zaWQubGVuZ3RoP24uc2lkOlkoKSksdm9pZCAwIT09bi5pbml0JiYodC5pbml0PW4uaW5pdCksIXQuZGlkJiZuLmRpZCYmKHQuZGlkPWAke24uZGlkfWApLCJudW1iZXIiPT10eXBlb2Ygbi5zdGFydGVkJiYodC5zdGFydGVkPW4uc3RhcnRlZCksdC5pZ25vcmVEdXJhdGlvbil0LmR1cmF0aW9uPXZvaWQgMDtlbHNlIGlmKCJudW1iZXIiPT10eXBlb2Ygbi5kdXJhdGlvbil0LmR1cmF0aW9uPW4uZHVyYXRpb247ZWxzZXtjb25zdCBuPXQudGltZXN0YW1wLXQuc3RhcnRlZDt0LmR1cmF0aW9uPW4+PTA/bjowfW4ucmVsZWFzZSYmKHQucmVsZWFzZT1uLnJlbGVhc2UpLG4uZW52aXJvbm1lbnQmJih0LmVudmlyb25tZW50PW4uZW52aXJvbm1lbnQpLCF0LmlwQWRkcmVzcyYmbi5pcEFkZHJlc3MmJih0LmlwQWRkcmVzcz1uLmlwQWRkcmVzcyksIXQudXNlckFnZW50JiZuLnVzZXJBZ2VudCYmKHQudXNlckFnZW50PW4udXNlckFnZW50KSwibnVtYmVyIj09dHlwZW9mIG4uZXJyb3JzJiYodC5lcnJvcnM9bi5lcnJvcnMpLG4uc3RhdHVzJiYodC5zdGF0dXM9bi5zdGF0dXMpfWZ1bmN0aW9uIFYoKXtyZXR1cm4gWSgpfWZ1bmN0aW9uIFooKXtyZXR1cm4gWSgpLnN1YnN0cmluZygxNil9ZnVuY3Rpb24gcSh0LG4sZT0yKXtpZighbnx8Im9iamVjdCIhPXR5cGVvZiBufHxlPD0wKXJldHVybiBuO2lmKHQmJjA9PT1PYmplY3Qua2V5cyhuKS5sZW5ndGgpcmV0dXJuIHQ7Y29uc3Qgcj17Li4udH07Zm9yKGNvbnN0IHQgaW4gbilPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobix0KSYmKHJbdF09cShyW3RdLG5bdF0sZS0xKSk7cmV0dXJuIHJ9Y29uc3QgUT0iX3NlbnRyeVNwYW4iO2Z1bmN0aW9uIFgodCxuKXtuP2Z1bmN0aW9uKHQsbixlKXt0cnl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbix7dmFsdWU6ZSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9KX1jYXRjaChlKXtsJiZ3LmxvZyhgRmFpbGVkIHRvIGFkZCBub24tZW51bWVyYWJsZSBwcm9wZXJ0eSAiJHtufSIgdG8gb2JqZWN0YCx0KX19KHQsUSxuKTpkZWxldGUgdFtRXX1mdW5jdGlvbiB0dCh0KXtyZXR1cm4gdFtRXX1jbGFzcyBudHtjb25zdHJ1Y3Rvcigpe3RoaXMucD0hMSx0aGlzLmw9W10sdGhpcy5tPVtdLHRoaXMuXz1bXSx0aGlzLnY9W10sdGhpcy5TPXt9LHRoaXMuTj17fSx0aGlzLlQ9e30sdGhpcy5DPXt9LHRoaXMuUj17fSx0aGlzLms9e3RyYWNlSWQ6VigpLHNhbXBsZVJhbmQ6TWF0aC5yYW5kb20oKX19Y2xvbmUoKXtjb25zdCB0PW5ldyBudDtyZXR1cm4gdC5fPVsuLi50aGlzLl9dLHQuTj17Li4udGhpcy5OfSx0LlQ9ey4uLnRoaXMuVH0sdC5DPXsuLi50aGlzLkN9LHRoaXMuQy5mbGFncyYmKHQuQy5mbGFncz17dmFsdWVzOlsuLi50aGlzLkMuZmxhZ3MudmFsdWVzXX0pLHQuUz10aGlzLlMsdC5qPXRoaXMuaix0LkQ9dGhpcy5ELHQuST10aGlzLkksdC5PPXRoaXMuTyx0Lm09Wy4uLnRoaXMubV0sdC52PVsuLi50aGlzLnZdLHQuUj17Li4udGhpcy5SfSx0Lms9ey4uLnRoaXMua30sdC5BPXRoaXMuQSx0LlA9dGhpcy5QLFgodCx0dCh0aGlzKSksdH1zZXRDbGllbnQodCl7dGhpcy5BPXR9c2V0TGFzdEV2ZW50SWQodCl7dGhpcy5QPXR9Z2V0Q2xpZW50KCl7cmV0dXJuIHRoaXMuQX1sYXN0RXZlbnRJZCgpe3JldHVybiB0aGlzLlB9YWRkU2NvcGVMaXN0ZW5lcih0KXt0aGlzLmwucHVzaCh0KX1hZGRFdmVudFByb2Nlc3Nvcih0KXtyZXR1cm4gdGhpcy5tLnB1c2godCksdGhpc31zZXRVc2VyKHQpe3JldHVybiB0aGlzLlM9dHx8e2VtYWlsOnZvaWQgMCxpZDp2b2lkIDAsaXBfYWRkcmVzczp2b2lkIDAsdXNlcm5hbWU6dm9pZCAwfSx0aGlzLkQmJksodGhpcy5ELHt1c2VyOnR9KSx0aGlzLlUoKSx0aGlzfWdldFVzZXIoKXtyZXR1cm4gdGhpcy5TfXNldFRhZ3ModCl7cmV0dXJuIHRoaXMuTj17Li4udGhpcy5OLC4uLnR9LHRoaXMuVSgpLHRoaXN9c2V0VGFnKHQsbil7cmV0dXJuIHRoaXMuTj17Li4udGhpcy5OLFt0XTpufSx0aGlzLlUoKSx0aGlzfXNldEV4dHJhcyh0KXtyZXR1cm4gdGhpcy5UPXsuLi50aGlzLlQsLi4udH0sdGhpcy5VKCksdGhpc31zZXRFeHRyYSh0LG4pe3JldHVybiB0aGlzLlQ9ey4uLnRoaXMuVCxbdF06bn0sdGhpcy5VKCksdGhpc31zZXRGaW5nZXJwcmludCh0KXtyZXR1cm4gdGhpcy5PPXQsdGhpcy5VKCksdGhpc31zZXRMZXZlbCh0KXtyZXR1cm4gdGhpcy5qPXQsdGhpcy5VKCksdGhpc31zZXRUcmFuc2FjdGlvbk5hbWUodCl7cmV0dXJuIHRoaXMuST10LHRoaXMuVSgpLHRoaXN9c2V0Q29udGV4dCh0LG4pe3JldHVybiBudWxsPT09bj9kZWxldGUgdGhpcy5DW3RdOnRoaXMuQ1t0XT1uLHRoaXMuVSgpLHRoaXN9c2V0U2Vzc2lvbih0KXtyZXR1cm4gdD90aGlzLkQ9dDpkZWxldGUgdGhpcy5ELHRoaXMuVSgpLHRoaXN9Z2V0U2Vzc2lvbigpe3JldHVybiB0aGlzLkR9dXBkYXRlKHQpe2lmKCF0KXJldHVybiB0aGlzO2NvbnN0IG49ImZ1bmN0aW9uIj09dHlwZW9mIHQ/dCh0aGlzKTp0LGU9biBpbnN0YW5jZW9mIG50P24uZ2V0U2NvcGVEYXRhKCk6SShuKT90OnZvaWQgMCx7dGFnczpyLGV4dHJhOm8sdXNlcjpzLGNvbnRleHRzOmksbGV2ZWw6YyxmaW5nZXJwcmludDp1PVtdLHByb3BhZ2F0aW9uQ29udGV4dDphfT1lfHx7fTtyZXR1cm4gdGhpcy5OPXsuLi50aGlzLk4sLi4ucn0sdGhpcy5UPXsuLi50aGlzLlQsLi4ub30sdGhpcy5DPXsuLi50aGlzLkMsLi4uaX0scyYmT2JqZWN0LmtleXMocykubGVuZ3RoJiYodGhpcy5TPXMpLGMmJih0aGlzLmo9YyksdS5sZW5ndGgmJih0aGlzLk89dSksYSYmKHRoaXMuaz1hKSx0aGlzfWNsZWFyKCl7cmV0dXJuIHRoaXMuXz1bXSx0aGlzLk49e30sdGhpcy5UPXt9LHRoaXMuUz17fSx0aGlzLkM9e30sdGhpcy5qPXZvaWQgMCx0aGlzLkk9dm9pZCAwLHRoaXMuTz12b2lkIDAsdGhpcy5EPXZvaWQgMCxYKHRoaXMsdm9pZCAwKSx0aGlzLnY9W10sdGhpcy5zZXRQcm9wYWdhdGlvbkNvbnRleHQoe3RyYWNlSWQ6VigpLHNhbXBsZVJhbmQ6TWF0aC5yYW5kb20oKX0pLHRoaXMuVSgpLHRoaXN9YWRkQnJlYWRjcnVtYih0LG4pe2NvbnN0IGU9Im51bWJlciI9PXR5cGVvZiBuP246MTAwO2lmKGU8PTApcmV0dXJuIHRoaXM7Y29uc3Qgcj17dGltZXN0YW1wOkMoKSwuLi50LG1lc3NhZ2U6dC5tZXNzYWdlP0wodC5tZXNzYWdlLDIwNDgpOnQubWVzc2FnZX07cmV0dXJuIHRoaXMuXy5wdXNoKHIpLHRoaXMuXy5sZW5ndGg+ZSYmKHRoaXMuXz10aGlzLl8uc2xpY2UoLWUpLHRoaXMuQT8ucmVjb3JkRHJvcHBlZEV2ZW50KCJidWZmZXJfb3ZlcmZsb3ciLCJsb2dfaXRlbSIpKSx0aGlzLlUoKSx0aGlzfWdldExhc3RCcmVhZGNydW1iKCl7cmV0dXJuIHRoaXMuX1t0aGlzLl8ubGVuZ3RoLTFdfWNsZWFyQnJlYWRjcnVtYnMoKXtyZXR1cm4gdGhpcy5fPVtdLHRoaXMuVSgpLHRoaXN9YWRkQXR0YWNobWVudCh0KXtyZXR1cm4gdGhpcy52LnB1c2godCksdGhpc31jbGVhckF0dGFjaG1lbnRzKCl7cmV0dXJuIHRoaXMudj1bXSx0aGlzfWdldFNjb3BlRGF0YSgpe3JldHVybnticmVhZGNydW1iczp0aGlzLl8sYXR0YWNobWVudHM6dGhpcy52LGNvbnRleHRzOnRoaXMuQyx0YWdzOnRoaXMuTixleHRyYTp0aGlzLlQsdXNlcjp0aGlzLlMsbGV2ZWw6dGhpcy5qLGZpbmdlcnByaW50OnRoaXMuT3x8W10sZXZlbnRQcm9jZXNzb3JzOnRoaXMubSxwcm9wYWdhdGlvbkNvbnRleHQ6dGhpcy5rLHNka1Byb2Nlc3NpbmdNZXRhZGF0YTp0aGlzLlIsdHJhbnNhY3Rpb25OYW1lOnRoaXMuSSxzcGFuOnR0KHRoaXMpfX1zZXRTREtQcm9jZXNzaW5nTWV0YWRhdGEodCl7cmV0dXJuIHRoaXMuUj1xKHRoaXMuUix0LDIpLHRoaXN9c2V0UHJvcGFnYXRpb25Db250ZXh0KHQpe3JldHVybiB0aGlzLms9dCx0aGlzfWdldFByb3BhZ2F0aW9uQ29udGV4dCgpe3JldHVybiB0aGlzLmt9Y2FwdHVyZUV4Y2VwdGlvbih0LG4pe2NvbnN0IGU9bj8uZXZlbnRfaWR8fFkoKTtpZighdGhpcy5BKXJldHVybiB3Lndhcm4oIk5vIGNsaWVudCBjb25maWd1cmVkIG9uIHNjb3BlIC0gd2lsbCBub3QgY2FwdHVyZSBleGNlcHRpb24hIiksZTtjb25zdCByPW5ldyBFcnJvcigiU2VudHJ5IHN5bnRoZXRpY0V4Y2VwdGlvbiIpO3JldHVybiB0aGlzLkEuY2FwdHVyZUV4Y2VwdGlvbih0LHtvcmlnaW5hbEV4Y2VwdGlvbjp0LHN5bnRoZXRpY0V4Y2VwdGlvbjpyLC4uLm4sZXZlbnRfaWQ6ZX0sdGhpcyksZX1jYXB0dXJlTWVzc2FnZSh0LG4sZSl7Y29uc3Qgcj1lPy5ldmVudF9pZHx8WSgpO2lmKCF0aGlzLkEpcmV0dXJuIHcud2FybigiTm8gY2xpZW50IGNvbmZpZ3VyZWQgb24gc2NvcGUgLSB3aWxsIG5vdCBjYXB0dXJlIG1lc3NhZ2UhIikscjtjb25zdCBvPW5ldyBFcnJvcih0KTtyZXR1cm4gdGhpcy5BLmNhcHR1cmVNZXNzYWdlKHQsbix7b3JpZ2luYWxFeGNlcHRpb246dCxzeW50aGV0aWNFeGNlcHRpb246bywuLi5lLGV2ZW50X2lkOnJ9LHRoaXMpLHJ9Y2FwdHVyZUV2ZW50KHQsbil7Y29uc3QgZT1uPy5ldmVudF9pZHx8WSgpO3JldHVybiB0aGlzLkE/KHRoaXMuQS5jYXB0dXJlRXZlbnQodCx7Li4ubixldmVudF9pZDplfSx0aGlzKSxlKToody53YXJuKCJObyBjbGllbnQgY29uZmlndXJlZCBvbiBzY29wZSAtIHdpbGwgbm90IGNhcHR1cmUgZXZlbnQhIiksZSl9VSgpe3RoaXMucHx8KHRoaXMucD0hMCx0aGlzLmwuZm9yRWFjaCgodD0+e3QodGhpcyl9KSksdGhpcy5wPSExKX19Y2xhc3MgZXR7Y29uc3RydWN0b3IodCxuKXtsZXQgZSxyO2U9dHx8bmV3IG50LHI9bnx8bmV3IG50LHRoaXMuTT1be3Njb3BlOmV9XSx0aGlzLkw9cn13aXRoU2NvcGUodCl7Y29uc3Qgbj10aGlzLkIoKTtsZXQgZTt0cnl7ZT10KG4pfWNhdGNoKHQpe3Rocm93IHRoaXMuRygpLHR9cmV0dXJuIE8oZSk/ZS50aGVuKCh0PT4odGhpcy5HKCksdCkpLCh0PT57dGhyb3cgdGhpcy5HKCksdH0pKToodGhpcy5HKCksZSl9Z2V0Q2xpZW50KCl7cmV0dXJuIHRoaXMuZ2V0U3RhY2tUb3AoKS5jbGllbnR9Z2V0U2NvcGUoKXtyZXR1cm4gdGhpcy5nZXRTdGFja1RvcCgpLnNjb3BlfWdldElzb2xhdGlvblNjb3BlKCl7cmV0dXJuIHRoaXMuTH1nZXRTdGFja1RvcCgpe3JldHVybiB0aGlzLk1bdGhpcy5NLmxlbmd0aC0xXX1CKCl7Y29uc3QgdD10aGlzLmdldFNjb3BlKCkuY2xvbmUoKTtyZXR1cm4gdGhpcy5NLnB1c2goe2NsaWVudDp0aGlzLmdldENsaWVudCgpLHNjb3BlOnR9KSx0fUcoKXtyZXR1cm4hKHRoaXMuTS5sZW5ndGg8PTEpJiYhIXRoaXMuTS5wb3AoKX19ZnVuY3Rpb24gcnQoKXtjb25zdCB0PWcobSgpKTtyZXR1cm4gdC5zdGFjaz10LnN0YWNrfHxuZXcgZXQoeSgiZGVmYXVsdEN1cnJlbnRTY29wZSIsKCgpPT5uZXcgbnQpKSx5KCJkZWZhdWx0SXNvbGF0aW9uU2NvcGUiLCgoKT0+bmV3IG50KSkpfWZ1bmN0aW9uIG90KHQpe3JldHVybiBydCgpLndpdGhTY29wZSh0KX1mdW5jdGlvbiBzdCh0LG4pe2NvbnN0IGU9cnQoKTtyZXR1cm4gZS53aXRoU2NvcGUoKCgpPT4oZS5nZXRTdGFja1RvcCgpLnNjb3BlPXQsbih0KSkpKX1mdW5jdGlvbiBpdCh0KXtyZXR1cm4gcnQoKS53aXRoU2NvcGUoKCgpPT50KHJ0KCkuZ2V0SXNvbGF0aW9uU2NvcGUoKSkpKX1mdW5jdGlvbiBjdCh0KXtjb25zdCBuPWcodCk7cmV0dXJuIG4uYWNzP24uYWNzOnt3aXRoSXNvbGF0aW9uU2NvcGU6aXQsd2l0aFNjb3BlOm90LHdpdGhTZXRTY29wZTpzdCx3aXRoU2V0SXNvbGF0aW9uU2NvcGU6KHQsbik9Pml0KG4pLGdldEN1cnJlbnRTY29wZTooKT0+cnQoKS5nZXRTY29wZSgpLGdldElzb2xhdGlvblNjb3BlOigpPT5ydCgpLmdldElzb2xhdGlvblNjb3BlKCl9fWZ1bmN0aW9uIHV0KCl7cmV0dXJuIGN0KG0oKSkuZ2V0Q3VycmVudFNjb3BlKCkuZ2V0Q2xpZW50KCl9Y29uc3QgYXQ9InNlbnRyeS5zb3VyY2UiLGZ0PSJzZW50cnkuc2FtcGxlX3JhdGUiLGh0PSJzZW50cnkub3AiLHB0PSJzZW50cnkub3JpZ2luIixsdD0wLGR0PTEsbXQ9Il9zZW50cnlTY29wZSIsZ3Q9Il9zZW50cnlJc29sYXRpb25TY29wZSI7ZnVuY3Rpb24geXQodCl7cmV0dXJue3Njb3BlOnRbbXRdLGlzb2xhdGlvblNjb3BlOnRbZ3RdfX1jb25zdCBidD0ic2VudHJ5LSIsX3Q9L15zZW50cnktLztmdW5jdGlvbiB2dCh0KXtjb25zdCBuPWZ1bmN0aW9uKHQpe2lmKCF0fHwhRCh0KSYmIUFycmF5LmlzQXJyYXkodCkpcmV0dXJuO2lmKEFycmF5LmlzQXJyYXkodCkpcmV0dXJuIHQucmVkdWNlKCgodCxuKT0+e2NvbnN0IGU9d3Qobik7cmV0dXJuIE9iamVjdC5lbnRyaWVzKGUpLmZvckVhY2goKChbbixlXSk9Pnt0W25dPWV9KSksdH0pLHt9KTtyZXR1cm4gd3QodCl9KHQpO2lmKCFuKXJldHVybjtjb25zdCBlPU9iamVjdC5lbnRyaWVzKG4pLnJlZHVjZSgoKHQsW24sZV0pPT57aWYobi5tYXRjaChfdCkpe3Rbbi5zbGljZShidC5sZW5ndGgpXT1lfXJldHVybiB0fSkse30pO3JldHVybiBPYmplY3Qua2V5cyhlKS5sZW5ndGg+MD9lOnZvaWQgMH1mdW5jdGlvbiB3dCh0KXtyZXR1cm4gdC5zcGxpdCgiLCIpLm1hcCgodD0+dC5zcGxpdCgiPSIpLm1hcCgodD0+ZGVjb2RlVVJJQ29tcG9uZW50KHQudHJpbSgpKSkpKSkucmVkdWNlKCgodCxbbixlXSk9PihuJiZlJiYodFtuXT1lKSx0KSkse30pfWNvbnN0IFN0PTE7ZnVuY3Rpb24gJHQodCl7Y29uc3R7c3BhbklkOm4sdHJhY2VJZDplLGlzUmVtb3RlOnJ9PXQuc3BhbkNvbnRleHQoKSxvPXI/bjpUdCh0KS5wYXJlbnRfc3Bhbl9pZCxzPXl0KHQpLnNjb3BlO3JldHVybntwYXJlbnRfc3Bhbl9pZDpvLHNwYW5faWQ6cj9zPy5nZXRQcm9wYWdhdGlvbkNvbnRleHQoKS5wcm9wYWdhdGlvblNwYW5JZHx8WigpOm4sdHJhY2VfaWQ6ZX19ZnVuY3Rpb24gRXQodCl7cmV0dXJuIHQmJnQubGVuZ3RoPjA/dC5tYXAoKCh7Y29udGV4dDp7c3BhbklkOnQsdHJhY2VJZDpuLHRyYWNlRmxhZ3M6ZSwuLi5yfSxhdHRyaWJ1dGVzOm99KT0+KHtzcGFuX2lkOnQsdHJhY2VfaWQ6bixzYW1wbGVkOmU9PT1TdCxhdHRyaWJ1dGVzOm8sLi4ucn0pKSk6dm9pZCAwfWZ1bmN0aW9uIHh0KHQpe3JldHVybiJudW1iZXIiPT10eXBlb2YgdD9OdCh0KTpBcnJheS5pc0FycmF5KHQpP3RbMF0rdFsxXS8xZTk6dCBpbnN0YW5jZW9mIERhdGU/TnQodC5nZXRUaW1lKCkpOlIoKX1mdW5jdGlvbiBOdCh0KXtyZXR1cm4gdD45OTk5OTk5OTk5P3QvMWUzOnR9ZnVuY3Rpb24gVHQodCl7aWYoZnVuY3Rpb24odCl7cmV0dXJuImZ1bmN0aW9uIj09dHlwZW9mIHQuZ2V0U3BhbkpTT059KHQpKXJldHVybiB0LmdldFNwYW5KU09OKCk7Y29uc3R7c3BhbklkOm4sdHJhY2VJZDplfT10LnNwYW5Db250ZXh0KCk7aWYoZnVuY3Rpb24odCl7Y29uc3Qgbj10O3JldHVybiEhKG4uYXR0cmlidXRlcyYmbi5zdGFydFRpbWUmJm4ubmFtZSYmbi5lbmRUaW1lJiZuLnN0YXR1cyl9KHQpKXtjb25zdHthdHRyaWJ1dGVzOnIsc3RhcnRUaW1lOm8sbmFtZTpzLGVuZFRpbWU6aSxzdGF0dXM6YyxsaW5rczp1fT10LGE9dC5wYXJlbnRTcGFuQ29udGV4dD8uc3BhbklkO3JldHVybntzcGFuX2lkOm4sdHJhY2VfaWQ6ZSxkYXRhOnIsZGVzY3JpcHRpb246cyxwYXJlbnRfc3Bhbl9pZDphLHN0YXJ0X3RpbWVzdGFtcDp4dChvKSx0aW1lc3RhbXA6eHQoaSl8fHZvaWQgMCxzdGF0dXM6Q3QoYyksb3A6cltodF0sb3JpZ2luOnJbcHRdLGxpbmtzOkV0KHUpfX1yZXR1cm57c3Bhbl9pZDpuLHRyYWNlX2lkOmUsc3RhcnRfdGltZXN0YW1wOjAsZGF0YTp7fX19ZnVuY3Rpb24gQ3QodCl7aWYodCYmdC5jb2RlIT09bHQpcmV0dXJuIHQuY29kZT09PWR0PyJvayI6dC5tZXNzYWdlfHwidW5rbm93bl9lcnJvciJ9Y29uc3QgUnQ9Il9zZW50cnlSb290U3BhbiI7ZnVuY3Rpb24ga3QodCl7cmV0dXJuIHRbUnRdfHx0fWNvbnN0IGp0PSJwcm9kdWN0aW9uIixEdD0iX2Zyb3plbkRzYyI7ZnVuY3Rpb24gSXQodCl7Y29uc3Qgbj11dCgpO2lmKCFuKXJldHVybnt9O2NvbnN0IGU9a3QodCkscj1UdChlKSxvPXIuZGF0YSxzPWUuc3BhbkNvbnRleHQoKS50cmFjZVN0YXRlLGk9cz8uZ2V0KCJzZW50cnkuc2FtcGxlX3JhdGUiKT8/b1tmdF07ZnVuY3Rpb24gYyh0KXtyZXR1cm4ibnVtYmVyIiE9dHlwZW9mIGkmJiJzdHJpbmciIT10eXBlb2YgaXx8KHQuc2FtcGxlX3JhdGU9YCR7aX1gKSx0fWNvbnN0IHU9ZVtEdF07aWYodSlyZXR1cm4gYyh1KTtjb25zdCBhPXM/LmdldCgic2VudHJ5LmRzYyIpLGY9YSYmdnQoYSk7aWYoZilyZXR1cm4gYyhmKTtjb25zdCBoPWZ1bmN0aW9uKHQsbil7Y29uc3QgZT1uLmdldE9wdGlvbnMoKSx7cHVibGljS2V5OnJ9PW4uZ2V0RHNuKCl8fHt9LG89e2Vudmlyb25tZW50OmUuZW52aXJvbm1lbnR8fGp0LHJlbGVhc2U6ZS5yZWxlYXNlLHB1YmxpY19rZXk6cix0cmFjZV9pZDp0fTtyZXR1cm4gbi5lbWl0KCJjcmVhdGVEc2MiLG8pLG99KHQuc3BhbkNvbnRleHQoKS50cmFjZUlkLG4pLHA9b1thdF0sbD1yLmRlc2NyaXB0aW9uO3JldHVybiJ1cmwiIT09cCYmbCYmKGgudHJhbnNhY3Rpb249bCksZnVuY3Rpb24odCl7aWYoImJvb2xlYW4iPT10eXBlb2YgX19TRU5UUllfVFJBQ0lOR19fJiYhX19TRU5UUllfVFJBQ0lOR19fKXJldHVybiExO2NvbnN0IG49dHx8dXQoKT8uZ2V0T3B0aW9ucygpO3JldHVybiEoIW58fG51bGw9PW4udHJhY2VzU2FtcGxlUmF0ZSYmIW4udHJhY2VzU2FtcGxlcil9KCkmJihoLnNhbXBsZWQ9U3RyaW5nKGZ1bmN0aW9uKHQpe2NvbnN0e3RyYWNlRmxhZ3M6bn09dC5zcGFuQ29udGV4dCgpO3JldHVybiBuPT09U3R9KGUpKSxoLnNhbXBsZV9yYW5kPXM/LmdldCgic2VudHJ5LnNhbXBsZV9yYW5kIik/P3l0KGUpLnNjb3BlPy5nZXRQcm9wYWdhdGlvbkNvbnRleHQoKS5zYW1wbGVSYW5kLnRvU3RyaW5nKCkpLGMoaCksbi5lbWl0KCJjcmVhdGVEc2MiLGgsZSksaH1mdW5jdGlvbiBPdCh0LG49ITEpe2NvbnN0e2hvc3Q6ZSxwYXRoOnIscGFzczpvLHBvcnQ6cyxwcm9qZWN0SWQ6aSxwcm90b2NvbDpjLHB1YmxpY0tleTp1fT10O3JldHVybmAke2N9Oi8vJHt1fSR7biYmbz9gOiR7b31gOiIifUAke2V9JHtzP2A6JHtzfWA6IiJ9LyR7cj9gJHtyfS9gOnJ9JHtpfWB9ZnVuY3Rpb24gQXQodCxuPTEwMCxlPTEvMCl7dHJ5e3JldHVybiBQdCgiIix0LG4sZSl9Y2F0Y2godCl7cmV0dXJue0VSUk9SOmAqKm5vbi1zZXJpYWxpemFibGUqKiAoJHt0fSlgfX19ZnVuY3Rpb24gUHQodCxuLGU9MS8wLHI9MS8wLG89ZnVuY3Rpb24oKXtjb25zdCB0PW5ldyBXZWFrU2V0O2Z1bmN0aW9uIG4obil7cmV0dXJuISF0LmhhcyhuKXx8KHQuYWRkKG4pLCExKX1mdW5jdGlvbiBlKG4pe3QuZGVsZXRlKG4pfXJldHVybltuLGVdfSgpKXtjb25zdFtzLGldPW87aWYobnVsbD09bnx8WyJib29sZWFuIiwic3RyaW5nIl0uaW5jbHVkZXModHlwZW9mIG4pfHwibnVtYmVyIj09dHlwZW9mIG4mJk51bWJlci5pc0Zpbml0ZShuKSlyZXR1cm4gbjtjb25zdCBjPWZ1bmN0aW9uKHQsbil7dHJ5e2lmKCJkb21haW4iPT09dCYmbiYmIm9iamVjdCI9PXR5cGVvZiBuJiZuLkopcmV0dXJuIltEb21haW5dIjtpZigiZG9tYWluRW1pdHRlciI9PT10KXJldHVybiJbRG9tYWluRW1pdHRlcl0iO2lmKCJ1bmRlZmluZWQiIT10eXBlb2YgZ2xvYmFsJiZuPT09Z2xvYmFsKXJldHVybiJbR2xvYmFsXSI7aWYoInVuZGVmaW5lZCIhPXR5cGVvZiB3aW5kb3cmJm49PT13aW5kb3cpcmV0dXJuIltXaW5kb3ddIjtpZigidW5kZWZpbmVkIiE9dHlwZW9mIGRvY3VtZW50JiZuPT09ZG9jdW1lbnQpcmV0dXJuIltEb2N1bWVudF0iO2lmKCJvYmplY3QiPT10eXBlb2YoZT1uKSYmbnVsbCE9PWUmJihlLl9faXNWdWV8fGUuWSkpcmV0dXJuIltWdWVWaWV3TW9kZWxdIjtpZihmdW5jdGlvbih0KXtyZXR1cm4gSSh0KSYmIm5hdGl2ZUV2ZW50ImluIHQmJiJwcmV2ZW50RGVmYXVsdCJpbiB0JiYic3RvcFByb3BhZ2F0aW9uImluIHR9KG4pKXJldHVybiJbU3ludGhldGljRXZlbnRdIjtpZigibnVtYmVyIj09dHlwZW9mIG4mJiFOdW1iZXIuaXNGaW5pdGUobikpcmV0dXJuYFske259XWA7aWYoImZ1bmN0aW9uIj09dHlwZW9mIG4pcmV0dXJuYFtGdW5jdGlvbjogJHtmdW5jdGlvbih0KXt0cnl7cmV0dXJuIHQmJiJmdW5jdGlvbiI9PXR5cGVvZiB0JiZ0Lm5hbWV8fE59Y2F0Y2godCl7cmV0dXJuIE59fShuKX1dYDtpZigic3ltYm9sIj09dHlwZW9mIG4pcmV0dXJuYFske1N0cmluZyhuKX1dYDtpZigiYmlnaW50Ij09dHlwZW9mIG4pcmV0dXJuYFtCaWdJbnQ6ICR7U3RyaW5nKG4pfV1gO2NvbnN0IHI9ZnVuY3Rpb24odCl7Y29uc3Qgbj1PYmplY3QuZ2V0UHJvdG90eXBlT2YodCk7cmV0dXJuIG4/LmNvbnN0cnVjdG9yP24uY29uc3RydWN0b3IubmFtZToibnVsbCBwcm90b3R5cGUifShuKTtyZXR1cm4vXkhUTUwoXHcqKUVsZW1lbnQkLy50ZXN0KHIpP2BbSFRNTEVsZW1lbnQ6ICR7cn1dYDpgW29iamVjdCAke3J9XWB9Y2F0Y2godCl7cmV0dXJuYCoqbm9uLXNlcmlhbGl6YWJsZSoqICgke3R9KWB9dmFyIGV9KHQsbik7aWYoIWMuc3RhcnRzV2l0aCgiW29iamVjdCAiKSlyZXR1cm4gYztpZihuLl9fc2VudHJ5X3NraXBfbm9ybWFsaXphdGlvbl9fKXJldHVybiBuO2NvbnN0IHU9Im51bWJlciI9PXR5cGVvZiBuLl9fc2VudHJ5X292ZXJyaWRlX25vcm1hbGl6YXRpb25fZGVwdGhfXz9uLl9fc2VudHJ5X292ZXJyaWRlX25vcm1hbGl6YXRpb25fZGVwdGhfXzplO2lmKDA9PT11KXJldHVybiBjLnJlcGxhY2UoIm9iamVjdCAiLCIiKTtpZihzKG4pKXJldHVybiJbQ2lyY3VsYXIgfl0iO2NvbnN0IGE9bjtpZihhJiYiZnVuY3Rpb24iPT10eXBlb2YgYS50b0pTT04pdHJ5e3JldHVybiBQdCgiIixhLnRvSlNPTigpLHUtMSxyLG8pfWNhdGNoKHQpe31jb25zdCBmPUFycmF5LmlzQXJyYXkobik/W106e307bGV0IGg9MDtjb25zdCBwPUIobik7Zm9yKGNvbnN0IHQgaW4gcCl7aWYoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwLHQpKWNvbnRpbnVlO2lmKGg+PXIpe2ZbdF09IltNYXhQcm9wZXJ0aWVzIH5dIjticmVha31jb25zdCBuPXBbdF07Zlt0XT1QdCh0LG4sdS0xLHIsbyksaCsrfXJldHVybiBpKG4pLGZ9ZnVuY3Rpb24gVXQodCxuKXtjb25zdCBlPW4ucmVwbGFjZSgvXFwvZywiLyIpLnJlcGxhY2UoL1t8XFx7fSgpW1xdXiQrKj8uXS9nLCJcXCQmIik7bGV0IHI9dDt0cnl7cj1kZWNvZGVVUkkodCl9Y2F0Y2godCl7fXJldHVybiByLnJlcGxhY2UoL1xcL2csIi8iKS5yZXBsYWNlKC93ZWJwYWNrOlwvPy9nLCIiKS5yZXBsYWNlKG5ldyBSZWdFeHAoYChmaWxlOi8vKT8vKiR7ZX0vKmAsImlnIiksImFwcDovLy8iKX1mdW5jdGlvbiBNdCh0LG49W10pe3JldHVyblt0LG5dfWZ1bmN0aW9uIEx0KHQsbil7Y29uc3QgZT10WzFdO2Zvcihjb25zdCB0IG9mIGUpe2lmKG4odCx0WzBdLnR5cGUpKXJldHVybiEwfXJldHVybiExfWZ1bmN0aW9uIEJ0KHQpe2NvbnN0IG49ZyhwKTtyZXR1cm4gbi5lbmNvZGVQb2x5ZmlsbD9uLmVuY29kZVBvbHlmaWxsKHQpOihuZXcgVGV4dEVuY29kZXIpLmVuY29kZSh0KX1mdW5jdGlvbiBHdCh0KXtjb25zdFtuLGVdPXQ7bGV0IHI9SlNPTi5zdHJpbmdpZnkobik7ZnVuY3Rpb24gbyh0KXsic3RyaW5nIj09dHlwZW9mIHI/cj0ic3RyaW5nIj09dHlwZW9mIHQ/cit0OltCdChyKSx0XTpyLnB1c2goInN0cmluZyI9PXR5cGVvZiB0P0J0KHQpOnQpfWZvcihjb25zdCB0IG9mIGUpe2NvbnN0W24sZV09dDtpZihvKGBcbiR7SlNPTi5zdHJpbmdpZnkobil9XG5gKSwic3RyaW5nIj09dHlwZW9mIGV8fGUgaW5zdGFuY2VvZiBVaW50OEFycmF5KW8oZSk7ZWxzZXtsZXQgdDt0cnl7dD1KU09OLnN0cmluZ2lmeShlKX1jYXRjaChuKXt0PUpTT04uc3RyaW5naWZ5KEF0KGUpKX1vKHQpfX1yZXR1cm4ic3RyaW5nIj09dHlwZW9mIHI/cjpmdW5jdGlvbih0KXtjb25zdCBuPXQucmVkdWNlKCgodCxuKT0+dCtuLmxlbmd0aCksMCksZT1uZXcgVWludDhBcnJheShuKTtsZXQgcj0wO2Zvcihjb25zdCBuIG9mIHQpZS5zZXQobixyKSxyKz1uLmxlbmd0aDtyZXR1cm4gZX0ocil9Y29uc3QgSnQ9e3Nlc3Npb246InNlc3Npb24iLHNlc3Npb25zOiJzZXNzaW9uIixhdHRhY2htZW50OiJhdHRhY2htZW50Iix0cmFuc2FjdGlvbjoidHJhbnNhY3Rpb24iLGV2ZW50OiJlcnJvciIsY2xpZW50X3JlcG9ydDoiaW50ZXJuYWwiLHVzZXJfcmVwb3J0OiJkZWZhdWx0Iixwcm9maWxlOiJwcm9maWxlIixwcm9maWxlX2NodW5rOiJwcm9maWxlIixyZXBsYXlfZXZlbnQ6InJlcGxheSIscmVwbGF5X3JlY29yZGluZzoicmVwbGF5IixjaGVja19pbjoibW9uaXRvciIsZmVlZGJhY2s6ImZlZWRiYWNrIixzcGFuOiJzcGFuIixyYXdfc2VjdXJpdHk6InNlY3VyaXR5IixvdGVsX2xvZzoibG9nX2l0ZW0ifTtmdW5jdGlvbiBZdCh0KXtpZighdD8uc2RrKXJldHVybjtjb25zdHtuYW1lOm4sdmVyc2lvbjplfT10LnNkaztyZXR1cm57bmFtZTpuLHZlcnNpb246ZX19ZnVuY3Rpb24genQodCxuLGUscil7Y29uc3Qgbz1ZdChlKSxzPXQudHlwZSYmInJlcGxheV9ldmVudCIhPT10LnR5cGU/dC50eXBlOiJldmVudCI7IWZ1bmN0aW9uKHQsbil7biYmKHQuc2RrPXQuc2RrfHx7fSx0LnNkay5uYW1lPXQuc2RrLm5hbWV8fG4ubmFtZSx0LnNkay52ZXJzaW9uPXQuc2RrLnZlcnNpb258fG4udmVyc2lvbix0LnNkay5pbnRlZ3JhdGlvbnM9Wy4uLnQuc2RrLmludGVncmF0aW9uc3x8W10sLi4ubi5pbnRlZ3JhdGlvbnN8fFtdXSx0LnNkay5wYWNrYWdlcz1bLi4udC5zZGsucGFja2FnZXN8fFtdLC4uLm4ucGFja2FnZXN8fFtdXSl9KHQsZT8uc2RrKTtjb25zdCBpPWZ1bmN0aW9uKHQsbixlLHIpe2NvbnN0IG89dC5zZGtQcm9jZXNzaW5nTWV0YWRhdGE/LmR5bmFtaWNTYW1wbGluZ0NvbnRleHQ7cmV0dXJue2V2ZW50X2lkOnQuZXZlbnRfaWQsc2VudF9hdDoobmV3IERhdGUpLnRvSVNPU3RyaW5nKCksLi4ubiYme3NkazpufSwuLi4hIWUmJnImJntkc246T3Qocil9LC4uLm8mJnt0cmFjZTpvfX19KHQsbyxyLG4pO2RlbGV0ZSB0LnNka1Byb2Nlc3NpbmdNZXRhZGF0YTtyZXR1cm4gTXQoaSxbW3t0eXBlOnN9LHRdXSl9Y29uc3QgSHQ9Il9fU0VOVFJZX1NVUFBSRVNTX1RSQUNJTkdfXyI7ZnVuY3Rpb24gRnQodCl7Y29uc3Qgbj1jdChtKCkpO3JldHVybiBuLnN1cHByZXNzVHJhY2luZz9uLnN1cHByZXNzVHJhY2luZyh0KTpmdW5jdGlvbiguLi50KXtjb25zdCBuPWN0KG0oKSk7aWYoMj09PXQubGVuZ3RoKXtjb25zdFtlLHJdPXQ7cmV0dXJuIGU/bi53aXRoU2V0U2NvcGUoZSxyKTpuLndpdGhTY29wZShyKX1yZXR1cm4gbi53aXRoU2NvcGUodFswXSl9KChuPT4obi5zZXRTREtQcm9jZXNzaW5nTWV0YWRhdGEoe1tIdF06ITB9KSx0KCkpKSl9ZnVuY3Rpb24gV3QodCxuKXtjb25zdHtmaW5nZXJwcmludDplLHNwYW46cixicmVhZGNydW1iczpvLHNka1Byb2Nlc3NpbmdNZXRhZGF0YTpzfT1uOyFmdW5jdGlvbih0LG4pe2NvbnN0e2V4dHJhOmUsdGFnczpyLHVzZXI6byxjb250ZXh0czpzLGxldmVsOmksdHJhbnNhY3Rpb25OYW1lOmN9PW47T2JqZWN0LmtleXMoZSkubGVuZ3RoJiYodC5leHRyYT17Li4uZSwuLi50LmV4dHJhfSk7T2JqZWN0LmtleXMocikubGVuZ3RoJiYodC50YWdzPXsuLi5yLC4uLnQudGFnc30pO09iamVjdC5rZXlzKG8pLmxlbmd0aCYmKHQudXNlcj17Li4ubywuLi50LnVzZXJ9KTtPYmplY3Qua2V5cyhzKS5sZW5ndGgmJih0LmNvbnRleHRzPXsuLi5zLC4uLnQuY29udGV4dHN9KTtpJiYodC5sZXZlbD1pKTtjJiYidHJhbnNhY3Rpb24iIT09dC50eXBlJiYodC50cmFuc2FjdGlvbj1jKX0odCxuKSxyJiZmdW5jdGlvbih0LG4pe3QuY29udGV4dHM9e3RyYWNlOiR0KG4pLC4uLnQuY29udGV4dHN9LHQuc2RrUHJvY2Vzc2luZ01ldGFkYXRhPXtkeW5hbWljU2FtcGxpbmdDb250ZXh0Okl0KG4pLC4uLnQuc2RrUHJvY2Vzc2luZ01ldGFkYXRhfTtjb25zdCBlPWt0KG4pLHI9VHQoZSkuZGVzY3JpcHRpb247ciYmIXQudHJhbnNhY3Rpb24mJiJ0cmFuc2FjdGlvbiI9PT10LnR5cGUmJih0LnRyYW5zYWN0aW9uPXIpfSh0LHIpLGZ1bmN0aW9uKHQsbil7dC5maW5nZXJwcmludD10LmZpbmdlcnByaW50P0FycmF5LmlzQXJyYXkodC5maW5nZXJwcmludCk/dC5maW5nZXJwcmludDpbdC5maW5nZXJwcmludF06W10sbiYmKHQuZmluZ2VycHJpbnQ9dC5maW5nZXJwcmludC5jb25jYXQobikpO3QuZmluZ2VycHJpbnQubGVuZ3RofHxkZWxldGUgdC5maW5nZXJwcmludH0odCxlKSxmdW5jdGlvbih0LG4pe2NvbnN0IGU9Wy4uLnQuYnJlYWRjcnVtYnN8fFtdLC4uLm5dO3QuYnJlYWRjcnVtYnM9ZS5sZW5ndGg/ZTp2b2lkIDB9KHQsbyksZnVuY3Rpb24odCxuKXt0LnNka1Byb2Nlc3NpbmdNZXRhZGF0YT17Li4udC5zZGtQcm9jZXNzaW5nTWV0YWRhdGEsLi4ubn19KHQscyl9Y29uc3QgS3Q9IjciO2NvbnN0IFZ0PVN5bWJvbC5mb3IoIlNlbnRyeUJ1ZmZlckZ1bGxFcnJvciIpO2Z1bmN0aW9uIFp0KHQpe2NvbnN0IG49W107ZnVuY3Rpb24gZSh0KXtyZXR1cm4gbi5zcGxpY2Uobi5pbmRleE9mKHQpLDEpWzBdfHxQcm9taXNlLnJlc29sdmUodm9pZCAwKX1yZXR1cm57JDpuLGFkZDpmdW5jdGlvbihyKXtpZighKHZvaWQgMD09PXR8fG4ubGVuZ3RoPHQpKXJldHVybiBvPVZ0LG5ldyBGKCgodCxuKT0+e24obyl9KSk7dmFyIG87Y29uc3Qgcz1yKCk7cmV0dXJuLTE9PT1uLmluZGV4T2YocykmJm4ucHVzaChzKSxzLnRoZW4oKCgpPT5lKHMpKSkudGhlbihudWxsLCgoKT0+ZShzKS50aGVuKG51bGwsKCgpPT57fSkpKSksc30sZHJhaW46ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBGKCgoZSxyKT0+e2xldCBvPW4ubGVuZ3RoO2lmKCFvKXJldHVybiBlKCEwKTtjb25zdCBzPXNldFRpbWVvdXQoKCgpPT57dCYmdD4wJiZlKCExKX0pLHQpO24uZm9yRWFjaCgodD0+e0godCkudGhlbigoKCk9PnstLW98fChjbGVhclRpbWVvdXQocyksZSghMCkpfSkscil9KSl9KSl9fX1jb25zdCBxdD02ZTQ7ZnVuY3Rpb24gUXQodCx7c3RhdHVzQ29kZTpuLGhlYWRlcnM6ZX0scj1EYXRlLm5vdygpKXtjb25zdCBvPXsuLi50fSxzPWU/LlsieC1zZW50cnktcmF0ZS1saW1pdHMiXSxpPWU/LlsicmV0cnktYWZ0ZXIiXTtpZihzKWZvcihjb25zdCB0IG9mIHMudHJpbSgpLnNwbGl0KCIsIikpe2NvbnN0W24sZSwsLHNdPXQuc3BsaXQoIjoiLDUpLGk9cGFyc2VJbnQobiwxMCksYz0xZTMqKGlzTmFOKGkpPzYwOmkpO2lmKGUpZm9yKGNvbnN0IHQgb2YgZS5zcGxpdCgiOyIpKSJtZXRyaWNfYnVja2V0Ij09PXQmJnMmJiFzLnNwbGl0KCI7IikuaW5jbHVkZXMoImN1c3RvbSIpfHwob1t0XT1yK2MpO2Vsc2Ugby5hbGw9citjfWVsc2UgaT9vLmFsbD1yK2Z1bmN0aW9uKHQsbj1EYXRlLm5vdygpKXtjb25zdCBlPXBhcnNlSW50KGAke3R9YCwxMCk7aWYoIWlzTmFOKGUpKXJldHVybiAxZTMqZTtjb25zdCByPURhdGUucGFyc2UoYCR7dH1gKTtyZXR1cm4gaXNOYU4ocik/cXQ6ci1ufShpLHIpOjQyOT09PW4mJihvLmFsbD1yKzZlNCk7cmV0dXJuIG99Y29uc3QgWHQ9NjQ7ZnVuY3Rpb24gdG4odCxuLGU9WnQodC5idWZmZXJTaXplfHxYdCkpe2xldCByPXt9O3JldHVybntzZW5kOmZ1bmN0aW9uKHQpe2NvbnN0IG89W107aWYoTHQodCwoKHQsbik9Pntjb25zdCBlPWZ1bmN0aW9uKHQpe3JldHVybiBKdFt0XX0obik7KGZ1bmN0aW9uKHQsbixlPURhdGUubm93KCkpe3JldHVybiBmdW5jdGlvbih0LG4pe3JldHVybiB0W25dfHx0LmFsbHx8MH0odCxuKT5lfSkocixlKXx8by5wdXNoKHQpfSkpLDA9PT1vLmxlbmd0aClyZXR1cm4gSCh7fSk7Y29uc3Qgcz1NdCh0WzBdLG8pLGk9dD0+e0x0KHMsKCh0LG4pPT57fSkpfTtyZXR1cm4gZS5hZGQoKCgpPT5uKHtib2R5Okd0KHMpfSkudGhlbigodD0+KHZvaWQgMCE9PXQuc3RhdHVzQ29kZSYmKHQuc3RhdHVzQ29kZTwyMDB8fHQuc3RhdHVzQ29kZT49MzAwKSYmaCYmdy53YXJuKGBTZW50cnkgcmVzcG9uZGVkIHdpdGggc3RhdHVzIGNvZGUgJHt0LnN0YXR1c0NvZGV9IHRvIHNlbnQgZXZlbnQuYCkscj1RdChyLHQpLHQpKSwodD0+e3Rocm93IGkoKSxoJiZ3LmVycm9yKCJFbmNvdW50ZXJlZCBlcnJvciBydW5uaW5nIHRyYW5zcG9ydCByZXF1ZXN0OiIsdCksdH0pKSkpLnRoZW4oKHQ9PnQpLCh0PT57aWYodD09PVZ0KXJldHVybiBoJiZ3LmVycm9yKCJTa2lwcGVkIHNlbmRpbmcgZXZlbnQgYmVjYXVzZSBidWZmZXIgaXMgZnVsbC4iKSxpKCksSCh7fSk7dGhyb3cgdH0pKX0sZmx1c2g6dD0+ZS5kcmFpbih0KX19Y29uc3Qgbm49L14oXFMrOlxcfFwvPykoW1xzXFNdKj8pKCg/OlwuezEsMn18W14vXFxdKz98KShcLlteLi9cXF0qfCkpKD86Wy9cXF0qKSQvO2Z1bmN0aW9uIGVuKHQpe2NvbnN0IG49ZnVuY3Rpb24odCl7Y29uc3Qgbj10Lmxlbmd0aD4xMDI0P2A8dHJ1bmNhdGVkPiR7dC5zbGljZSgtMTAyNCl9YDp0LGU9bm4uZXhlYyhuKTtyZXR1cm4gZT9lLnNsaWNlKDEpOltdfSh0KSxlPW5bMF18fCIiO2xldCByPW5bMV07cmV0dXJuIGV8fHI/KHImJihyPXIuc2xpY2UoMCxyLmxlbmd0aC0xKSksZStyKToiLiJ9ZnVuY3Rpb24gcm4odCxuPSExKXtyZXR1cm4hKG58fHQmJiF0LnN0YXJ0c1dpdGgoIi8iKSYmIXQubWF0Y2goL15bQS1aXTovKSYmIXQuc3RhcnRzV2l0aCgiLiIpJiYhdC5tYXRjaCgvXlthLXpBLVpdKFthLXpBLVowLTkuXC0rXSkqOlwvXC8vKSkmJnZvaWQgMCE9PXQmJiF0LmluY2x1ZGVzKCJub2RlX21vZHVsZXMvIil9Y29uc3Qgb249U3ltYm9sKCJBZ2VudEJhc2VJbnRlcm5hbFN0YXRlIik7Y2xhc3Mgc24gZXh0ZW5kcyBzLkFnZW50e2NvbnN0cnVjdG9yKHQpe3N1cGVyKHQpLHRoaXNbb25dPXt9fWlzU2VjdXJlRW5kcG9pbnQodCl7aWYodCl7aWYoImJvb2xlYW4iPT10eXBlb2YgdC5zZWN1cmVFbmRwb2ludClyZXR1cm4gdC5zZWN1cmVFbmRwb2ludDtpZigic3RyaW5nIj09dHlwZW9mIHQucHJvdG9jb2wpcmV0dXJuImh0dHBzOiI9PT10LnByb3RvY29sfWNvbnN0e3N0YWNrOm59PW5ldyBFcnJvcjtyZXR1cm4ic3RyaW5nIj09dHlwZW9mIG4mJm4uc3BsaXQoIlxuIikuc29tZSgodD0+LTEhPT10LmluZGV4T2YoIihodHRwcy5qczoiKXx8LTEhPT10LmluZGV4T2YoIm5vZGU6aHR0cHM6IikpKX1jcmVhdGVTb2NrZXQodCxuLGUpe2NvbnN0IHI9ey4uLm4sc2VjdXJlRW5kcG9pbnQ6dGhpcy5pc1NlY3VyZUVuZHBvaW50KG4pfTtQcm9taXNlLnJlc29sdmUoKS50aGVuKCgoKT0+dGhpcy5jb25uZWN0KHQscikpKS50aGVuKChvPT57aWYobyBpbnN0YW5jZW9mIHMuQWdlbnQpcmV0dXJuIG8uYWRkUmVxdWVzdCh0LHIpO3RoaXNbb25dLmN1cnJlbnRTb2NrZXQ9byxzdXBlci5jcmVhdGVTb2NrZXQodCxuLGUpfSksZSl9Y3JlYXRlQ29ubmVjdGlvbigpe2NvbnN0IHQ9dGhpc1tvbl0uY3VycmVudFNvY2tldDtpZih0aGlzW29uXS5jdXJyZW50U29ja2V0PXZvaWQgMCwhdCl0aHJvdyBuZXcgRXJyb3IoIk5vIHNvY2tldCB3YXMgcmV0dXJuZWQgaW4gdGhlIGBjb25uZWN0KClgIGZ1bmN0aW9uIik7cmV0dXJuIHR9Z2V0IGRlZmF1bHRQb3J0KCl7cmV0dXJuIHRoaXNbb25dLmRlZmF1bHRQb3J0Pz8oImh0dHBzOiI9PT10aGlzLnByb3RvY29sPzQ0Mzo4MCl9c2V0IGRlZmF1bHRQb3J0KHQpe3RoaXNbb25dJiYodGhpc1tvbl0uZGVmYXVsdFBvcnQ9dCl9Z2V0IHByb3RvY29sKCl7cmV0dXJuIHRoaXNbb25dLnByb3RvY29sPz8odGhpcy5pc1NlY3VyZUVuZHBvaW50KCk/Imh0dHBzOiI6Imh0dHA6Iil9c2V0IHByb3RvY29sKHQpe3RoaXNbb25dJiYodGhpc1tvbl0ucHJvdG9jb2w9dCl9fWZ1bmN0aW9uIGNuKC4uLnQpe3cubG9nKCJbaHR0cHMtcHJveHktYWdlbnQ6cGFyc2UtcHJveHktcmVzcG9uc2VdIiwuLi50KX1mdW5jdGlvbiB1bih0KXtyZXR1cm4gbmV3IFByb21pc2UoKChuLGUpPT57bGV0IHI9MDtjb25zdCBvPVtdO2Z1bmN0aW9uIHMoKXtjb25zdCBjPXQucmVhZCgpO2M/ZnVuY3Rpb24oYyl7by5wdXNoKGMpLHIrPWMubGVuZ3RoO2NvbnN0IHU9QnVmZmVyLmNvbmNhdChvLHIpLGE9dS5pbmRleE9mKCJcclxuXHJcbiIpO2lmKC0xPT09YSlyZXR1cm4gY24oImhhdmUgbm90IHJlY2VpdmVkIGVuZCBvZiBIVFRQIGhlYWRlcnMgeWV0Li4uIiksdm9pZCBzKCk7Y29uc3QgZj11LnN1YmFycmF5KDAsYSkudG9TdHJpbmcoImFzY2lpIikuc3BsaXQoIlxyXG4iKSxoPWYuc2hpZnQoKTtpZighaClyZXR1cm4gdC5kZXN0cm95KCksZShuZXcgRXJyb3IoIk5vIGhlYWRlciByZWNlaXZlZCBmcm9tIHByb3h5IENPTk5FQ1QgcmVzcG9uc2UiKSk7Y29uc3QgcD1oLnNwbGl0KCIgIiksbD0rKHBbMV18fDApLGQ9cC5zbGljZSgyKS5qb2luKCIgIiksbT17fTtmb3IoY29uc3QgbiBvZiBmKXtpZighbiljb250aW51ZTtjb25zdCByPW4uaW5kZXhPZigiOiIpO2lmKC0xPT09cilyZXR1cm4gdC5kZXN0cm95KCksZShuZXcgRXJyb3IoYEludmFsaWQgaGVhZGVyIGZyb20gcHJveHkgQ09OTkVDVCByZXNwb25zZTogIiR7bn0iYCkpO2NvbnN0IG89bi5zbGljZSgwLHIpLnRvTG93ZXJDYXNlKCkscz1uLnNsaWNlKHIrMSkudHJpbVN0YXJ0KCksaT1tW29dOyJzdHJpbmciPT10eXBlb2YgaT9tW29dPVtpLHNdOkFycmF5LmlzQXJyYXkoaSk/aS5wdXNoKHMpOm1bb109c31jbigiZ290IHByb3h5IHNlcnZlciByZXNwb25zZTogJW8gJW8iLGgsbSksaSgpLG4oe2Nvbm5lY3Q6e3N0YXR1c0NvZGU6bCxzdGF0dXNUZXh0OmQsaGVhZGVyczptfSxidWZmZXJlZDp1fSl9KGMpOnQub25jZSgicmVhZGFibGUiLHMpfWZ1bmN0aW9uIGkoKXt0LnJlbW92ZUxpc3RlbmVyKCJlbmQiLGMpLHQucmVtb3ZlTGlzdGVuZXIoImVycm9yIix1KSx0LnJlbW92ZUxpc3RlbmVyKCJyZWFkYWJsZSIscyl9ZnVuY3Rpb24gYygpe2koKSxjbigib25lbmQiKSxlKG5ldyBFcnJvcigiUHJveHkgY29ubmVjdGlvbiBlbmRlZCBiZWZvcmUgcmVjZWl2aW5nIENPTk5FQ1QgcmVzcG9uc2UiKSl9ZnVuY3Rpb24gdSh0KXtpKCksY24oIm9uZXJyb3IgJW8iLHQpLGUodCl9dC5vbigiZXJyb3IiLHUpLHQub24oImVuZCIsYykscygpfSkpfWZ1bmN0aW9uIGFuKC4uLnQpe3cubG9nKCJbaHR0cHMtcHJveHktYWdlbnRdIiwuLi50KX1jbGFzcyBmbiBleHRlbmRzIHNue3N0YXRpYyBfX2luaXRTdGF0aWMoKXt0aGlzLnByb3RvY29scz1bImh0dHAiLCJodHRwcyJdfWNvbnN0cnVjdG9yKHQsbil7c3VwZXIobiksdGhpcy5vcHRpb25zPXt9LHRoaXMucHJveHk9InN0cmluZyI9PXR5cGVvZiB0P25ldyBVUkwodCk6dCx0aGlzLnByb3h5SGVhZGVycz1uPy5oZWFkZXJzPz97fSxhbigiQ3JlYXRpbmcgbmV3IEh0dHBzUHJveHlBZ2VudCBpbnN0YW5jZTogJW8iLHRoaXMucHJveHkuaHJlZik7Y29uc3QgZT0odGhpcy5wcm94eS5ob3N0bmFtZXx8dGhpcy5wcm94eS5ob3N0KS5yZXBsYWNlKC9eXFt8XF0kL2csIiIpLHI9dGhpcy5wcm94eS5wb3J0P3BhcnNlSW50KHRoaXMucHJveHkucG9ydCwxMCk6Imh0dHBzOiI9PT10aGlzLnByb3h5LnByb3RvY29sPzQ0Mzo4MDt0aGlzLmNvbm5lY3RPcHRzPXtBTFBOUHJvdG9jb2xzOlsiaHR0cC8xLjEiXSwuLi5uP3BuKG4sImhlYWRlcnMiKTpudWxsLGhvc3Q6ZSxwb3J0OnJ9fWFzeW5jIGNvbm5lY3QodCxuKXtjb25zdHtwcm94eTplfT10aGlzO2lmKCFuLmhvc3QpdGhyb3cgbmV3IFR5cGVFcnJvcignTm8gImhvc3QiIHByb3ZpZGVkJyk7bGV0IHI7aWYoImh0dHBzOiI9PT1lLnByb3RvY29sKXthbigiQ3JlYXRpbmcgYHRscy5Tb2NrZXRgOiAlbyIsdGhpcy5jb25uZWN0T3B0cyk7Y29uc3QgdD10aGlzLmNvbm5lY3RPcHRzLnNlcnZlcm5hbWV8fHRoaXMuY29ubmVjdE9wdHMuaG9zdDtyPWYuY29ubmVjdCh7Li4udGhpcy5jb25uZWN0T3B0cyxzZXJ2ZXJuYW1lOnQmJmEuaXNJUCh0KT92b2lkIDA6dH0pfWVsc2UgYW4oIkNyZWF0aW5nIGBuZXQuU29ja2V0YDogJW8iLHRoaXMuY29ubmVjdE9wdHMpLHI9YS5jb25uZWN0KHRoaXMuY29ubmVjdE9wdHMpO2NvbnN0IG89ImZ1bmN0aW9uIj09dHlwZW9mIHRoaXMucHJveHlIZWFkZXJzP3RoaXMucHJveHlIZWFkZXJzKCk6ey4uLnRoaXMucHJveHlIZWFkZXJzfSxzPWEuaXNJUHY2KG4uaG9zdCk/YFske24uaG9zdH1dYDpuLmhvc3Q7bGV0IGk9YENPTk5FQ1QgJHtzfToke24ucG9ydH0gSFRUUC8xLjFcclxuYDtpZihlLnVzZXJuYW1lfHxlLnBhc3N3b3JkKXtjb25zdCB0PWAke2RlY29kZVVSSUNvbXBvbmVudChlLnVzZXJuYW1lKX06JHtkZWNvZGVVUklDb21wb25lbnQoZS5wYXNzd29yZCl9YDtvWyJQcm94eS1BdXRob3JpemF0aW9uIl09YEJhc2ljICR7QnVmZmVyLmZyb20odCkudG9TdHJpbmcoImJhc2U2NCIpfWB9by5Ib3N0PWAke3N9OiR7bi5wb3J0fWAsb1siUHJveHktQ29ubmVjdGlvbiJdfHwob1siUHJveHktQ29ubmVjdGlvbiJdPXRoaXMua2VlcEFsaXZlPyJLZWVwLUFsaXZlIjoiY2xvc2UiKTtmb3IoY29uc3QgdCBvZiBPYmplY3Qua2V5cyhvKSlpKz1gJHt0fTogJHtvW3RdfVxyXG5gO2NvbnN0IGM9dW4ocik7ci53cml0ZShgJHtpfVxyXG5gKTtjb25zdHtjb25uZWN0OnUsYnVmZmVyZWQ6aH09YXdhaXQgYztpZih0LmVtaXQoInByb3h5Q29ubmVjdCIsdSksdGhpcy5lbWl0KCJwcm94eUNvbm5lY3QiLHUsdCksMjAwPT09dS5zdGF0dXNDb2RlKXtpZih0Lm9uY2UoInNvY2tldCIsaG4pLG4uc2VjdXJlRW5kcG9pbnQpe2FuKCJVcGdyYWRpbmcgc29ja2V0IGNvbm5lY3Rpb24gdG8gVExTIik7Y29uc3QgdD1uLnNlcnZlcm5hbWV8fG4uaG9zdDtyZXR1cm4gZi5jb25uZWN0KHsuLi5wbihuLCJob3N0IiwicGF0aCIsInBvcnQiKSxzb2NrZXQ6cixzZXJ2ZXJuYW1lOmEuaXNJUCh0KT92b2lkIDA6dH0pfXJldHVybiByfXIuZGVzdHJveSgpO2NvbnN0IHA9bmV3IGEuU29ja2V0KHt3cml0YWJsZTohMX0pO3JldHVybiBwLnJlYWRhYmxlPSEwLHQub25jZSgic29ja2V0IiwodD0+e2FuKCJSZXBsYXlpbmcgcHJveHkgYnVmZmVyIGZvciBmYWlsZWQgcmVxdWVzdCIpLHQucHVzaChoKSx0LnB1c2gobnVsbCl9KSkscH19ZnVuY3Rpb24gaG4odCl7dC5yZXN1bWUoKX1mdW5jdGlvbiBwbih0LC4uLm4pe2NvbnN0IGU9e307bGV0IHI7Zm9yKHIgaW4gdCluLmluY2x1ZGVzKHIpfHwoZVtyXT10W3JdKTtyZXR1cm4gZX1mbi5fX2luaXRTdGF0aWMoKTtjb25zdCBsbj0zMjc2ODtmdW5jdGlvbiBkbih0KXtyZXR1cm4gdC5yZXBsYWNlKC9eW0EtWl06LywiIikucmVwbGFjZSgvXFwvZywiLyIpfWNvbnN0IG1uPW47bGV0IGduLHluPTAsYm49e307ZnVuY3Rpb24gX24odCl7bW4uZGVidWcmJmNvbnNvbGUubG9nKGBbQU5SIFdvcmtlcl0gJHt0fWApfXZhciB2bix3bixTbjtjb25zdCAkbj1mdW5jdGlvbih0KXtsZXQgbjt0cnl7bj1uZXcgVVJMKHQudXJsKX1jYXRjaChuKXtyZXR1cm4gdigoKCk9Pntjb25zb2xlLndhcm4oIltAc2VudHJ5L25vZGVdOiBJbnZhbGlkIGRzbiBvciB0dW5uZWwgb3B0aW9uLCB3aWxsIG5vdCBzZW5kIGFueSBldmVudHMuIFRoZSB0dW5uZWwgb3B0aW9uIG11c3QgYmUgYSBmdWxsIFVSTCB3aGVuIHVzZWQuIil9KSksdG4odCwoKCk9PlByb21pc2UucmVzb2x2ZSh7fSkpKX1jb25zdCBlPSJodHRwczoiPT09bi5wcm90b2NvbCxyPWZ1bmN0aW9uKHQsbil7Y29uc3R7bm9fcHJveHk6ZX09cHJvY2Vzcy5lbnYscj1lPy5zcGxpdCgiLCIpLnNvbWUoKG49PnQuaG9zdC5lbmRzV2l0aChuKXx8dC5ob3N0bmFtZS5lbmRzV2l0aChuKSkpO3JldHVybiByP3ZvaWQgMDpufShuLHQucHJveHl8fChlP3Byb2Nlc3MuZW52Lmh0dHBzX3Byb3h5OnZvaWQgMCl8fHByb2Nlc3MuZW52Lmh0dHBfcHJveHkpLG89ZT9pOnMsYT12b2lkIDAhPT10LmtlZXBBbGl2ZSYmdC5rZWVwQWxpdmUsZj1yP25ldyBmbihyKTpuZXcgby5BZ2VudCh7a2VlcEFsaXZlOmEsbWF4U29ja2V0czozMCx0aW1lb3V0OjJlM30pLGg9ZnVuY3Rpb24odCxuLGUpe2NvbnN0e2hvc3RuYW1lOnIscGF0aG5hbWU6byxwb3J0OnMscHJvdG9jb2w6aSxzZWFyY2g6YX09bmV3IFVSTCh0LnVybCk7cmV0dXJuIGZ1bmN0aW9uKGYpe3JldHVybiBuZXcgUHJvbWlzZSgoKGgscCk9PntGdCgoKCk9PntsZXQgbD1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGMoe3JlYWQoKXt0aGlzLnB1c2godCksdGhpcy5wdXNoKG51bGwpfX0pfShmLmJvZHkpO2NvbnN0IGQ9ey4uLnQuaGVhZGVyc307Zi5ib2R5Lmxlbmd0aD5sbiYmKGRbImNvbnRlbnQtZW5jb2RpbmciXT0iZ3ppcCIsbD1sLnBpcGUodSgpKSk7Y29uc3QgbT1uLnJlcXVlc3Qoe21ldGhvZDoiUE9TVCIsYWdlbnQ6ZSxoZWFkZXJzOmQsaG9zdG5hbWU6cixwYXRoOmAke299JHthfWAscG9ydDpzLHByb3RvY29sOmksY2E6dC5jYUNlcnRzfSwodD0+e3Qub24oImRhdGEiLCgoKT0+e30pKSx0Lm9uKCJlbmQiLCgoKT0+e30pKSx0LnNldEVuY29kaW5nKCJ1dGY4Iik7Y29uc3Qgbj10LmhlYWRlcnNbInJldHJ5LWFmdGVyIl0/P251bGwsZT10LmhlYWRlcnNbIngtc2VudHJ5LXJhdGUtbGltaXRzIl0/P251bGw7aCh7c3RhdHVzQ29kZTp0LnN0YXR1c0NvZGUsaGVhZGVyczp7InJldHJ5LWFmdGVyIjpuLCJ4LXNlbnRyeS1yYXRlLWxpbWl0cyI6QXJyYXkuaXNBcnJheShlKT9lWzBdfHxudWxsOmV9fSl9KSk7bS5vbigiZXJyb3IiLHApLGwucGlwZShtKX0pKX0pKX19KHQsdC5odHRwTW9kdWxlPz9vLGYpO3JldHVybiB0bih0LGgpfSh7dXJsOih2bj1tbi5kc24sd249bW4udHVubmVsLFNuPW1uLnNka01ldGFkYXRhLnNkayx3bnx8YCR7ZnVuY3Rpb24odCl7cmV0dXJuYCR7ZnVuY3Rpb24odCl7Y29uc3Qgbj10LnByb3RvY29sP2Ake3QucHJvdG9jb2x9OmA6IiIsZT10LnBvcnQ/YDoke3QucG9ydH1gOiIiO3JldHVybmAke259Ly8ke3QuaG9zdH0ke2V9JHt0LnBhdGg/YC8ke3QucGF0aH1gOiIifS9hcGkvYH0odCl9JHt0LnByb2plY3RJZH0vZW52ZWxvcGUvYH0odm4pfT8ke2Z1bmN0aW9uKHQsbil7Y29uc3QgZT17c2VudHJ5X3ZlcnNpb246S3R9O3JldHVybiB0LnB1YmxpY0tleSYmKGUuc2VudHJ5X2tleT10LnB1YmxpY0tleSksbiYmKGUuc2VudHJ5X2NsaWVudD1gJHtuLm5hbWV9LyR7bi52ZXJzaW9ufWApLG5ldyBVUkxTZWFyY2hQYXJhbXMoZSkudG9TdHJpbmcoKX0odm4sU24pfWApfSk7YXN5bmMgZnVuY3Rpb24gRW4oKXtpZihnbil7X24oIlNlbmRpbmcgYWJub3JtYWwgc2Vzc2lvbiIpLEsoZ24se3N0YXR1czoiYWJub3JtYWwiLGFibm9ybWFsX21lY2hhbmlzbToiYW5yX2ZvcmVncm91bmQiLHJlbGVhc2U6bW4ucmVsZWFzZSxlbnZpcm9ubWVudDptbi5lbnZpcm9ubWVudH0pO2NvbnN0IHQ9ZnVuY3Rpb24odCxuLGUscil7Y29uc3Qgbz1ZdChlKTtyZXR1cm4gTXQoe3NlbnRfYXQ6KG5ldyBEYXRlKS50b0lTT1N0cmluZygpLC4uLm8mJntzZGs6b30sLi4uISFyJiZuJiZ7ZHNuOk90KG4pfX0sWyJhZ2dyZWdhdGVzImluIHQ/W3t0eXBlOiJzZXNzaW9ucyJ9LHRdOlt7dHlwZToic2Vzc2lvbiJ9LHQudG9KU09OKCldXSl9KGduLG1uLmRzbixtbi5zZGtNZXRhZGF0YSxtbi50dW5uZWwpO19uKEpTT04uc3RyaW5naWZ5KHQpKSxhd2FpdCAkbi5zZW5kKHQpO3RyeXtlPy5wb3N0TWVzc2FnZSgic2Vzc2lvbi1lbmRlZCIpfWNhdGNoKHQpe319fWZ1bmN0aW9uIHhuKHQpe2lmKCF0KXJldHVybjtjb25zdCBuPWZ1bmN0aW9uKHQpe2lmKCF0Lmxlbmd0aClyZXR1cm5bXTtjb25zdCBuPUFycmF5LmZyb20odCk7cmV0dXJuL3NlbnRyeVdyYXBwZWQvLnRlc3QoeChuKS5mdW5jdGlvbnx8IiIpJiZuLnBvcCgpLG4ucmV2ZXJzZSgpLEUudGVzdCh4KG4pLmZ1bmN0aW9ufHwiIikmJihuLnBvcCgpLEUudGVzdCh4KG4pLmZ1bmN0aW9ufHwiIikmJm4ucG9wKCkpLG4uc2xpY2UoMCxTKS5tYXAoKHQ9Pih7Li4udCxmaWxlbmFtZTp0LmZpbGVuYW1lfHx4KG4pLmZpbGVuYW1lLGZ1bmN0aW9uOnQuZnVuY3Rpb258fCR9KSkpfSh0KTtpZihtbi5hcHBSb290UGF0aClmb3IoY29uc3QgdCBvZiBuKXQuZmlsZW5hbWUmJih0LmZpbGVuYW1lPVV0KHQuZmlsZW5hbWUsbW4uYXBwUm9vdFBhdGgpKTtyZXR1cm4gbn1hc3luYyBmdW5jdGlvbiBObih0LG4pe2lmKHluPj1tbi5tYXhBbnJFdmVudHMpcmV0dXJuO3luKz0xLGF3YWl0IEVuKCksX24oIlNlbmRpbmcgZXZlbnQiKTtjb25zdCBlPXtldmVudF9pZDpZKCksY29udGV4dHM6bW4uY29udGV4dHMscmVsZWFzZTptbi5yZWxlYXNlLGVudmlyb25tZW50Om1uLmVudmlyb25tZW50LGRpc3Q6bW4uZGlzdCxwbGF0Zm9ybToibm9kZSIsbGV2ZWw6ImVycm9yIixleGNlcHRpb246e3ZhbHVlczpbe3R5cGU6IkFwcGxpY2F0aW9uTm90UmVzcG9uZGluZyIsdmFsdWU6YEFwcGxpY2F0aW9uIE5vdCBSZXNwb25kaW5nIGZvciBhdCBsZWFzdCAke21uLmFuclRocmVzaG9sZH0gbXNgLHN0YWNrdHJhY2U6e2ZyYW1lczp4bih0KX0sbWVjaGFuaXNtOnt0eXBlOiJBTlIifX1dfSx0YWdzOm1uLnN0YXRpY1RhZ3N9O24mJmZ1bmN0aW9uKHQsbil7aWYoV3QodCxuKSwhdC5jb250ZXh0cz8udHJhY2Upe2NvbnN0e3RyYWNlSWQ6ZSxwYXJlbnRTcGFuSWQ6cixwcm9wYWdhdGlvblNwYW5JZDpvfT1uLnByb3BhZ2F0aW9uQ29udGV4dDt0LmNvbnRleHRzPXt0cmFjZTp7dHJhY2VfaWQ6ZSxzcGFuX2lkOm98fFooKSxwYXJlbnRfc3Bhbl9pZDpyfSwuLi50LmNvbnRleHRzfX19KGUsbiksZnVuY3Rpb24odCl7aWYoMD09PU9iamVjdC5rZXlzKGJuKS5sZW5ndGgpcmV0dXJuO2NvbnN0IG49bW4uYXBwUm9vdFBhdGg/e306Ym47aWYobW4uYXBwUm9vdFBhdGgpZm9yKGNvbnN0W3QsZV1vZiBPYmplY3QuZW50cmllcyhibikpbltVdCh0LG1uLmFwcFJvb3RQYXRoKV09ZTtjb25zdCBlPW5ldyBNYXA7Zm9yKGNvbnN0IHIgb2YgdC5leGNlcHRpb24/LnZhbHVlc3x8W10pZm9yKGNvbnN0IHQgb2Ygci5zdGFja3RyYWNlPy5mcmFtZXN8fFtdKXtjb25zdCByPXQuYWJzX3BhdGh8fHQuZmlsZW5hbWU7ciYmbltyXSYmZS5zZXQocixuW3JdKX1pZihlLnNpemU+MCl7Y29uc3Qgbj1bXTtmb3IoY29uc3RbdCxyXW9mIGUuZW50cmllcygpKW4ucHVzaCh7dHlwZToic291cmNlbWFwIixjb2RlX2ZpbGU6dCxkZWJ1Z19pZDpyfSk7dC5kZWJ1Z19tZXRhPXtpbWFnZXM6bn19fShlKTtjb25zdCByPXp0KGUsbW4uZHNuLG1uLnNka01ldGFkYXRhLG1uLnR1bm5lbCk7X24oSlNPTi5zdHJpbmdpZnkocikpLGF3YWl0ICRuLnNlbmQociksYXdhaXQgJG4uZmx1c2goMmUzKSx5bj49bW4ubWF4QW5yRXZlbnRzJiZzZXRUaW1lb3V0KCgoKT0+e3Byb2Nlc3MuZXhpdCgwKX0pLDVlMyl9bGV0IFRuO2lmKF9uKCJTdGFydGVkIiksbW4uY2FwdHVyZVN0YWNrVHJhY2Upe19uKCJDb25uZWN0aW5nIHRvIGRlYnVnZ2VyIik7Y29uc3Qgbj1uZXcgdDtuLmNvbm5lY3RUb01haW5UaHJlYWQoKSxfbigiQ29ubmVjdGVkIHRvIGRlYnVnZ2VyIik7Y29uc3QgZT1uZXcgTWFwO24ub24oIkRlYnVnZ2VyLnNjcmlwdFBhcnNlZCIsKHQ9PntlLnNldCh0LnBhcmFtcy5zY3JpcHRJZCx0LnBhcmFtcy51cmwpfSkpLG4ub24oIkRlYnVnZ2VyLnBhdXNlZCIsKHQ9PntpZigib3RoZXIiPT09dC5wYXJhbXMucmVhc29uKXRyeXtfbigiRGVidWdnZXIgcGF1c2VkIik7Y29uc3Qgcz1bLi4udC5wYXJhbXMuY2FsbEZyYW1lc10saT1tbi5hcHBSb290UGF0aD9mdW5jdGlvbih0PShwcm9jZXNzLmFyZ3ZbMV0/ZW4ocHJvY2Vzcy5hcmd2WzFdKTpwcm9jZXNzLmN3ZCgpKSxuPSJcXCI9PT1vKXtjb25zdCBlPW4/ZG4odCk6dDtyZXR1cm4gdD0+e2lmKCF0KXJldHVybjtjb25zdCBvPW4/ZG4odCk6dDtsZXR7ZGlyOnMsYmFzZTppLGV4dDpjfT1yLnBhcnNlKG8pOyIuanMiIT09YyYmIi5tanMiIT09YyYmIi5janMiIT09Y3x8KGk9aS5zbGljZSgwLC0xKmMubGVuZ3RoKSk7Y29uc3QgdT1kZWNvZGVVUklDb21wb25lbnQoaSk7c3x8KHM9Ii4iKTtjb25zdCBhPXMubGFzdEluZGV4T2YoIi9ub2RlX21vZHVsZXMiKTtpZihhPi0xKXJldHVybmAke3Muc2xpY2UoYSsxNCkucmVwbGFjZSgvXC8vZywiLiIpfToke3V9YDtpZihzLnN0YXJ0c1dpdGgoZSkpe2NvbnN0IHQ9cy5zbGljZShlLmxlbmd0aCsxKS5yZXBsYWNlKC9cLy9nLCIuIik7cmV0dXJuIHQ/YCR7dH06JHt1fWA6dX1yZXR1cm4gdX19KG1uLmFwcFJvb3RQYXRoKTooKT0+e30sYz1zLm1hcCgodD0+ZnVuY3Rpb24odCxuLGUpe2NvbnN0IHI9bj9uLnJlcGxhY2UoL15maWxlOlwvXC8vLCIiKTp2b2lkIDAsbz10LmxvY2F0aW9uLmNvbHVtbk51bWJlcj90LmxvY2F0aW9uLmNvbHVtbk51bWJlcisxOnZvaWQgMCxzPXQubG9jYXRpb24ubGluZU51bWJlcj90LmxvY2F0aW9uLmxpbmVOdW1iZXIrMTp2b2lkIDA7cmV0dXJue2ZpbGVuYW1lOnIsbW9kdWxlOmUociksZnVuY3Rpb246dC5mdW5jdGlvbk5hbWV8fCQsY29sbm86byxsaW5lbm86cyxpbl9hcHA6cj9ybihyKTp2b2lkIDB9fSh0LGUuZ2V0KHQubG9jYXRpb24uc2NyaXB0SWQpLGkpKSksdT1zZXRUaW1lb3V0KCgoKT0+e05uKGMpLnRoZW4obnVsbCwoKCk9PntfbigiU2VuZGluZyBBTlIgZXZlbnQgZmFpbGVkLiIpfSkpfSksNWUzKTtuLnBvc3QoIlJ1bnRpbWUuZXZhbHVhdGUiLHtleHByZXNzaW9uOiJnbG9iYWwuX19TRU5UUllfR0VUX1NDT1BFU19fKCk7IixzaWxlbnQ6ITAscmV0dXJuQnlWYWx1ZTohMH0sKCh0LGUpPT57dCYmX24oYEVycm9yIGV4ZWN1dGluZyBzY3JpcHQ6ICcke3QubWVzc2FnZX0nYCksY2xlYXJUaW1lb3V0KHUpO2NvbnN0IHI9ZT8ucmVzdWx0P2UucmVzdWx0LnZhbHVlOnZvaWQgMDtuLnBvc3QoIkRlYnVnZ2VyLnJlc3VtZSIpLG4ucG9zdCgiRGVidWdnZXIuZGlzYWJsZSIpLE5uKGMscikudGhlbihudWxsLCgoKT0+e19uKCJTZW5kaW5nIEFOUiBldmVudCBmYWlsZWQuIil9KSl9KSl9Y2F0Y2godCl7dGhyb3cgbi5wb3N0KCJEZWJ1Z2dlci5yZXN1bWUiKSxuLnBvc3QoIkRlYnVnZ2VyLmRpc2FibGUiKSx0fX0pKSxUbj0oKT0+e3RyeXtuLnBvc3QoIkRlYnVnZ2VyLmVuYWJsZSIsKCgpPT57bi5wb3N0KCJEZWJ1Z2dlci5wYXVzZSIpfSkpfWNhdGNoKHQpe319fWNvbnN0e3BvbGw6Q259PWZ1bmN0aW9uKHQsbixlLHIpe2NvbnN0IG89dCgpO2xldCBzPSExLGk9ITA7cmV0dXJuIHNldEludGVydmFsKCgoKT0+e2NvbnN0IHQ9by5nZXRUaW1lTXMoKTshMT09PXMmJnQ+bitlJiYocz0hMCxpJiZyKCkpLHQ8bitlJiYocz0hMSl9KSwyMCkse3BvbGw6KCk9PntvLnJlc2V0KCl9LGVuYWJsZWQ6dD0+e2k9dH19fSgoZnVuY3Rpb24oKXtsZXQgdD1wcm9jZXNzLmhydGltZSgpO3JldHVybntnZXRUaW1lTXM6KCk9Pntjb25zdFtuLGVdPXByb2Nlc3MuaHJ0aW1lKHQpO3JldHVybiBNYXRoLmZsb29yKDFlMypuK2UvMWU2KX0scmVzZXQ6KCk9Pnt0PXByb2Nlc3MuaHJ0aW1lKCl9fX0pLG1uLnBvbGxJbnRlcnZhbCxtbi5hbnJUaHJlc2hvbGQsKGZ1bmN0aW9uKCl7X24oIldhdGNoZG9nIHRpbWVvdXQiKSxUbj8oX24oIlBhdXNpbmcgZGVidWdnZXIgdG8gY2FwdHVyZSBzdGFjayB0cmFjZSIpLFRuKCkpOihfbigiQ2FwdHVyaW5nIGV2ZW50IHdpdGhvdXQgYSBzdGFjayB0cmFjZSIpLE5uKCkudGhlbihudWxsLCgoKT0+e19uKCJTZW5kaW5nIEFOUiBldmVudCBmYWlsZWQgb24gd2F0Y2hkb2cgdGltZW91dC4iKX0pKSl9KSk7ZT8ub24oIm1lc3NhZ2UiLCh0PT57dC5zZXNzaW9uJiYoZ249Vyh0LnNlc3Npb24pKSx0LmRlYnVnSW1hZ2VzJiYoYm49dC5kZWJ1Z0ltYWdlcyksQ24oKX0pKTs=';
 
 const DEFAULT_INTERVAL = 50;
 const DEFAULT_HANG_THRESHOLD = 5000;
diff --git a/build/esm/integrations/anr/worker-script.js b/build/esm/integrations/anr/worker-script.js
index 20055aff0e683afd54a390a0263775a0068264aa..2aafc7b7ecfa3988d80a3397045f83c380ff02e8 100644
--- a/build/esm/integrations/anr/worker-script.js
+++ b/build/esm/integrations/anr/worker-script.js
@@ -1,2 +1,2 @@
-/*! @sentry/node 9.12.0 (4eb78e5) | https://github.com/getsentry/sentry-javascript */
-import{Session as t}from"node:inspector";import{workerData as n,parentPort as e}from"node:worker_threads";import{posix as r,sep as o}from"node:path";import*as s from"node:http";import*as i from"node:https";import{Readable as c}from"node:stream";import{createGzip as u}from"node:zlib";import*as a from"node:net";import*as f from"node:tls";const h="undefined"==typeof __SENTRY_DEBUG__||__SENTRY_DEBUG__,p=globalThis,l="undefined"==typeof __SENTRY_DEBUG__||__SENTRY_DEBUG__,d="9.12.0";function m(){return g(p),p}function g(t){const n=t.__SENTRY__=t.__SENTRY__||{};return n.version=n.version||d,n[d]=n[d]||{}}function y(t,n,e=p){const r=e.__SENTRY__=e.__SENTRY__||{},o=r[d]=r[d]||{};return o[t]||(o[t]=n())}const b=["debug","info","warn","error","log","assert","trace"],_={};function v(t){if(!("console"in p))return t();const n=p.console,e={},r=Object.keys(_);r.forEach((t=>{const r=_[t];e[t]=n[t],n[t]=r}));try{return t()}finally{r.forEach((t=>{n[t]=e[t]}))}}const w=y("logger",(function(){let t=!1;const n={enable:()=>{t=!0},disable:()=>{t=!1},isEnabled:()=>t};return l?b.forEach((e=>{n[e]=(...n)=>{t&&v((()=>{p.console[e](`Sentry Logger [${e}]:`,...n)}))}})):b.forEach((t=>{n[t]=()=>{}})),n})),S=50,$="?",E=/captureMessage|captureException/;function x(t){return t[t.length-1]||{}}const N="<anonymous>";const T=1e3;function C(){return Date.now()/T}const R=function(){const{performance:t}=p;if(!t?.now)return C;const n=Date.now()-t.now(),e=null==t.timeOrigin?n:t.timeOrigin;return()=>(e+t.now())/T}(),k=Object.prototype.toString;function j(t,n){return k.call(t)===`[object ${n}]`}function D(t){return j(t,"String")}function I(t){return j(t,"Object")}function O(t){return Boolean(t?.then&&"function"==typeof t.then)}function A(t,n){try{return t instanceof n}catch(t){return!1}}const P=p,U=80;function M(t,n){const e=t,r=[];if(!e?.tagName)return"";if(P.HTMLElement&&e instanceof HTMLElement&&e.dataset){if(e.dataset.sentryComponent)return e.dataset.sentryComponent;if(e.dataset.sentryElement)return e.dataset.sentryElement}r.push(e.tagName.toLowerCase());const o=n?.length?n.filter((t=>e.getAttribute(t))).map((t=>[t,e.getAttribute(t)])):null;if(o?.length)o.forEach((t=>{r.push(`[${t[0]}="${t[1]}"]`)}));else{e.id&&r.push(`#${e.id}`);const t=e.className;if(t&&D(t)){const n=t.split(/\s+/);for(const t of n)r.push(`.${t}`)}}const s=["aria-label","type","name","title","alt"];for(const t of s){const n=e.getAttribute(t);n&&r.push(`[${t}="${n}"]`)}return r.join("")}function L(t,n=0){return"string"!=typeof t||0===n||t.length<=n?t:`${t.slice(0,n)}...`}function B(t){if(function(t){switch(k.call(t)){case"[object Error]":case"[object Exception]":case"[object DOMException]":case"[object WebAssembly.Exception]":return!0;default:return A(t,Error)}}(t))return{message:t.message,name:t.name,stack:t.stack,...J(t)};if(n=t,"undefined"!=typeof Event&&A(n,Event)){const n={type:t.type,target:G(t.target),currentTarget:G(t.currentTarget),...J(t)};return"undefined"!=typeof CustomEvent&&A(t,CustomEvent)&&(n.detail=t.detail),n}return t;var n}function G(t){try{return n=t,"undefined"!=typeof Element&&A(n,Element)?function(t,n={}){if(!t)return"<unknown>";try{let e=t;const r=5,o=[];let s=0,i=0;const c=" > ",u=c.length;let a;const f=Array.isArray(n)?n:n.keyAttrs,h=!Array.isArray(n)&&n.maxStringLength||U;for(;e&&s++<r&&(a=M(e,f),!("html"===a||s>1&&i+o.length*u+a.length>=h));)o.push(a),i+=a.length,e=e.parentNode;return o.reverse().join(c)}catch(t){return"<unknown>"}}(t):Object.prototype.toString.call(t)}catch(t){return"<unknown>"}var n}function J(t){if("object"==typeof t&&null!==t){const n={};for(const e in t)Object.prototype.hasOwnProperty.call(t,e)&&(n[e]=t[e]);return n}return{}}function Y(t=function(){const t=p;return t.crypto||t.msCrypto}()){let n=()=>16*Math.random();try{if(t?.randomUUID)return t.randomUUID().replace(/-/g,"");t?.getRandomValues&&(n=()=>{const n=new Uint8Array(1);return t.getRandomValues(n),n[0]})}catch(t){}return([1e7]+1e3+4e3+8e3+1e11).replace(/[018]/g,(t=>(t^(15&n())>>t/4).toString(16)))}var z;function H(t){return new F((n=>{n(t)}))}!function(t){t[t.PENDING=0]="PENDING";t[t.RESOLVED=1]="RESOLVED";t[t.REJECTED=2]="REJECTED"}(z||(z={}));class F{constructor(t){this.t=z.PENDING,this.o=[],this.i(t)}then(t,n){return new F(((e,r)=>{this.o.push([!1,n=>{if(t)try{e(t(n))}catch(t){r(t)}else e(n)},t=>{if(n)try{e(n(t))}catch(t){r(t)}else r(t)}]),this.u()}))}catch(t){return this.then((t=>t),t)}finally(t){return new F(((n,e)=>{let r,o;return this.then((n=>{o=!1,r=n,t&&t()}),(n=>{o=!0,r=n,t&&t()})).then((()=>{o?e(r):n(r)}))}))}u(){if(this.t===z.PENDING)return;const t=this.o.slice();this.o=[],t.forEach((t=>{t[0]||(this.t===z.RESOLVED&&t[1](this.h),this.t===z.REJECTED&&t[2](this.h),t[0]=!0)}))}i(t){const n=(t,n)=>{this.t===z.PENDING&&(O(n)?n.then(e,r):(this.t=t,this.h=n,this.u()))},e=t=>{n(z.RESOLVED,t)},r=t=>{n(z.REJECTED,t)};try{t(e,r)}catch(t){r(t)}}}function W(t){const n=R(),e={sid:Y(),init:!0,timestamp:n,started:n,duration:0,status:"ok",errors:0,ignoreDuration:!1,toJSON:()=>function(t){return{sid:`${t.sid}`,init:t.init,started:new Date(1e3*t.started).toISOString(),timestamp:new Date(1e3*t.timestamp).toISOString(),status:t.status,errors:t.errors,did:"number"==typeof t.did||"string"==typeof t.did?`${t.did}`:void 0,duration:t.duration,abnormal_mechanism:t.abnormal_mechanism,attrs:{release:t.release,environment:t.environment,ip_address:t.ipAddress,user_agent:t.userAgent}}}(e)};return t&&K(e,t),e}function K(t,n={}){if(n.user&&(!t.ipAddress&&n.user.ip_address&&(t.ipAddress=n.user.ip_address),t.did||n.did||(t.did=n.user.id||n.user.email||n.user.username)),t.timestamp=n.timestamp||R(),n.abnormal_mechanism&&(t.abnormal_mechanism=n.abnormal_mechanism),n.ignoreDuration&&(t.ignoreDuration=n.ignoreDuration),n.sid&&(t.sid=32===n.sid.length?n.sid:Y()),void 0!==n.init&&(t.init=n.init),!t.did&&n.did&&(t.did=`${n.did}`),"number"==typeof n.started&&(t.started=n.started),t.ignoreDuration)t.duration=void 0;else if("number"==typeof n.duration)t.duration=n.duration;else{const n=t.timestamp-t.started;t.duration=n>=0?n:0}n.release&&(t.release=n.release),n.environment&&(t.environment=n.environment),!t.ipAddress&&n.ipAddress&&(t.ipAddress=n.ipAddress),!t.userAgent&&n.userAgent&&(t.userAgent=n.userAgent),"number"==typeof n.errors&&(t.errors=n.errors),n.status&&(t.status=n.status)}function V(){return Y()}function Z(){return Y().substring(16)}function q(t,n,e=2){if(!n||"object"!=typeof n||e<=0)return n;if(t&&0===Object.keys(n).length)return t;const r={...t};for(const t in n)Object.prototype.hasOwnProperty.call(n,t)&&(r[t]=q(r[t],n[t],e-1));return r}const Q="_sentrySpan";function X(t,n){n?function(t,n,e){try{Object.defineProperty(t,n,{value:e,writable:!0,configurable:!0})}catch(e){l&&w.log(`Failed to add non-enumerable property "${n}" to object`,t)}}(t,Q,n):delete t[Q]}function tt(t){return t[Q]}class nt{constructor(){this.p=!1,this.l=[],this.m=[],this._=[],this.v=[],this.S={},this.N={},this.T={},this.C={},this.R={},this.k={traceId:V(),sampleRand:Math.random()}}clone(){const t=new nt;return t._=[...this._],t.N={...this.N},t.T={...this.T},t.C={...this.C},this.C.flags&&(t.C.flags={values:[...this.C.flags.values]}),t.S=this.S,t.j=this.j,t.D=this.D,t.I=this.I,t.O=this.O,t.m=[...this.m],t.v=[...this.v],t.R={...this.R},t.k={...this.k},t.A=this.A,t.P=this.P,X(t,tt(this)),t}setClient(t){this.A=t}setLastEventId(t){this.P=t}getClient(){return this.A}lastEventId(){return this.P}addScopeListener(t){this.l.push(t)}addEventProcessor(t){return this.m.push(t),this}setUser(t){return this.S=t||{email:void 0,id:void 0,ip_address:void 0,username:void 0},this.D&&K(this.D,{user:t}),this.U(),this}getUser(){return this.S}setTags(t){return this.N={...this.N,...t},this.U(),this}setTag(t,n){return this.N={...this.N,[t]:n},this.U(),this}setExtras(t){return this.T={...this.T,...t},this.U(),this}setExtra(t,n){return this.T={...this.T,[t]:n},this.U(),this}setFingerprint(t){return this.O=t,this.U(),this}setLevel(t){return this.j=t,this.U(),this}setTransactionName(t){return this.I=t,this.U(),this}setContext(t,n){return null===n?delete this.C[t]:this.C[t]=n,this.U(),this}setSession(t){return t?this.D=t:delete this.D,this.U(),this}getSession(){return this.D}update(t){if(!t)return this;const n="function"==typeof t?t(this):t,e=n instanceof nt?n.getScopeData():I(n)?t:void 0,{tags:r,extra:o,user:s,contexts:i,level:c,fingerprint:u=[],propagationContext:a}=e||{};return this.N={...this.N,...r},this.T={...this.T,...o},this.C={...this.C,...i},s&&Object.keys(s).length&&(this.S=s),c&&(this.j=c),u.length&&(this.O=u),a&&(this.k=a),this}clear(){return this._=[],this.N={},this.T={},this.S={},this.C={},this.j=void 0,this.I=void 0,this.O=void 0,this.D=void 0,X(this,void 0),this.v=[],this.setPropagationContext({traceId:V(),sampleRand:Math.random()}),this.U(),this}addBreadcrumb(t,n){const e="number"==typeof n?n:100;if(e<=0)return this;const r={timestamp:C(),...t,message:t.message?L(t.message,2048):t.message};return this._.push(r),this._.length>e&&(this._=this._.slice(-e),this.A?.recordDroppedEvent("buffer_overflow","log_item")),this.U(),this}getLastBreadcrumb(){return this._[this._.length-1]}clearBreadcrumbs(){return this._=[],this.U(),this}addAttachment(t){return this.v.push(t),this}clearAttachments(){return this.v=[],this}getScopeData(){return{breadcrumbs:this._,attachments:this.v,contexts:this.C,tags:this.N,extra:this.T,user:this.S,level:this.j,fingerprint:this.O||[],eventProcessors:this.m,propagationContext:this.k,sdkProcessingMetadata:this.R,transactionName:this.I,span:tt(this)}}setSDKProcessingMetadata(t){return this.R=q(this.R,t,2),this}setPropagationContext(t){return this.k=t,this}getPropagationContext(){return this.k}captureException(t,n){const e=n?.event_id||Y();if(!this.A)return w.warn("No client configured on scope - will not capture exception!"),e;const r=new Error("Sentry syntheticException");return this.A.captureException(t,{originalException:t,syntheticException:r,...n,event_id:e},this),e}captureMessage(t,n,e){const r=e?.event_id||Y();if(!this.A)return w.warn("No client configured on scope - will not capture message!"),r;const o=new Error(t);return this.A.captureMessage(t,n,{originalException:t,syntheticException:o,...e,event_id:r},this),r}captureEvent(t,n){const e=n?.event_id||Y();return this.A?(this.A.captureEvent(t,{...n,event_id:e},this),e):(w.warn("No client configured on scope - will not capture event!"),e)}U(){this.p||(this.p=!0,this.l.forEach((t=>{t(this)})),this.p=!1)}}class et{constructor(t,n){let e,r;e=t||new nt,r=n||new nt,this.M=[{scope:e}],this.L=r}withScope(t){const n=this.B();let e;try{e=t(n)}catch(t){throw this.G(),t}return O(e)?e.then((t=>(this.G(),t)),(t=>{throw this.G(),t})):(this.G(),e)}getClient(){return this.getStackTop().client}getScope(){return this.getStackTop().scope}getIsolationScope(){return this.L}getStackTop(){return this.M[this.M.length-1]}B(){const t=this.getScope().clone();return this.M.push({client:this.getClient(),scope:t}),t}G(){return!(this.M.length<=1)&&!!this.M.pop()}}function rt(){const t=g(m());return t.stack=t.stack||new et(y("defaultCurrentScope",(()=>new nt)),y("defaultIsolationScope",(()=>new nt)))}function ot(t){return rt().withScope(t)}function st(t,n){const e=rt();return e.withScope((()=>(e.getStackTop().scope=t,n(t))))}function it(t){return rt().withScope((()=>t(rt().getIsolationScope())))}function ct(t){const n=g(t);return n.acs?n.acs:{withIsolationScope:it,withScope:ot,withSetScope:st,withSetIsolationScope:(t,n)=>it(n),getCurrentScope:()=>rt().getScope(),getIsolationScope:()=>rt().getIsolationScope()}}function ut(){return ct(m()).getCurrentScope().getClient()}const at="sentry.source",ft="sentry.sample_rate",ht="sentry.op",pt="sentry.origin",lt=0,dt=1,mt="_sentryScope",gt="_sentryIsolationScope";function yt(t){return{scope:t[mt],isolationScope:t[gt]}}const bt="sentry-",_t=/^sentry-/;function vt(t){const n=function(t){if(!t||!D(t)&&!Array.isArray(t))return;if(Array.isArray(t))return t.reduce(((t,n)=>{const e=wt(n);return Object.entries(e).forEach((([n,e])=>{t[n]=e})),t}),{});return wt(t)}(t);if(!n)return;const e=Object.entries(n).reduce(((t,[n,e])=>{if(n.match(_t)){t[n.slice(bt.length)]=e}return t}),{});return Object.keys(e).length>0?e:void 0}function wt(t){return t.split(",").map((t=>t.split("=").map((t=>decodeURIComponent(t.trim()))))).reduce(((t,[n,e])=>(n&&e&&(t[n]=e),t)),{})}const St=1;function $t(t){const{spanId:n,traceId:e,isRemote:r}=t.spanContext(),o=r?n:Tt(t).parent_span_id,s=yt(t).scope;return{parent_span_id:o,span_id:r?s?.getPropagationContext().propagationSpanId||Z():n,trace_id:e}}function Et(t){return t&&t.length>0?t.map((({context:{spanId:t,traceId:n,traceFlags:e,...r},attributes:o})=>({span_id:t,trace_id:n,sampled:e===St,attributes:o,...r}))):void 0}function xt(t){return"number"==typeof t?Nt(t):Array.isArray(t)?t[0]+t[1]/1e9:t instanceof Date?Nt(t.getTime()):R()}function Nt(t){return t>9999999999?t/1e3:t}function Tt(t){if(function(t){return"function"==typeof t.getSpanJSON}(t))return t.getSpanJSON();const{spanId:n,traceId:e}=t.spanContext();if(function(t){const n=t;return!!(n.attributes&&n.startTime&&n.name&&n.endTime&&n.status)}(t)){const{attributes:r,startTime:o,name:s,endTime:i,parentSpanId:c,status:u,links:a}=t;return{span_id:n,trace_id:e,data:r,description:s,parent_span_id:c,start_timestamp:xt(o),timestamp:xt(i)||void 0,status:Ct(u),op:r[ht],origin:r[pt],links:Et(a)}}return{span_id:n,trace_id:e,start_timestamp:0,data:{}}}function Ct(t){if(t&&t.code!==lt)return t.code===dt?"ok":t.message||"unknown_error"}const Rt="_sentryRootSpan";function kt(t){return t[Rt]||t}const jt="production",Dt="_frozenDsc";function It(t){const n=ut();if(!n)return{};const e=kt(t),r=Tt(e),o=r.data,s=e.spanContext().traceState,i=s?.get("sentry.sample_rate")??o[ft];function c(t){return"number"!=typeof i&&"string"!=typeof i||(t.sample_rate=`${i}`),t}const u=e[Dt];if(u)return c(u);const a=s?.get("sentry.dsc"),f=a&&vt(a);if(f)return c(f);const h=function(t,n){const e=n.getOptions(),{publicKey:r}=n.getDsn()||{},o={environment:e.environment||jt,release:e.release,public_key:r,trace_id:t};return n.emit("createDsc",o),o}(t.spanContext().traceId,n),p=o[at],l=r.description;return"url"!==p&&l&&(h.transaction=l),function(t){if("boolean"==typeof __SENTRY_TRACING__&&!__SENTRY_TRACING__)return!1;const n=t||ut()?.getOptions();return!(!n||null==n.tracesSampleRate&&!n.tracesSampler)}()&&(h.sampled=String(function(t){const{traceFlags:n}=t.spanContext();return n===St}(e)),h.sample_rand=s?.get("sentry.sample_rand")??yt(e).scope?.getPropagationContext().sampleRand.toString()),c(h),n.emit("createDsc",h,e),h}function Ot(t,n=!1){const{host:e,path:r,pass:o,port:s,projectId:i,protocol:c,publicKey:u}=t;return`${c}://${u}${n&&o?`:${o}`:""}@${e}${s?`:${s}`:""}/${r?`${r}/`:r}${i}`}function At(t,n=100,e=1/0){try{return Pt("",t,n,e)}catch(t){return{ERROR:`**non-serializable** (${t})`}}}function Pt(t,n,e=1/0,r=1/0,o=function(){const t=new WeakSet;function n(n){return!!t.has(n)||(t.add(n),!1)}function e(n){t.delete(n)}return[n,e]}()){const[s,i]=o;if(null==n||["boolean","string"].includes(typeof n)||"number"==typeof n&&Number.isFinite(n))return n;const c=function(t,n){try{if("domain"===t&&n&&"object"==typeof n&&n.J)return"[Domain]";if("domainEmitter"===t)return"[DomainEmitter]";if("undefined"!=typeof global&&n===global)return"[Global]";if("undefined"!=typeof window&&n===window)return"[Window]";if("undefined"!=typeof document&&n===document)return"[Document]";if("object"==typeof(e=n)&&null!==e&&(e.__isVue||e.Y))return"[VueViewModel]";if(function(t){return I(t)&&"nativeEvent"in t&&"preventDefault"in t&&"stopPropagation"in t}(n))return"[SyntheticEvent]";if("number"==typeof n&&!Number.isFinite(n))return`[${n}]`;if("function"==typeof n)return`[Function: ${function(t){try{return t&&"function"==typeof t&&t.name||N}catch(t){return N}}(n)}]`;if("symbol"==typeof n)return`[${String(n)}]`;if("bigint"==typeof n)return`[BigInt: ${String(n)}]`;const r=function(t){const n=Object.getPrototypeOf(t);return n?.constructor?n.constructor.name:"null prototype"}(n);return/^HTML(\w*)Element$/.test(r)?`[HTMLElement: ${r}]`:`[object ${r}]`}catch(t){return`**non-serializable** (${t})`}var e}(t,n);if(!c.startsWith("[object "))return c;if(n.__sentry_skip_normalization__)return n;const u="number"==typeof n.__sentry_override_normalization_depth__?n.__sentry_override_normalization_depth__:e;if(0===u)return c.replace("object ","");if(s(n))return"[Circular ~]";const a=n;if(a&&"function"==typeof a.toJSON)try{return Pt("",a.toJSON(),u-1,r,o)}catch(t){}const f=Array.isArray(n)?[]:{};let h=0;const p=B(n);for(const t in p){if(!Object.prototype.hasOwnProperty.call(p,t))continue;if(h>=r){f[t]="[MaxProperties ~]";break}const n=p[t];f[t]=Pt(t,n,u-1,r,o),h++}return i(n),f}function Ut(t,n){const e=n.replace(/\\/g,"/").replace(/[|\\{}()[\]^$+*?.]/g,"\\$&");let r=t;try{r=decodeURI(t)}catch(t){}return r.replace(/\\/g,"/").replace(/webpack:\/?/g,"").replace(new RegExp(`(file://)?/*${e}/*`,"ig"),"app:///")}function Mt(t,n=[]){return[t,n]}function Lt(t,n){const e=t[1];for(const t of e){if(n(t,t[0].type))return!0}return!1}function Bt(t){const n=g(p);return n.encodePolyfill?n.encodePolyfill(t):(new TextEncoder).encode(t)}function Gt(t){const[n,e]=t;let r=JSON.stringify(n);function o(t){"string"==typeof r?r="string"==typeof t?r+t:[Bt(r),t]:r.push("string"==typeof t?Bt(t):t)}for(const t of e){const[n,e]=t;if(o(`\n${JSON.stringify(n)}\n`),"string"==typeof e||e instanceof Uint8Array)o(e);else{let t;try{t=JSON.stringify(e)}catch(n){t=JSON.stringify(At(e))}o(t)}}return"string"==typeof r?r:function(t){const n=t.reduce(((t,n)=>t+n.length),0),e=new Uint8Array(n);let r=0;for(const n of t)e.set(n,r),r+=n.length;return e}(r)}const Jt={session:"session",sessions:"session",attachment:"attachment",transaction:"transaction",event:"error",client_report:"internal",user_report:"default",profile:"profile",profile_chunk:"profile",replay_event:"replay",replay_recording:"replay",check_in:"monitor",feedback:"feedback",span:"span",raw_security:"security",otel_log:"log_item"};function Yt(t){if(!t?.sdk)return;const{name:n,version:e}=t.sdk;return{name:n,version:e}}function zt(t,n,e,r){const o=Yt(e),s=t.type&&"replay_event"!==t.type?t.type:"event";!function(t,n){n&&(t.sdk=t.sdk||{},t.sdk.name=t.sdk.name||n.name,t.sdk.version=t.sdk.version||n.version,t.sdk.integrations=[...t.sdk.integrations||[],...n.integrations||[]],t.sdk.packages=[...t.sdk.packages||[],...n.packages||[]])}(t,e?.sdk);const i=function(t,n,e,r){const o=t.sdkProcessingMetadata?.dynamicSamplingContext;return{event_id:t.event_id,sent_at:(new Date).toISOString(),...n&&{sdk:n},...!!e&&r&&{dsn:Ot(r)},...o&&{trace:o}}}(t,o,r,n);delete t.sdkProcessingMetadata;return Mt(i,[[{type:s},t]])}const Ht="__SENTRY_SUPPRESS_TRACING__";function Ft(t){const n=ct(m());return n.suppressTracing?n.suppressTracing(t):function(...t){const n=ct(m());if(2===t.length){const[e,r]=t;return e?n.withSetScope(e,r):n.withScope(r)}return n.withScope(t[0])}((n=>(n.setSDKProcessingMetadata({[Ht]:!0}),t())))}function Wt(t,n){const{fingerprint:e,span:r,breadcrumbs:o,sdkProcessingMetadata:s}=n;!function(t,n){const{extra:e,tags:r,user:o,contexts:s,level:i,transactionName:c}=n;Object.keys(e).length&&(t.extra={...e,...t.extra});Object.keys(r).length&&(t.tags={...r,...t.tags});Object.keys(o).length&&(t.user={...o,...t.user});Object.keys(s).length&&(t.contexts={...s,...t.contexts});i&&(t.level=i);c&&"transaction"!==t.type&&(t.transaction=c)}(t,n),r&&function(t,n){t.contexts={trace:$t(n),...t.contexts},t.sdkProcessingMetadata={dynamicSamplingContext:It(n),...t.sdkProcessingMetadata};const e=kt(n),r=Tt(e).description;r&&!t.transaction&&"transaction"===t.type&&(t.transaction=r)}(t,r),function(t,n){t.fingerprint=t.fingerprint?Array.isArray(t.fingerprint)?t.fingerprint:[t.fingerprint]:[],n&&(t.fingerprint=t.fingerprint.concat(n));t.fingerprint.length||delete t.fingerprint}(t,e),function(t,n){const e=[...t.breadcrumbs||[],...n];t.breadcrumbs=e.length?e:void 0}(t,o),function(t,n){t.sdkProcessingMetadata={...t.sdkProcessingMetadata,...n}}(t,s)}const Kt="7";const Vt=Symbol.for("SentryBufferFullError");function Zt(t){const n=[];function e(t){return n.splice(n.indexOf(t),1)[0]||Promise.resolve(void 0)}return{$:n,add:function(r){if(!(void 0===t||n.length<t))return o=Vt,new F(((t,n)=>{n(o)}));var o;const s=r();return-1===n.indexOf(s)&&n.push(s),s.then((()=>e(s))).then(null,(()=>e(s).then(null,(()=>{})))),s},drain:function(t){return new F(((e,r)=>{let o=n.length;if(!o)return e(!0);const s=setTimeout((()=>{t&&t>0&&e(!1)}),t);n.forEach((t=>{H(t).then((()=>{--o||(clearTimeout(s),e(!0))}),r)}))}))}}}const qt=6e4;function Qt(t,{statusCode:n,headers:e},r=Date.now()){const o={...t},s=e?.["x-sentry-rate-limits"],i=e?.["retry-after"];if(s)for(const t of s.trim().split(",")){const[n,e,,,s]=t.split(":",5),i=parseInt(n,10),c=1e3*(isNaN(i)?60:i);if(e)for(const t of e.split(";"))"metric_bucket"===t&&s&&!s.split(";").includes("custom")||(o[t]=r+c);else o.all=r+c}else i?o.all=r+function(t,n=Date.now()){const e=parseInt(`${t}`,10);if(!isNaN(e))return 1e3*e;const r=Date.parse(`${t}`);return isNaN(r)?qt:r-n}(i,r):429===n&&(o.all=r+6e4);return o}const Xt=64;function tn(t,n,e=Zt(t.bufferSize||Xt)){let r={};return{send:function(t){const o=[];if(Lt(t,((t,n)=>{const e=function(t){return Jt[t]}(n);(function(t,n,e=Date.now()){return function(t,n){return t[n]||t.all||0}(t,n)>e})(r,e)||o.push(t)})),0===o.length)return H({});const s=Mt(t[0],o),i=t=>{Lt(s,((t,n)=>{}))};return e.add((()=>n({body:Gt(s)}).then((t=>(void 0!==t.statusCode&&(t.statusCode<200||t.statusCode>=300)&&h&&w.warn(`Sentry responded with status code ${t.statusCode} to sent event.`),r=Qt(r,t),t)),(t=>{throw i(),h&&w.error("Encountered error running transport request:",t),t})))).then((t=>t),(t=>{if(t===Vt)return h&&w.error("Skipped sending event because buffer is full."),i(),H({});throw t}))},flush:t=>e.drain(t)}}const nn=/^(\S+:\\|\/?)([\s\S]*?)((?:\.{1,2}|[^/\\]+?|)(\.[^./\\]*|))(?:[/\\]*)$/;function en(t){const n=function(t){const n=t.length>1024?`<truncated>${t.slice(-1024)}`:t,e=nn.exec(n);return e?e.slice(1):[]}(t),e=n[0]||"";let r=n[1];return e||r?(r&&(r=r.slice(0,r.length-1)),e+r):"."}function rn(t,n=!1){return!(n||t&&!t.startsWith("/")&&!t.match(/^[A-Z]:/)&&!t.startsWith(".")&&!t.match(/^[a-zA-Z]([a-zA-Z0-9.\-+])*:\/\//))&&void 0!==t&&!t.includes("node_modules/")}const on=Symbol("AgentBaseInternalState");class sn extends s.Agent{constructor(t){super(t),this[on]={}}isSecureEndpoint(t){if(t){if("boolean"==typeof t.secureEndpoint)return t.secureEndpoint;if("string"==typeof t.protocol)return"https:"===t.protocol}const{stack:n}=new Error;return"string"==typeof n&&n.split("\n").some((t=>-1!==t.indexOf("(https.js:")||-1!==t.indexOf("node:https:")))}createSocket(t,n,e){const r={...n,secureEndpoint:this.isSecureEndpoint(n)};Promise.resolve().then((()=>this.connect(t,r))).then((o=>{if(o instanceof s.Agent)return o.addRequest(t,r);this[on].currentSocket=o,super.createSocket(t,n,e)}),e)}createConnection(){const t=this[on].currentSocket;if(this[on].currentSocket=void 0,!t)throw new Error("No socket was returned in the `connect()` function");return t}get defaultPort(){return this[on].defaultPort??("https:"===this.protocol?443:80)}set defaultPort(t){this[on]&&(this[on].defaultPort=t)}get protocol(){return this[on].protocol??(this.isSecureEndpoint()?"https:":"http:")}set protocol(t){this[on]&&(this[on].protocol=t)}}function cn(...t){w.log("[https-proxy-agent:parse-proxy-response]",...t)}function un(t){return new Promise(((n,e)=>{let r=0;const o=[];function s(){const c=t.read();c?function(c){o.push(c),r+=c.length;const u=Buffer.concat(o,r),a=u.indexOf("\r\n\r\n");if(-1===a)return cn("have not received end of HTTP headers yet..."),void s();const f=u.subarray(0,a).toString("ascii").split("\r\n"),h=f.shift();if(!h)return t.destroy(),e(new Error("No header received from proxy CONNECT response"));const p=h.split(" "),l=+(p[1]||0),d=p.slice(2).join(" "),m={};for(const n of f){if(!n)continue;const r=n.indexOf(":");if(-1===r)return t.destroy(),e(new Error(`Invalid header from proxy CONNECT response: "${n}"`));const o=n.slice(0,r).toLowerCase(),s=n.slice(r+1).trimStart(),i=m[o];"string"==typeof i?m[o]=[i,s]:Array.isArray(i)?i.push(s):m[o]=s}cn("got proxy server response: %o %o",h,m),i(),n({connect:{statusCode:l,statusText:d,headers:m},buffered:u})}(c):t.once("readable",s)}function i(){t.removeListener("end",c),t.removeListener("error",u),t.removeListener("readable",s)}function c(){i(),cn("onend"),e(new Error("Proxy connection ended before receiving CONNECT response"))}function u(t){i(),cn("onerror %o",t),e(t)}t.on("error",u),t.on("end",c),s()}))}function an(...t){w.log("[https-proxy-agent]",...t)}class fn extends sn{static __initStatic(){this.protocols=["http","https"]}constructor(t,n){super(n),this.options={},this.proxy="string"==typeof t?new URL(t):t,this.proxyHeaders=n?.headers??{},an("Creating new HttpsProxyAgent instance: %o",this.proxy.href);const e=(this.proxy.hostname||this.proxy.host).replace(/^\[|\]$/g,""),r=this.proxy.port?parseInt(this.proxy.port,10):"https:"===this.proxy.protocol?443:80;this.connectOpts={ALPNProtocols:["http/1.1"],...n?pn(n,"headers"):null,host:e,port:r}}async connect(t,n){const{proxy:e}=this;if(!n.host)throw new TypeError('No "host" provided');let r;if("https:"===e.protocol){an("Creating `tls.Socket`: %o",this.connectOpts);const t=this.connectOpts.servername||this.connectOpts.host;r=f.connect({...this.connectOpts,servername:t&&a.isIP(t)?void 0:t})}else an("Creating `net.Socket`: %o",this.connectOpts),r=a.connect(this.connectOpts);const o="function"==typeof this.proxyHeaders?this.proxyHeaders():{...this.proxyHeaders},s=a.isIPv6(n.host)?`[${n.host}]`:n.host;let i=`CONNECT ${s}:${n.port} HTTP/1.1\r\n`;if(e.username||e.password){const t=`${decodeURIComponent(e.username)}:${decodeURIComponent(e.password)}`;o["Proxy-Authorization"]=`Basic ${Buffer.from(t).toString("base64")}`}o.Host=`${s}:${n.port}`,o["Proxy-Connection"]||(o["Proxy-Connection"]=this.keepAlive?"Keep-Alive":"close");for(const t of Object.keys(o))i+=`${t}: ${o[t]}\r\n`;const c=un(r);r.write(`${i}\r\n`);const{connect:u,buffered:h}=await c;if(t.emit("proxyConnect",u),this.emit("proxyConnect",u,t),200===u.statusCode){if(t.once("socket",hn),n.secureEndpoint){an("Upgrading socket connection to TLS");const t=n.servername||n.host;return f.connect({...pn(n,"host","path","port"),socket:r,servername:a.isIP(t)?void 0:t})}return r}r.destroy();const p=new a.Socket({writable:!1});return p.readable=!0,t.once("socket",(t=>{an("Replaying proxy buffer for failed request"),t.push(h),t.push(null)})),p}}function hn(t){t.resume()}function pn(t,...n){const e={};let r;for(r in t)n.includes(r)||(e[r]=t[r]);return e}fn.__initStatic();const ln=32768;function dn(t){return t.replace(/^[A-Z]:/,"").replace(/\\/g,"/")}const mn=n;let gn,yn=0,bn={};function _n(t){mn.debug&&console.log(`[ANR Worker] ${t}`)}var vn,wn,Sn;const $n=function(t){let n;try{n=new URL(t.url)}catch(n){return v((()=>{console.warn("[@sentry/node]: Invalid dsn or tunnel option, will not send any events. The tunnel option must be a full URL when used.")})),tn(t,(()=>Promise.resolve({})))}const e="https:"===n.protocol,r=function(t,n){const{no_proxy:e}=process.env,r=e?.split(",").some((n=>t.host.endsWith(n)||t.hostname.endsWith(n)));return r?void 0:n}(n,t.proxy||(e?process.env.https_proxy:void 0)||process.env.http_proxy),o=e?i:s,a=void 0!==t.keepAlive&&t.keepAlive,f=r?new fn(r):new o.Agent({keepAlive:a,maxSockets:30,timeout:2e3}),h=function(t,n,e){const{hostname:r,pathname:o,port:s,protocol:i,search:a}=new URL(t.url);return function(f){return new Promise(((h,p)=>{Ft((()=>{let l=function(t){return new c({read(){this.push(t),this.push(null)}})}(f.body);const d={...t.headers};f.body.length>ln&&(d["content-encoding"]="gzip",l=l.pipe(u()));const m=n.request({method:"POST",agent:e,headers:d,hostname:r,path:`${o}${a}`,port:s,protocol:i,ca:t.caCerts},(t=>{t.on("data",(()=>{})),t.on("end",(()=>{})),t.setEncoding("utf8");const n=t.headers["retry-after"]??null,e=t.headers["x-sentry-rate-limits"]??null;h({statusCode:t.statusCode,headers:{"retry-after":n,"x-sentry-rate-limits":Array.isArray(e)?e[0]||null:e}})}));m.on("error",p),l.pipe(m)}))}))}}(t,t.httpModule??o,f);return tn(t,h)}({url:(vn=mn.dsn,wn=mn.tunnel,Sn=mn.sdkMetadata.sdk,wn||`${function(t){return`${function(t){const n=t.protocol?`${t.protocol}:`:"",e=t.port?`:${t.port}`:"";return`${n}//${t.host}${e}${t.path?`/${t.path}`:""}/api/`}(t)}${t.projectId}/envelope/`}(vn)}?${function(t,n){const e={sentry_version:Kt};return t.publicKey&&(e.sentry_key=t.publicKey),n&&(e.sentry_client=`${n.name}/${n.version}`),new URLSearchParams(e).toString()}(vn,Sn)}`)});async function En(){if(gn){_n("Sending abnormal session"),K(gn,{status:"abnormal",abnormal_mechanism:"anr_foreground",release:mn.release,environment:mn.environment});const t=function(t,n,e,r){const o=Yt(e);return Mt({sent_at:(new Date).toISOString(),...o&&{sdk:o},...!!r&&n&&{dsn:Ot(n)}},["aggregates"in t?[{type:"sessions"},t]:[{type:"session"},t.toJSON()]])}(gn,mn.dsn,mn.sdkMetadata,mn.tunnel);_n(JSON.stringify(t)),await $n.send(t);try{e?.postMessage("session-ended")}catch(t){}}}function xn(t){if(!t)return;const n=function(t){if(!t.length)return[];const n=Array.from(t);return/sentryWrapped/.test(x(n).function||"")&&n.pop(),n.reverse(),E.test(x(n).function||"")&&(n.pop(),E.test(x(n).function||"")&&n.pop()),n.slice(0,S).map((t=>({...t,filename:t.filename||x(n).filename,function:t.function||$})))}(t);if(mn.appRootPath)for(const t of n)t.filename&&(t.filename=Ut(t.filename,mn.appRootPath));return n}async function Nn(t,n){if(yn>=mn.maxAnrEvents)return;yn+=1,await En(),_n("Sending event");const e={event_id:Y(),contexts:mn.contexts,release:mn.release,environment:mn.environment,dist:mn.dist,platform:"node",level:"error",exception:{values:[{type:"ApplicationNotResponding",value:`Application Not Responding for at least ${mn.anrThreshold} ms`,stacktrace:{frames:xn(t)},mechanism:{type:"ANR"}}]},tags:mn.staticTags};n&&function(t,n){if(Wt(t,n),!t.contexts?.trace){const{traceId:e,parentSpanId:r,propagationSpanId:o}=n.propagationContext;t.contexts={trace:{trace_id:e,span_id:o||Z(),parent_span_id:r},...t.contexts}}}(e,n),function(t){if(0===Object.keys(bn).length)return;const n=mn.appRootPath?{}:bn;if(mn.appRootPath)for(const[t,e]of Object.entries(bn))n[Ut(t,mn.appRootPath)]=e;const e=new Map;for(const r of t.exception?.values||[])for(const t of r.stacktrace?.frames||[]){const r=t.abs_path||t.filename;r&&n[r]&&e.set(r,n[r])}if(e.size>0){const n=[];for(const[t,r]of e.entries())n.push({type:"sourcemap",code_file:t,debug_id:r});t.debug_meta={images:n}}}(e);const r=zt(e,mn.dsn,mn.sdkMetadata,mn.tunnel);_n(JSON.stringify(r)),await $n.send(r),await $n.flush(2e3),yn>=mn.maxAnrEvents&&setTimeout((()=>{process.exit(0)}),5e3)}let Tn;if(_n("Started"),mn.captureStackTrace){_n("Connecting to debugger");const n=new t;n.connectToMainThread(),_n("Connected to debugger");const e=new Map;n.on("Debugger.scriptParsed",(t=>{e.set(t.params.scriptId,t.params.url)})),n.on("Debugger.paused",(t=>{if("other"===t.params.reason)try{_n("Debugger paused");const s=[...t.params.callFrames],i=mn.appRootPath?function(t=(process.argv[1]?en(process.argv[1]):process.cwd()),n="\\"===o){const e=n?dn(t):t;return t=>{if(!t)return;const o=n?dn(t):t;let{dir:s,base:i,ext:c}=r.parse(o);".js"!==c&&".mjs"!==c&&".cjs"!==c||(i=i.slice(0,-1*c.length));const u=decodeURIComponent(i);s||(s=".");const a=s.lastIndexOf("/node_modules");if(a>-1)return`${s.slice(a+14).replace(/\//g,".")}:${u}`;if(s.startsWith(e)){const t=s.slice(e.length+1).replace(/\//g,".");return t?`${t}:${u}`:u}return u}}(mn.appRootPath):()=>{},c=s.map((t=>function(t,n,e){const r=n?n.replace(/^file:\/\//,""):void 0,o=t.location.columnNumber?t.location.columnNumber+1:void 0,s=t.location.lineNumber?t.location.lineNumber+1:void 0;return{filename:r,module:e(r),function:t.functionName||$,colno:o,lineno:s,in_app:r?rn(r):void 0}}(t,e.get(t.location.scriptId),i))),u=setTimeout((()=>{Nn(c).then(null,(()=>{_n("Sending ANR event failed.")}))}),5e3);n.post("Runtime.evaluate",{expression:"global.__SENTRY_GET_SCOPES__();",silent:!0,returnByValue:!0},((t,e)=>{t&&_n(`Error executing script: '${t.message}'`),clearTimeout(u);const r=e?.result?e.result.value:void 0;n.post("Debugger.resume"),n.post("Debugger.disable"),Nn(c,r).then(null,(()=>{_n("Sending ANR event failed.")}))}))}catch(t){throw n.post("Debugger.resume"),n.post("Debugger.disable"),t}})),Tn=()=>{try{n.post("Debugger.enable",(()=>{n.post("Debugger.pause")}))}catch(t){}}}const{poll:Cn}=function(t,n,e,r){const o=t();let s=!1,i=!0;return setInterval((()=>{const t=o.getTimeMs();!1===s&&t>n+e&&(s=!0,i&&r()),t<n+e&&(s=!1)}),20),{poll:()=>{o.reset()},enabled:t=>{i=t}}}((function(){let t=process.hrtime();return{getTimeMs:()=>{const[n,e]=process.hrtime(t);return Math.floor(1e3*n+e/1e6)},reset:()=>{t=process.hrtime()}}}),mn.pollInterval,mn.anrThreshold,(function(){_n("Watchdog timeout"),Tn?(_n("Pausing debugger to capture stack trace"),Tn()):(_n("Capturing event without a stack trace"),Nn().then(null,(()=>{_n("Sending ANR event failed on watchdog timeout.")})))}));e?.on("message",(t=>{t.session&&(gn=W(t.session)),t.debugImages&&(bn=t.debugImages),Cn()}));
+/*! @sentry/node 9.12.0 (2cf5322d9) | https://github.com/getsentry/sentry-javascript */
+import{Session as t}from"node:inspector";import{workerData as n,parentPort as e}from"node:worker_threads";import{posix as r,sep as o}from"node:path";import*as s from"node:http";import*as i from"node:https";import{Readable as c}from"node:stream";import{createGzip as u}from"node:zlib";import*as a from"node:net";import*as f from"node:tls";const h="undefined"==typeof __SENTRY_DEBUG__||__SENTRY_DEBUG__,p=globalThis,l="undefined"==typeof __SENTRY_DEBUG__||__SENTRY_DEBUG__,d="9.12.0";function m(){return g(p),p}function g(t){const n=t.__SENTRY__=t.__SENTRY__||{};return n.version=n.version||d,n[d]=n[d]||{}}function y(t,n,e=p){const r=e.__SENTRY__=e.__SENTRY__||{},o=r[d]=r[d]||{};return o[t]||(o[t]=n())}const b=["debug","info","warn","error","log","assert","trace"],_={};function v(t){if(!("console"in p))return t();const n=p.console,e={},r=Object.keys(_);r.forEach((t=>{const r=_[t];e[t]=n[t],n[t]=r}));try{return t()}finally{r.forEach((t=>{n[t]=e[t]}))}}const w=y("logger",(function(){let t=!1;const n={enable:()=>{t=!0},disable:()=>{t=!1},isEnabled:()=>t};return l?b.forEach((e=>{n[e]=(...n)=>{t&&v((()=>{p.console[e](`Sentry Logger [${e}]:`,...n)}))}})):b.forEach((t=>{n[t]=()=>{}})),n})),S=50,$="?",E=/captureMessage|captureException/;function x(t){return t[t.length-1]||{}}const N="<anonymous>";const T=1e3;function C(){return Date.now()/T}const R=function(){const{performance:t}=p;if(!t?.now)return C;const n=Date.now()-t.now(),e=null==t.timeOrigin?n:t.timeOrigin;return()=>(e+t.now())/T}(),k=Object.prototype.toString;function j(t,n){return k.call(t)===`[object ${n}]`}function D(t){return j(t,"String")}function I(t){return j(t,"Object")}function O(t){return Boolean(t?.then&&"function"==typeof t.then)}function A(t,n){try{return t instanceof n}catch(t){return!1}}const P=p,U=80;function M(t,n){const e=t,r=[];if(!e?.tagName)return"";if(P.HTMLElement&&e instanceof HTMLElement&&e.dataset){if(e.dataset.sentryComponent)return e.dataset.sentryComponent;if(e.dataset.sentryElement)return e.dataset.sentryElement}r.push(e.tagName.toLowerCase());const o=n?.length?n.filter((t=>e.getAttribute(t))).map((t=>[t,e.getAttribute(t)])):null;if(o?.length)o.forEach((t=>{r.push(`[${t[0]}="${t[1]}"]`)}));else{e.id&&r.push(`#${e.id}`);const t=e.className;if(t&&D(t)){const n=t.split(/\s+/);for(const t of n)r.push(`.${t}`)}}const s=["aria-label","type","name","title","alt"];for(const t of s){const n=e.getAttribute(t);n&&r.push(`[${t}="${n}"]`)}return r.join("")}function L(t,n=0){return"string"!=typeof t||0===n||t.length<=n?t:`${t.slice(0,n)}...`}function B(t){if(function(t){switch(k.call(t)){case"[object Error]":case"[object Exception]":case"[object DOMException]":case"[object WebAssembly.Exception]":return!0;default:return A(t,Error)}}(t))return{message:t.message,name:t.name,stack:t.stack,...J(t)};if(n=t,"undefined"!=typeof Event&&A(n,Event)){const n={type:t.type,target:G(t.target),currentTarget:G(t.currentTarget),...J(t)};return"undefined"!=typeof CustomEvent&&A(t,CustomEvent)&&(n.detail=t.detail),n}return t;var n}function G(t){try{return n=t,"undefined"!=typeof Element&&A(n,Element)?function(t,n={}){if(!t)return"<unknown>";try{let e=t;const r=5,o=[];let s=0,i=0;const c=" > ",u=c.length;let a;const f=Array.isArray(n)?n:n.keyAttrs,h=!Array.isArray(n)&&n.maxStringLength||U;for(;e&&s++<r&&(a=M(e,f),!("html"===a||s>1&&i+o.length*u+a.length>=h));)o.push(a),i+=a.length,e=e.parentNode;return o.reverse().join(c)}catch(t){return"<unknown>"}}(t):Object.prototype.toString.call(t)}catch(t){return"<unknown>"}var n}function J(t){if("object"==typeof t&&null!==t){const n={};for(const e in t)Object.prototype.hasOwnProperty.call(t,e)&&(n[e]=t[e]);return n}return{}}function Y(t=function(){const t=p;return t.crypto||t.msCrypto}()){let n=()=>16*Math.random();try{if(t?.randomUUID)return t.randomUUID().replace(/-/g,"");t?.getRandomValues&&(n=()=>{const n=new Uint8Array(1);return t.getRandomValues(n),n[0]})}catch(t){}return([1e7]+1e3+4e3+8e3+1e11).replace(/[018]/g,(t=>(t^(15&n())>>t/4).toString(16)))}var z;function H(t){return new F((n=>{n(t)}))}!function(t){t[t.PENDING=0]="PENDING";t[t.RESOLVED=1]="RESOLVED";t[t.REJECTED=2]="REJECTED"}(z||(z={}));class F{constructor(t){this.t=z.PENDING,this.o=[],this.i(t)}then(t,n){return new F(((e,r)=>{this.o.push([!1,n=>{if(t)try{e(t(n))}catch(t){r(t)}else e(n)},t=>{if(n)try{e(n(t))}catch(t){r(t)}else r(t)}]),this.u()}))}catch(t){return this.then((t=>t),t)}finally(t){return new F(((n,e)=>{let r,o;return this.then((n=>{o=!1,r=n,t&&t()}),(n=>{o=!0,r=n,t&&t()})).then((()=>{o?e(r):n(r)}))}))}u(){if(this.t===z.PENDING)return;const t=this.o.slice();this.o=[],t.forEach((t=>{t[0]||(this.t===z.RESOLVED&&t[1](this.h),this.t===z.REJECTED&&t[2](this.h),t[0]=!0)}))}i(t){const n=(t,n)=>{this.t===z.PENDING&&(O(n)?n.then(e,r):(this.t=t,this.h=n,this.u()))},e=t=>{n(z.RESOLVED,t)},r=t=>{n(z.REJECTED,t)};try{t(e,r)}catch(t){r(t)}}}function W(t){const n=R(),e={sid:Y(),init:!0,timestamp:n,started:n,duration:0,status:"ok",errors:0,ignoreDuration:!1,toJSON:()=>function(t){return{sid:`${t.sid}`,init:t.init,started:new Date(1e3*t.started).toISOString(),timestamp:new Date(1e3*t.timestamp).toISOString(),status:t.status,errors:t.errors,did:"number"==typeof t.did||"string"==typeof t.did?`${t.did}`:void 0,duration:t.duration,abnormal_mechanism:t.abnormal_mechanism,attrs:{release:t.release,environment:t.environment,ip_address:t.ipAddress,user_agent:t.userAgent}}}(e)};return t&&K(e,t),e}function K(t,n={}){if(n.user&&(!t.ipAddress&&n.user.ip_address&&(t.ipAddress=n.user.ip_address),t.did||n.did||(t.did=n.user.id||n.user.email||n.user.username)),t.timestamp=n.timestamp||R(),n.abnormal_mechanism&&(t.abnormal_mechanism=n.abnormal_mechanism),n.ignoreDuration&&(t.ignoreDuration=n.ignoreDuration),n.sid&&(t.sid=32===n.sid.length?n.sid:Y()),void 0!==n.init&&(t.init=n.init),!t.did&&n.did&&(t.did=`${n.did}`),"number"==typeof n.started&&(t.started=n.started),t.ignoreDuration)t.duration=void 0;else if("number"==typeof n.duration)t.duration=n.duration;else{const n=t.timestamp-t.started;t.duration=n>=0?n:0}n.release&&(t.release=n.release),n.environment&&(t.environment=n.environment),!t.ipAddress&&n.ipAddress&&(t.ipAddress=n.ipAddress),!t.userAgent&&n.userAgent&&(t.userAgent=n.userAgent),"number"==typeof n.errors&&(t.errors=n.errors),n.status&&(t.status=n.status)}function V(){return Y()}function Z(){return Y().substring(16)}function q(t,n,e=2){if(!n||"object"!=typeof n||e<=0)return n;if(t&&0===Object.keys(n).length)return t;const r={...t};for(const t in n)Object.prototype.hasOwnProperty.call(n,t)&&(r[t]=q(r[t],n[t],e-1));return r}const Q="_sentrySpan";function X(t,n){n?function(t,n,e){try{Object.defineProperty(t,n,{value:e,writable:!0,configurable:!0})}catch(e){l&&w.log(`Failed to add non-enumerable property "${n}" to object`,t)}}(t,Q,n):delete t[Q]}function tt(t){return t[Q]}class nt{constructor(){this.p=!1,this.l=[],this.m=[],this._=[],this.v=[],this.S={},this.N={},this.T={},this.C={},this.R={},this.k={traceId:V(),sampleRand:Math.random()}}clone(){const t=new nt;return t._=[...this._],t.N={...this.N},t.T={...this.T},t.C={...this.C},this.C.flags&&(t.C.flags={values:[...this.C.flags.values]}),t.S=this.S,t.j=this.j,t.D=this.D,t.I=this.I,t.O=this.O,t.m=[...this.m],t.v=[...this.v],t.R={...this.R},t.k={...this.k},t.A=this.A,t.P=this.P,X(t,tt(this)),t}setClient(t){this.A=t}setLastEventId(t){this.P=t}getClient(){return this.A}lastEventId(){return this.P}addScopeListener(t){this.l.push(t)}addEventProcessor(t){return this.m.push(t),this}setUser(t){return this.S=t||{email:void 0,id:void 0,ip_address:void 0,username:void 0},this.D&&K(this.D,{user:t}),this.U(),this}getUser(){return this.S}setTags(t){return this.N={...this.N,...t},this.U(),this}setTag(t,n){return this.N={...this.N,[t]:n},this.U(),this}setExtras(t){return this.T={...this.T,...t},this.U(),this}setExtra(t,n){return this.T={...this.T,[t]:n},this.U(),this}setFingerprint(t){return this.O=t,this.U(),this}setLevel(t){return this.j=t,this.U(),this}setTransactionName(t){return this.I=t,this.U(),this}setContext(t,n){return null===n?delete this.C[t]:this.C[t]=n,this.U(),this}setSession(t){return t?this.D=t:delete this.D,this.U(),this}getSession(){return this.D}update(t){if(!t)return this;const n="function"==typeof t?t(this):t,e=n instanceof nt?n.getScopeData():I(n)?t:void 0,{tags:r,extra:o,user:s,contexts:i,level:c,fingerprint:u=[],propagationContext:a}=e||{};return this.N={...this.N,...r},this.T={...this.T,...o},this.C={...this.C,...i},s&&Object.keys(s).length&&(this.S=s),c&&(this.j=c),u.length&&(this.O=u),a&&(this.k=a),this}clear(){return this._=[],this.N={},this.T={},this.S={},this.C={},this.j=void 0,this.I=void 0,this.O=void 0,this.D=void 0,X(this,void 0),this.v=[],this.setPropagationContext({traceId:V(),sampleRand:Math.random()}),this.U(),this}addBreadcrumb(t,n){const e="number"==typeof n?n:100;if(e<=0)return this;const r={timestamp:C(),...t,message:t.message?L(t.message,2048):t.message};return this._.push(r),this._.length>e&&(this._=this._.slice(-e),this.A?.recordDroppedEvent("buffer_overflow","log_item")),this.U(),this}getLastBreadcrumb(){return this._[this._.length-1]}clearBreadcrumbs(){return this._=[],this.U(),this}addAttachment(t){return this.v.push(t),this}clearAttachments(){return this.v=[],this}getScopeData(){return{breadcrumbs:this._,attachments:this.v,contexts:this.C,tags:this.N,extra:this.T,user:this.S,level:this.j,fingerprint:this.O||[],eventProcessors:this.m,propagationContext:this.k,sdkProcessingMetadata:this.R,transactionName:this.I,span:tt(this)}}setSDKProcessingMetadata(t){return this.R=q(this.R,t,2),this}setPropagationContext(t){return this.k=t,this}getPropagationContext(){return this.k}captureException(t,n){const e=n?.event_id||Y();if(!this.A)return w.warn("No client configured on scope - will not capture exception!"),e;const r=new Error("Sentry syntheticException");return this.A.captureException(t,{originalException:t,syntheticException:r,...n,event_id:e},this),e}captureMessage(t,n,e){const r=e?.event_id||Y();if(!this.A)return w.warn("No client configured on scope - will not capture message!"),r;const o=new Error(t);return this.A.captureMessage(t,n,{originalException:t,syntheticException:o,...e,event_id:r},this),r}captureEvent(t,n){const e=n?.event_id||Y();return this.A?(this.A.captureEvent(t,{...n,event_id:e},this),e):(w.warn("No client configured on scope - will not capture event!"),e)}U(){this.p||(this.p=!0,this.l.forEach((t=>{t(this)})),this.p=!1)}}class et{constructor(t,n){let e,r;e=t||new nt,r=n||new nt,this.M=[{scope:e}],this.L=r}withScope(t){const n=this.B();let e;try{e=t(n)}catch(t){throw this.G(),t}return O(e)?e.then((t=>(this.G(),t)),(t=>{throw this.G(),t})):(this.G(),e)}getClient(){return this.getStackTop().client}getScope(){return this.getStackTop().scope}getIsolationScope(){return this.L}getStackTop(){return this.M[this.M.length-1]}B(){const t=this.getScope().clone();return this.M.push({client:this.getClient(),scope:t}),t}G(){return!(this.M.length<=1)&&!!this.M.pop()}}function rt(){const t=g(m());return t.stack=t.stack||new et(y("defaultCurrentScope",(()=>new nt)),y("defaultIsolationScope",(()=>new nt)))}function ot(t){return rt().withScope(t)}function st(t,n){const e=rt();return e.withScope((()=>(e.getStackTop().scope=t,n(t))))}function it(t){return rt().withScope((()=>t(rt().getIsolationScope())))}function ct(t){const n=g(t);return n.acs?n.acs:{withIsolationScope:it,withScope:ot,withSetScope:st,withSetIsolationScope:(t,n)=>it(n),getCurrentScope:()=>rt().getScope(),getIsolationScope:()=>rt().getIsolationScope()}}function ut(){return ct(m()).getCurrentScope().getClient()}const at="sentry.source",ft="sentry.sample_rate",ht="sentry.op",pt="sentry.origin",lt=0,dt=1,mt="_sentryScope",gt="_sentryIsolationScope";function yt(t){return{scope:t[mt],isolationScope:t[gt]}}const bt="sentry-",_t=/^sentry-/;function vt(t){const n=function(t){if(!t||!D(t)&&!Array.isArray(t))return;if(Array.isArray(t))return t.reduce(((t,n)=>{const e=wt(n);return Object.entries(e).forEach((([n,e])=>{t[n]=e})),t}),{});return wt(t)}(t);if(!n)return;const e=Object.entries(n).reduce(((t,[n,e])=>{if(n.match(_t)){t[n.slice(bt.length)]=e}return t}),{});return Object.keys(e).length>0?e:void 0}function wt(t){return t.split(",").map((t=>t.split("=").map((t=>decodeURIComponent(t.trim()))))).reduce(((t,[n,e])=>(n&&e&&(t[n]=e),t)),{})}const St=1;function $t(t){const{spanId:n,traceId:e,isRemote:r}=t.spanContext(),o=r?n:Tt(t).parent_span_id,s=yt(t).scope;return{parent_span_id:o,span_id:r?s?.getPropagationContext().propagationSpanId||Z():n,trace_id:e}}function Et(t){return t&&t.length>0?t.map((({context:{spanId:t,traceId:n,traceFlags:e,...r},attributes:o})=>({span_id:t,trace_id:n,sampled:e===St,attributes:o,...r}))):void 0}function xt(t){return"number"==typeof t?Nt(t):Array.isArray(t)?t[0]+t[1]/1e9:t instanceof Date?Nt(t.getTime()):R()}function Nt(t){return t>9999999999?t/1e3:t}function Tt(t){if(function(t){return"function"==typeof t.getSpanJSON}(t))return t.getSpanJSON();const{spanId:n,traceId:e}=t.spanContext();if(function(t){const n=t;return!!(n.attributes&&n.startTime&&n.name&&n.endTime&&n.status)}(t)){const{attributes:r,startTime:o,name:s,endTime:i,status:c,links:u}=t,a=t.parentSpanContext?.spanId;return{span_id:n,trace_id:e,data:r,description:s,parent_span_id:a,start_timestamp:xt(o),timestamp:xt(i)||void 0,status:Ct(c),op:r[ht],origin:r[pt],links:Et(u)}}return{span_id:n,trace_id:e,start_timestamp:0,data:{}}}function Ct(t){if(t&&t.code!==lt)return t.code===dt?"ok":t.message||"unknown_error"}const Rt="_sentryRootSpan";function kt(t){return t[Rt]||t}const jt="production",Dt="_frozenDsc";function It(t){const n=ut();if(!n)return{};const e=kt(t),r=Tt(e),o=r.data,s=e.spanContext().traceState,i=s?.get("sentry.sample_rate")??o[ft];function c(t){return"number"!=typeof i&&"string"!=typeof i||(t.sample_rate=`${i}`),t}const u=e[Dt];if(u)return c(u);const a=s?.get("sentry.dsc"),f=a&&vt(a);if(f)return c(f);const h=function(t,n){const e=n.getOptions(),{publicKey:r}=n.getDsn()||{},o={environment:e.environment||jt,release:e.release,public_key:r,trace_id:t};return n.emit("createDsc",o),o}(t.spanContext().traceId,n),p=o[at],l=r.description;return"url"!==p&&l&&(h.transaction=l),function(t){if("boolean"==typeof __SENTRY_TRACING__&&!__SENTRY_TRACING__)return!1;const n=t||ut()?.getOptions();return!(!n||null==n.tracesSampleRate&&!n.tracesSampler)}()&&(h.sampled=String(function(t){const{traceFlags:n}=t.spanContext();return n===St}(e)),h.sample_rand=s?.get("sentry.sample_rand")??yt(e).scope?.getPropagationContext().sampleRand.toString()),c(h),n.emit("createDsc",h,e),h}function Ot(t,n=!1){const{host:e,path:r,pass:o,port:s,projectId:i,protocol:c,publicKey:u}=t;return`${c}://${u}${n&&o?`:${o}`:""}@${e}${s?`:${s}`:""}/${r?`${r}/`:r}${i}`}function At(t,n=100,e=1/0){try{return Pt("",t,n,e)}catch(t){return{ERROR:`**non-serializable** (${t})`}}}function Pt(t,n,e=1/0,r=1/0,o=function(){const t=new WeakSet;function n(n){return!!t.has(n)||(t.add(n),!1)}function e(n){t.delete(n)}return[n,e]}()){const[s,i]=o;if(null==n||["boolean","string"].includes(typeof n)||"number"==typeof n&&Number.isFinite(n))return n;const c=function(t,n){try{if("domain"===t&&n&&"object"==typeof n&&n.J)return"[Domain]";if("domainEmitter"===t)return"[DomainEmitter]";if("undefined"!=typeof global&&n===global)return"[Global]";if("undefined"!=typeof window&&n===window)return"[Window]";if("undefined"!=typeof document&&n===document)return"[Document]";if("object"==typeof(e=n)&&null!==e&&(e.__isVue||e.Y))return"[VueViewModel]";if(function(t){return I(t)&&"nativeEvent"in t&&"preventDefault"in t&&"stopPropagation"in t}(n))return"[SyntheticEvent]";if("number"==typeof n&&!Number.isFinite(n))return`[${n}]`;if("function"==typeof n)return`[Function: ${function(t){try{return t&&"function"==typeof t&&t.name||N}catch(t){return N}}(n)}]`;if("symbol"==typeof n)return`[${String(n)}]`;if("bigint"==typeof n)return`[BigInt: ${String(n)}]`;const r=function(t){const n=Object.getPrototypeOf(t);return n?.constructor?n.constructor.name:"null prototype"}(n);return/^HTML(\w*)Element$/.test(r)?`[HTMLElement: ${r}]`:`[object ${r}]`}catch(t){return`**non-serializable** (${t})`}var e}(t,n);if(!c.startsWith("[object "))return c;if(n.__sentry_skip_normalization__)return n;const u="number"==typeof n.__sentry_override_normalization_depth__?n.__sentry_override_normalization_depth__:e;if(0===u)return c.replace("object ","");if(s(n))return"[Circular ~]";const a=n;if(a&&"function"==typeof a.toJSON)try{return Pt("",a.toJSON(),u-1,r,o)}catch(t){}const f=Array.isArray(n)?[]:{};let h=0;const p=B(n);for(const t in p){if(!Object.prototype.hasOwnProperty.call(p,t))continue;if(h>=r){f[t]="[MaxProperties ~]";break}const n=p[t];f[t]=Pt(t,n,u-1,r,o),h++}return i(n),f}function Ut(t,n){const e=n.replace(/\\/g,"/").replace(/[|\\{}()[\]^$+*?.]/g,"\\$&");let r=t;try{r=decodeURI(t)}catch(t){}return r.replace(/\\/g,"/").replace(/webpack:\/?/g,"").replace(new RegExp(`(file://)?/*${e}/*`,"ig"),"app:///")}function Mt(t,n=[]){return[t,n]}function Lt(t,n){const e=t[1];for(const t of e){if(n(t,t[0].type))return!0}return!1}function Bt(t){const n=g(p);return n.encodePolyfill?n.encodePolyfill(t):(new TextEncoder).encode(t)}function Gt(t){const[n,e]=t;let r=JSON.stringify(n);function o(t){"string"==typeof r?r="string"==typeof t?r+t:[Bt(r),t]:r.push("string"==typeof t?Bt(t):t)}for(const t of e){const[n,e]=t;if(o(`\n${JSON.stringify(n)}\n`),"string"==typeof e||e instanceof Uint8Array)o(e);else{let t;try{t=JSON.stringify(e)}catch(n){t=JSON.stringify(At(e))}o(t)}}return"string"==typeof r?r:function(t){const n=t.reduce(((t,n)=>t+n.length),0),e=new Uint8Array(n);let r=0;for(const n of t)e.set(n,r),r+=n.length;return e}(r)}const Jt={session:"session",sessions:"session",attachment:"attachment",transaction:"transaction",event:"error",client_report:"internal",user_report:"default",profile:"profile",profile_chunk:"profile",replay_event:"replay",replay_recording:"replay",check_in:"monitor",feedback:"feedback",span:"span",raw_security:"security",otel_log:"log_item"};function Yt(t){if(!t?.sdk)return;const{name:n,version:e}=t.sdk;return{name:n,version:e}}function zt(t,n,e,r){const o=Yt(e),s=t.type&&"replay_event"!==t.type?t.type:"event";!function(t,n){n&&(t.sdk=t.sdk||{},t.sdk.name=t.sdk.name||n.name,t.sdk.version=t.sdk.version||n.version,t.sdk.integrations=[...t.sdk.integrations||[],...n.integrations||[]],t.sdk.packages=[...t.sdk.packages||[],...n.packages||[]])}(t,e?.sdk);const i=function(t,n,e,r){const o=t.sdkProcessingMetadata?.dynamicSamplingContext;return{event_id:t.event_id,sent_at:(new Date).toISOString(),...n&&{sdk:n},...!!e&&r&&{dsn:Ot(r)},...o&&{trace:o}}}(t,o,r,n);delete t.sdkProcessingMetadata;return Mt(i,[[{type:s},t]])}const Ht="__SENTRY_SUPPRESS_TRACING__";function Ft(t){const n=ct(m());return n.suppressTracing?n.suppressTracing(t):function(...t){const n=ct(m());if(2===t.length){const[e,r]=t;return e?n.withSetScope(e,r):n.withScope(r)}return n.withScope(t[0])}((n=>(n.setSDKProcessingMetadata({[Ht]:!0}),t())))}function Wt(t,n){const{fingerprint:e,span:r,breadcrumbs:o,sdkProcessingMetadata:s}=n;!function(t,n){const{extra:e,tags:r,user:o,contexts:s,level:i,transactionName:c}=n;Object.keys(e).length&&(t.extra={...e,...t.extra});Object.keys(r).length&&(t.tags={...r,...t.tags});Object.keys(o).length&&(t.user={...o,...t.user});Object.keys(s).length&&(t.contexts={...s,...t.contexts});i&&(t.level=i);c&&"transaction"!==t.type&&(t.transaction=c)}(t,n),r&&function(t,n){t.contexts={trace:$t(n),...t.contexts},t.sdkProcessingMetadata={dynamicSamplingContext:It(n),...t.sdkProcessingMetadata};const e=kt(n),r=Tt(e).description;r&&!t.transaction&&"transaction"===t.type&&(t.transaction=r)}(t,r),function(t,n){t.fingerprint=t.fingerprint?Array.isArray(t.fingerprint)?t.fingerprint:[t.fingerprint]:[],n&&(t.fingerprint=t.fingerprint.concat(n));t.fingerprint.length||delete t.fingerprint}(t,e),function(t,n){const e=[...t.breadcrumbs||[],...n];t.breadcrumbs=e.length?e:void 0}(t,o),function(t,n){t.sdkProcessingMetadata={...t.sdkProcessingMetadata,...n}}(t,s)}const Kt="7";const Vt=Symbol.for("SentryBufferFullError");function Zt(t){const n=[];function e(t){return n.splice(n.indexOf(t),1)[0]||Promise.resolve(void 0)}return{$:n,add:function(r){if(!(void 0===t||n.length<t))return o=Vt,new F(((t,n)=>{n(o)}));var o;const s=r();return-1===n.indexOf(s)&&n.push(s),s.then((()=>e(s))).then(null,(()=>e(s).then(null,(()=>{})))),s},drain:function(t){return new F(((e,r)=>{let o=n.length;if(!o)return e(!0);const s=setTimeout((()=>{t&&t>0&&e(!1)}),t);n.forEach((t=>{H(t).then((()=>{--o||(clearTimeout(s),e(!0))}),r)}))}))}}}const qt=6e4;function Qt(t,{statusCode:n,headers:e},r=Date.now()){const o={...t},s=e?.["x-sentry-rate-limits"],i=e?.["retry-after"];if(s)for(const t of s.trim().split(",")){const[n,e,,,s]=t.split(":",5),i=parseInt(n,10),c=1e3*(isNaN(i)?60:i);if(e)for(const t of e.split(";"))"metric_bucket"===t&&s&&!s.split(";").includes("custom")||(o[t]=r+c);else o.all=r+c}else i?o.all=r+function(t,n=Date.now()){const e=parseInt(`${t}`,10);if(!isNaN(e))return 1e3*e;const r=Date.parse(`${t}`);return isNaN(r)?qt:r-n}(i,r):429===n&&(o.all=r+6e4);return o}const Xt=64;function tn(t,n,e=Zt(t.bufferSize||Xt)){let r={};return{send:function(t){const o=[];if(Lt(t,((t,n)=>{const e=function(t){return Jt[t]}(n);(function(t,n,e=Date.now()){return function(t,n){return t[n]||t.all||0}(t,n)>e})(r,e)||o.push(t)})),0===o.length)return H({});const s=Mt(t[0],o),i=t=>{Lt(s,((t,n)=>{}))};return e.add((()=>n({body:Gt(s)}).then((t=>(void 0!==t.statusCode&&(t.statusCode<200||t.statusCode>=300)&&h&&w.warn(`Sentry responded with status code ${t.statusCode} to sent event.`),r=Qt(r,t),t)),(t=>{throw i(),h&&w.error("Encountered error running transport request:",t),t})))).then((t=>t),(t=>{if(t===Vt)return h&&w.error("Skipped sending event because buffer is full."),i(),H({});throw t}))},flush:t=>e.drain(t)}}const nn=/^(\S+:\\|\/?)([\s\S]*?)((?:\.{1,2}|[^/\\]+?|)(\.[^./\\]*|))(?:[/\\]*)$/;function en(t){const n=function(t){const n=t.length>1024?`<truncated>${t.slice(-1024)}`:t,e=nn.exec(n);return e?e.slice(1):[]}(t),e=n[0]||"";let r=n[1];return e||r?(r&&(r=r.slice(0,r.length-1)),e+r):"."}function rn(t,n=!1){return!(n||t&&!t.startsWith("/")&&!t.match(/^[A-Z]:/)&&!t.startsWith(".")&&!t.match(/^[a-zA-Z]([a-zA-Z0-9.\-+])*:\/\//))&&void 0!==t&&!t.includes("node_modules/")}const on=Symbol("AgentBaseInternalState");class sn extends s.Agent{constructor(t){super(t),this[on]={}}isSecureEndpoint(t){if(t){if("boolean"==typeof t.secureEndpoint)return t.secureEndpoint;if("string"==typeof t.protocol)return"https:"===t.protocol}const{stack:n}=new Error;return"string"==typeof n&&n.split("\n").some((t=>-1!==t.indexOf("(https.js:")||-1!==t.indexOf("node:https:")))}createSocket(t,n,e){const r={...n,secureEndpoint:this.isSecureEndpoint(n)};Promise.resolve().then((()=>this.connect(t,r))).then((o=>{if(o instanceof s.Agent)return o.addRequest(t,r);this[on].currentSocket=o,super.createSocket(t,n,e)}),e)}createConnection(){const t=this[on].currentSocket;if(this[on].currentSocket=void 0,!t)throw new Error("No socket was returned in the `connect()` function");return t}get defaultPort(){return this[on].defaultPort??("https:"===this.protocol?443:80)}set defaultPort(t){this[on]&&(this[on].defaultPort=t)}get protocol(){return this[on].protocol??(this.isSecureEndpoint()?"https:":"http:")}set protocol(t){this[on]&&(this[on].protocol=t)}}function cn(...t){w.log("[https-proxy-agent:parse-proxy-response]",...t)}function un(t){return new Promise(((n,e)=>{let r=0;const o=[];function s(){const c=t.read();c?function(c){o.push(c),r+=c.length;const u=Buffer.concat(o,r),a=u.indexOf("\r\n\r\n");if(-1===a)return cn("have not received end of HTTP headers yet..."),void s();const f=u.subarray(0,a).toString("ascii").split("\r\n"),h=f.shift();if(!h)return t.destroy(),e(new Error("No header received from proxy CONNECT response"));const p=h.split(" "),l=+(p[1]||0),d=p.slice(2).join(" "),m={};for(const n of f){if(!n)continue;const r=n.indexOf(":");if(-1===r)return t.destroy(),e(new Error(`Invalid header from proxy CONNECT response: "${n}"`));const o=n.slice(0,r).toLowerCase(),s=n.slice(r+1).trimStart(),i=m[o];"string"==typeof i?m[o]=[i,s]:Array.isArray(i)?i.push(s):m[o]=s}cn("got proxy server response: %o %o",h,m),i(),n({connect:{statusCode:l,statusText:d,headers:m},buffered:u})}(c):t.once("readable",s)}function i(){t.removeListener("end",c),t.removeListener("error",u),t.removeListener("readable",s)}function c(){i(),cn("onend"),e(new Error("Proxy connection ended before receiving CONNECT response"))}function u(t){i(),cn("onerror %o",t),e(t)}t.on("error",u),t.on("end",c),s()}))}function an(...t){w.log("[https-proxy-agent]",...t)}class fn extends sn{static __initStatic(){this.protocols=["http","https"]}constructor(t,n){super(n),this.options={},this.proxy="string"==typeof t?new URL(t):t,this.proxyHeaders=n?.headers??{},an("Creating new HttpsProxyAgent instance: %o",this.proxy.href);const e=(this.proxy.hostname||this.proxy.host).replace(/^\[|\]$/g,""),r=this.proxy.port?parseInt(this.proxy.port,10):"https:"===this.proxy.protocol?443:80;this.connectOpts={ALPNProtocols:["http/1.1"],...n?pn(n,"headers"):null,host:e,port:r}}async connect(t,n){const{proxy:e}=this;if(!n.host)throw new TypeError('No "host" provided');let r;if("https:"===e.protocol){an("Creating `tls.Socket`: %o",this.connectOpts);const t=this.connectOpts.servername||this.connectOpts.host;r=f.connect({...this.connectOpts,servername:t&&a.isIP(t)?void 0:t})}else an("Creating `net.Socket`: %o",this.connectOpts),r=a.connect(this.connectOpts);const o="function"==typeof this.proxyHeaders?this.proxyHeaders():{...this.proxyHeaders},s=a.isIPv6(n.host)?`[${n.host}]`:n.host;let i=`CONNECT ${s}:${n.port} HTTP/1.1\r\n`;if(e.username||e.password){const t=`${decodeURIComponent(e.username)}:${decodeURIComponent(e.password)}`;o["Proxy-Authorization"]=`Basic ${Buffer.from(t).toString("base64")}`}o.Host=`${s}:${n.port}`,o["Proxy-Connection"]||(o["Proxy-Connection"]=this.keepAlive?"Keep-Alive":"close");for(const t of Object.keys(o))i+=`${t}: ${o[t]}\r\n`;const c=un(r);r.write(`${i}\r\n`);const{connect:u,buffered:h}=await c;if(t.emit("proxyConnect",u),this.emit("proxyConnect",u,t),200===u.statusCode){if(t.once("socket",hn),n.secureEndpoint){an("Upgrading socket connection to TLS");const t=n.servername||n.host;return f.connect({...pn(n,"host","path","port"),socket:r,servername:a.isIP(t)?void 0:t})}return r}r.destroy();const p=new a.Socket({writable:!1});return p.readable=!0,t.once("socket",(t=>{an("Replaying proxy buffer for failed request"),t.push(h),t.push(null)})),p}}function hn(t){t.resume()}function pn(t,...n){const e={};let r;for(r in t)n.includes(r)||(e[r]=t[r]);return e}fn.__initStatic();const ln=32768;function dn(t){return t.replace(/^[A-Z]:/,"").replace(/\\/g,"/")}const mn=n;let gn,yn=0,bn={};function _n(t){mn.debug&&console.log(`[ANR Worker] ${t}`)}var vn,wn,Sn;const $n=function(t){let n;try{n=new URL(t.url)}catch(n){return v((()=>{console.warn("[@sentry/node]: Invalid dsn or tunnel option, will not send any events. The tunnel option must be a full URL when used.")})),tn(t,(()=>Promise.resolve({})))}const e="https:"===n.protocol,r=function(t,n){const{no_proxy:e}=process.env,r=e?.split(",").some((n=>t.host.endsWith(n)||t.hostname.endsWith(n)));return r?void 0:n}(n,t.proxy||(e?process.env.https_proxy:void 0)||process.env.http_proxy),o=e?i:s,a=void 0!==t.keepAlive&&t.keepAlive,f=r?new fn(r):new o.Agent({keepAlive:a,maxSockets:30,timeout:2e3}),h=function(t,n,e){const{hostname:r,pathname:o,port:s,protocol:i,search:a}=new URL(t.url);return function(f){return new Promise(((h,p)=>{Ft((()=>{let l=function(t){return new c({read(){this.push(t),this.push(null)}})}(f.body);const d={...t.headers};f.body.length>ln&&(d["content-encoding"]="gzip",l=l.pipe(u()));const m=n.request({method:"POST",agent:e,headers:d,hostname:r,path:`${o}${a}`,port:s,protocol:i,ca:t.caCerts},(t=>{t.on("data",(()=>{})),t.on("end",(()=>{})),t.setEncoding("utf8");const n=t.headers["retry-after"]??null,e=t.headers["x-sentry-rate-limits"]??null;h({statusCode:t.statusCode,headers:{"retry-after":n,"x-sentry-rate-limits":Array.isArray(e)?e[0]||null:e}})}));m.on("error",p),l.pipe(m)}))}))}}(t,t.httpModule??o,f);return tn(t,h)}({url:(vn=mn.dsn,wn=mn.tunnel,Sn=mn.sdkMetadata.sdk,wn||`${function(t){return`${function(t){const n=t.protocol?`${t.protocol}:`:"",e=t.port?`:${t.port}`:"";return`${n}//${t.host}${e}${t.path?`/${t.path}`:""}/api/`}(t)}${t.projectId}/envelope/`}(vn)}?${function(t,n){const e={sentry_version:Kt};return t.publicKey&&(e.sentry_key=t.publicKey),n&&(e.sentry_client=`${n.name}/${n.version}`),new URLSearchParams(e).toString()}(vn,Sn)}`)});async function En(){if(gn){_n("Sending abnormal session"),K(gn,{status:"abnormal",abnormal_mechanism:"anr_foreground",release:mn.release,environment:mn.environment});const t=function(t,n,e,r){const o=Yt(e);return Mt({sent_at:(new Date).toISOString(),...o&&{sdk:o},...!!r&&n&&{dsn:Ot(n)}},["aggregates"in t?[{type:"sessions"},t]:[{type:"session"},t.toJSON()]])}(gn,mn.dsn,mn.sdkMetadata,mn.tunnel);_n(JSON.stringify(t)),await $n.send(t);try{e?.postMessage("session-ended")}catch(t){}}}function xn(t){if(!t)return;const n=function(t){if(!t.length)return[];const n=Array.from(t);return/sentryWrapped/.test(x(n).function||"")&&n.pop(),n.reverse(),E.test(x(n).function||"")&&(n.pop(),E.test(x(n).function||"")&&n.pop()),n.slice(0,S).map((t=>({...t,filename:t.filename||x(n).filename,function:t.function||$})))}(t);if(mn.appRootPath)for(const t of n)t.filename&&(t.filename=Ut(t.filename,mn.appRootPath));return n}async function Nn(t,n){if(yn>=mn.maxAnrEvents)return;yn+=1,await En(),_n("Sending event");const e={event_id:Y(),contexts:mn.contexts,release:mn.release,environment:mn.environment,dist:mn.dist,platform:"node",level:"error",exception:{values:[{type:"ApplicationNotResponding",value:`Application Not Responding for at least ${mn.anrThreshold} ms`,stacktrace:{frames:xn(t)},mechanism:{type:"ANR"}}]},tags:mn.staticTags};n&&function(t,n){if(Wt(t,n),!t.contexts?.trace){const{traceId:e,parentSpanId:r,propagationSpanId:o}=n.propagationContext;t.contexts={trace:{trace_id:e,span_id:o||Z(),parent_span_id:r},...t.contexts}}}(e,n),function(t){if(0===Object.keys(bn).length)return;const n=mn.appRootPath?{}:bn;if(mn.appRootPath)for(const[t,e]of Object.entries(bn))n[Ut(t,mn.appRootPath)]=e;const e=new Map;for(const r of t.exception?.values||[])for(const t of r.stacktrace?.frames||[]){const r=t.abs_path||t.filename;r&&n[r]&&e.set(r,n[r])}if(e.size>0){const n=[];for(const[t,r]of e.entries())n.push({type:"sourcemap",code_file:t,debug_id:r});t.debug_meta={images:n}}}(e);const r=zt(e,mn.dsn,mn.sdkMetadata,mn.tunnel);_n(JSON.stringify(r)),await $n.send(r),await $n.flush(2e3),yn>=mn.maxAnrEvents&&setTimeout((()=>{process.exit(0)}),5e3)}let Tn;if(_n("Started"),mn.captureStackTrace){_n("Connecting to debugger");const n=new t;n.connectToMainThread(),_n("Connected to debugger");const e=new Map;n.on("Debugger.scriptParsed",(t=>{e.set(t.params.scriptId,t.params.url)})),n.on("Debugger.paused",(t=>{if("other"===t.params.reason)try{_n("Debugger paused");const s=[...t.params.callFrames],i=mn.appRootPath?function(t=(process.argv[1]?en(process.argv[1]):process.cwd()),n="\\"===o){const e=n?dn(t):t;return t=>{if(!t)return;const o=n?dn(t):t;let{dir:s,base:i,ext:c}=r.parse(o);".js"!==c&&".mjs"!==c&&".cjs"!==c||(i=i.slice(0,-1*c.length));const u=decodeURIComponent(i);s||(s=".");const a=s.lastIndexOf("/node_modules");if(a>-1)return`${s.slice(a+14).replace(/\//g,".")}:${u}`;if(s.startsWith(e)){const t=s.slice(e.length+1).replace(/\//g,".");return t?`${t}:${u}`:u}return u}}(mn.appRootPath):()=>{},c=s.map((t=>function(t,n,e){const r=n?n.replace(/^file:\/\//,""):void 0,o=t.location.columnNumber?t.location.columnNumber+1:void 0,s=t.location.lineNumber?t.location.lineNumber+1:void 0;return{filename:r,module:e(r),function:t.functionName||$,colno:o,lineno:s,in_app:r?rn(r):void 0}}(t,e.get(t.location.scriptId),i))),u=setTimeout((()=>{Nn(c).then(null,(()=>{_n("Sending ANR event failed.")}))}),5e3);n.post("Runtime.evaluate",{expression:"global.__SENTRY_GET_SCOPES__();",silent:!0,returnByValue:!0},((t,e)=>{t&&_n(`Error executing script: '${t.message}'`),clearTimeout(u);const r=e?.result?e.result.value:void 0;n.post("Debugger.resume"),n.post("Debugger.disable"),Nn(c,r).then(null,(()=>{_n("Sending ANR event failed.")}))}))}catch(t){throw n.post("Debugger.resume"),n.post("Debugger.disable"),t}})),Tn=()=>{try{n.post("Debugger.enable",(()=>{n.post("Debugger.pause")}))}catch(t){}}}const{poll:Cn}=function(t,n,e,r){const o=t();let s=!1,i=!0;return setInterval((()=>{const t=o.getTimeMs();!1===s&&t>n+e&&(s=!0,i&&r()),t<n+e&&(s=!1)}),20),{poll:()=>{o.reset()},enabled:t=>{i=t}}}((function(){let t=process.hrtime();return{getTimeMs:()=>{const[n,e]=process.hrtime(t);return Math.floor(1e3*n+e/1e6)},reset:()=>{t=process.hrtime()}}}),mn.pollInterval,mn.anrThreshold,(function(){_n("Watchdog timeout"),Tn?(_n("Pausing debugger to capture stack trace"),Tn()):(_n("Capturing event without a stack trace"),Nn().then(null,(()=>{_n("Sending ANR event failed on watchdog timeout.")})))}));e?.on("message",(t=>{t.session&&(gn=W(t.session)),t.debugImages&&(bn=t.debugImages),Cn()}));
diff --git a/build/esm/integrations/http/SentryHttpInstrumentation.js b/build/esm/integrations/http/SentryHttpInstrumentation.js
index 21b7bb87789035d151e12e907f011025c460e09a..491ab2b3f9f5df1e14b7692e67a9b5617c035585 100644
--- a/build/esm/integrations/http/SentryHttpInstrumentation.js
+++ b/build/esm/integrations/http/SentryHttpInstrumentation.js
@@ -1,5 +1,4 @@
 import { propagation, context } from '@opentelemetry/api';
-import { VERSION } from '@opentelemetry/core';
 import { InstrumentationBase, InstrumentationNodeModuleDefinition } from '@opentelemetry/instrumentation';
 import { getIsolationScope, httpRequestToRequestData, stripUrlQueryAndFragment, withIsolationScope, generateSpanId, getCurrentScope, logger, getClient, getBreadcrumbLogLevelFromHttpStatusCode, addBreadcrumb, parseUrl, getSanitizedUrlString } from '@sentry/core';
 import { DEBUG_BUILD } from '../../debug-build.js';
@@ -27,7 +26,7 @@ const MAX_BODY_BYTE_LENGTH = 1024 * 1024;
  */
 class SentryHttpInstrumentation extends InstrumentationBase {
    constructor(config = {}) {
-    super('@sentry/instrumentation-http', VERSION, config);
+    super('@sentry/instrumentation-http', '2.0.0', config);
   }
 
   /** @inheritdoc */
diff --git a/build/esm/integrations/http/SentryHttpInstrumentation.js.map b/build/esm/integrations/http/SentryHttpInstrumentation.js.map
index 31a3131baa0ce637e55f5be24d00fa01017170b5..9f9117873708778144336470118a039722d4b03e 100644
--- a/build/esm/integrations/http/SentryHttpInstrumentation.js.map
+++ b/build/esm/integrations/http/SentryHttpInstrumentation.js.map
@@ -1 +1 @@
-{"version":3,"file":"SentryHttpInstrumentation.js","sources":["../../../../src/integrations/http/SentryHttpInstrumentation.ts"],"sourcesContent":["/* eslint-disable max-lines */\nimport { context, propagation } from '@opentelemetry/api';\nimport { VERSION } from '@opentelemetry/core';\nimport type { InstrumentationConfig } from '@opentelemetry/instrumentation';\nimport { InstrumentationBase, InstrumentationNodeModuleDefinition } from '@opentelemetry/instrumentation';\nimport type { AggregationCounts, Client, RequestEventData, SanitizedRequestData, Scope } from '@sentry/core';\nimport {\n  addBreadcrumb,\n  generateSpanId,\n  getBreadcrumbLogLevelFromHttpStatusCode,\n  getClient,\n  getCurrentScope,\n  getIsolationScope,\n  getSanitizedUrlString,\n  httpRequestToRequestData,\n  logger,\n  parseUrl,\n  stripUrlQueryAndFragment,\n  withIsolationScope,\n} from '@sentry/core';\nimport type * as http from 'node:http';\nimport type { IncomingMessage, RequestOptions } from 'node:http';\nimport type * as https from 'node:https';\nimport type { EventEmitter } from 'node:stream';\nimport { DEBUG_BUILD } from '../../debug-build';\nimport { getRequestUrl } from '../../utils/getRequestUrl';\nimport { stealthWrap } from './utils';\nimport { getRequestInfo } from './vendor/getRequestInfo';\n\ntype Http = typeof http;\ntype Https = typeof https;\n\nexport type SentryHttpInstrumentationOptions = InstrumentationConfig & {\n  /**\n   * Whether breadcrumbs should be recorded for requests.\n   *\n   * @default `true`\n   */\n  breadcrumbs?: boolean;\n\n  /**\n   * Whether to extract the trace ID from the `sentry-trace` header for incoming requests.\n   * By default this is done by the HttpInstrumentation, but if that is not added (e.g. because tracing is disabled, ...)\n   * then this instrumentation can take over.\n   *\n   * @default `false`\n   */\n  extractIncomingTraceFromHeader?: boolean;\n\n  /**\n   * Do not capture breadcrumbs for outgoing HTTP requests to URLs where the given callback returns `true`.\n   * For the scope of this instrumentation, this callback only controls breadcrumb creation.\n   * The same option can be passed to the top-level httpIntegration where it controls both, breadcrumb and\n   * span creation.\n   *\n   * @param url Contains the entire URL, including query string (if any), protocol, host, etc. of the outgoing request.\n   * @param request Contains the {@type RequestOptions} object used to make the outgoing request.\n   */\n  ignoreOutgoingRequests?: (url: string, request: RequestOptions) => boolean;\n\n  /**\n   * Do not capture the request body for incoming HTTP requests to URLs where the given callback returns `true`.\n   * This can be useful for long running requests where the body is not needed and we want to avoid capturing it.\n   *\n   * @param url Contains the entire URL, including query string (if any), protocol, host, etc. of the outgoing request.\n   * @param request Contains the {@type RequestOptions} object used to make the outgoing request.\n   */\n  ignoreIncomingRequestBody?: (url: string, request: RequestOptions) => boolean;\n\n  /**\n   * Whether the integration should create [Sessions](https://docs.sentry.io/product/releases/health/#sessions) for incoming requests to track the health and crash-free rate of your releases in Sentry.\n   * Read more about Release Health: https://docs.sentry.io/product/releases/health/\n   *\n   * Defaults to `true`.\n   */\n  trackIncomingRequestsAsSessions?: boolean;\n\n  /**\n   * Number of milliseconds until sessions tracked with `trackIncomingRequestsAsSessions` will be flushed as a session aggregate.\n   *\n   * Defaults to `60000` (60s).\n   */\n  sessionFlushingDelayMS?: number;\n};\n\n// We only want to capture request bodies up to 1mb.\nconst MAX_BODY_BYTE_LENGTH = 1024 * 1024;\n\n/**\n * This custom HTTP instrumentation is used to isolate incoming requests and annotate them with additional information.\n * It does not emit any spans.\n *\n * The reason this is isolated from the OpenTelemetry instrumentation is that users may overwrite this,\n * which would lead to Sentry not working as expected.\n *\n * Important note: Contrary to other OTEL instrumentation, this one cannot be unwrapped.\n * It only does minimal things though and does not emit any spans.\n *\n * This is heavily inspired & adapted from:\n * https://github.com/open-telemetry/opentelemetry-js/blob/f8ab5592ddea5cba0a3b33bf8d74f27872c0367f/experimental/packages/opentelemetry-instrumentation-http/src/http.ts\n */\nexport class SentryHttpInstrumentation extends InstrumentationBase<SentryHttpInstrumentationOptions> {\n  public constructor(config: SentryHttpInstrumentationOptions = {}) {\n    super('@sentry/instrumentation-http', VERSION, config);\n  }\n\n  /** @inheritdoc */\n  public init(): [InstrumentationNodeModuleDefinition, InstrumentationNodeModuleDefinition] {\n    return [this._getHttpsInstrumentation(), this._getHttpInstrumentation()];\n  }\n\n  /** Get the instrumentation for the http module. */\n  private _getHttpInstrumentation(): InstrumentationNodeModuleDefinition {\n    return new InstrumentationNodeModuleDefinition(\n      'http',\n      ['*'],\n      (moduleExports: Http): Http => {\n        // Patch incoming requests for request isolation\n        stealthWrap(moduleExports.Server.prototype, 'emit', this._getPatchIncomingRequestFunction());\n\n        // Patch outgoing requests for breadcrumbs\n        const patchedRequest = stealthWrap(moduleExports, 'request', this._getPatchOutgoingRequestFunction());\n        stealthWrap(moduleExports, 'get', this._getPatchOutgoingGetFunction(patchedRequest));\n\n        return moduleExports;\n      },\n      () => {\n        // no unwrap here\n      },\n    );\n  }\n\n  /** Get the instrumentation for the https module. */\n  private _getHttpsInstrumentation(): InstrumentationNodeModuleDefinition {\n    return new InstrumentationNodeModuleDefinition(\n      'https',\n      ['*'],\n      (moduleExports: Https): Https => {\n        // Patch incoming requests for request isolation\n        stealthWrap(moduleExports.Server.prototype, 'emit', this._getPatchIncomingRequestFunction());\n\n        // Patch outgoing requests for breadcrumbs\n        const patchedRequest = stealthWrap(moduleExports, 'request', this._getPatchOutgoingRequestFunction());\n        stealthWrap(moduleExports, 'get', this._getPatchOutgoingGetFunction(patchedRequest));\n\n        return moduleExports;\n      },\n      () => {\n        // no unwrap here\n      },\n    );\n  }\n\n  /**\n   * Patch the incoming request function for request isolation.\n   */\n  private _getPatchIncomingRequestFunction(): (\n    original: (event: string, ...args: unknown[]) => boolean,\n  ) => (this: unknown, event: string, ...args: unknown[]) => boolean {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const instrumentation = this;\n    const { ignoreIncomingRequestBody } = instrumentation.getConfig();\n\n    return (\n      original: (event: string, ...args: unknown[]) => boolean,\n    ): ((this: unknown, event: string, ...args: unknown[]) => boolean) => {\n      return function incomingRequest(this: unknown, ...args: [event: string, ...args: unknown[]]): boolean {\n        // Only traces request events\n        if (args[0] !== 'request') {\n          return original.apply(this, args);\n        }\n\n        instrumentation._diag.debug('http instrumentation for incoming request');\n\n        const isolationScope = getIsolationScope().clone();\n        const request = args[1] as http.IncomingMessage;\n        const response = args[2] as http.OutgoingMessage;\n\n        const normalizedRequest = httpRequestToRequestData(request);\n\n        // request.ip is non-standard but some frameworks set this\n        const ipAddress = (request as { ip?: string }).ip || request.socket?.remoteAddress;\n\n        const url = request.url || '/';\n        if (!ignoreIncomingRequestBody?.(url, request)) {\n          patchRequestToCaptureBody(request, isolationScope);\n        }\n\n        // Update the isolation scope, isolate this request\n        isolationScope.setSDKProcessingMetadata({ normalizedRequest, ipAddress });\n\n        // attempt to update the scope's `transactionName` based on the request URL\n        // Ideally, framework instrumentations coming after the HttpInstrumentation\n        // update the transactionName once we get a parameterized route.\n        const httpMethod = (request.method || 'GET').toUpperCase();\n        const httpTarget = stripUrlQueryAndFragment(url);\n\n        const bestEffortTransactionName = `${httpMethod} ${httpTarget}`;\n\n        isolationScope.setTransactionName(bestEffortTransactionName);\n\n        if (instrumentation.getConfig().trackIncomingRequestsAsSessions !== false) {\n          recordRequestSession({\n            requestIsolationScope: isolationScope,\n            response,\n            sessionFlushingDelayMS: instrumentation.getConfig().sessionFlushingDelayMS ?? 60_000,\n          });\n        }\n\n        return withIsolationScope(isolationScope, () => {\n          // Set a new propagationSpanId for this request\n          // We rely on the fact that `withIsolationScope()` will implicitly also fork the current scope\n          // This way we can save an \"unnecessary\" `withScope()` invocation\n          getCurrentScope().getPropagationContext().propagationSpanId = generateSpanId();\n\n          // If we don't want to extract the trace from the header, we can skip this\n          if (!instrumentation.getConfig().extractIncomingTraceFromHeader) {\n            return original.apply(this, args);\n          }\n\n          const ctx = propagation.extract(context.active(), normalizedRequest.headers);\n          return context.with(ctx, () => {\n            return original.apply(this, args);\n          });\n        });\n      };\n    };\n  }\n\n  /**\n   * Patch the outgoing request function for breadcrumbs.\n   */\n  private _getPatchOutgoingRequestFunction(): (\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    original: (...args: any[]) => http.ClientRequest,\n  ) => (options: URL | http.RequestOptions | string, ...args: unknown[]) => http.ClientRequest {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const instrumentation = this;\n\n    return (original: (...args: unknown[]) => http.ClientRequest): ((...args: unknown[]) => http.ClientRequest) => {\n      return function outgoingRequest(this: unknown, ...args: unknown[]): http.ClientRequest {\n        instrumentation._diag.debug('http instrumentation for outgoing requests');\n\n        // Making a copy to avoid mutating the original args array\n        // We need to access and reconstruct the request options object passed to `ignoreOutgoingRequests`\n        // so that it matches what Otel instrumentation passes to `ignoreOutgoingRequestHook`.\n        // @see https://github.com/open-telemetry/opentelemetry-js/blob/7293e69c1e55ca62e15d0724d22605e61bd58952/experimental/packages/opentelemetry-instrumentation-http/src/http.ts#L756-L789\n        const argsCopy = [...args];\n\n        const options = argsCopy.shift() as URL | http.RequestOptions | string;\n\n        const extraOptions =\n          typeof argsCopy[0] === 'object' && (typeof options === 'string' || options instanceof URL)\n            ? (argsCopy.shift() as http.RequestOptions)\n            : undefined;\n\n        const { optionsParsed } = getRequestInfo(instrumentation._diag, options, extraOptions);\n\n        const request = original.apply(this, args) as ReturnType<typeof http.request>;\n\n        request.prependListener('response', (response: http.IncomingMessage) => {\n          const _breadcrumbs = instrumentation.getConfig().breadcrumbs;\n          const breadCrumbsEnabled = typeof _breadcrumbs === 'undefined' ? true : _breadcrumbs;\n\n          const _ignoreOutgoingRequests = instrumentation.getConfig().ignoreOutgoingRequests;\n          const shouldCreateBreadcrumb =\n            typeof _ignoreOutgoingRequests === 'function'\n              ? !_ignoreOutgoingRequests(getRequestUrl(request), optionsParsed)\n              : true;\n\n          if (breadCrumbsEnabled && shouldCreateBreadcrumb) {\n            addRequestBreadcrumb(request, response);\n          }\n        });\n\n        return request;\n      };\n    };\n  }\n\n  /** Path the outgoing get function for breadcrumbs. */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private _getPatchOutgoingGetFunction(clientRequest: (...args: any[]) => http.ClientRequest) {\n    return (_original: unknown): ((...args: unknown[]) => http.ClientRequest) => {\n      // Re-implement http.get. This needs to be done (instead of using\n      // getPatchOutgoingRequestFunction to patch it) because we need to\n      // set the trace context header before the returned http.ClientRequest is\n      // ended. The Node.js docs state that the only differences between\n      // request and get are that (1) get defaults to the HTTP GET method and\n      // (2) the returned request object is ended immediately. The former is\n      // already true (at least in supported Node versions up to v10), so we\n      // simply follow the latter. Ref:\n      // https://nodejs.org/dist/latest/docs/api/http.html#http_http_get_options_callback\n      // https://github.com/googleapis/cloud-trace-nodejs/blob/master/src/instrumentations/instrumentation-http.ts#L198\n      return function outgoingGetRequest(...args: unknown[]): http.ClientRequest {\n        const req = clientRequest(...args);\n        req.end();\n        return req;\n      };\n    };\n  }\n}\n\n/** Add a breadcrumb for outgoing requests. */\nfunction addRequestBreadcrumb(request: http.ClientRequest, response: http.IncomingMessage): void {\n  const data = getBreadcrumbData(request);\n\n  const statusCode = response.statusCode;\n  const level = getBreadcrumbLogLevelFromHttpStatusCode(statusCode);\n\n  addBreadcrumb(\n    {\n      category: 'http',\n      data: {\n        status_code: statusCode,\n        ...data,\n      },\n      type: 'http',\n      level,\n    },\n    {\n      event: 'response',\n      request,\n      response,\n    },\n  );\n}\n\nfunction getBreadcrumbData(request: http.ClientRequest): Partial<SanitizedRequestData> {\n  try {\n    // `request.host` does not contain the port, but the host header does\n    const host = request.getHeader('host') || request.host;\n    const url = new URL(request.path, `${request.protocol}//${host}`);\n    const parsedUrl = parseUrl(url.toString());\n\n    const data: Partial<SanitizedRequestData> = {\n      url: getSanitizedUrlString(parsedUrl),\n      'http.method': request.method || 'GET',\n    };\n\n    if (parsedUrl.search) {\n      data['http.query'] = parsedUrl.search;\n    }\n    if (parsedUrl.hash) {\n      data['http.fragment'] = parsedUrl.hash;\n    }\n\n    return data;\n  } catch {\n    return {};\n  }\n}\n\n/**\n * This method patches the request object to capture the body.\n * Instead of actually consuming the streamed body ourselves, which has potential side effects,\n * we monkey patch `req.on('data')` to intercept the body chunks.\n * This way, we only read the body if the user also consumes the body, ensuring we do not change any behavior in unexpected ways.\n */\nfunction patchRequestToCaptureBody(req: IncomingMessage, isolationScope: Scope): void {\n  const chunks: Buffer[] = [];\n\n  function getChunksSize(): number {\n    return chunks.reduce((acc, chunk) => acc + chunk.byteLength, 0);\n  }\n\n  /**\n   * We need to keep track of the original callbacks, in order to be able to remove listeners again.\n   * Since `off` depends on having the exact same function reference passed in, we need to be able to map\n   * original listeners to our wrapped ones.\n   */\n  const callbackMap = new WeakMap();\n\n  try {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    req.on = new Proxy(req.on, {\n      apply: (target, thisArg, args: Parameters<typeof req.on>) => {\n        const [event, listener, ...restArgs] = args;\n\n        if (event === 'data') {\n          const callback = new Proxy(listener, {\n            apply: (target, thisArg, args: Parameters<typeof listener>) => {\n              // If we have already read more than the max body length, we stop adding chunks\n              // To avoid growing the memory indefinitely if a response is e.g. streamed\n              if (getChunksSize() < MAX_BODY_BYTE_LENGTH) {\n                const chunk = args[0] as Buffer;\n                chunks.push(chunk);\n              } else if (DEBUG_BUILD) {\n                logger.log(\n                  `Dropping request body chunk because it maximum body length of ${MAX_BODY_BYTE_LENGTH}b is exceeded.`,\n                );\n              }\n\n              return Reflect.apply(target, thisArg, args);\n            },\n          });\n\n          callbackMap.set(listener, callback);\n\n          return Reflect.apply(target, thisArg, [event, callback, ...restArgs]);\n        }\n\n        if (event === 'end') {\n          const callback = new Proxy(listener, {\n            apply: (target, thisArg, args) => {\n              try {\n                const body = Buffer.concat(chunks).toString('utf-8');\n\n                if (body) {\n                  const normalizedRequest = { data: body } satisfies RequestEventData;\n                  isolationScope.setSDKProcessingMetadata({ normalizedRequest });\n                }\n              } catch {\n                // ignore errors here\n              }\n\n              return Reflect.apply(target, thisArg, args);\n            },\n          });\n\n          callbackMap.set(listener, callback);\n\n          return Reflect.apply(target, thisArg, [event, callback, ...restArgs]);\n        }\n\n        return Reflect.apply(target, thisArg, args);\n      },\n    });\n\n    // Ensure we also remove callbacks correctly\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    req.off = new Proxy(req.off, {\n      apply: (target, thisArg, args: Parameters<typeof req.off>) => {\n        const [, listener] = args;\n\n        const callback = callbackMap.get(listener);\n        if (callback) {\n          callbackMap.delete(listener);\n\n          const modifiedArgs = args.slice();\n          modifiedArgs[1] = callback;\n          return Reflect.apply(target, thisArg, modifiedArgs);\n        }\n\n        return Reflect.apply(target, thisArg, args);\n      },\n    });\n  } catch {\n    // ignore errors if we can't patch stuff\n  }\n}\n\n/**\n * Starts a session and tracks it in the context of a given isolation scope.\n * When the passed response is finished, the session is put into a task and is\n * aggregated with other sessions that may happen in a certain time window\n * (sessionFlushingDelayMs).\n *\n * The sessions are always aggregated by the client that is on the current scope\n * at the time of ending the response (if there is one).\n */\n// Exported for unit tests\nexport function recordRequestSession({\n  requestIsolationScope,\n  response,\n  sessionFlushingDelayMS,\n}: {\n  requestIsolationScope: Scope;\n  response: EventEmitter;\n  sessionFlushingDelayMS?: number;\n}): void {\n  requestIsolationScope.setSDKProcessingMetadata({\n    requestSession: { status: 'ok' },\n  });\n  response.once('close', () => {\n    // We need to grab the client off the current scope instead of the isolation scope because the isolation scope doesn't hold any client out of the box.\n    const client = getClient();\n    const requestSession = requestIsolationScope.getScopeData().sdkProcessingMetadata.requestSession;\n\n    if (client && requestSession) {\n      DEBUG_BUILD && logger.debug(`Recorded request session with status: ${requestSession.status}`);\n\n      const roundedDate = new Date();\n      roundedDate.setSeconds(0, 0);\n      const dateBucketKey = roundedDate.toISOString();\n\n      const existingClientAggregate = clientToRequestSessionAggregatesMap.get(client);\n      const bucket = existingClientAggregate?.[dateBucketKey] || { exited: 0, crashed: 0, errored: 0 };\n      bucket[({ ok: 'exited', crashed: 'crashed', errored: 'errored' } as const)[requestSession.status]]++;\n\n      if (existingClientAggregate) {\n        existingClientAggregate[dateBucketKey] = bucket;\n      } else {\n        DEBUG_BUILD && logger.debug('Opened new request session aggregate.');\n        const newClientAggregate = { [dateBucketKey]: bucket };\n        clientToRequestSessionAggregatesMap.set(client, newClientAggregate);\n\n        const flushPendingClientAggregates = (): void => {\n          clearTimeout(timeout);\n          unregisterClientFlushHook();\n          clientToRequestSessionAggregatesMap.delete(client);\n\n          const aggregatePayload: AggregationCounts[] = Object.entries(newClientAggregate).map(\n            ([timestamp, value]) => ({\n              started: timestamp,\n              exited: value.exited,\n              errored: value.errored,\n              crashed: value.crashed,\n            }),\n          );\n          client.sendSession({ aggregates: aggregatePayload });\n        };\n\n        const unregisterClientFlushHook = client.on('flush', () => {\n          DEBUG_BUILD && logger.debug('Sending request session aggregate due to client flush');\n          flushPendingClientAggregates();\n        });\n        const timeout = setTimeout(() => {\n          DEBUG_BUILD && logger.debug('Sending request session aggregate due to flushing schedule');\n          flushPendingClientAggregates();\n        }, sessionFlushingDelayMS).unref();\n      }\n    }\n  });\n}\n\nconst clientToRequestSessionAggregatesMap = new Map<\n  Client,\n  { [timestampRoundedToSeconds: string]: { exited: number; crashed: number; errored: number } }\n>();\n"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"SentryHttpInstrumentation.js","sources":["../../../../src/integrations/http/SentryHttpInstrumentation.ts"],"sourcesContent":["/* eslint-disable max-lines */\nimport { context, propagation } from '@opentelemetry/api';\nimport type { InstrumentationConfig } from '@opentelemetry/instrumentation';\nimport { InstrumentationBase, InstrumentationNodeModuleDefinition } from '@opentelemetry/instrumentation';\nimport type { AggregationCounts, Client, RequestEventData, SanitizedRequestData, Scope } from '@sentry/core';\nimport {\n  addBreadcrumb,\n  generateSpanId,\n  getBreadcrumbLogLevelFromHttpStatusCode,\n  getClient,\n  getCurrentScope,\n  getIsolationScope,\n  getSanitizedUrlString,\n  httpRequestToRequestData,\n  logger,\n  parseUrl,\n  stripUrlQueryAndFragment,\n  withIsolationScope,\n} from '@sentry/core';\nimport type * as http from 'node:http';\nimport type { IncomingMessage, RequestOptions } from 'node:http';\nimport type * as https from 'node:https';\nimport type { EventEmitter } from 'node:stream';\nimport { DEBUG_BUILD } from '../../debug-build';\nimport { getRequestUrl } from '../../utils/getRequestUrl';\nimport { stealthWrap } from './utils';\nimport { getRequestInfo } from './vendor/getRequestInfo';\n\ntype Http = typeof http;\ntype Https = typeof https;\n\nexport type SentryHttpInstrumentationOptions = InstrumentationConfig & {\n  /**\n   * Whether breadcrumbs should be recorded for requests.\n   *\n   * @default `true`\n   */\n  breadcrumbs?: boolean;\n\n  /**\n   * Whether to extract the trace ID from the `sentry-trace` header for incoming requests.\n   * By default this is done by the HttpInstrumentation, but if that is not added (e.g. because tracing is disabled, ...)\n   * then this instrumentation can take over.\n   *\n   * @default `false`\n   */\n  extractIncomingTraceFromHeader?: boolean;\n\n  /**\n   * Do not capture breadcrumbs for outgoing HTTP requests to URLs where the given callback returns `true`.\n   * For the scope of this instrumentation, this callback only controls breadcrumb creation.\n   * The same option can be passed to the top-level httpIntegration where it controls both, breadcrumb and\n   * span creation.\n   *\n   * @param url Contains the entire URL, including query string (if any), protocol, host, etc. of the outgoing request.\n   * @param request Contains the {@type RequestOptions} object used to make the outgoing request.\n   */\n  ignoreOutgoingRequests?: (url: string, request: RequestOptions) => boolean;\n\n  /**\n   * Do not capture the request body for incoming HTTP requests to URLs where the given callback returns `true`.\n   * This can be useful for long running requests where the body is not needed and we want to avoid capturing it.\n   *\n   * @param url Contains the entire URL, including query string (if any), protocol, host, etc. of the outgoing request.\n   * @param request Contains the {@type RequestOptions} object used to make the outgoing request.\n   */\n  ignoreIncomingRequestBody?: (url: string, request: RequestOptions) => boolean;\n\n  /**\n   * Whether the integration should create [Sessions](https://docs.sentry.io/product/releases/health/#sessions) for incoming requests to track the health and crash-free rate of your releases in Sentry.\n   * Read more about Release Health: https://docs.sentry.io/product/releases/health/\n   *\n   * Defaults to `true`.\n   */\n  trackIncomingRequestsAsSessions?: boolean;\n\n  /**\n   * Number of milliseconds until sessions tracked with `trackIncomingRequestsAsSessions` will be flushed as a session aggregate.\n   *\n   * Defaults to `60000` (60s).\n   */\n  sessionFlushingDelayMS?: number;\n};\n\n// We only want to capture request bodies up to 1mb.\nconst MAX_BODY_BYTE_LENGTH = 1024 * 1024;\n\n/**\n * This custom HTTP instrumentation is used to isolate incoming requests and annotate them with additional information.\n * It does not emit any spans.\n *\n * The reason this is isolated from the OpenTelemetry instrumentation is that users may overwrite this,\n * which would lead to Sentry not working as expected.\n *\n * Important note: Contrary to other OTEL instrumentation, this one cannot be unwrapped.\n * It only does minimal things though and does not emit any spans.\n *\n * This is heavily inspired & adapted from:\n * https://github.com/open-telemetry/opentelemetry-js/blob/f8ab5592ddea5cba0a3b33bf8d74f27872c0367f/experimental/packages/opentelemetry-instrumentation-http/src/http.ts\n */\nexport class SentryHttpInstrumentation extends InstrumentationBase<SentryHttpInstrumentationOptions> {\n  public constructor(config: SentryHttpInstrumentationOptions = {}) {\n    super('@sentry/instrumentation-http', '2.0.0', config);\n  }\n\n  /** @inheritdoc */\n  public init(): [InstrumentationNodeModuleDefinition, InstrumentationNodeModuleDefinition] {\n    return [this._getHttpsInstrumentation(), this._getHttpInstrumentation()];\n  }\n\n  /** Get the instrumentation for the http module. */\n  private _getHttpInstrumentation(): InstrumentationNodeModuleDefinition {\n    return new InstrumentationNodeModuleDefinition(\n      'http',\n      ['*'],\n      (moduleExports: Http): Http => {\n        // Patch incoming requests for request isolation\n        stealthWrap(moduleExports.Server.prototype, 'emit', this._getPatchIncomingRequestFunction());\n\n        // Patch outgoing requests for breadcrumbs\n        const patchedRequest = stealthWrap(moduleExports, 'request', this._getPatchOutgoingRequestFunction());\n        stealthWrap(moduleExports, 'get', this._getPatchOutgoingGetFunction(patchedRequest));\n\n        return moduleExports;\n      },\n      () => {\n        // no unwrap here\n      },\n    );\n  }\n\n  /** Get the instrumentation for the https module. */\n  private _getHttpsInstrumentation(): InstrumentationNodeModuleDefinition {\n    return new InstrumentationNodeModuleDefinition(\n      'https',\n      ['*'],\n      (moduleExports: Https): Https => {\n        // Patch incoming requests for request isolation\n        stealthWrap(moduleExports.Server.prototype, 'emit', this._getPatchIncomingRequestFunction());\n\n        // Patch outgoing requests for breadcrumbs\n        const patchedRequest = stealthWrap(moduleExports, 'request', this._getPatchOutgoingRequestFunction());\n        stealthWrap(moduleExports, 'get', this._getPatchOutgoingGetFunction(patchedRequest));\n\n        return moduleExports;\n      },\n      () => {\n        // no unwrap here\n      },\n    );\n  }\n\n  /**\n   * Patch the incoming request function for request isolation.\n   */\n  private _getPatchIncomingRequestFunction(): (\n    original: (event: string, ...args: unknown[]) => boolean,\n  ) => (this: unknown, event: string, ...args: unknown[]) => boolean {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const instrumentation = this;\n    const { ignoreIncomingRequestBody } = instrumentation.getConfig();\n\n    return (\n      original: (event: string, ...args: unknown[]) => boolean,\n    ): ((this: unknown, event: string, ...args: unknown[]) => boolean) => {\n      return function incomingRequest(this: unknown, ...args: [event: string, ...args: unknown[]]): boolean {\n        // Only traces request events\n        if (args[0] !== 'request') {\n          return original.apply(this, args);\n        }\n\n        instrumentation._diag.debug('http instrumentation for incoming request');\n\n        const isolationScope = getIsolationScope().clone();\n        const request = args[1] as http.IncomingMessage;\n        const response = args[2] as http.OutgoingMessage;\n\n        const normalizedRequest = httpRequestToRequestData(request);\n\n        // request.ip is non-standard but some frameworks set this\n        const ipAddress = (request as { ip?: string }).ip || request.socket?.remoteAddress;\n\n        const url = request.url || '/';\n        if (!ignoreIncomingRequestBody?.(url, request)) {\n          patchRequestToCaptureBody(request, isolationScope);\n        }\n\n        // Update the isolation scope, isolate this request\n        isolationScope.setSDKProcessingMetadata({ normalizedRequest, ipAddress });\n\n        // attempt to update the scope's `transactionName` based on the request URL\n        // Ideally, framework instrumentations coming after the HttpInstrumentation\n        // update the transactionName once we get a parameterized route.\n        const httpMethod = (request.method || 'GET').toUpperCase();\n        const httpTarget = stripUrlQueryAndFragment(url);\n\n        const bestEffortTransactionName = `${httpMethod} ${httpTarget}`;\n\n        isolationScope.setTransactionName(bestEffortTransactionName);\n\n        if (instrumentation.getConfig().trackIncomingRequestsAsSessions !== false) {\n          recordRequestSession({\n            requestIsolationScope: isolationScope,\n            response,\n            sessionFlushingDelayMS: instrumentation.getConfig().sessionFlushingDelayMS ?? 60_000,\n          });\n        }\n\n        return withIsolationScope(isolationScope, () => {\n          // Set a new propagationSpanId for this request\n          // We rely on the fact that `withIsolationScope()` will implicitly also fork the current scope\n          // This way we can save an \"unnecessary\" `withScope()` invocation\n          getCurrentScope().getPropagationContext().propagationSpanId = generateSpanId();\n\n          // If we don't want to extract the trace from the header, we can skip this\n          if (!instrumentation.getConfig().extractIncomingTraceFromHeader) {\n            return original.apply(this, args);\n          }\n\n          const ctx = propagation.extract(context.active(), normalizedRequest.headers);\n          return context.with(ctx, () => {\n            return original.apply(this, args);\n          });\n        });\n      };\n    };\n  }\n\n  /**\n   * Patch the outgoing request function for breadcrumbs.\n   */\n  private _getPatchOutgoingRequestFunction(): (\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    original: (...args: any[]) => http.ClientRequest,\n  ) => (options: URL | http.RequestOptions | string, ...args: unknown[]) => http.ClientRequest {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const instrumentation = this;\n\n    return (original: (...args: unknown[]) => http.ClientRequest): ((...args: unknown[]) => http.ClientRequest) => {\n      return function outgoingRequest(this: unknown, ...args: unknown[]): http.ClientRequest {\n        instrumentation._diag.debug('http instrumentation for outgoing requests');\n\n        // Making a copy to avoid mutating the original args array\n        // We need to access and reconstruct the request options object passed to `ignoreOutgoingRequests`\n        // so that it matches what Otel instrumentation passes to `ignoreOutgoingRequestHook`.\n        // @see https://github.com/open-telemetry/opentelemetry-js/blob/7293e69c1e55ca62e15d0724d22605e61bd58952/experimental/packages/opentelemetry-instrumentation-http/src/http.ts#L756-L789\n        const argsCopy = [...args];\n\n        const options = argsCopy.shift() as URL | http.RequestOptions | string;\n\n        const extraOptions =\n          typeof argsCopy[0] === 'object' && (typeof options === 'string' || options instanceof URL)\n            ? (argsCopy.shift() as http.RequestOptions)\n            : undefined;\n\n        const { optionsParsed } = getRequestInfo(instrumentation._diag, options, extraOptions);\n\n        const request = original.apply(this, args) as ReturnType<typeof http.request>;\n\n        request.prependListener('response', (response: http.IncomingMessage) => {\n          const _breadcrumbs = instrumentation.getConfig().breadcrumbs;\n          const breadCrumbsEnabled = typeof _breadcrumbs === 'undefined' ? true : _breadcrumbs;\n\n          const _ignoreOutgoingRequests = instrumentation.getConfig().ignoreOutgoingRequests;\n          const shouldCreateBreadcrumb =\n            typeof _ignoreOutgoingRequests === 'function'\n              ? !_ignoreOutgoingRequests(getRequestUrl(request), optionsParsed)\n              : true;\n\n          if (breadCrumbsEnabled && shouldCreateBreadcrumb) {\n            addRequestBreadcrumb(request, response);\n          }\n        });\n\n        return request;\n      };\n    };\n  }\n\n  /** Path the outgoing get function for breadcrumbs. */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private _getPatchOutgoingGetFunction(clientRequest: (...args: any[]) => http.ClientRequest) {\n    return (_original: unknown): ((...args: unknown[]) => http.ClientRequest) => {\n      // Re-implement http.get. This needs to be done (instead of using\n      // getPatchOutgoingRequestFunction to patch it) because we need to\n      // set the trace context header before the returned http.ClientRequest is\n      // ended. The Node.js docs state that the only differences between\n      // request and get are that (1) get defaults to the HTTP GET method and\n      // (2) the returned request object is ended immediately. The former is\n      // already true (at least in supported Node versions up to v10), so we\n      // simply follow the latter. Ref:\n      // https://nodejs.org/dist/latest/docs/api/http.html#http_http_get_options_callback\n      // https://github.com/googleapis/cloud-trace-nodejs/blob/master/src/instrumentations/instrumentation-http.ts#L198\n      return function outgoingGetRequest(...args: unknown[]): http.ClientRequest {\n        const req = clientRequest(...args);\n        req.end();\n        return req;\n      };\n    };\n  }\n}\n\n/** Add a breadcrumb for outgoing requests. */\nfunction addRequestBreadcrumb(request: http.ClientRequest, response: http.IncomingMessage): void {\n  const data = getBreadcrumbData(request);\n\n  const statusCode = response.statusCode;\n  const level = getBreadcrumbLogLevelFromHttpStatusCode(statusCode);\n\n  addBreadcrumb(\n    {\n      category: 'http',\n      data: {\n        status_code: statusCode,\n        ...data,\n      },\n      type: 'http',\n      level,\n    },\n    {\n      event: 'response',\n      request,\n      response,\n    },\n  );\n}\n\nfunction getBreadcrumbData(request: http.ClientRequest): Partial<SanitizedRequestData> {\n  try {\n    // `request.host` does not contain the port, but the host header does\n    const host = request.getHeader('host') || request.host;\n    const url = new URL(request.path, `${request.protocol}//${host}`);\n    const parsedUrl = parseUrl(url.toString());\n\n    const data: Partial<SanitizedRequestData> = {\n      url: getSanitizedUrlString(parsedUrl),\n      'http.method': request.method || 'GET',\n    };\n\n    if (parsedUrl.search) {\n      data['http.query'] = parsedUrl.search;\n    }\n    if (parsedUrl.hash) {\n      data['http.fragment'] = parsedUrl.hash;\n    }\n\n    return data;\n  } catch {\n    return {};\n  }\n}\n\n/**\n * This method patches the request object to capture the body.\n * Instead of actually consuming the streamed body ourselves, which has potential side effects,\n * we monkey patch `req.on('data')` to intercept the body chunks.\n * This way, we only read the body if the user also consumes the body, ensuring we do not change any behavior in unexpected ways.\n */\nfunction patchRequestToCaptureBody(req: IncomingMessage, isolationScope: Scope): void {\n  const chunks: Buffer[] = [];\n\n  function getChunksSize(): number {\n    return chunks.reduce((acc, chunk) => acc + chunk.byteLength, 0);\n  }\n\n  /**\n   * We need to keep track of the original callbacks, in order to be able to remove listeners again.\n   * Since `off` depends on having the exact same function reference passed in, we need to be able to map\n   * original listeners to our wrapped ones.\n   */\n  const callbackMap = new WeakMap();\n\n  try {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    req.on = new Proxy(req.on, {\n      apply: (target, thisArg, args: Parameters<typeof req.on>) => {\n        const [event, listener, ...restArgs] = args;\n\n        if (event === 'data') {\n          const callback = new Proxy(listener, {\n            apply: (target, thisArg, args: Parameters<typeof listener>) => {\n              // If we have already read more than the max body length, we stop adding chunks\n              // To avoid growing the memory indefinitely if a response is e.g. streamed\n              if (getChunksSize() < MAX_BODY_BYTE_LENGTH) {\n                const chunk = args[0] as Buffer;\n                chunks.push(chunk);\n              } else if (DEBUG_BUILD) {\n                logger.log(\n                  `Dropping request body chunk because it maximum body length of ${MAX_BODY_BYTE_LENGTH}b is exceeded.`,\n                );\n              }\n\n              return Reflect.apply(target, thisArg, args);\n            },\n          });\n\n          callbackMap.set(listener, callback);\n\n          return Reflect.apply(target, thisArg, [event, callback, ...restArgs]);\n        }\n\n        if (event === 'end') {\n          const callback = new Proxy(listener, {\n            apply: (target, thisArg, args) => {\n              try {\n                const body = Buffer.concat(chunks).toString('utf-8');\n\n                if (body) {\n                  const normalizedRequest = { data: body } satisfies RequestEventData;\n                  isolationScope.setSDKProcessingMetadata({ normalizedRequest });\n                }\n              } catch {\n                // ignore errors here\n              }\n\n              return Reflect.apply(target, thisArg, args);\n            },\n          });\n\n          callbackMap.set(listener, callback);\n\n          return Reflect.apply(target, thisArg, [event, callback, ...restArgs]);\n        }\n\n        return Reflect.apply(target, thisArg, args);\n      },\n    });\n\n    // Ensure we also remove callbacks correctly\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    req.off = new Proxy(req.off, {\n      apply: (target, thisArg, args: Parameters<typeof req.off>) => {\n        const [, listener] = args;\n\n        const callback = callbackMap.get(listener);\n        if (callback) {\n          callbackMap.delete(listener);\n\n          const modifiedArgs = args.slice();\n          modifiedArgs[1] = callback;\n          return Reflect.apply(target, thisArg, modifiedArgs);\n        }\n\n        return Reflect.apply(target, thisArg, args);\n      },\n    });\n  } catch {\n    // ignore errors if we can't patch stuff\n  }\n}\n\n/**\n * Starts a session and tracks it in the context of a given isolation scope.\n * When the passed response is finished, the session is put into a task and is\n * aggregated with other sessions that may happen in a certain time window\n * (sessionFlushingDelayMs).\n *\n * The sessions are always aggregated by the client that is on the current scope\n * at the time of ending the response (if there is one).\n */\n// Exported for unit tests\nexport function recordRequestSession({\n  requestIsolationScope,\n  response,\n  sessionFlushingDelayMS,\n}: {\n  requestIsolationScope: Scope;\n  response: EventEmitter;\n  sessionFlushingDelayMS?: number;\n}): void {\n  requestIsolationScope.setSDKProcessingMetadata({\n    requestSession: { status: 'ok' },\n  });\n  response.once('close', () => {\n    // We need to grab the client off the current scope instead of the isolation scope because the isolation scope doesn't hold any client out of the box.\n    const client = getClient();\n    const requestSession = requestIsolationScope.getScopeData().sdkProcessingMetadata.requestSession;\n\n    if (client && requestSession) {\n      DEBUG_BUILD && logger.debug(`Recorded request session with status: ${requestSession.status}`);\n\n      const roundedDate = new Date();\n      roundedDate.setSeconds(0, 0);\n      const dateBucketKey = roundedDate.toISOString();\n\n      const existingClientAggregate = clientToRequestSessionAggregatesMap.get(client);\n      const bucket = existingClientAggregate?.[dateBucketKey] || { exited: 0, crashed: 0, errored: 0 };\n      bucket[({ ok: 'exited', crashed: 'crashed', errored: 'errored' } as const)[requestSession.status]]++;\n\n      if (existingClientAggregate) {\n        existingClientAggregate[dateBucketKey] = bucket;\n      } else {\n        DEBUG_BUILD && logger.debug('Opened new request session aggregate.');\n        const newClientAggregate = { [dateBucketKey]: bucket };\n        clientToRequestSessionAggregatesMap.set(client, newClientAggregate);\n\n        const flushPendingClientAggregates = (): void => {\n          clearTimeout(timeout);\n          unregisterClientFlushHook();\n          clientToRequestSessionAggregatesMap.delete(client);\n\n          const aggregatePayload: AggregationCounts[] = Object.entries(newClientAggregate).map(\n            ([timestamp, value]) => ({\n              started: timestamp,\n              exited: value.exited,\n              errored: value.errored,\n              crashed: value.crashed,\n            }),\n          );\n          client.sendSession({ aggregates: aggregatePayload });\n        };\n\n        const unregisterClientFlushHook = client.on('flush', () => {\n          DEBUG_BUILD && logger.debug('Sending request session aggregate due to client flush');\n          flushPendingClientAggregates();\n        });\n        const timeout = setTimeout(() => {\n          DEBUG_BUILD && logger.debug('Sending request session aggregate due to flushing schedule');\n          flushPendingClientAggregates();\n        }, sessionFlushingDelayMS).unref();\n      }\n    }\n  });\n}\n\nconst clientToRequestSessionAggregatesMap = new Map<\n  Client,\n  { [timestampRoundedToSeconds: string]: { exited: number; crashed: number; errored: number } }\n>();\n"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/build/esm/integrations/http/SentryHttpInstrumentationBeforeOtel.js b/build/esm/integrations/http/SentryHttpInstrumentationBeforeOtel.js
index 8f8d45700daaea59029fd0e947dc52ab0f2cdada..54b96535eeffa0d0fa71d8eb1728c62d8db1bf37 100644
--- a/build/esm/integrations/http/SentryHttpInstrumentationBeforeOtel.js
+++ b/build/esm/integrations/http/SentryHttpInstrumentationBeforeOtel.js
@@ -1,4 +1,3 @@
-import { VERSION } from '@opentelemetry/core';
 import { InstrumentationBase, InstrumentationNodeModuleDefinition } from '@opentelemetry/instrumentation';
 import { vercelWaitUntil, logger, flush } from '@sentry/core';
 import { DEBUG_BUILD } from '../../debug-build.js';
@@ -20,7 +19,7 @@ import { stealthWrap } from './utils.js';
  */
 class SentryHttpInstrumentationBeforeOtel extends InstrumentationBase {
    constructor() {
-    super('@sentry/instrumentation-http-before-otel', VERSION, {});
+    super('@sentry/instrumentation-http-before-otel', "2.0.0", {});
   }
 
   // eslint-disable-next-line jsdoc/require-jsdoc
diff --git a/build/esm/integrations/http/SentryHttpInstrumentationBeforeOtel.js.map b/build/esm/integrations/http/SentryHttpInstrumentationBeforeOtel.js.map
index 8f438562b3dc4d2f13f96f0e9c6644d97e6cab02..6fc1d666eba747471ae1b74bff21d493c5883c24 100644
--- a/build/esm/integrations/http/SentryHttpInstrumentationBeforeOtel.js.map
+++ b/build/esm/integrations/http/SentryHttpInstrumentationBeforeOtel.js.map
@@ -1 +1 @@
-{"version":3,"file":"SentryHttpInstrumentationBeforeOtel.js","sources":["../../../../src/integrations/http/SentryHttpInstrumentationBeforeOtel.ts"],"sourcesContent":["import { VERSION } from '@opentelemetry/core';\nimport { InstrumentationBase, InstrumentationNodeModuleDefinition } from '@opentelemetry/instrumentation';\nimport { flush, logger, vercelWaitUntil } from '@sentry/core';\nimport type * as http from 'node:http';\nimport type * as https from 'node:https';\nimport { DEBUG_BUILD } from '../../debug-build';\nimport { stealthWrap } from './utils';\n\ntype Http = typeof http;\ntype Https = typeof https;\n\n// The reason this \"before OTEL\" integration even exists is due to timing reasons. We need to be able to register a\n// `res.on('close')` handler **after** OTEL registers its own handler (which it uses to end spans), so that we can do\n// something (ie. flush) after OTEL has ended a span for a request. If you think about it like an onion:\n//\n// (Sentry after OTEL instrumentation\n//   (OTEL instrumentation\n//     (Sentry before OTEL instrumentation\n//       (orig HTTP request handler))))\n//\n// registering an instrumentation before OTEL allows us to do this for incoming requests.\n\n/**\n * A Sentry specific http instrumentation that is applied before the otel instrumentation.\n */\nexport class SentryHttpInstrumentationBeforeOtel extends InstrumentationBase {\n  public constructor() {\n    super('@sentry/instrumentation-http-before-otel', VERSION, {});\n  }\n\n  // eslint-disable-next-line jsdoc/require-jsdoc\n  public init(): [InstrumentationNodeModuleDefinition, InstrumentationNodeModuleDefinition] {\n    return [this._getHttpsInstrumentation(), this._getHttpInstrumentation()];\n  }\n\n  /** Get the instrumentation for the http module. */\n  private _getHttpInstrumentation(): InstrumentationNodeModuleDefinition {\n    return new InstrumentationNodeModuleDefinition('http', ['*'], (moduleExports: Http): Http => {\n      // Patch incoming requests\n      stealthWrap(moduleExports.Server.prototype, 'emit', this._getPatchIncomingRequestFunction());\n\n      return moduleExports;\n    });\n  }\n\n  /** Get the instrumentation for the https module. */\n  private _getHttpsInstrumentation(): InstrumentationNodeModuleDefinition {\n    return new InstrumentationNodeModuleDefinition('https', ['*'], (moduleExports: Https): Https => {\n      // Patch incoming requests\n      stealthWrap(moduleExports.Server.prototype, 'emit', this._getPatchIncomingRequestFunction());\n\n      return moduleExports;\n    });\n  }\n\n  /**\n   * Patch the incoming request function for request isolation.\n   */\n  private _getPatchIncomingRequestFunction(): (\n    original: (event: string, ...args: unknown[]) => boolean,\n  ) => (this: unknown, event: string, ...args: unknown[]) => boolean {\n    return (\n      original: (event: string, ...args: unknown[]) => boolean,\n    ): ((this: unknown, event: string, ...args: unknown[]) => boolean) => {\n      return function incomingRequest(this: unknown, ...args: [event: string, ...args: unknown[]]): boolean {\n        // Only traces request events\n        if (args[0] !== 'request') {\n          return original.apply(this, args);\n        }\n\n        const response = args[1] as http.OutgoingMessage;\n\n        patchResponseToFlushOnServerlessPlatforms(response);\n\n        return original.apply(this, args);\n      };\n    };\n  }\n}\n\nfunction patchResponseToFlushOnServerlessPlatforms(res: http.OutgoingMessage): void {\n  // Freely extend this function with other platforms if necessary\n  if (process.env.VERCEL) {\n    // In some cases res.end does not seem to be defined leading to errors if passed to Proxy\n    // https://github.com/getsentry/sentry-javascript/issues/15759\n    if (typeof res.end === 'function') {\n      let markOnEndDone = (): void => undefined;\n      const onEndDonePromise = new Promise<void>(res => {\n        markOnEndDone = res;\n      });\n\n      res.on('close', () => {\n        markOnEndDone();\n      });\n\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      res.end = new Proxy(res.end, {\n        apply(target, thisArg, argArray) {\n          vercelWaitUntil(\n            new Promise<void>(finishWaitUntil => {\n              // Define a timeout that unblocks the lambda just to be safe so we're not indefinitely keeping it alive, exploding server bills\n              const timeout = setTimeout(() => {\n                finishWaitUntil();\n              }, 2000);\n\n              onEndDonePromise\n                .then(() => {\n                  DEBUG_BUILD && logger.log('Flushing events before Vercel Lambda freeze');\n                  return flush(2000);\n                })\n                .then(\n                  () => {\n                    clearTimeout(timeout);\n                    finishWaitUntil();\n                  },\n                  e => {\n                    clearTimeout(timeout);\n                    DEBUG_BUILD && logger.log('Error while flushing events for Vercel:\\n', e);\n                    finishWaitUntil();\n                  },\n                );\n            }),\n          );\n\n          return target.apply(thisArg, argArray);\n        },\n      });\n    }\n  }\n}\n"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"SentryHttpInstrumentationBeforeOtel.js","sources":["../../../../src/integrations/http/SentryHttpInstrumentationBeforeOtel.ts"],"sourcesContent":["import { InstrumentationBase, InstrumentationNodeModuleDefinition } from '@opentelemetry/instrumentation';\nimport { flush, logger, vercelWaitUntil } from '@sentry/core';\nimport type * as http from 'node:http';\nimport type * as https from 'node:https';\nimport { DEBUG_BUILD } from '../../debug-build';\nimport { stealthWrap } from './utils';\n\ntype Http = typeof http;\ntype Https = typeof https;\n\n// The reason this \"before OTEL\" integration even exists is due to timing reasons. We need to be able to register a\n// `res.on('close')` handler **after** OTEL registers its own handler (which it uses to end spans), so that we can do\n// something (ie. flush) after OTEL has ended a span for a request. If you think about it like an onion:\n//\n// (Sentry after OTEL instrumentation\n//   (OTEL instrumentation\n//     (Sentry before OTEL instrumentation\n//       (orig HTTP request handler))))\n//\n// registering an instrumentation before OTEL allows us to do this for incoming requests.\n\n/**\n * A Sentry specific http instrumentation that is applied before the otel instrumentation.\n */\nexport class SentryHttpInstrumentationBeforeOtel extends InstrumentationBase {\n  public constructor() {\n    super('@sentry/instrumentation-http-before-otel', \"2.0.0\", {});\n  }\n\n  // eslint-disable-next-line jsdoc/require-jsdoc\n  public init(): [InstrumentationNodeModuleDefinition, InstrumentationNodeModuleDefinition] {\n    return [this._getHttpsInstrumentation(), this._getHttpInstrumentation()];\n  }\n\n  /** Get the instrumentation for the http module. */\n  private _getHttpInstrumentation(): InstrumentationNodeModuleDefinition {\n    return new InstrumentationNodeModuleDefinition('http', ['*'], (moduleExports: Http): Http => {\n      // Patch incoming requests\n      stealthWrap(moduleExports.Server.prototype, 'emit', this._getPatchIncomingRequestFunction());\n\n      return moduleExports;\n    });\n  }\n\n  /** Get the instrumentation for the https module. */\n  private _getHttpsInstrumentation(): InstrumentationNodeModuleDefinition {\n    return new InstrumentationNodeModuleDefinition('https', ['*'], (moduleExports: Https): Https => {\n      // Patch incoming requests\n      stealthWrap(moduleExports.Server.prototype, 'emit', this._getPatchIncomingRequestFunction());\n\n      return moduleExports;\n    });\n  }\n\n  /**\n   * Patch the incoming request function for request isolation.\n   */\n  private _getPatchIncomingRequestFunction(): (\n    original: (event: string, ...args: unknown[]) => boolean,\n  ) => (this: unknown, event: string, ...args: unknown[]) => boolean {\n    return (\n      original: (event: string, ...args: unknown[]) => boolean,\n    ): ((this: unknown, event: string, ...args: unknown[]) => boolean) => {\n      return function incomingRequest(this: unknown, ...args: [event: string, ...args: unknown[]]): boolean {\n        // Only traces request events\n        if (args[0] !== 'request') {\n          return original.apply(this, args);\n        }\n\n        const response = args[1] as http.OutgoingMessage;\n\n        patchResponseToFlushOnServerlessPlatforms(response);\n\n        return original.apply(this, args);\n      };\n    };\n  }\n}\n\nfunction patchResponseToFlushOnServerlessPlatforms(res: http.OutgoingMessage): void {\n  // Freely extend this function with other platforms if necessary\n  if (process.env.VERCEL) {\n    // In some cases res.end does not seem to be defined leading to errors if passed to Proxy\n    // https://github.com/getsentry/sentry-javascript/issues/15759\n    if (typeof res.end === 'function') {\n      let markOnEndDone = (): void => undefined;\n      const onEndDonePromise = new Promise<void>(res => {\n        markOnEndDone = res;\n      });\n\n      res.on('close', () => {\n        markOnEndDone();\n      });\n\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      res.end = new Proxy(res.end, {\n        apply(target, thisArg, argArray) {\n          vercelWaitUntil(\n            new Promise<void>(finishWaitUntil => {\n              // Define a timeout that unblocks the lambda just to be safe so we're not indefinitely keeping it alive, exploding server bills\n              const timeout = setTimeout(() => {\n                finishWaitUntil();\n              }, 2000);\n\n              onEndDonePromise\n                .then(() => {\n                  DEBUG_BUILD && logger.log('Flushing events before Vercel Lambda freeze');\n                  return flush(2000);\n                })\n                .then(\n                  () => {\n                    clearTimeout(timeout);\n                    finishWaitUntil();\n                  },\n                  e => {\n                    clearTimeout(timeout);\n                    DEBUG_BUILD && logger.log('Error while flushing events for Vercel:\\n', e);\n                    finishWaitUntil();\n                  },\n                );\n            }),\n          );\n\n          return target.apply(thisArg, argArray);\n        },\n      });\n    }\n  }\n}\n"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/build/esm/integrations/local-variables/local-variables-async.js b/build/esm/integrations/local-variables/local-variables-async.js
index c33d7fc3c1e3c8fff27d1da7e1649f609fbd14a5..2e4bace30a1999c2d37dd8efbff1a245f7eb54d2 100644
--- a/build/esm/integrations/local-variables/local-variables-async.js
+++ b/build/esm/integrations/local-variables/local-variables-async.js
@@ -4,7 +4,7 @@ import { isDebuggerEnabled } from '../../utils/debug.js';
 import { LOCAL_VARIABLES_KEY, functionNamesMatch } from './common.js';
 
 // This string is a placeholder that gets overwritten with the worker code.
-const base64WorkerScript = 'LyohIEBzZW50cnkvbm9kZSA5LjEyLjAgKDRlYjc4ZTUpIHwgaHR0cHM6Ly9naXRodWIuY29tL2dldHNlbnRyeS9zZW50cnktamF2YXNjcmlwdCAqLwppbXBvcnR7U2Vzc2lvbiBhcyBlfWZyb20ibm9kZTppbnNwZWN0b3IvcHJvbWlzZXMiO2ltcG9ydHt3b3JrZXJEYXRhIGFzIHR9ZnJvbSJub2RlOndvcmtlcl90aHJlYWRzIjtjb25zdCBuPWdsb2JhbFRoaXMsbz0idW5kZWZpbmVkIj09dHlwZW9mIF9fU0VOVFJZX0RFQlVHX198fF9fU0VOVFJZX0RFQlVHX18saT0iOS4xMi4wIjtjb25zdCBhPVsiZGVidWciLCJpbmZvIiwid2FybiIsImVycm9yIiwibG9nIiwiYXNzZXJ0IiwidHJhY2UiXSxzPXt9O2Z1bmN0aW9uIGMoZSl7aWYoISgiY29uc29sZSJpbiBuKSlyZXR1cm4gZSgpO2NvbnN0IHQ9bi5jb25zb2xlLG89e30saT1PYmplY3Qua2V5cyhzKTtpLmZvckVhY2goKGU9Pntjb25zdCBuPXNbZV07b1tlXT10W2VdLHRbZV09bn0pKTt0cnl7cmV0dXJuIGUoKX1maW5hbGx5e2kuZm9yRWFjaCgoZT0+e3RbZV09b1tlXX0pKX19IWZ1bmN0aW9uKGUsdCxvPW4pe2NvbnN0IGE9by5fX1NFTlRSWV9fPW8uX19TRU5UUllfX3x8e30scz1hW2ldPWFbaV18fHt9O3NbZV18fChzW2VdPXQoKSl9KCJsb2dnZXIiLChmdW5jdGlvbigpe2xldCBlPSExO2NvbnN0IHQ9e2VuYWJsZTooKT0+e2U9ITB9LGRpc2FibGU6KCk9PntlPSExfSxpc0VuYWJsZWQ6KCk9PmV9O3JldHVybiBvP2EuZm9yRWFjaCgobz0+e3Rbb109KC4uLnQpPT57ZSYmYygoKCk9PntuLmNvbnNvbGVbb10oYFNlbnRyeSBMb2dnZXIgWyR7b31dOmAsLi4udCl9KSl9fSkpOmEuZm9yRWFjaCgoZT0+e3RbZV09KCk9Pnt9fSkpLHR9KSk7Y29uc3Qgcj0iX19TRU5UUllfRVJST1JfTE9DQUxfVkFSSUFCTEVTX18iO2NvbnN0IHU9dDtmdW5jdGlvbiBsKC4uLmUpe3UuZGVidWcmJmMoKCgpPT5jb25zb2xlLmxvZygiW0xvY2FsVmFyaWFibGVzIFdvcmtlcl0iLC4uLmUpKSl9YXN5bmMgZnVuY3Rpb24gZihlLHQsbixvKXtjb25zdCBpPWF3YWl0IGUucG9zdCgiUnVudGltZS5nZXRQcm9wZXJ0aWVzIix7b2JqZWN0SWQ6dCxvd25Qcm9wZXJ0aWVzOiEwfSk7b1tuXT1pLnJlc3VsdC5maWx0ZXIoKGU9PiJsZW5ndGgiIT09ZS5uYW1lJiYhaXNOYU4ocGFyc2VJbnQoZS5uYW1lLDEwKSkpKS5zb3J0KCgoZSx0KT0+cGFyc2VJbnQoZS5uYW1lLDEwKS1wYXJzZUludCh0Lm5hbWUsMTApKSkubWFwKChlPT5lLnZhbHVlPy52YWx1ZSkpfWFzeW5jIGZ1bmN0aW9uIGcoZSx0LG4sbyl7Y29uc3QgaT1hd2FpdCBlLnBvc3QoIlJ1bnRpbWUuZ2V0UHJvcGVydGllcyIse29iamVjdElkOnQsb3duUHJvcGVydGllczohMH0pO29bbl09aS5yZXN1bHQubWFwKChlPT5bZS5uYW1lLGUudmFsdWU/LnZhbHVlXSkpLnJlZHVjZSgoKGUsW3Qsbl0pPT4oZVt0XT1uLGUpKSx7fSl9ZnVuY3Rpb24gZChlLHQpe2UudmFsdWUmJigidmFsdWUiaW4gZS52YWx1ZT92b2lkIDA9PT1lLnZhbHVlLnZhbHVlfHxudWxsPT09ZS52YWx1ZS52YWx1ZT90W2UubmFtZV09YDwke2UudmFsdWUudmFsdWV9PmA6dFtlLm5hbWVdPWUudmFsdWUudmFsdWU6ImRlc2NyaXB0aW9uImluIGUudmFsdWUmJiJmdW5jdGlvbiIhPT1lLnZhbHVlLnR5cGU/dFtlLm5hbWVdPWA8JHtlLnZhbHVlLmRlc2NyaXB0aW9ufT5gOiJ1bmRlZmluZWQiPT09ZS52YWx1ZS50eXBlJiYodFtlLm5hbWVdPSI8dW5kZWZpbmVkPiIpKX1hc3luYyBmdW5jdGlvbiBiKGUsdCl7Y29uc3Qgbj1hd2FpdCBlLnBvc3QoIlJ1bnRpbWUuZ2V0UHJvcGVydGllcyIse29iamVjdElkOnQsb3duUHJvcGVydGllczohMH0pLG89e307Zm9yKGNvbnN0IHQgb2Ygbi5yZXN1bHQpaWYodC52YWx1ZT8ub2JqZWN0SWQmJiJBcnJheSI9PT10LnZhbHVlLmNsYXNzTmFtZSl7Y29uc3Qgbj10LnZhbHVlLm9iamVjdElkO2F3YWl0IGYoZSxuLHQubmFtZSxvKX1lbHNlIGlmKHQudmFsdWU/Lm9iamVjdElkJiYiT2JqZWN0Ij09PXQudmFsdWUuY2xhc3NOYW1lKXtjb25zdCBuPXQudmFsdWUub2JqZWN0SWQ7YXdhaXQgZyhlLG4sdC5uYW1lLG8pfWVsc2UgdC52YWx1ZSYmZCh0LG8pO3JldHVybiBvfWxldCBwOyhhc3luYyBmdW5jdGlvbigpe2NvbnN0IHQ9bmV3IGU7dC5jb25uZWN0VG9NYWluVGhyZWFkKCksbCgiQ29ubmVjdGVkIHRvIG1haW4gdGhyZWFkIik7bGV0IG49ITE7dC5vbigiRGVidWdnZXIucmVzdW1lZCIsKCgpPT57bj0hMX0pKSx0Lm9uKCJEZWJ1Z2dlci5wYXVzZWQiLChlPT57bj0hMCxhc3luYyBmdW5jdGlvbihlLHtyZWFzb246dCxkYXRhOntvYmplY3RJZDpufSxjYWxsRnJhbWVzOm99KXtpZigiZXhjZXB0aW9uIiE9PXQmJiJwcm9taXNlUmVqZWN0aW9uIiE9PXQpcmV0dXJuO2lmKHA/LigpLG51bGw9PW4pcmV0dXJuO2NvbnN0IGk9W107Zm9yKGxldCB0PTA7dDxvLmxlbmd0aDt0Kyspe2NvbnN0e3Njb3BlQ2hhaW46bixmdW5jdGlvbk5hbWU6YSx0aGlzOnN9PW9bdF0sYz1uLmZpbmQoKGU9PiJsb2NhbCI9PT1lLnR5cGUpKSxyPSJnbG9iYWwiIT09cy5jbGFzc05hbWUmJnMuY2xhc3NOYW1lP2Ake3MuY2xhc3NOYW1lfS4ke2F9YDphO2lmKHZvaWQgMD09PWM/Lm9iamVjdC5vYmplY3RJZClpW3RdPXtmdW5jdGlvbjpyfTtlbHNle2NvbnN0IG49YXdhaXQgYihlLGMub2JqZWN0Lm9iamVjdElkKTtpW3RdPXtmdW5jdGlvbjpyLHZhcnM6bn19fWF3YWl0IGUucG9zdCgiUnVudGltZS5jYWxsRnVuY3Rpb25PbiIse2Z1bmN0aW9uRGVjbGFyYXRpb246YGZ1bmN0aW9uKCkgeyB0aGlzLiR7cn0gPSB0aGlzLiR7cn0gfHwgJHtKU09OLnN0cmluZ2lmeShpKX07IH1gLHNpbGVudDohMCxvYmplY3RJZDpufSksYXdhaXQgZS5wb3N0KCJSdW50aW1lLnJlbGVhc2VPYmplY3QiLHtvYmplY3RJZDpufSl9KHQsZS5wYXJhbXMpLnRoZW4oKGFzeW5jKCk9PntuJiZhd2FpdCB0LnBvc3QoIkRlYnVnZ2VyLnJlc3VtZSIpfSksKGFzeW5jIGU9PntuJiZhd2FpdCB0LnBvc3QoIkRlYnVnZ2VyLnJlc3VtZSIpfSkpfSkpLGF3YWl0IHQucG9zdCgiRGVidWdnZXIuZW5hYmxlIik7Y29uc3Qgbz0hMSE9PXUuY2FwdHVyZUFsbEV4Y2VwdGlvbnM7aWYoYXdhaXQgdC5wb3N0KCJEZWJ1Z2dlci5zZXRQYXVzZU9uRXhjZXB0aW9ucyIse3N0YXRlOm8/ImFsbCI6InVuY2F1Z2h0In0pLG8pe2NvbnN0IGU9dS5tYXhFeGNlcHRpb25zUGVyU2Vjb25kfHw1MDtwPWZ1bmN0aW9uKGUsdCxuKXtsZXQgbz0wLGk9NSxhPTA7cmV0dXJuIHNldEludGVydmFsKCgoKT0+ezA9PT1hP28+ZSYmKGkqPTIsbihpKSxpPjg2NDAwJiYoaT04NjQwMCksYT1pKTooYS09MSwwPT09YSYmdCgpKSxvPTB9KSwxZTMpLnVucmVmKCksKCk9PntvKz0xfX0oZSwoYXN5bmMoKT0+e2woIlJhdGUtbGltaXQgbGlmdGVkLiIpLGF3YWl0IHQucG9zdCgiRGVidWdnZXIuc2V0UGF1c2VPbkV4Y2VwdGlvbnMiLHtzdGF0ZToiYWxsIn0pfSksKGFzeW5jIGU9PntsKGBSYXRlLWxpbWl0IGV4Y2VlZGVkLiBEaXNhYmxpbmcgY2FwdHVyaW5nIG9mIGNhdWdodCBleGNlcHRpb25zIGZvciAke2V9IHNlY29uZHMuYCksYXdhaXQgdC5wb3N0KCJEZWJ1Z2dlci5zZXRQYXVzZU9uRXhjZXB0aW9ucyIse3N0YXRlOiJ1bmNhdWdodCJ9KX0pKX19KSgpLmNhdGNoKChlPT57bCgiRmFpbGVkIHRvIHN0YXJ0IGRlYnVnZ2VyIixlKX0pKSxzZXRJbnRlcnZhbCgoKCk9Pnt9KSwxZTQpOw==';
+const base64WorkerScript = 'LyohIEBzZW50cnkvbm9kZSA5LjEyLjAgKDJjZjUzMjJkOSkgfCBodHRwczovL2dpdGh1Yi5jb20vZ2V0c2VudHJ5L3NlbnRyeS1qYXZhc2NyaXB0ICovCmltcG9ydHtTZXNzaW9uIGFzIGV9ZnJvbSJub2RlOmluc3BlY3Rvci9wcm9taXNlcyI7aW1wb3J0e3dvcmtlckRhdGEgYXMgdH1mcm9tIm5vZGU6d29ya2VyX3RocmVhZHMiO2NvbnN0IG49Z2xvYmFsVGhpcyxvPSJ1bmRlZmluZWQiPT10eXBlb2YgX19TRU5UUllfREVCVUdfX3x8X19TRU5UUllfREVCVUdfXyxpPSI5LjEyLjAiO2NvbnN0IGE9WyJkZWJ1ZyIsImluZm8iLCJ3YXJuIiwiZXJyb3IiLCJsb2ciLCJhc3NlcnQiLCJ0cmFjZSJdLHM9e307ZnVuY3Rpb24gYyhlKXtpZighKCJjb25zb2xlImluIG4pKXJldHVybiBlKCk7Y29uc3QgdD1uLmNvbnNvbGUsbz17fSxpPU9iamVjdC5rZXlzKHMpO2kuZm9yRWFjaCgoZT0+e2NvbnN0IG49c1tlXTtvW2VdPXRbZV0sdFtlXT1ufSkpO3RyeXtyZXR1cm4gZSgpfWZpbmFsbHl7aS5mb3JFYWNoKChlPT57dFtlXT1vW2VdfSkpfX0hZnVuY3Rpb24oZSx0LG89bil7Y29uc3QgYT1vLl9fU0VOVFJZX189by5fX1NFTlRSWV9ffHx7fSxzPWFbaV09YVtpXXx8e307c1tlXXx8KHNbZV09dCgpKX0oImxvZ2dlciIsKGZ1bmN0aW9uKCl7bGV0IGU9ITE7Y29uc3QgdD17ZW5hYmxlOigpPT57ZT0hMH0sZGlzYWJsZTooKT0+e2U9ITF9LGlzRW5hYmxlZDooKT0+ZX07cmV0dXJuIG8/YS5mb3JFYWNoKChvPT57dFtvXT0oLi4udCk9PntlJiZjKCgoKT0+e24uY29uc29sZVtvXShgU2VudHJ5IExvZ2dlciBbJHtvfV06YCwuLi50KX0pKX19KSk6YS5mb3JFYWNoKChlPT57dFtlXT0oKT0+e319KSksdH0pKTtjb25zdCByPSJfX1NFTlRSWV9FUlJPUl9MT0NBTF9WQVJJQUJMRVNfXyI7Y29uc3QgdT10O2Z1bmN0aW9uIGwoLi4uZSl7dS5kZWJ1ZyYmYygoKCk9PmNvbnNvbGUubG9nKCJbTG9jYWxWYXJpYWJsZXMgV29ya2VyXSIsLi4uZSkpKX1hc3luYyBmdW5jdGlvbiBmKGUsdCxuLG8pe2NvbnN0IGk9YXdhaXQgZS5wb3N0KCJSdW50aW1lLmdldFByb3BlcnRpZXMiLHtvYmplY3RJZDp0LG93blByb3BlcnRpZXM6ITB9KTtvW25dPWkucmVzdWx0LmZpbHRlcigoZT0+Imxlbmd0aCIhPT1lLm5hbWUmJiFpc05hTihwYXJzZUludChlLm5hbWUsMTApKSkpLnNvcnQoKChlLHQpPT5wYXJzZUludChlLm5hbWUsMTApLXBhcnNlSW50KHQubmFtZSwxMCkpKS5tYXAoKGU9PmUudmFsdWU/LnZhbHVlKSl9YXN5bmMgZnVuY3Rpb24gZyhlLHQsbixvKXtjb25zdCBpPWF3YWl0IGUucG9zdCgiUnVudGltZS5nZXRQcm9wZXJ0aWVzIix7b2JqZWN0SWQ6dCxvd25Qcm9wZXJ0aWVzOiEwfSk7b1tuXT1pLnJlc3VsdC5tYXAoKGU9PltlLm5hbWUsZS52YWx1ZT8udmFsdWVdKSkucmVkdWNlKCgoZSxbdCxuXSk9PihlW3RdPW4sZSkpLHt9KX1mdW5jdGlvbiBkKGUsdCl7ZS52YWx1ZSYmKCJ2YWx1ZSJpbiBlLnZhbHVlP3ZvaWQgMD09PWUudmFsdWUudmFsdWV8fG51bGw9PT1lLnZhbHVlLnZhbHVlP3RbZS5uYW1lXT1gPCR7ZS52YWx1ZS52YWx1ZX0+YDp0W2UubmFtZV09ZS52YWx1ZS52YWx1ZToiZGVzY3JpcHRpb24iaW4gZS52YWx1ZSYmImZ1bmN0aW9uIiE9PWUudmFsdWUudHlwZT90W2UubmFtZV09YDwke2UudmFsdWUuZGVzY3JpcHRpb259PmA6InVuZGVmaW5lZCI9PT1lLnZhbHVlLnR5cGUmJih0W2UubmFtZV09Ijx1bmRlZmluZWQ+IikpfWFzeW5jIGZ1bmN0aW9uIGIoZSx0KXtjb25zdCBuPWF3YWl0IGUucG9zdCgiUnVudGltZS5nZXRQcm9wZXJ0aWVzIix7b2JqZWN0SWQ6dCxvd25Qcm9wZXJ0aWVzOiEwfSksbz17fTtmb3IoY29uc3QgdCBvZiBuLnJlc3VsdClpZih0LnZhbHVlPy5vYmplY3RJZCYmIkFycmF5Ij09PXQudmFsdWUuY2xhc3NOYW1lKXtjb25zdCBuPXQudmFsdWUub2JqZWN0SWQ7YXdhaXQgZihlLG4sdC5uYW1lLG8pfWVsc2UgaWYodC52YWx1ZT8ub2JqZWN0SWQmJiJPYmplY3QiPT09dC52YWx1ZS5jbGFzc05hbWUpe2NvbnN0IG49dC52YWx1ZS5vYmplY3RJZDthd2FpdCBnKGUsbix0Lm5hbWUsbyl9ZWxzZSB0LnZhbHVlJiZkKHQsbyk7cmV0dXJuIG99bGV0IHA7KGFzeW5jIGZ1bmN0aW9uKCl7Y29uc3QgdD1uZXcgZTt0LmNvbm5lY3RUb01haW5UaHJlYWQoKSxsKCJDb25uZWN0ZWQgdG8gbWFpbiB0aHJlYWQiKTtsZXQgbj0hMTt0Lm9uKCJEZWJ1Z2dlci5yZXN1bWVkIiwoKCk9PntuPSExfSkpLHQub24oIkRlYnVnZ2VyLnBhdXNlZCIsKGU9PntuPSEwLGFzeW5jIGZ1bmN0aW9uKGUse3JlYXNvbjp0LGRhdGE6e29iamVjdElkOm59LGNhbGxGcmFtZXM6b30pe2lmKCJleGNlcHRpb24iIT09dCYmInByb21pc2VSZWplY3Rpb24iIT09dClyZXR1cm47aWYocD8uKCksbnVsbD09bilyZXR1cm47Y29uc3QgaT1bXTtmb3IobGV0IHQ9MDt0PG8ubGVuZ3RoO3QrKyl7Y29uc3R7c2NvcGVDaGFpbjpuLGZ1bmN0aW9uTmFtZTphLHRoaXM6c309b1t0XSxjPW4uZmluZCgoZT0+ImxvY2FsIj09PWUudHlwZSkpLHI9Imdsb2JhbCIhPT1zLmNsYXNzTmFtZSYmcy5jbGFzc05hbWU/YCR7cy5jbGFzc05hbWV9LiR7YX1gOmE7aWYodm9pZCAwPT09Yz8ub2JqZWN0Lm9iamVjdElkKWlbdF09e2Z1bmN0aW9uOnJ9O2Vsc2V7Y29uc3Qgbj1hd2FpdCBiKGUsYy5vYmplY3Qub2JqZWN0SWQpO2lbdF09e2Z1bmN0aW9uOnIsdmFyczpufX19YXdhaXQgZS5wb3N0KCJSdW50aW1lLmNhbGxGdW5jdGlvbk9uIix7ZnVuY3Rpb25EZWNsYXJhdGlvbjpgZnVuY3Rpb24oKSB7IHRoaXMuJHtyfSA9IHRoaXMuJHtyfSB8fCAke0pTT04uc3RyaW5naWZ5KGkpfTsgfWAsc2lsZW50OiEwLG9iamVjdElkOm59KSxhd2FpdCBlLnBvc3QoIlJ1bnRpbWUucmVsZWFzZU9iamVjdCIse29iamVjdElkOm59KX0odCxlLnBhcmFtcykudGhlbigoYXN5bmMoKT0+e24mJmF3YWl0IHQucG9zdCgiRGVidWdnZXIucmVzdW1lIil9KSwoYXN5bmMgZT0+e24mJmF3YWl0IHQucG9zdCgiRGVidWdnZXIucmVzdW1lIil9KSl9KSksYXdhaXQgdC5wb3N0KCJEZWJ1Z2dlci5lbmFibGUiKTtjb25zdCBvPSExIT09dS5jYXB0dXJlQWxsRXhjZXB0aW9ucztpZihhd2FpdCB0LnBvc3QoIkRlYnVnZ2VyLnNldFBhdXNlT25FeGNlcHRpb25zIix7c3RhdGU6bz8iYWxsIjoidW5jYXVnaHQifSksbyl7Y29uc3QgZT11Lm1heEV4Y2VwdGlvbnNQZXJTZWNvbmR8fDUwO3A9ZnVuY3Rpb24oZSx0LG4pe2xldCBvPTAsaT01LGE9MDtyZXR1cm4gc2V0SW50ZXJ2YWwoKCgpPT57MD09PWE/bz5lJiYoaSo9MixuKGkpLGk+ODY0MDAmJihpPTg2NDAwKSxhPWkpOihhLT0xLDA9PT1hJiZ0KCkpLG89MH0pLDFlMykudW5yZWYoKSwoKT0+e28rPTF9fShlLChhc3luYygpPT57bCgiUmF0ZS1saW1pdCBsaWZ0ZWQuIiksYXdhaXQgdC5wb3N0KCJEZWJ1Z2dlci5zZXRQYXVzZU9uRXhjZXB0aW9ucyIse3N0YXRlOiJhbGwifSl9KSwoYXN5bmMgZT0+e2woYFJhdGUtbGltaXQgZXhjZWVkZWQuIERpc2FibGluZyBjYXB0dXJpbmcgb2YgY2F1Z2h0IGV4Y2VwdGlvbnMgZm9yICR7ZX0gc2Vjb25kcy5gKSxhd2FpdCB0LnBvc3QoIkRlYnVnZ2VyLnNldFBhdXNlT25FeGNlcHRpb25zIix7c3RhdGU6InVuY2F1Z2h0In0pfSkpfX0pKCkuY2F0Y2goKGU9PntsKCJGYWlsZWQgdG8gc3RhcnQgZGVidWdnZXIiLGUpfSkpLHNldEludGVydmFsKCgoKT0+e30pLDFlNCk7';
 
 function log(...args) {
   logger.log('[LocalVariables]', ...args);
diff --git a/build/esm/integrations/local-variables/worker-script.js b/build/esm/integrations/local-variables/worker-script.js
index de1ed896d898c3450b1df5186342d945a205fa6e..b0ff53f6c6a3410e5495e7274ab09ac232b5c163 100644
--- a/build/esm/integrations/local-variables/worker-script.js
+++ b/build/esm/integrations/local-variables/worker-script.js
@@ -1,2 +1,2 @@
-/*! @sentry/node 9.12.0 (4eb78e5) | https://github.com/getsentry/sentry-javascript */
+/*! @sentry/node 9.12.0 (2cf5322d9) | https://github.com/getsentry/sentry-javascript */
 import{Session as e}from"node:inspector/promises";import{workerData as t}from"node:worker_threads";const n=globalThis,o="undefined"==typeof __SENTRY_DEBUG__||__SENTRY_DEBUG__,i="9.12.0";const a=["debug","info","warn","error","log","assert","trace"],s={};function c(e){if(!("console"in n))return e();const t=n.console,o={},i=Object.keys(s);i.forEach((e=>{const n=s[e];o[e]=t[e],t[e]=n}));try{return e()}finally{i.forEach((e=>{t[e]=o[e]}))}}!function(e,t,o=n){const a=o.__SENTRY__=o.__SENTRY__||{},s=a[i]=a[i]||{};s[e]||(s[e]=t())}("logger",(function(){let e=!1;const t={enable:()=>{e=!0},disable:()=>{e=!1},isEnabled:()=>e};return o?a.forEach((o=>{t[o]=(...t)=>{e&&c((()=>{n.console[o](`Sentry Logger [${o}]:`,...t)}))}})):a.forEach((e=>{t[e]=()=>{}})),t}));const r="__SENTRY_ERROR_LOCAL_VARIABLES__";const u=t;function l(...e){u.debug&&c((()=>console.log("[LocalVariables Worker]",...e)))}async function f(e,t,n,o){const i=await e.post("Runtime.getProperties",{objectId:t,ownProperties:!0});o[n]=i.result.filter((e=>"length"!==e.name&&!isNaN(parseInt(e.name,10)))).sort(((e,t)=>parseInt(e.name,10)-parseInt(t.name,10))).map((e=>e.value?.value))}async function g(e,t,n,o){const i=await e.post("Runtime.getProperties",{objectId:t,ownProperties:!0});o[n]=i.result.map((e=>[e.name,e.value?.value])).reduce(((e,[t,n])=>(e[t]=n,e)),{})}function d(e,t){e.value&&("value"in e.value?void 0===e.value.value||null===e.value.value?t[e.name]=`<${e.value.value}>`:t[e.name]=e.value.value:"description"in e.value&&"function"!==e.value.type?t[e.name]=`<${e.value.description}>`:"undefined"===e.value.type&&(t[e.name]="<undefined>"))}async function b(e,t){const n=await e.post("Runtime.getProperties",{objectId:t,ownProperties:!0}),o={};for(const t of n.result)if(t.value?.objectId&&"Array"===t.value.className){const n=t.value.objectId;await f(e,n,t.name,o)}else if(t.value?.objectId&&"Object"===t.value.className){const n=t.value.objectId;await g(e,n,t.name,o)}else t.value&&d(t,o);return o}let p;(async function(){const t=new e;t.connectToMainThread(),l("Connected to main thread");let n=!1;t.on("Debugger.resumed",(()=>{n=!1})),t.on("Debugger.paused",(e=>{n=!0,async function(e,{reason:t,data:{objectId:n},callFrames:o}){if("exception"!==t&&"promiseRejection"!==t)return;if(p?.(),null==n)return;const i=[];for(let t=0;t<o.length;t++){const{scopeChain:n,functionName:a,this:s}=o[t],c=n.find((e=>"local"===e.type)),r="global"!==s.className&&s.className?`${s.className}.${a}`:a;if(void 0===c?.object.objectId)i[t]={function:r};else{const n=await b(e,c.object.objectId);i[t]={function:r,vars:n}}}await e.post("Runtime.callFunctionOn",{functionDeclaration:`function() { this.${r} = this.${r} || ${JSON.stringify(i)}; }`,silent:!0,objectId:n}),await e.post("Runtime.releaseObject",{objectId:n})}(t,e.params).then((async()=>{n&&await t.post("Debugger.resume")}),(async e=>{n&&await t.post("Debugger.resume")}))})),await t.post("Debugger.enable");const o=!1!==u.captureAllExceptions;if(await t.post("Debugger.setPauseOnExceptions",{state:o?"all":"uncaught"}),o){const e=u.maxExceptionsPerSecond||50;p=function(e,t,n){let o=0,i=5,a=0;return setInterval((()=>{0===a?o>e&&(i*=2,n(i),i>86400&&(i=86400),a=i):(a-=1,0===a&&t()),o=0}),1e3).unref(),()=>{o+=1}}(e,(async()=>{l("Rate-limit lifted."),await t.post("Debugger.setPauseOnExceptions",{state:"all"})}),(async e=>{l(`Rate-limit exceeded. Disabling capturing of caught exceptions for ${e} seconds.`),await t.post("Debugger.setPauseOnExceptions",{state:"uncaught"})}))}})().catch((e=>{l("Failed to start debugger",e)})),setInterval((()=>{}),1e4);
diff --git a/build/esm/integrations/node-fetch/SentryNodeFetchInstrumentation.js b/build/esm/integrations/node-fetch/SentryNodeFetchInstrumentation.js
index 1f9120cc3e98fc66edf694a0e51e06b241e1048a..a45a428a740188949b9bf3c98930a5a3f6549925 100644
--- a/build/esm/integrations/node-fetch/SentryNodeFetchInstrumentation.js
+++ b/build/esm/integrations/node-fetch/SentryNodeFetchInstrumentation.js
@@ -1,4 +1,3 @@
-import { VERSION } from '@opentelemetry/core';
 import { InstrumentationBase } from '@opentelemetry/instrumentation';
 import { LRUMap, getClient, getTraceData, getBreadcrumbLogLevelFromHttpStatusCode, addBreadcrumb, parseUrl, getSanitizedUrlString } from '@sentry/core';
 import { shouldPropagateTraceForUrl } from '@sentry/opentelemetry';
@@ -27,7 +26,7 @@ class SentryNodeFetchInstrumentation extends InstrumentationBase {
   // unsubscribing.
 
    constructor(config = {}) {
-    super('@sentry/instrumentation-node-fetch', VERSION, config);
+    super('@sentry/instrumentation-node-fetch', '2.0.0', config);
     this._channelSubs = [];
     this._propagationDecisionMap = new LRUMap(100);
   }
diff --git a/build/esm/integrations/node-fetch/SentryNodeFetchInstrumentation.js.map b/build/esm/integrations/node-fetch/SentryNodeFetchInstrumentation.js.map
index f19e5bffc464a276c5462f636fa7493f29e2e165..db0d79526af7d87c35c5a84f059a380ded8cd99b 100644
--- a/build/esm/integrations/node-fetch/SentryNodeFetchInstrumentation.js.map
+++ b/build/esm/integrations/node-fetch/SentryNodeFetchInstrumentation.js.map
@@ -1 +1 @@
-{"version":3,"file":"SentryNodeFetchInstrumentation.js","sources":["../../../../src/integrations/node-fetch/SentryNodeFetchInstrumentation.ts"],"sourcesContent":["import { VERSION } from '@opentelemetry/core';\nimport type { InstrumentationConfig } from '@opentelemetry/instrumentation';\nimport { InstrumentationBase } from '@opentelemetry/instrumentation';\nimport type { SanitizedRequestData } from '@sentry/core';\nimport { LRUMap, getClient, getTraceData } from '@sentry/core';\nimport { addBreadcrumb, getBreadcrumbLogLevelFromHttpStatusCode, getSanitizedUrlString, parseUrl } from '@sentry/core';\nimport { shouldPropagateTraceForUrl } from '@sentry/opentelemetry';\nimport * as diagch from 'diagnostics_channel';\nimport { NODE_MAJOR, NODE_MINOR } from '../../nodeVersion';\nimport { mergeBaggageHeaders } from '../../utils/baggage';\nimport type { UndiciRequest, UndiciResponse } from './types';\n\nconst SENTRY_TRACE_HEADER = 'sentry-trace';\nconst SENTRY_BAGGAGE_HEADER = 'baggage';\n\n// For baggage, we make sure to merge this into a possibly existing header\nconst BAGGAGE_HEADER_REGEX = /baggage: (.*)\\r\\n/;\n\nexport type SentryNodeFetchInstrumentationOptions = InstrumentationConfig & {\n  /**\n   * Whether breadcrumbs should be recorded for requests.\n   *\n   * @default `true`\n   */\n  breadcrumbs?: boolean;\n\n  /**\n   * Do not capture breadcrumbs or inject headers for outgoing fetch requests to URLs where the given callback returns `true`.\n   * The same option can be passed to the top-level httpIntegration where it controls both, breadcrumb and\n   * span creation.\n   *\n   * @param url Contains the entire URL, including query string (if any), protocol, host, etc. of the outgoing request.\n   */\n  ignoreOutgoingRequests?: (url: string) => boolean;\n};\n\ninterface ListenerRecord {\n  name: string;\n  unsubscribe: () => void;\n}\n\n/**\n * This custom node-fetch instrumentation is used to instrument outgoing fetch requests.\n * It does not emit any spans.\n *\n * The reason this is isolated from the OpenTelemetry instrumentation is that users may overwrite this,\n * which would lead to Sentry not working as expected.\n *\n * This is heavily inspired & adapted from:\n * https://github.com/open-telemetry/opentelemetry-js-contrib/blob/28e209a9da36bc4e1f8c2b0db7360170ed46cb80/plugins/node/instrumentation-undici/src/undici.ts\n */\nexport class SentryNodeFetchInstrumentation extends InstrumentationBase<SentryNodeFetchInstrumentationOptions> {\n  // Keep ref to avoid https://github.com/nodejs/node/issues/42170 bug and for\n  // unsubscribing.\n  private _channelSubs: Array<ListenerRecord>;\n  private _propagationDecisionMap: LRUMap<string, boolean>;\n\n  public constructor(config: SentryNodeFetchInstrumentationOptions = {}) {\n    super('@sentry/instrumentation-node-fetch', VERSION, config);\n    this._channelSubs = [];\n    this._propagationDecisionMap = new LRUMap<string, boolean>(100);\n  }\n\n  /** No need to instrument files/modules. */\n  public init(): void {\n    return undefined;\n  }\n\n  /** Disable the instrumentation. */\n  public disable(): void {\n    super.disable();\n    this._channelSubs.forEach(sub => sub.unsubscribe());\n    this._channelSubs = [];\n  }\n\n  /** Enable the instrumentation. */\n  public enable(): void {\n    // \"enabled\" handling is currently a bit messy with InstrumentationBase.\n    // If constructed with `{enabled: false}`, this `.enable()` is still called,\n    // and `this.getConfig().enabled !== this.isEnabled()`, creating confusion.\n    //\n    // For now, this class will setup for instrumenting if `.enable()` is\n    // called, but use `this.getConfig().enabled` to determine if\n    // instrumentation should be generated. This covers the more likely common\n    // case of config being given a construction time, rather than later via\n    // `instance.enable()`, `.disable()`, or `.setConfig()` calls.\n    super.enable();\n\n    // This method is called by the super-class constructor before ours is\n    // called. So we need to ensure the property is initalized.\n    this._channelSubs = this._channelSubs || [];\n\n    // Avoid to duplicate subscriptions\n    if (this._channelSubs.length > 0) {\n      return;\n    }\n\n    this._subscribeToChannel('undici:request:create', this._onRequestCreated.bind(this));\n    this._subscribeToChannel('undici:request:headers', this._onResponseHeaders.bind(this));\n  }\n\n  /**\n   * This method is called when a request is created.\n   * You can still mutate the request here before it is sent.\n   */\n  private _onRequestCreated({ request }: { request: UndiciRequest }): void {\n    const config = this.getConfig();\n    const enabled = config.enabled !== false;\n\n    if (!enabled) {\n      return;\n    }\n\n    // Add trace propagation headers\n    const url = getAbsoluteUrl(request.origin, request.path);\n    const _ignoreOutgoingRequests = config.ignoreOutgoingRequests;\n    const shouldIgnore = _ignoreOutgoingRequests && url && _ignoreOutgoingRequests(url);\n\n    if (shouldIgnore) {\n      return;\n    }\n\n    // Manually add the trace headers, if it applies\n    // Note: We do not use `propagation.inject()` here, because our propagator relies on an active span\n    // Which we do not have in this case\n    // The propagator _may_ overwrite this, but this should be fine as it is the same data\n    const tracePropagationTargets = getClient()?.getOptions().tracePropagationTargets;\n    const addedHeaders = shouldPropagateTraceForUrl(url, tracePropagationTargets, this._propagationDecisionMap)\n      ? getTraceData()\n      : undefined;\n\n    if (!addedHeaders) {\n      return;\n    }\n\n    const { 'sentry-trace': sentryTrace, baggage } = addedHeaders;\n\n    // We do not want to overwrite existing headers here\n    // If the core UndiciInstrumentation is registered, it will already have set the headers\n    // We do not want to add any then\n    if (Array.isArray(request.headers)) {\n      const requestHeaders = request.headers;\n\n      // We do not want to overwrite existing header here, if it was already set\n      if (sentryTrace && !requestHeaders.includes(SENTRY_TRACE_HEADER)) {\n        requestHeaders.push(SENTRY_TRACE_HEADER, sentryTrace);\n      }\n\n      // For baggage, we make sure to merge this into a possibly existing header\n      const existingBaggagePos = requestHeaders.findIndex(header => header === SENTRY_BAGGAGE_HEADER);\n      if (baggage && existingBaggagePos === -1) {\n        requestHeaders.push(SENTRY_BAGGAGE_HEADER, baggage);\n      } else if (baggage) {\n        const existingBaggage = requestHeaders[existingBaggagePos + 1];\n        const merged = mergeBaggageHeaders(existingBaggage, baggage);\n        if (merged) {\n          requestHeaders[existingBaggagePos + 1] = merged;\n        }\n      }\n    } else {\n      const requestHeaders = request.headers;\n      // We do not want to overwrite existing header here, if it was already set\n      if (sentryTrace && !requestHeaders.includes(`${SENTRY_TRACE_HEADER}:`)) {\n        request.headers += `${SENTRY_TRACE_HEADER}: ${sentryTrace}\\r\\n`;\n      }\n\n      const existingBaggage = request.headers.match(BAGGAGE_HEADER_REGEX)?.[1];\n      if (baggage && !existingBaggage) {\n        request.headers += `${SENTRY_BAGGAGE_HEADER}: ${baggage}\\r\\n`;\n      } else if (baggage) {\n        const merged = mergeBaggageHeaders(existingBaggage, baggage);\n        if (merged) {\n          request.headers = request.headers.replace(BAGGAGE_HEADER_REGEX, `baggage: ${merged}\\r\\n`);\n        }\n      }\n    }\n  }\n\n  /**\n   * This method is called when a response is received.\n   */\n  private _onResponseHeaders({ request, response }: { request: UndiciRequest; response: UndiciResponse }): void {\n    const config = this.getConfig();\n    const enabled = config.enabled !== false;\n\n    if (!enabled) {\n      return;\n    }\n\n    const _breadcrumbs = config.breadcrumbs;\n    const breadCrumbsEnabled = typeof _breadcrumbs === 'undefined' ? true : _breadcrumbs;\n\n    const _ignoreOutgoingRequests = config.ignoreOutgoingRequests;\n    const shouldCreateBreadcrumb =\n      typeof _ignoreOutgoingRequests === 'function'\n        ? !_ignoreOutgoingRequests(getAbsoluteUrl(request.origin, request.path))\n        : true;\n\n    if (breadCrumbsEnabled && shouldCreateBreadcrumb) {\n      addRequestBreadcrumb(request, response);\n    }\n  }\n\n  /** Subscribe to a diagnostics channel. */\n  private _subscribeToChannel(\n    diagnosticChannel: string,\n    onMessage: (message: unknown, name: string | symbol) => void,\n  ): void {\n    // `diagnostics_channel` had a ref counting bug until v18.19.0.\n    // https://github.com/nodejs/node/pull/47520\n    const useNewSubscribe = NODE_MAJOR > 18 || (NODE_MAJOR === 18 && NODE_MINOR >= 19);\n\n    let unsubscribe: () => void;\n    if (useNewSubscribe) {\n      diagch.subscribe?.(diagnosticChannel, onMessage);\n      unsubscribe = () => diagch.unsubscribe?.(diagnosticChannel, onMessage);\n    } else {\n      const channel = diagch.channel(diagnosticChannel);\n      channel.subscribe(onMessage);\n      unsubscribe = () => channel.unsubscribe(onMessage);\n    }\n\n    this._channelSubs.push({\n      name: diagnosticChannel,\n      unsubscribe,\n    });\n  }\n}\n\n/** Add a breadcrumb for outgoing requests. */\nfunction addRequestBreadcrumb(request: UndiciRequest, response: UndiciResponse): void {\n  const data = getBreadcrumbData(request);\n\n  const statusCode = response.statusCode;\n  const level = getBreadcrumbLogLevelFromHttpStatusCode(statusCode);\n\n  addBreadcrumb(\n    {\n      category: 'http',\n      data: {\n        status_code: statusCode,\n        ...data,\n      },\n      type: 'http',\n      level,\n    },\n    {\n      event: 'response',\n      request,\n      response,\n    },\n  );\n}\n\nfunction getBreadcrumbData(request: UndiciRequest): Partial<SanitizedRequestData> {\n  try {\n    const url = getAbsoluteUrl(request.origin, request.path);\n    const parsedUrl = parseUrl(url);\n\n    const data: Partial<SanitizedRequestData> = {\n      url: getSanitizedUrlString(parsedUrl),\n      'http.method': request.method || 'GET',\n    };\n\n    if (parsedUrl.search) {\n      data['http.query'] = parsedUrl.search;\n    }\n    if (parsedUrl.hash) {\n      data['http.fragment'] = parsedUrl.hash;\n    }\n\n    return data;\n  } catch {\n    return {};\n  }\n}\n\nfunction getAbsoluteUrl(origin: string, path: string = '/'): string {\n  try {\n    const url = new URL(path, origin);\n    return url.toString();\n  } catch {\n    // fallback: Construct it on our own\n    const url = `${origin}`;\n\n    if (url.endsWith('/') && path.startsWith('/')) {\n      return `${url}${path.slice(1)}`;\n    }\n\n    if (!url.endsWith('/') && !path.startsWith('/')) {\n      return `${url}/${path.slice(1)}`;\n    }\n\n    return `${url}${path}`;\n  }\n}\n"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"SentryNodeFetchInstrumentation.js","sources":["../../../../src/integrations/node-fetch/SentryNodeFetchInstrumentation.ts"],"sourcesContent":["import type { InstrumentationConfig } from '@opentelemetry/instrumentation';\nimport { InstrumentationBase } from '@opentelemetry/instrumentation';\nimport type { SanitizedRequestData } from '@sentry/core';\nimport { LRUMap, getClient, getTraceData } from '@sentry/core';\nimport { addBreadcrumb, getBreadcrumbLogLevelFromHttpStatusCode, getSanitizedUrlString, parseUrl } from '@sentry/core';\nimport { shouldPropagateTraceForUrl } from '@sentry/opentelemetry';\nimport * as diagch from 'diagnostics_channel';\nimport { NODE_MAJOR, NODE_MINOR } from '../../nodeVersion';\nimport { mergeBaggageHeaders } from '../../utils/baggage';\nimport type { UndiciRequest, UndiciResponse } from './types';\n\nconst SENTRY_TRACE_HEADER = 'sentry-trace';\nconst SENTRY_BAGGAGE_HEADER = 'baggage';\n\n// For baggage, we make sure to merge this into a possibly existing header\nconst BAGGAGE_HEADER_REGEX = /baggage: (.*)\\r\\n/;\n\nexport type SentryNodeFetchInstrumentationOptions = InstrumentationConfig & {\n  /**\n   * Whether breadcrumbs should be recorded for requests.\n   *\n   * @default `true`\n   */\n  breadcrumbs?: boolean;\n\n  /**\n   * Do not capture breadcrumbs or inject headers for outgoing fetch requests to URLs where the given callback returns `true`.\n   * The same option can be passed to the top-level httpIntegration where it controls both, breadcrumb and\n   * span creation.\n   *\n   * @param url Contains the entire URL, including query string (if any), protocol, host, etc. of the outgoing request.\n   */\n  ignoreOutgoingRequests?: (url: string) => boolean;\n};\n\ninterface ListenerRecord {\n  name: string;\n  unsubscribe: () => void;\n}\n\n/**\n * This custom node-fetch instrumentation is used to instrument outgoing fetch requests.\n * It does not emit any spans.\n *\n * The reason this is isolated from the OpenTelemetry instrumentation is that users may overwrite this,\n * which would lead to Sentry not working as expected.\n *\n * This is heavily inspired & adapted from:\n * https://github.com/open-telemetry/opentelemetry-js-contrib/blob/28e209a9da36bc4e1f8c2b0db7360170ed46cb80/plugins/node/instrumentation-undici/src/undici.ts\n */\nexport class SentryNodeFetchInstrumentation extends InstrumentationBase<SentryNodeFetchInstrumentationOptions> {\n  // Keep ref to avoid https://github.com/nodejs/node/issues/42170 bug and for\n  // unsubscribing.\n  private _channelSubs: Array<ListenerRecord>;\n  private _propagationDecisionMap: LRUMap<string, boolean>;\n\n  public constructor(config: SentryNodeFetchInstrumentationOptions = {}) {\n    super('@sentry/instrumentation-node-fetch', '2.0.0', config);\n    this._channelSubs = [];\n    this._propagationDecisionMap = new LRUMap<string, boolean>(100);\n  }\n\n  /** No need to instrument files/modules. */\n  public init(): void {\n    return undefined;\n  }\n\n  /** Disable the instrumentation. */\n  public disable(): void {\n    super.disable();\n    this._channelSubs.forEach(sub => sub.unsubscribe());\n    this._channelSubs = [];\n  }\n\n  /** Enable the instrumentation. */\n  public enable(): void {\n    // \"enabled\" handling is currently a bit messy with InstrumentationBase.\n    // If constructed with `{enabled: false}`, this `.enable()` is still called,\n    // and `this.getConfig().enabled !== this.isEnabled()`, creating confusion.\n    //\n    // For now, this class will setup for instrumenting if `.enable()` is\n    // called, but use `this.getConfig().enabled` to determine if\n    // instrumentation should be generated. This covers the more likely common\n    // case of config being given a construction time, rather than later via\n    // `instance.enable()`, `.disable()`, or `.setConfig()` calls.\n    super.enable();\n\n    // This method is called by the super-class constructor before ours is\n    // called. So we need to ensure the property is initalized.\n    this._channelSubs = this._channelSubs || [];\n\n    // Avoid to duplicate subscriptions\n    if (this._channelSubs.length > 0) {\n      return;\n    }\n\n    this._subscribeToChannel('undici:request:create', this._onRequestCreated.bind(this));\n    this._subscribeToChannel('undici:request:headers', this._onResponseHeaders.bind(this));\n  }\n\n  /**\n   * This method is called when a request is created.\n   * You can still mutate the request here before it is sent.\n   */\n  private _onRequestCreated({ request }: { request: UndiciRequest }): void {\n    const config = this.getConfig();\n    const enabled = config.enabled !== false;\n\n    if (!enabled) {\n      return;\n    }\n\n    // Add trace propagation headers\n    const url = getAbsoluteUrl(request.origin, request.path);\n    const _ignoreOutgoingRequests = config.ignoreOutgoingRequests;\n    const shouldIgnore = _ignoreOutgoingRequests && url && _ignoreOutgoingRequests(url);\n\n    if (shouldIgnore) {\n      return;\n    }\n\n    // Manually add the trace headers, if it applies\n    // Note: We do not use `propagation.inject()` here, because our propagator relies on an active span\n    // Which we do not have in this case\n    // The propagator _may_ overwrite this, but this should be fine as it is the same data\n    const tracePropagationTargets = getClient()?.getOptions().tracePropagationTargets;\n    const addedHeaders = shouldPropagateTraceForUrl(url, tracePropagationTargets, this._propagationDecisionMap)\n      ? getTraceData()\n      : undefined;\n\n    if (!addedHeaders) {\n      return;\n    }\n\n    const { 'sentry-trace': sentryTrace, baggage } = addedHeaders;\n\n    // We do not want to overwrite existing headers here\n    // If the core UndiciInstrumentation is registered, it will already have set the headers\n    // We do not want to add any then\n    if (Array.isArray(request.headers)) {\n      const requestHeaders = request.headers;\n\n      // We do not want to overwrite existing header here, if it was already set\n      if (sentryTrace && !requestHeaders.includes(SENTRY_TRACE_HEADER)) {\n        requestHeaders.push(SENTRY_TRACE_HEADER, sentryTrace);\n      }\n\n      // For baggage, we make sure to merge this into a possibly existing header\n      const existingBaggagePos = requestHeaders.findIndex(header => header === SENTRY_BAGGAGE_HEADER);\n      if (baggage && existingBaggagePos === -1) {\n        requestHeaders.push(SENTRY_BAGGAGE_HEADER, baggage);\n      } else if (baggage) {\n        const existingBaggage = requestHeaders[existingBaggagePos + 1];\n        const merged = mergeBaggageHeaders(existingBaggage, baggage);\n        if (merged) {\n          requestHeaders[existingBaggagePos + 1] = merged;\n        }\n      }\n    } else {\n      const requestHeaders = request.headers;\n      // We do not want to overwrite existing header here, if it was already set\n      if (sentryTrace && !requestHeaders.includes(`${SENTRY_TRACE_HEADER}:`)) {\n        request.headers += `${SENTRY_TRACE_HEADER}: ${sentryTrace}\\r\\n`;\n      }\n\n      const existingBaggage = request.headers.match(BAGGAGE_HEADER_REGEX)?.[1];\n      if (baggage && !existingBaggage) {\n        request.headers += `${SENTRY_BAGGAGE_HEADER}: ${baggage}\\r\\n`;\n      } else if (baggage) {\n        const merged = mergeBaggageHeaders(existingBaggage, baggage);\n        if (merged) {\n          request.headers = request.headers.replace(BAGGAGE_HEADER_REGEX, `baggage: ${merged}\\r\\n`);\n        }\n      }\n    }\n  }\n\n  /**\n   * This method is called when a response is received.\n   */\n  private _onResponseHeaders({ request, response }: { request: UndiciRequest; response: UndiciResponse }): void {\n    const config = this.getConfig();\n    const enabled = config.enabled !== false;\n\n    if (!enabled) {\n      return;\n    }\n\n    const _breadcrumbs = config.breadcrumbs;\n    const breadCrumbsEnabled = typeof _breadcrumbs === 'undefined' ? true : _breadcrumbs;\n\n    const _ignoreOutgoingRequests = config.ignoreOutgoingRequests;\n    const shouldCreateBreadcrumb =\n      typeof _ignoreOutgoingRequests === 'function'\n        ? !_ignoreOutgoingRequests(getAbsoluteUrl(request.origin, request.path))\n        : true;\n\n    if (breadCrumbsEnabled && shouldCreateBreadcrumb) {\n      addRequestBreadcrumb(request, response);\n    }\n  }\n\n  /** Subscribe to a diagnostics channel. */\n  private _subscribeToChannel(\n    diagnosticChannel: string,\n    onMessage: (message: unknown, name: string | symbol) => void,\n  ): void {\n    // `diagnostics_channel` had a ref counting bug until v18.19.0.\n    // https://github.com/nodejs/node/pull/47520\n    const useNewSubscribe = NODE_MAJOR > 18 || (NODE_MAJOR === 18 && NODE_MINOR >= 19);\n\n    let unsubscribe: () => void;\n    if (useNewSubscribe) {\n      diagch.subscribe?.(diagnosticChannel, onMessage);\n      unsubscribe = () => diagch.unsubscribe?.(diagnosticChannel, onMessage);\n    } else {\n      const channel = diagch.channel(diagnosticChannel);\n      channel.subscribe(onMessage);\n      unsubscribe = () => channel.unsubscribe(onMessage);\n    }\n\n    this._channelSubs.push({\n      name: diagnosticChannel,\n      unsubscribe,\n    });\n  }\n}\n\n/** Add a breadcrumb for outgoing requests. */\nfunction addRequestBreadcrumb(request: UndiciRequest, response: UndiciResponse): void {\n  const data = getBreadcrumbData(request);\n\n  const statusCode = response.statusCode;\n  const level = getBreadcrumbLogLevelFromHttpStatusCode(statusCode);\n\n  addBreadcrumb(\n    {\n      category: 'http',\n      data: {\n        status_code: statusCode,\n        ...data,\n      },\n      type: 'http',\n      level,\n    },\n    {\n      event: 'response',\n      request,\n      response,\n    },\n  );\n}\n\nfunction getBreadcrumbData(request: UndiciRequest): Partial<SanitizedRequestData> {\n  try {\n    const url = getAbsoluteUrl(request.origin, request.path);\n    const parsedUrl = parseUrl(url);\n\n    const data: Partial<SanitizedRequestData> = {\n      url: getSanitizedUrlString(parsedUrl),\n      'http.method': request.method || 'GET',\n    };\n\n    if (parsedUrl.search) {\n      data['http.query'] = parsedUrl.search;\n    }\n    if (parsedUrl.hash) {\n      data['http.fragment'] = parsedUrl.hash;\n    }\n\n    return data;\n  } catch {\n    return {};\n  }\n}\n\nfunction getAbsoluteUrl(origin: string, path: string = '/'): string {\n  try {\n    const url = new URL(path, origin);\n    return url.toString();\n  } catch {\n    // fallback: Construct it on our own\n    const url = `${origin}`;\n\n    if (url.endsWith('/') && path.startsWith('/')) {\n      return `${url}${path.slice(1)}`;\n    }\n\n    if (!url.endsWith('/') && !path.startsWith('/')) {\n      return `${url}/${path.slice(1)}`;\n    }\n\n    return `${url}${path}`;\n  }\n}\n"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/build/esm/sdk/client.js b/build/esm/sdk/client.js
index bbab6905c52fd45df8f3cb4ad4ce5a366da812bf..4f19f17311ef76a69b635b74006781f3cb4e1761 100644
--- a/build/esm/sdk/client.js
+++ b/build/esm/sdk/client.js
@@ -70,10 +70,9 @@ class NodeClient extends ServerRuntimeClient {
   // eslint-disable-next-line jsdoc/require-jsdoc
    async flush(timeout) {
     const provider = this.traceProvider;
-    const spanProcessor = provider?.activeSpanProcessor;
 
-    if (spanProcessor) {
-      await spanProcessor.forceFlush();
+    if (provider) {
+      await provider.forceFlush();
     }
 
     if (this.getOptions().sendClientReports) {
diff --git a/build/esm/sdk/client.js.map b/build/esm/sdk/client.js.map
index 36c4bc1e340a042ac0bdc9da659d58cc5b5e2919..44bf92b5153c5ca9b338323ac0d3780a60e12f06 100644
--- a/build/esm/sdk/client.js.map
+++ b/build/esm/sdk/client.js.map
@@ -1 +1 @@
-{"version":3,"file":"client.js","sources":["../../../src/sdk/client.ts"],"sourcesContent":["import * as os from 'node:os';\nimport type { Tracer } from '@opentelemetry/api';\nimport { trace } from '@opentelemetry/api';\nimport { registerInstrumentations } from '@opentelemetry/instrumentation';\nimport type { BasicTracerProvider } from '@opentelemetry/sdk-trace-base';\nimport type { DynamicSamplingContext, Scope, ServerRuntimeClientOptions, TraceContext } from '@sentry/core';\nimport { _INTERNAL_flushLogsBuffer, SDK_VERSION, ServerRuntimeClient, applySdkMetadata, logger } from '@sentry/core';\nimport { getTraceContextForScope } from '@sentry/opentelemetry';\nimport { isMainThread, threadId } from 'worker_threads';\nimport { DEBUG_BUILD } from '../debug-build';\nimport type { NodeClientOptions } from '../types';\n\nconst DEFAULT_CLIENT_REPORT_FLUSH_INTERVAL_MS = 60_000; // 60s was chosen arbitrarily\n\n/** A client for using Sentry with Node & OpenTelemetry. */\nexport class NodeClient extends ServerRuntimeClient<NodeClientOptions> {\n  public traceProvider: BasicTracerProvider | undefined;\n  private _tracer: Tracer | undefined;\n  private _clientReportInterval: NodeJS.Timeout | undefined;\n  private _clientReportOnExitFlushListener: (() => void) | undefined;\n  private _logOnExitFlushListener: (() => void) | undefined;\n\n  public constructor(options: NodeClientOptions) {\n    const serverName = options.serverName || global.process.env.SENTRY_NAME || os.hostname();\n    const clientOptions: ServerRuntimeClientOptions = {\n      ...options,\n      platform: 'node',\n      runtime: { name: 'node', version: global.process.version },\n      serverName,\n    };\n\n    if (options.openTelemetryInstrumentations) {\n      registerInstrumentations({\n        instrumentations: options.openTelemetryInstrumentations,\n      });\n    }\n\n    applySdkMetadata(clientOptions, 'node');\n\n    logger.log(\n      `Initializing Sentry: process: ${process.pid}, thread: ${isMainThread ? 'main' : `worker-${threadId}`}.`,\n    );\n\n    super(clientOptions);\n\n    if (this.getOptions()._experiments?.enableLogs) {\n      this._logOnExitFlushListener = () => {\n        _INTERNAL_flushLogsBuffer(this);\n      };\n\n      if (serverName) {\n        this.on('beforeCaptureLog', log => {\n          log.attributes = {\n            ...log.attributes,\n            'server.address': serverName,\n          };\n        });\n      }\n\n      process.on('beforeExit', this._logOnExitFlushListener);\n    }\n  }\n\n  /** Get the OTEL tracer. */\n  public get tracer(): Tracer {\n    if (this._tracer) {\n      return this._tracer;\n    }\n\n    const name = '@sentry/node';\n    const version = SDK_VERSION;\n    const tracer = trace.getTracer(name, version);\n    this._tracer = tracer;\n\n    return tracer;\n  }\n\n  // Eslint ignore explanation: This is already documented in super.\n  // eslint-disable-next-line jsdoc/require-jsdoc\n  public async flush(timeout?: number): Promise<boolean> {\n    const provider = this.traceProvider;\n    const spanProcessor = provider?.activeSpanProcessor;\n\n    if (spanProcessor) {\n      await spanProcessor.forceFlush();\n    }\n\n    if (this.getOptions().sendClientReports) {\n      this._flushOutcomes();\n    }\n\n    return super.flush(timeout);\n  }\n\n  // Eslint ignore explanation: This is already documented in super.\n  // eslint-disable-next-line jsdoc/require-jsdoc\n  public close(timeout?: number | undefined): PromiseLike<boolean> {\n    if (this._clientReportInterval) {\n      clearInterval(this._clientReportInterval);\n    }\n\n    if (this._clientReportOnExitFlushListener) {\n      process.off('beforeExit', this._clientReportOnExitFlushListener);\n    }\n\n    if (this._logOnExitFlushListener) {\n      process.off('beforeExit', this._logOnExitFlushListener);\n    }\n\n    return super.close(timeout);\n  }\n\n  /**\n   * Will start tracking client reports for this client.\n   *\n   * NOTICE: This method will create an interval that is periodically called and attach a `process.on('beforeExit')`\n   * hook. To clean up these resources, call `.close()` when you no longer intend to use the client. Not doing so will\n   * result in a memory leak.\n   */\n  // The reason client reports need to be manually activated with this method instead of just enabling them in a\n  // constructor, is that if users periodically and unboundedly create new clients, we will create more and more\n  // intervals and beforeExit listeners, thus leaking memory. In these situations, users are required to call\n  // `client.close()` in order to dispose of the acquired resources.\n  // We assume that calling this method in Sentry.init() is a sensible default, because calling Sentry.init() over and\n  // over again would also result in memory leaks.\n  // Note: We have experimented with using `FinalizationRegisty` to clear the interval when the client is garbage\n  // collected, but it did not work, because the cleanup function never got called.\n  public startClientReportTracking(): void {\n    const clientOptions = this.getOptions();\n    if (clientOptions.sendClientReports) {\n      this._clientReportOnExitFlushListener = () => {\n        this._flushOutcomes();\n      };\n\n      this._clientReportInterval = setInterval(() => {\n        DEBUG_BUILD && logger.log('Flushing client reports based on interval.');\n        this._flushOutcomes();\n      }, clientOptions.clientReportFlushInterval ?? DEFAULT_CLIENT_REPORT_FLUSH_INTERVAL_MS)\n        // Unref is critical for not preventing the process from exiting because the interval is active.\n        .unref();\n\n      process.on('beforeExit', this._clientReportOnExitFlushListener);\n    }\n  }\n\n  /** Custom implementation for OTEL, so we can handle scope-span linking. */\n  protected _getTraceInfoFromScope(\n    scope: Scope | undefined,\n  ): [dynamicSamplingContext: Partial<DynamicSamplingContext> | undefined, traceContext: TraceContext | undefined] {\n    if (!scope) {\n      return [undefined, undefined];\n    }\n\n    return getTraceContextForScope(this, scope);\n  }\n}\n"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"client.js","sources":["../../../src/sdk/client.ts"],"sourcesContent":["import * as os from 'node:os';\nimport type { Tracer } from '@opentelemetry/api';\nimport { trace } from '@opentelemetry/api';\nimport { registerInstrumentations } from '@opentelemetry/instrumentation';\nimport type { BasicTracerProvider } from '@opentelemetry/sdk-trace-base';\nimport type { DynamicSamplingContext, Scope, ServerRuntimeClientOptions, TraceContext } from '@sentry/core';\nimport { _INTERNAL_flushLogsBuffer, SDK_VERSION, ServerRuntimeClient, applySdkMetadata, logger } from '@sentry/core';\nimport { getTraceContextForScope } from '@sentry/opentelemetry';\nimport { isMainThread, threadId } from 'worker_threads';\nimport { DEBUG_BUILD } from '../debug-build';\nimport type { NodeClientOptions } from '../types';\n\nconst DEFAULT_CLIENT_REPORT_FLUSH_INTERVAL_MS = 60_000; // 60s was chosen arbitrarily\n\n/** A client for using Sentry with Node & OpenTelemetry. */\nexport class NodeClient extends ServerRuntimeClient<NodeClientOptions> {\n  public traceProvider: BasicTracerProvider | undefined;\n  private _tracer: Tracer | undefined;\n  private _clientReportInterval: NodeJS.Timeout | undefined;\n  private _clientReportOnExitFlushListener: (() => void) | undefined;\n  private _logOnExitFlushListener: (() => void) | undefined;\n\n  public constructor(options: NodeClientOptions) {\n    const serverName = options.serverName || global.process.env.SENTRY_NAME || os.hostname();\n    const clientOptions: ServerRuntimeClientOptions = {\n      ...options,\n      platform: 'node',\n      runtime: { name: 'node', version: global.process.version },\n      serverName,\n    };\n\n    if (options.openTelemetryInstrumentations) {\n      registerInstrumentations({\n        instrumentations: options.openTelemetryInstrumentations,\n      });\n    }\n\n    applySdkMetadata(clientOptions, 'node');\n\n    logger.log(\n      `Initializing Sentry: process: ${process.pid}, thread: ${isMainThread ? 'main' : `worker-${threadId}`}.`,\n    );\n\n    super(clientOptions);\n\n    if (this.getOptions()._experiments?.enableLogs) {\n      this._logOnExitFlushListener = () => {\n        _INTERNAL_flushLogsBuffer(this);\n      };\n\n      if (serverName) {\n        this.on('beforeCaptureLog', log => {\n          log.attributes = {\n            ...log.attributes,\n            'server.address': serverName,\n          };\n        });\n      }\n\n      process.on('beforeExit', this._logOnExitFlushListener);\n    }\n  }\n\n  /** Get the OTEL tracer. */\n  public get tracer(): Tracer {\n    if (this._tracer) {\n      return this._tracer;\n    }\n\n    const name = '@sentry/node';\n    const version = SDK_VERSION;\n    const tracer = trace.getTracer(name, version);\n    this._tracer = tracer;\n\n    return tracer;\n  }\n\n  // Eslint ignore explanation: This is already documented in super.\n  // eslint-disable-next-line jsdoc/require-jsdoc\n  public async flush(timeout?: number): Promise<boolean> {\n    const provider = this.traceProvider;\n\n    if (provider) {\n      await provider.forceFlush();\n    }\n\n    if (this.getOptions().sendClientReports) {\n      this._flushOutcomes();\n    }\n\n    return super.flush(timeout);\n  }\n\n  // Eslint ignore explanation: This is already documented in super.\n  // eslint-disable-next-line jsdoc/require-jsdoc\n  public close(timeout?: number | undefined): PromiseLike<boolean> {\n    if (this._clientReportInterval) {\n      clearInterval(this._clientReportInterval);\n    }\n\n    if (this._clientReportOnExitFlushListener) {\n      process.off('beforeExit', this._clientReportOnExitFlushListener);\n    }\n\n    if (this._logOnExitFlushListener) {\n      process.off('beforeExit', this._logOnExitFlushListener);\n    }\n\n    return super.close(timeout);\n  }\n\n  /**\n   * Will start tracking client reports for this client.\n   *\n   * NOTICE: This method will create an interval that is periodically called and attach a `process.on('beforeExit')`\n   * hook. To clean up these resources, call `.close()` when you no longer intend to use the client. Not doing so will\n   * result in a memory leak.\n   */\n  // The reason client reports need to be manually activated with this method instead of just enabling them in a\n  // constructor, is that if users periodically and unboundedly create new clients, we will create more and more\n  // intervals and beforeExit listeners, thus leaking memory. In these situations, users are required to call\n  // `client.close()` in order to dispose of the acquired resources.\n  // We assume that calling this method in Sentry.init() is a sensible default, because calling Sentry.init() over and\n  // over again would also result in memory leaks.\n  // Note: We have experimented with using `FinalizationRegisty` to clear the interval when the client is garbage\n  // collected, but it did not work, because the cleanup function never got called.\n  public startClientReportTracking(): void {\n    const clientOptions = this.getOptions();\n    if (clientOptions.sendClientReports) {\n      this._clientReportOnExitFlushListener = () => {\n        this._flushOutcomes();\n      };\n\n      this._clientReportInterval = setInterval(() => {\n        DEBUG_BUILD && logger.log('Flushing client reports based on interval.');\n        this._flushOutcomes();\n      }, clientOptions.clientReportFlushInterval ?? DEFAULT_CLIENT_REPORT_FLUSH_INTERVAL_MS)\n        // Unref is critical for not preventing the process from exiting because the interval is active.\n        .unref();\n\n      process.on('beforeExit', this._clientReportOnExitFlushListener);\n    }\n  }\n\n  /** Custom implementation for OTEL, so we can handle scope-span linking. */\n  protected _getTraceInfoFromScope(\n    scope: Scope | undefined,\n  ): [dynamicSamplingContext: Partial<DynamicSamplingContext> | undefined, traceContext: TraceContext | undefined] {\n    if (!scope) {\n      return [undefined, undefined];\n    }\n\n    return getTraceContextForScope(this, scope);\n  }\n}\n"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/build/esm/sdk/initOtel.js b/build/esm/sdk/initOtel.js
index d1086af11c2db5f567fb5781098d6319fe1b29cd..03881e3c1db53e299137df54c8ccfb63e9752965 100644
--- a/build/esm/sdk/initOtel.js
+++ b/build/esm/sdk/initOtel.js
@@ -1,6 +1,6 @@
 import moduleModule from 'module';
 import { diag, DiagLogLevel, trace, propagation, context } from '@opentelemetry/api';
-import { Resource } from '@opentelemetry/resources';
+import { defaultResource, resourceFromAttributes } from '@opentelemetry/resources';
 import { BasicTracerProvider } from '@opentelemetry/sdk-trace-base';
 import { ATTR_SERVICE_VERSION, SEMRESATTRS_SERVICE_NAMESPACE, ATTR_SERVICE_NAME } from '@opentelemetry/semantic-conventions';
 import { GLOBAL_OBJ, logger, consoleSandbox, SDK_VERSION } from '@sentry/core';
@@ -96,12 +96,14 @@ function setupOtel(client, options = {}) {
   // Create and configure NodeTracerProvider
   const provider = new BasicTracerProvider({
     sampler: new SentrySampler(client),
-    resource: new Resource({
-      [ATTR_SERVICE_NAME]: 'node',
-      // eslint-disable-next-line deprecation/deprecation
-      [SEMRESATTRS_SERVICE_NAMESPACE]: 'sentry',
-      [ATTR_SERVICE_VERSION]: SDK_VERSION,
-    }),
+    resource: defaultResource().merge(
+      resourceFromAttributes({
+        [ATTR_SERVICE_NAME]: 'node',
+        // eslint-disable-next-line deprecation/deprecation
+        [SEMRESATTRS_SERVICE_NAMESPACE]: 'sentry',
+        [ATTR_SERVICE_VERSION]: SDK_VERSION,
+      }),
+    ),
     forceFlushTimeoutMillis: 500,
     spanProcessors: [
       new SentrySpanProcessor({
diff --git a/build/esm/sdk/initOtel.js.map b/build/esm/sdk/initOtel.js.map
index b72637c36341c6f7a258705187c336213901d9cf..d5529d6ed42c8747c52efe9f51574f20950b9c01 100644
--- a/build/esm/sdk/initOtel.js.map
+++ b/build/esm/sdk/initOtel.js.map
@@ -1 +1 @@
-{"version":3,"file":"initOtel.js","sources":["../../../src/sdk/initOtel.ts"],"sourcesContent":["import moduleModule from 'module';\nimport { DiagLogLevel, context, diag, propagation, trace } from '@opentelemetry/api';\nimport { Resource } from '@opentelemetry/resources';\nimport type { SpanProcessor } from '@opentelemetry/sdk-trace-base';\nimport { BasicTracerProvider } from '@opentelemetry/sdk-trace-base';\nimport {\n  ATTR_SERVICE_NAME,\n  ATTR_SERVICE_VERSION,\n  SEMRESATTRS_SERVICE_NAMESPACE,\n} from '@opentelemetry/semantic-conventions';\nimport { GLOBAL_OBJ, SDK_VERSION, consoleSandbox, logger } from '@sentry/core';\nimport { SentryPropagator, SentrySampler, SentrySpanProcessor } from '@sentry/opentelemetry';\nimport { createAddHookMessageChannel } from 'import-in-the-middle';\nimport { DEBUG_BUILD } from '../debug-build';\nimport { getOpenTelemetryInstrumentationToPreload } from '../integrations/tracing';\nimport { SentryContextManager } from '../otel/contextManager';\nimport { isCjs } from '../utils/commonjs';\nimport type { NodeClient } from './client';\n\n// About 277h - this must fit into new Array(len)!\nconst MAX_MAX_SPAN_WAIT_DURATION = 1_000_000;\n\ninterface AdditionalOpenTelemetryOptions {\n  /** Additional SpanProcessor instances that should be used. */\n  spanProcessors?: SpanProcessor[];\n}\n\n/**\n * Initialize OpenTelemetry for Node.\n */\nexport function initOpenTelemetry(client: NodeClient, options: AdditionalOpenTelemetryOptions = {}): void {\n  if (client.getOptions().debug) {\n    setupOpenTelemetryLogger();\n  }\n\n  const provider = setupOtel(client, options);\n  client.traceProvider = provider;\n}\n\n/** Initialize the ESM loader. */\nexport function maybeInitializeEsmLoader(): void {\n  const [nodeMajor = 0, nodeMinor = 0] = process.versions.node.split('.').map(Number);\n\n  // Register hook was added in v20.6.0 and v18.19.0\n  if (nodeMajor >= 22 || (nodeMajor === 20 && nodeMinor >= 6) || (nodeMajor === 18 && nodeMinor >= 19)) {\n    if (!GLOBAL_OBJ._sentryEsmLoaderHookRegistered) {\n      try {\n        const { addHookMessagePort } = createAddHookMessageChannel();\n        // @ts-expect-error register is available in these versions\n        moduleModule.register('import-in-the-middle/hook.mjs', import.meta.url, {\n          data: { addHookMessagePort, include: [] },\n          transferList: [addHookMessagePort],\n        });\n      } catch (error) {\n        logger.warn('Failed to register ESM hook', error);\n      }\n    }\n  } else {\n    consoleSandbox(() => {\n      // eslint-disable-next-line no-console\n      console.warn(\n        '[Sentry] You are using Node.js in ESM mode (\"import syntax\"). The Sentry Node.js SDK is not compatible with ESM in Node.js versions before 18.19.0 or before 20.6.0. Please either build your application with CommonJS (\"require() syntax\"), or upgrade your Node.js version.',\n      );\n    });\n  }\n}\n\ninterface NodePreloadOptions {\n  debug?: boolean;\n  integrations?: string[];\n}\n\n/**\n * Preload OpenTelemetry for Node.\n * This can be used to preload instrumentation early, but set up Sentry later.\n * By preloading the OTEL instrumentation wrapping still happens early enough that everything works.\n */\nexport function preloadOpenTelemetry(options: NodePreloadOptions = {}): void {\n  const { debug } = options;\n\n  if (debug) {\n    logger.enable();\n    setupOpenTelemetryLogger();\n  }\n\n  if (!isCjs()) {\n    maybeInitializeEsmLoader();\n  }\n\n  // These are all integrations that we need to pre-load to ensure they are set up before any other code runs\n  getPreloadMethods(options.integrations).forEach(fn => {\n    fn();\n\n    if (debug) {\n      logger.log(`[Sentry] Preloaded ${fn.id} instrumentation`);\n    }\n  });\n}\n\nfunction getPreloadMethods(integrationNames?: string[]): ((() => void) & { id: string })[] {\n  const instruments = getOpenTelemetryInstrumentationToPreload();\n\n  if (!integrationNames) {\n    return instruments;\n  }\n\n  return instruments.filter(instrumentation => integrationNames.includes(instrumentation.id));\n}\n\n/** Just exported for tests. */\nexport function setupOtel(client: NodeClient, options: AdditionalOpenTelemetryOptions = {}): BasicTracerProvider {\n  // Create and configure NodeTracerProvider\n  const provider = new BasicTracerProvider({\n    sampler: new SentrySampler(client),\n    resource: new Resource({\n      [ATTR_SERVICE_NAME]: 'node',\n      // eslint-disable-next-line deprecation/deprecation\n      [SEMRESATTRS_SERVICE_NAMESPACE]: 'sentry',\n      [ATTR_SERVICE_VERSION]: SDK_VERSION,\n    }),\n    forceFlushTimeoutMillis: 500,\n    spanProcessors: [\n      new SentrySpanProcessor({\n        timeout: _clampSpanProcessorTimeout(client.getOptions().maxSpanWaitDuration),\n      }),\n      ...(options.spanProcessors || []),\n    ],\n  });\n\n  // Register as globals\n  trace.setGlobalTracerProvider(provider);\n  propagation.setGlobalPropagator(new SentryPropagator());\n  context.setGlobalContextManager(new SentryContextManager());\n\n  return provider;\n}\n\n/** Just exported for tests. */\nexport function _clampSpanProcessorTimeout(maxSpanWaitDuration: number | undefined): number | undefined {\n  if (maxSpanWaitDuration == null) {\n    return undefined;\n  }\n\n  // We guard for a max. value here, because we create an array with this length\n  // So if this value is too large, this would fail\n  if (maxSpanWaitDuration > MAX_MAX_SPAN_WAIT_DURATION) {\n    DEBUG_BUILD &&\n      logger.warn(`\\`maxSpanWaitDuration\\` is too high, using the maximum value of ${MAX_MAX_SPAN_WAIT_DURATION}`);\n    return MAX_MAX_SPAN_WAIT_DURATION;\n  } else if (maxSpanWaitDuration <= 0 || Number.isNaN(maxSpanWaitDuration)) {\n    DEBUG_BUILD && logger.warn('`maxSpanWaitDuration` must be a positive number, using default value instead.');\n    return undefined;\n  }\n\n  return maxSpanWaitDuration;\n}\n\n/**\n * Setup the OTEL logger to use our own logger.\n */\nfunction setupOpenTelemetryLogger(): void {\n  const otelLogger = new Proxy(logger as typeof logger & { verbose: (typeof logger)['debug'] }, {\n    get(target, prop, receiver) {\n      const actualProp = prop === 'verbose' ? 'debug' : prop;\n      return Reflect.get(target, actualProp, receiver);\n    },\n  });\n\n  // Disable diag, to ensure this works even if called multiple times\n  diag.disable();\n  diag.setLogger(otelLogger, DiagLogLevel.DEBUG);\n}\n"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"initOtel.js","sources":["../../../src/sdk/initOtel.ts"],"sourcesContent":["import moduleModule from 'module';\nimport { DiagLogLevel, context, diag, propagation, trace } from '@opentelemetry/api';\nimport { defaultResource, resourceFromAttributes } from '@opentelemetry/resources';\nimport type { SpanProcessor } from '@opentelemetry/sdk-trace-base';\nimport { BasicTracerProvider } from '@opentelemetry/sdk-trace-base';\nimport {\n  ATTR_SERVICE_NAME,\n  ATTR_SERVICE_VERSION,\n  SEMRESATTRS_SERVICE_NAMESPACE,\n} from '@opentelemetry/semantic-conventions';\nimport { GLOBAL_OBJ, SDK_VERSION, consoleSandbox, logger } from '@sentry/core';\nimport { SentryPropagator, SentrySampler, SentrySpanProcessor } from '@sentry/opentelemetry';\nimport { createAddHookMessageChannel } from 'import-in-the-middle';\nimport { DEBUG_BUILD } from '../debug-build';\nimport { getOpenTelemetryInstrumentationToPreload } from '../integrations/tracing';\nimport { SentryContextManager } from '../otel/contextManager';\nimport { isCjs } from '../utils/commonjs';\nimport type { NodeClient } from './client';\n\n// About 277h - this must fit into new Array(len)!\nconst MAX_MAX_SPAN_WAIT_DURATION = 1_000_000;\n\ninterface AdditionalOpenTelemetryOptions {\n  /** Additional SpanProcessor instances that should be used. */\n  spanProcessors?: SpanProcessor[];\n}\n\n/**\n * Initialize OpenTelemetry for Node.\n */\nexport function initOpenTelemetry(client: NodeClient, options: AdditionalOpenTelemetryOptions = {}): void {\n  if (client.getOptions().debug) {\n    setupOpenTelemetryLogger();\n  }\n\n  const provider = setupOtel(client, options);\n  client.traceProvider = provider;\n}\n\n/** Initialize the ESM loader. */\nexport function maybeInitializeEsmLoader(): void {\n  const [nodeMajor = 0, nodeMinor = 0] = process.versions.node.split('.').map(Number);\n\n  // Register hook was added in v20.6.0 and v18.19.0\n  if (nodeMajor >= 22 || (nodeMajor === 20 && nodeMinor >= 6) || (nodeMajor === 18 && nodeMinor >= 19)) {\n    if (!GLOBAL_OBJ._sentryEsmLoaderHookRegistered) {\n      try {\n        const { addHookMessagePort } = createAddHookMessageChannel();\n        // @ts-expect-error register is available in these versions\n        moduleModule.register('import-in-the-middle/hook.mjs', import.meta.url, {\n          data: { addHookMessagePort, include: [] },\n          transferList: [addHookMessagePort],\n        });\n      } catch (error) {\n        logger.warn('Failed to register ESM hook', error);\n      }\n    }\n  } else {\n    consoleSandbox(() => {\n      // eslint-disable-next-line no-console\n      console.warn(\n        '[Sentry] You are using Node.js in ESM mode (\"import syntax\"). The Sentry Node.js SDK is not compatible with ESM in Node.js versions before 18.19.0 or before 20.6.0. Please either build your application with CommonJS (\"require() syntax\"), or upgrade your Node.js version.',\n      );\n    });\n  }\n}\n\ninterface NodePreloadOptions {\n  debug?: boolean;\n  integrations?: string[];\n}\n\n/**\n * Preload OpenTelemetry for Node.\n * This can be used to preload instrumentation early, but set up Sentry later.\n * By preloading the OTEL instrumentation wrapping still happens early enough that everything works.\n */\nexport function preloadOpenTelemetry(options: NodePreloadOptions = {}): void {\n  const { debug } = options;\n\n  if (debug) {\n    logger.enable();\n    setupOpenTelemetryLogger();\n  }\n\n  if (!isCjs()) {\n    maybeInitializeEsmLoader();\n  }\n\n  // These are all integrations that we need to pre-load to ensure they are set up before any other code runs\n  getPreloadMethods(options.integrations).forEach(fn => {\n    fn();\n\n    if (debug) {\n      logger.log(`[Sentry] Preloaded ${fn.id} instrumentation`);\n    }\n  });\n}\n\nfunction getPreloadMethods(integrationNames?: string[]): ((() => void) & { id: string })[] {\n  const instruments = getOpenTelemetryInstrumentationToPreload();\n\n  if (!integrationNames) {\n    return instruments;\n  }\n\n  return instruments.filter(instrumentation => integrationNames.includes(instrumentation.id));\n}\n\n/** Just exported for tests. */\nexport function setupOtel(client: NodeClient, options: AdditionalOpenTelemetryOptions = {}): BasicTracerProvider {\n  // Create and configure NodeTracerProvider\n  const provider = new BasicTracerProvider({\n    sampler: new SentrySampler(client),\n    resource: defaultResource().merge(\n      resourceFromAttributes({\n        [ATTR_SERVICE_NAME]: 'node',\n        // eslint-disable-next-line deprecation/deprecation\n        [SEMRESATTRS_SERVICE_NAMESPACE]: 'sentry',\n        [ATTR_SERVICE_VERSION]: SDK_VERSION,\n      }),\n    ),\n    forceFlushTimeoutMillis: 500,\n    spanProcessors: [\n      new SentrySpanProcessor({\n        timeout: _clampSpanProcessorTimeout(client.getOptions().maxSpanWaitDuration),\n      }),\n      ...(options.spanProcessors || []),\n    ],\n  });\n\n  // Register as globals\n  trace.setGlobalTracerProvider(provider);\n  propagation.setGlobalPropagator(new SentryPropagator());\n  context.setGlobalContextManager(new SentryContextManager());\n\n  return provider;\n}\n\n/** Just exported for tests. */\nexport function _clampSpanProcessorTimeout(maxSpanWaitDuration: number | undefined): number | undefined {\n  if (maxSpanWaitDuration == null) {\n    return undefined;\n  }\n\n  // We guard for a max. value here, because we create an array with this length\n  // So if this value is too large, this would fail\n  if (maxSpanWaitDuration > MAX_MAX_SPAN_WAIT_DURATION) {\n    DEBUG_BUILD &&\n      logger.warn(`\\`maxSpanWaitDuration\\` is too high, using the maximum value of ${MAX_MAX_SPAN_WAIT_DURATION}`);\n    return MAX_MAX_SPAN_WAIT_DURATION;\n  } else if (maxSpanWaitDuration <= 0 || Number.isNaN(maxSpanWaitDuration)) {\n    DEBUG_BUILD && logger.warn('`maxSpanWaitDuration` must be a positive number, using default value instead.');\n    return undefined;\n  }\n\n  return maxSpanWaitDuration;\n}\n\n/**\n * Setup the OTEL logger to use our own logger.\n */\nfunction setupOpenTelemetryLogger(): void {\n  const otelLogger = new Proxy(logger as typeof logger & { verbose: (typeof logger)['debug'] }, {\n    get(target, prop, receiver) {\n      const actualProp = prop === 'verbose' ? 'debug' : prop;\n      return Reflect.get(target, actualProp, receiver);\n    },\n  });\n\n  // Disable diag, to ensure this works even if called multiple times\n  diag.disable();\n  diag.setLogger(otelLogger, DiagLogLevel.DEBUG);\n}\n"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/build/esm/utils/ensureIsWrapped.js b/build/esm/utils/ensureIsWrapped.js
index cfad3a65fef1b252e343d2f041df71738c9ef0d8..70d60c8c3ab0002c0f177146c6c7533dcbece8bb 100644
--- a/build/esm/utils/ensureIsWrapped.js
+++ b/build/esm/utils/ensureIsWrapped.js
@@ -1,4 +1,4 @@
-import { isWrapped } from '@opentelemetry/core';
+import { isWrapped } from '@opentelemetry/instrumentation';
 import { getClient, isEnabled, hasSpansEnabled, consoleSandbox, getGlobalScope } from '@sentry/core';
 import { isCjs } from './commonjs.js';
 import { createMissingInstrumentationContext } from './createMissingInstrumentationContext.js';
diff --git a/build/esm/utils/ensureIsWrapped.js.map b/build/esm/utils/ensureIsWrapped.js.map
index e44ff094e993433d5092a522966ba568cbae4183..b7b086e9a5bffd3248871f358786f5fd0b32a127 100644
--- a/build/esm/utils/ensureIsWrapped.js.map
+++ b/build/esm/utils/ensureIsWrapped.js.map
@@ -1 +1 @@
-{"version":3,"file":"ensureIsWrapped.js","sources":["../../../src/utils/ensureIsWrapped.ts"],"sourcesContent":["import { isWrapped } from '@opentelemetry/core';\nimport { consoleSandbox, getClient, getGlobalScope, hasSpansEnabled, isEnabled } from '@sentry/core';\nimport type { NodeClient } from '../sdk/client';\nimport { isCjs } from './commonjs';\nimport { createMissingInstrumentationContext } from './createMissingInstrumentationContext';\n\n/**\n * Checks and warns if a framework isn't wrapped by opentelemetry.\n */\nexport function ensureIsWrapped(\n  maybeWrappedFunction: unknown,\n  name: 'express' | 'connect' | 'fastify' | 'hapi' | 'koa',\n): void {\n  const clientOptions = getClient<NodeClient>()?.getOptions();\n  if (\n    !clientOptions?.disableInstrumentationWarnings &&\n    !isWrapped(maybeWrappedFunction) &&\n    isEnabled() &&\n    hasSpansEnabled(clientOptions)\n  ) {\n    consoleSandbox(() => {\n      if (isCjs()) {\n        // eslint-disable-next-line no-console\n        console.warn(\n          `[Sentry] ${name} is not instrumented. This is likely because you required/imported ${name} before calling \\`Sentry.init()\\`.`,\n        );\n      } else {\n        // eslint-disable-next-line no-console\n        console.warn(\n          `[Sentry] ${name} is not instrumented. Please make sure to initialize Sentry in a separate file that you \\`--import\\` when running node, see: https://docs.sentry.io/platforms/javascript/guides/${name}/install/esm/.`,\n        );\n      }\n    });\n\n    getGlobalScope().setContext('missing_instrumentation', createMissingInstrumentationContext(name));\n  }\n}\n"],"names":[],"mappings":";;;;;AAMA;AACA;AACA;AACO,SAAS,eAAe;AAC/B,EAAE,oBAAoB;AACtB,EAAE,IAAI;AACN,EAAQ;AACR,EAAE,MAAM,gBAAgB,SAAS,EAAc,EAAE,UAAU,EAAE;AAC7D,EAAE;AACF,IAAI,CAAC,aAAa,EAAE,8BAA+B;AACnD,IAAI,CAAC,SAAS,CAAC,oBAAoB,CAAE;AACrC,IAAI,SAAS,EAAG;AAChB,IAAI,eAAe,CAAC,aAAa;AACjC,IAAI;AACJ,IAAI,cAAc,CAAC,MAAM;AACzB,MAAM,IAAI,KAAK,EAAE,EAAE;AACnB;AACA,QAAQ,OAAO,CAAC,IAAI;AACpB,UAAU,CAAC,SAAS,EAAE,IAAI,CAAC,mEAAmE,EAAE,IAAI,CAAC,kCAAkC,CAAC;AACxI,SAAS;AACT,aAAa;AACb;AACA,QAAQ,OAAO,CAAC,IAAI;AACpB,UAAU,CAAC,SAAS,EAAE,IAAI,CAAC,gLAAgL,EAAE,IAAI,CAAC,cAAc,CAAC;AACjO,SAAS;AACT;AACA,KAAK,CAAC;;AAEN,IAAI,cAAc,EAAE,CAAC,UAAU,CAAC,yBAAyB,EAAE,mCAAmC,CAAC,IAAI,CAAC,CAAC;AACrG;AACA;;;;"}
\ No newline at end of file
+{"version":3,"file":"ensureIsWrapped.js","sources":["../../../src/utils/ensureIsWrapped.ts"],"sourcesContent":["import { isWrapped } from '@opentelemetry/instrumentation';\nimport { consoleSandbox, getClient, getGlobalScope, hasSpansEnabled, isEnabled } from '@sentry/core';\nimport type { NodeClient } from '../sdk/client';\nimport { isCjs } from './commonjs';\nimport { createMissingInstrumentationContext } from './createMissingInstrumentationContext';\n\n/**\n * Checks and warns if a framework isn't wrapped by opentelemetry.\n */\nexport function ensureIsWrapped(\n  maybeWrappedFunction: unknown,\n  name: 'express' | 'connect' | 'fastify' | 'hapi' | 'koa',\n): void {\n  const clientOptions = getClient<NodeClient>()?.getOptions();\n  if (\n    !clientOptions?.disableInstrumentationWarnings &&\n    !isWrapped(maybeWrappedFunction) &&\n    isEnabled() &&\n    hasSpansEnabled(clientOptions)\n  ) {\n    consoleSandbox(() => {\n      if (isCjs()) {\n        // eslint-disable-next-line no-console\n        console.warn(\n          `[Sentry] ${name} is not instrumented. This is likely because you required/imported ${name} before calling \\`Sentry.init()\\`.`,\n        );\n      } else {\n        // eslint-disable-next-line no-console\n        console.warn(\n          `[Sentry] ${name} is not instrumented. Please make sure to initialize Sentry in a separate file that you \\`--import\\` when running node, see: https://docs.sentry.io/platforms/javascript/guides/${name}/install/esm/.`,\n        );\n      }\n    });\n\n    getGlobalScope().setContext('missing_instrumentation', createMissingInstrumentationContext(name));\n  }\n}\n"],"names":[],"mappings":";;;;;AAMA;AACA;AACA;AACO,SAAS,eAAe;AAC/B,EAAE,oBAAoB;AACtB,EAAE,IAAI;AACN,EAAQ;AACR,EAAE,MAAM,gBAAgB,SAAS,EAAc,EAAE,UAAU,EAAE;AAC7D,EAAE;AACF,IAAI,CAAC,aAAa,EAAE,8BAA+B;AACnD,IAAI,CAAC,SAAS,CAAC,oBAAoB,CAAE;AACrC,IAAI,SAAS,EAAG;AAChB,IAAI,eAAe,CAAC,aAAa;AACjC,IAAI;AACJ,IAAI,cAAc,CAAC,MAAM;AACzB,MAAM,IAAI,KAAK,EAAE,EAAE;AACnB;AACA,QAAQ,OAAO,CAAC,IAAI;AACpB,UAAU,CAAC,SAAS,EAAE,IAAI,CAAC,mEAAmE,EAAE,IAAI,CAAC,kCAAkC,CAAC;AACxI,SAAS;AACT,aAAa;AACb;AACA,QAAQ,OAAO,CAAC,IAAI;AACpB,UAAU,CAAC,SAAS,EAAE,IAAI,CAAC,gLAAgL,EAAE,IAAI,CAAC,cAAc,CAAC;AACjO,SAAS;AACT;AACA,KAAK,CAAC;;AAEN,IAAI,cAAc,EAAE,CAAC,UAAU,CAAC,yBAAyB,EAAE,mCAAmC,CAAC,IAAI,CAAC,CAAC;AACrG;AACA;;;;"}
\ No newline at end of file
diff --git a/build/types/integrations/http/SentryHttpInstrumentation.d.ts.map b/build/types/integrations/http/SentryHttpInstrumentation.d.ts.map
index 8bccab422a8c384bd4799a0c2d5c32e1d0d47bfc..2c896a16a9f45e13de996e5889426d733f363cf5 100644
--- a/build/types/integrations/http/SentryHttpInstrumentation.d.ts.map
+++ b/build/types/integrations/http/SentryHttpInstrumentation.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"SentryHttpInstrumentation.d.ts","sourceRoot":"","sources":["../../../../src/integrations/http/SentryHttpInstrumentation.ts"],"names":[],"mappings":";;AAGA,OAAO,KAAK,EAAE,qBAAqB,EAAE,MAAM,gCAAgC,CAAC;AAC5E,OAAO,EAAE,mBAAmB,EAAE,mCAAmC,EAAE,MAAM,gCAAgC,CAAC;AAC1G,OAAO,KAAK,EAAqE,KAAK,EAAE,MAAM,cAAc,CAAC;AAgB7G,OAAO,KAAK,EAAmB,cAAc,EAAE,MAAM,WAAW,CAAC;AAEjE,OAAO,KAAK,EAAE,YAAY,EAAE,MAAM,aAAa,CAAC;AAShD,MAAM,MAAM,gCAAgC,GAAG,qBAAqB,GAAG;IACrE;;;;OAIG;IACH,WAAW,CAAC,EAAE,OAAO,CAAC;IAEtB;;;;;;OAMG;IACH,8BAA8B,CAAC,EAAE,OAAO,CAAC;IAEzC;;;;;;;;OAQG;IACH,sBAAsB,CAAC,EAAE,CAAC,GAAG,EAAE,MAAM,EAAE,OAAO,EAAE,cAAc,KAAK,OAAO,CAAC;IAE3E;;;;;;OAMG;IACH,yBAAyB,CAAC,EAAE,CAAC,GAAG,EAAE,MAAM,EAAE,OAAO,EAAE,cAAc,KAAK,OAAO,CAAC;IAE9E;;;;;OAKG;IACH,+BAA+B,CAAC,EAAE,OAAO,CAAC;IAE1C;;;;OAIG;IACH,sBAAsB,CAAC,EAAE,MAAM,CAAC;CACjC,CAAC;AAKF;;;;;;;;;;;;GAYG;AACH,qBAAa,yBAA0B,SAAQ,mBAAmB,CAAC,gCAAgC,CAAC;gBAC/E,MAAM,GAAE,gCAAqC;IAIhE,kBAAkB;IACX,IAAI,IAAI,CAAC,mCAAmC,EAAE,mCAAmC,CAAC;IAIzF,mDAAmD;IACnD,OAAO,CAAC,uBAAuB;IAoB/B,oDAAoD;IACpD,OAAO,CAAC,wBAAwB;IAoBhC;;OAEG;IACH,OAAO,CAAC,gCAAgC;IAyExC;;OAEG;IACH,OAAO,CAAC,gCAAgC;IAgDxC,sDAAsD;IAEtD,OAAO,CAAC,4BAA4B;CAmBrC;AAuJD;;;;;;;;GAQG;AAEH,wBAAgB,oBAAoB,CAAC,EACnC,qBAAqB,EACrB,QAAQ,EACR,sBAAsB,GACvB,EAAE;IACD,qBAAqB,EAAE,KAAK,CAAC;IAC7B,QAAQ,EAAE,YAAY,CAAC;IACvB,sBAAsB,CAAC,EAAE,MAAM,CAAC;CACjC,GAAG,IAAI,CAsDP"}
\ No newline at end of file
+{"version":3,"file":"SentryHttpInstrumentation.d.ts","sourceRoot":"","sources":["../../../../src/integrations/http/SentryHttpInstrumentation.ts"],"names":[],"mappings":";;AAEA,OAAO,KAAK,EAAE,qBAAqB,EAAE,MAAM,gCAAgC,CAAC;AAC5E,OAAO,EAAE,mBAAmB,EAAE,mCAAmC,EAAE,MAAM,gCAAgC,CAAC;AAC1G,OAAO,KAAK,EAAqE,KAAK,EAAE,MAAM,cAAc,CAAC;AAgB7G,OAAO,KAAK,EAAmB,cAAc,EAAE,MAAM,WAAW,CAAC;AAEjE,OAAO,KAAK,EAAE,YAAY,EAAE,MAAM,aAAa,CAAC;AAShD,MAAM,MAAM,gCAAgC,GAAG,qBAAqB,GAAG;IACrE;;;;OAIG;IACH,WAAW,CAAC,EAAE,OAAO,CAAC;IAEtB;;;;;;OAMG;IACH,8BAA8B,CAAC,EAAE,OAAO,CAAC;IAEzC;;;;;;;;OAQG;IACH,sBAAsB,CAAC,EAAE,CAAC,GAAG,EAAE,MAAM,EAAE,OAAO,EAAE,cAAc,KAAK,OAAO,CAAC;IAE3E;;;;;;OAMG;IACH,yBAAyB,CAAC,EAAE,CAAC,GAAG,EAAE,MAAM,EAAE,OAAO,EAAE,cAAc,KAAK,OAAO,CAAC;IAE9E;;;;;OAKG;IACH,+BAA+B,CAAC,EAAE,OAAO,CAAC;IAE1C;;;;OAIG;IACH,sBAAsB,CAAC,EAAE,MAAM,CAAC;CACjC,CAAC;AAKF;;;;;;;;;;;;GAYG;AACH,qBAAa,yBAA0B,SAAQ,mBAAmB,CAAC,gCAAgC,CAAC;gBAC/E,MAAM,GAAE,gCAAqC;IAIhE,kBAAkB;IACX,IAAI,IAAI,CAAC,mCAAmC,EAAE,mCAAmC,CAAC;IAIzF,mDAAmD;IACnD,OAAO,CAAC,uBAAuB;IAoB/B,oDAAoD;IACpD,OAAO,CAAC,wBAAwB;IAoBhC;;OAEG;IACH,OAAO,CAAC,gCAAgC;IAyExC;;OAEG;IACH,OAAO,CAAC,gCAAgC;IAgDxC,sDAAsD;IAEtD,OAAO,CAAC,4BAA4B;CAmBrC;AAuJD;;;;;;;;GAQG;AAEH,wBAAgB,oBAAoB,CAAC,EACnC,qBAAqB,EACrB,QAAQ,EACR,sBAAsB,GACvB,EAAE;IACD,qBAAqB,EAAE,KAAK,CAAC;IAC7B,QAAQ,EAAE,YAAY,CAAC;IACvB,sBAAsB,CAAC,EAAE,MAAM,CAAC;CACjC,GAAG,IAAI,CAsDP"}
\ No newline at end of file
diff --git a/build/types/integrations/http/SentryHttpInstrumentationBeforeOtel.d.ts.map b/build/types/integrations/http/SentryHttpInstrumentationBeforeOtel.d.ts.map
index 1a3714af155f3adbe0b43de653d78792eb19028c..03a6a71ae189d551a8eac0d62c76d64158a3c952 100644
--- a/build/types/integrations/http/SentryHttpInstrumentationBeforeOtel.d.ts.map
+++ b/build/types/integrations/http/SentryHttpInstrumentationBeforeOtel.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"SentryHttpInstrumentationBeforeOtel.d.ts","sourceRoot":"","sources":["../../../../src/integrations/http/SentryHttpInstrumentationBeforeOtel.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,mBAAmB,EAAE,mCAAmC,EAAE,MAAM,gCAAgC,CAAC;AAqB1G;;GAEG;AACH,qBAAa,mCAAoC,SAAQ,mBAAmB;;IAMnE,IAAI,IAAI,CAAC,mCAAmC,EAAE,mCAAmC,CAAC;IAIzF,mDAAmD;IACnD,OAAO,CAAC,uBAAuB;IAS/B,oDAAoD;IACpD,OAAO,CAAC,wBAAwB;IAShC;;OAEG;IACH,OAAO,CAAC,gCAAgC;CAoBzC"}
\ No newline at end of file
+{"version":3,"file":"SentryHttpInstrumentationBeforeOtel.d.ts","sourceRoot":"","sources":["../../../../src/integrations/http/SentryHttpInstrumentationBeforeOtel.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,mBAAmB,EAAE,mCAAmC,EAAE,MAAM,gCAAgC,CAAC;AAqB1G;;GAEG;AACH,qBAAa,mCAAoC,SAAQ,mBAAmB;;IAMnE,IAAI,IAAI,CAAC,mCAAmC,EAAE,mCAAmC,CAAC;IAIzF,mDAAmD;IACnD,OAAO,CAAC,uBAAuB;IAS/B,oDAAoD;IACpD,OAAO,CAAC,wBAAwB;IAShC;;OAEG;IACH,OAAO,CAAC,gCAAgC;CAoBzC"}
\ No newline at end of file
diff --git a/build/types/integrations/node-fetch/SentryNodeFetchInstrumentation.d.ts.map b/build/types/integrations/node-fetch/SentryNodeFetchInstrumentation.d.ts.map
index f9e2a14ed5e782a83c360152de63b48d79f6f1ca..290342d24ab714a2b1bc21ca23c6080f2801ae16 100644
--- a/build/types/integrations/node-fetch/SentryNodeFetchInstrumentation.d.ts.map
+++ b/build/types/integrations/node-fetch/SentryNodeFetchInstrumentation.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"SentryNodeFetchInstrumentation.d.ts","sourceRoot":"","sources":["../../../../src/integrations/node-fetch/SentryNodeFetchInstrumentation.ts"],"names":[],"mappings":"AACA,OAAO,KAAK,EAAE,qBAAqB,EAAE,MAAM,gCAAgC,CAAC;AAC5E,OAAO,EAAE,mBAAmB,EAAE,MAAM,gCAAgC,CAAC;AAgBrE,MAAM,MAAM,qCAAqC,GAAG,qBAAqB,GAAG;IAC1E;;;;OAIG;IACH,WAAW,CAAC,EAAE,OAAO,CAAC;IAEtB;;;;;;OAMG;IACH,sBAAsB,CAAC,EAAE,CAAC,GAAG,EAAE,MAAM,KAAK,OAAO,CAAC;CACnD,CAAC;AAOF;;;;;;;;;GASG;AACH,qBAAa,8BAA+B,SAAQ,mBAAmB,CAAC,qCAAqC,CAAC;IAG5G,OAAO,CAAC,YAAY,CAAwB;IAC5C,OAAO,CAAC,uBAAuB,CAA0B;gBAEtC,MAAM,GAAE,qCAA0C;IAMrE,2CAA2C;IACpC,IAAI,IAAI,IAAI;IAInB,mCAAmC;IAC5B,OAAO,IAAI,IAAI;IAMtB,kCAAkC;IAC3B,MAAM,IAAI,IAAI;IAyBrB;;;OAGG;IACH,OAAO,CAAC,iBAAiB;IAyEzB;;OAEG;IACH,OAAO,CAAC,kBAAkB;IAsB1B,0CAA0C;IAC1C,OAAO,CAAC,mBAAmB;CAuB5B"}
\ No newline at end of file
+{"version":3,"file":"SentryNodeFetchInstrumentation.d.ts","sourceRoot":"","sources":["../../../../src/integrations/node-fetch/SentryNodeFetchInstrumentation.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EAAE,qBAAqB,EAAE,MAAM,gCAAgC,CAAC;AAC5E,OAAO,EAAE,mBAAmB,EAAE,MAAM,gCAAgC,CAAC;AAgBrE,MAAM,MAAM,qCAAqC,GAAG,qBAAqB,GAAG;IAC1E;;;;OAIG;IACH,WAAW,CAAC,EAAE,OAAO,CAAC;IAEtB;;;;;;OAMG;IACH,sBAAsB,CAAC,EAAE,CAAC,GAAG,EAAE,MAAM,KAAK,OAAO,CAAC;CACnD,CAAC;AAOF;;;;;;;;;GASG;AACH,qBAAa,8BAA+B,SAAQ,mBAAmB,CAAC,qCAAqC,CAAC;IAG5G,OAAO,CAAC,YAAY,CAAwB;IAC5C,OAAO,CAAC,uBAAuB,CAA0B;gBAEtC,MAAM,GAAE,qCAA0C;IAMrE,2CAA2C;IACpC,IAAI,IAAI,IAAI;IAInB,mCAAmC;IAC5B,OAAO,IAAI,IAAI;IAMtB,kCAAkC;IAC3B,MAAM,IAAI,IAAI;IAyBrB;;;OAGG;IACH,OAAO,CAAC,iBAAiB;IAyEzB;;OAEG;IACH,OAAO,CAAC,kBAAkB;IAsB1B,0CAA0C;IAC1C,OAAO,CAAC,mBAAmB;CAuB5B"}
\ No newline at end of file
diff --git a/build/types/sdk/client.d.ts.map b/build/types/sdk/client.d.ts.map
index afab663afa67b872a26f75e1f10861806f0e7fb2..096d1f0399e7ef9ce7aac59687c6bd998b2662ab 100644
--- a/build/types/sdk/client.d.ts.map
+++ b/build/types/sdk/client.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"client.d.ts","sourceRoot":"","sources":["../../../src/sdk/client.ts"],"names":[],"mappings":"AACA,OAAO,KAAK,EAAE,MAAM,EAAE,MAAM,oBAAoB,CAAC;AAGjD,OAAO,KAAK,EAAE,mBAAmB,EAAE,MAAM,+BAA+B,CAAC;AACzE,OAAO,KAAK,EAAE,sBAAsB,EAAE,KAAK,EAA8B,YAAY,EAAE,MAAM,cAAc,CAAC;AAC5G,OAAO,EAA0C,mBAAmB,EAA4B,MAAM,cAAc,CAAC;AAIrH,OAAO,KAAK,EAAE,iBAAiB,EAAE,MAAM,UAAU,CAAC;AAIlD,2DAA2D;AAC3D,qBAAa,UAAW,SAAQ,mBAAmB,CAAC,iBAAiB,CAAC;IAC7D,aAAa,EAAE,mBAAmB,GAAG,SAAS,CAAC;IACtD,OAAO,CAAC,OAAO,CAAqB;IACpC,OAAO,CAAC,qBAAqB,CAA6B;IAC1D,OAAO,CAAC,gCAAgC,CAA2B;IACnE,OAAO,CAAC,uBAAuB,CAA2B;gBAEvC,OAAO,EAAE,iBAAiB;IAyC7C,2BAA2B;IAC3B,IAAW,MAAM,IAAI,MAAM,CAW1B;IAIY,KAAK,CAAC,OAAO,CAAC,EAAE,MAAM,GAAG,OAAO,CAAC,OAAO,CAAC;IAiB/C,KAAK,CAAC,OAAO,CAAC,EAAE,MAAM,GAAG,SAAS,GAAG,WAAW,CAAC,OAAO,CAAC;IAgBhE;;;;;;OAMG;IASI,yBAAyB,IAAI,IAAI;IAkBxC,2EAA2E;IAC3E,SAAS,CAAC,sBAAsB,CAC9B,KAAK,EAAE,KAAK,GAAG,SAAS,GACvB,CAAC,sBAAsB,EAAE,OAAO,CAAC,sBAAsB,CAAC,GAAG,SAAS,EAAE,YAAY,EAAE,YAAY,GAAG,SAAS,CAAC;CAOjH"}
\ No newline at end of file
+{"version":3,"file":"client.d.ts","sourceRoot":"","sources":["../../../src/sdk/client.ts"],"names":[],"mappings":"AACA,OAAO,KAAK,EAAE,MAAM,EAAE,MAAM,oBAAoB,CAAC;AAGjD,OAAO,KAAK,EAAE,mBAAmB,EAAE,MAAM,+BAA+B,CAAC;AACzE,OAAO,KAAK,EAAE,sBAAsB,EAAE,KAAK,EAA8B,YAAY,EAAE,MAAM,cAAc,CAAC;AAC5G,OAAO,EAA0C,mBAAmB,EAA4B,MAAM,cAAc,CAAC;AAIrH,OAAO,KAAK,EAAE,iBAAiB,EAAE,MAAM,UAAU,CAAC;AAIlD,2DAA2D;AAC3D,qBAAa,UAAW,SAAQ,mBAAmB,CAAC,iBAAiB,CAAC;IAC7D,aAAa,EAAE,mBAAmB,GAAG,SAAS,CAAC;IACtD,OAAO,CAAC,OAAO,CAAqB;IACpC,OAAO,CAAC,qBAAqB,CAA6B;IAC1D,OAAO,CAAC,gCAAgC,CAA2B;IACnE,OAAO,CAAC,uBAAuB,CAA2B;gBAEvC,OAAO,EAAE,iBAAiB;IAyC7C,2BAA2B;IAC3B,IAAW,MAAM,IAAI,MAAM,CAW1B;IAIY,KAAK,CAAC,OAAO,CAAC,EAAE,MAAM,GAAG,OAAO,CAAC,OAAO,CAAC;IAgB/C,KAAK,CAAC,OAAO,CAAC,EAAE,MAAM,GAAG,SAAS,GAAG,WAAW,CAAC,OAAO,CAAC;IAgBhE;;;;;;OAMG;IASI,yBAAyB,IAAI,IAAI;IAkBxC,2EAA2E;IAC3E,SAAS,CAAC,sBAAsB,CAC9B,KAAK,EAAE,KAAK,GAAG,SAAS,GACvB,CAAC,sBAAsB,EAAE,OAAO,CAAC,sBAAsB,CAAC,GAAG,SAAS,EAAE,YAAY,EAAE,YAAY,GAAG,SAAS,CAAC;CAOjH"}
\ No newline at end of file
diff --git a/build/types/sdk/initOtel.d.ts.map b/build/types/sdk/initOtel.d.ts.map
index ecb89195db42ec149f176c6444ae66bae93d8a2b..dc512c295d9d922e1bc1c37d53a3f29fe97de043 100644
--- a/build/types/sdk/initOtel.d.ts.map
+++ b/build/types/sdk/initOtel.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"initOtel.d.ts","sourceRoot":"","sources":["../../../src/sdk/initOtel.ts"],"names":[],"mappings":"AAGA,OAAO,KAAK,EAAE,aAAa,EAAE,MAAM,+BAA+B,CAAC;AACnE,OAAO,EAAE,mBAAmB,EAAE,MAAM,+BAA+B,CAAC;AAapE,OAAO,KAAK,EAAE,UAAU,EAAE,MAAM,UAAU,CAAC;AAK3C,UAAU,8BAA8B;IACtC,8DAA8D;IAC9D,cAAc,CAAC,EAAE,aAAa,EAAE,CAAC;CAClC;AAED;;GAEG;AACH,wBAAgB,iBAAiB,CAAC,MAAM,EAAE,UAAU,EAAE,OAAO,GAAE,8BAAmC,GAAG,IAAI,CAOxG;AAED,iCAAiC;AACjC,wBAAgB,wBAAwB,IAAI,IAAI,CAyB/C;AAED,UAAU,kBAAkB;IAC1B,KAAK,CAAC,EAAE,OAAO,CAAC;IAChB,YAAY,CAAC,EAAE,MAAM,EAAE,CAAC;CACzB;AAED;;;;GAIG;AACH,wBAAgB,oBAAoB,CAAC,OAAO,GAAE,kBAAuB,GAAG,IAAI,CAoB3E;AAYD,+BAA+B;AAC/B,wBAAgB,SAAS,CAAC,MAAM,EAAE,UAAU,EAAE,OAAO,GAAE,8BAAmC,GAAG,mBAAmB,CAyB/G;AAED,+BAA+B;AAC/B,wBAAgB,0BAA0B,CAAC,mBAAmB,EAAE,MAAM,GAAG,SAAS,GAAG,MAAM,GAAG,SAAS,CAiBtG"}
\ No newline at end of file
+{"version":3,"file":"initOtel.d.ts","sourceRoot":"","sources":["../../../src/sdk/initOtel.ts"],"names":[],"mappings":"AAGA,OAAO,KAAK,EAAE,aAAa,EAAE,MAAM,+BAA+B,CAAC;AACnE,OAAO,EAAE,mBAAmB,EAAE,MAAM,+BAA+B,CAAC;AAapE,OAAO,KAAK,EAAE,UAAU,EAAE,MAAM,UAAU,CAAC;AAK3C,UAAU,8BAA8B;IACtC,8DAA8D;IAC9D,cAAc,CAAC,EAAE,aAAa,EAAE,CAAC;CAClC;AAED;;GAEG;AACH,wBAAgB,iBAAiB,CAAC,MAAM,EAAE,UAAU,EAAE,OAAO,GAAE,8BAAmC,GAAG,IAAI,CAOxG;AAED,iCAAiC;AACjC,wBAAgB,wBAAwB,IAAI,IAAI,CAyB/C;AAED,UAAU,kBAAkB;IAC1B,KAAK,CAAC,EAAE,OAAO,CAAC;IAChB,YAAY,CAAC,EAAE,MAAM,EAAE,CAAC;CACzB;AAED;;;;GAIG;AACH,wBAAgB,oBAAoB,CAAC,OAAO,GAAE,kBAAuB,GAAG,IAAI,CAoB3E;AAYD,+BAA+B;AAC/B,wBAAgB,SAAS,CAAC,MAAM,EAAE,UAAU,EAAE,OAAO,GAAE,8BAAmC,GAAG,mBAAmB,CA2B/G;AAED,+BAA+B;AAC/B,wBAAgB,0BAA0B,CAAC,mBAAmB,EAAE,MAAM,GAAG,SAAS,GAAG,MAAM,GAAG,SAAS,CAiBtG"}
\ No newline at end of file
diff --git a/package.json b/package.json
index e98d8137c68f302e192a8f76c60191892cc00a41..c1200004c83e85a167a1d3a9f6fa296d274b8b33 100644
--- a/package.json
+++ b/package.json
@@ -66,9 +66,9 @@
   },
   "dependencies": {
     "@opentelemetry/api": "^1.9.0",
-    "@opentelemetry/context-async-hooks": "^1.30.1",
-    "@opentelemetry/core": "^1.30.1",
-    "@opentelemetry/instrumentation": "^0.57.2",
+    "@opentelemetry/context-async-hooks": "^2.0.0",
+    "@opentelemetry/core": "^2.0.0",
+    "@opentelemetry/instrumentation": "^0.200.0",
     "@opentelemetry/instrumentation-amqplib": "^0.46.1",
     "@opentelemetry/instrumentation-connect": "0.43.1",
     "@opentelemetry/instrumentation-dataloader": "0.16.1",
@@ -78,7 +78,7 @@
     "@opentelemetry/instrumentation-generic-pool": "0.43.1",
     "@opentelemetry/instrumentation-graphql": "0.47.1",
     "@opentelemetry/instrumentation-hapi": "0.45.2",
-    "@opentelemetry/instrumentation-http": "0.57.2",
+    "@opentelemetry/instrumentation-http": "0.200.0",
     "@opentelemetry/instrumentation-ioredis": "0.47.1",
     "@opentelemetry/instrumentation-kafkajs": "0.7.1",
     "@opentelemetry/instrumentation-knex": "0.44.1",
@@ -92,8 +92,8 @@
     "@opentelemetry/instrumentation-redis-4": "0.46.1",
     "@opentelemetry/instrumentation-tedious": "0.18.1",
     "@opentelemetry/instrumentation-undici": "0.10.1",
-    "@opentelemetry/resources": "^1.30.1",
-    "@opentelemetry/sdk-trace-base": "^1.30.1",
+    "@opentelemetry/resources": "^2.0.0",
+    "@opentelemetry/sdk-trace-base": "^2.0.0",
     "@opentelemetry/semantic-conventions": "^1.30.0",
     "@prisma/instrumentation": "6.5.0",
     "@sentry/core": "9.12.0",
